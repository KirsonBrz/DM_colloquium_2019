/* Generated code for Python module 'ssl'
 * created by Nuitka version 0.6.2
 *
 * This code is in part copyright 2019 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_ssl" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_ssl;
PyDictObject *moduledict_ssl;

/* The declarations of module constants used, if any. */
extern PyObject *const_str_plain_compression;
extern PyObject *const_str_plain_isdir;
extern PyObject *const_str_plain_family;
static PyObject *const_str_plain__Enum;
extern PyObject *const_str_plain___spec__;
static PyObject *const_str_plain_connected;
static PyObject *const_str_plain__set_npn_protocols;
static PyObject *const_str_digest_c7fd72035abc3711f49929c6db8a5d90;
extern PyObject *const_str_plain___name__;
static PyObject *const_str_plain_suppress_ragged_eofs;
static PyObject *const_tuple_fa0db5e4cde953f91817f4436d4446fe_tuple;
extern PyObject *const_bytearray_72cdf64f605ef12d57287fc4b61c2b5e;
static PyObject *const_str_digest_086013992ea1d11747aa99e000896ea7;
static PyObject *const_tuple_str_plain_self_str_plain_cb_type_tuple;
extern PyObject *const_str_plain_i;
static PyObject *const_str_digest_bf85e7fd1bca2b2685cec66cc7c88826;
static PyObject *const_str_plain_DefaultVerifyPaths;
extern PyObject *const_str_plain_encode;
static PyObject *const_tuple_67f07609e3644b8c19de10c902eeeb48_tuple;
static PyObject *const_str_plain_OP_;
static PyObject *const_str_plain_commonName;
extern PyObject *const_str_plain_fileno;
static PyObject *const_str_digest_2b5d4e1e8c4b95888f9c32cd5e107a2a;
extern PyObject *const_str_plain_gettimeout;
static PyObject *const_str_plain__session;
static PyObject *const_str_plain_sni_callback;
static PyObject *const_dict_a4af7150f3c5b467e93a8aa2f6959c6a;
extern PyObject *const_str_chr_42;
static PyObject *const_str_plain_sendmsg;
extern PyObject *const_str_plain_os;
extern PyObject *const_str_plain_None;
static PyObject *const_str_plain_cipher;
static PyObject *const_str_plain_sslsock;
extern PyObject *const_str_plain_callable;
static PyObject *const_str_plain__ASN1Object;
extern PyObject *const_str_plain_view;
static PyObject *const_tuple_str_plain_subject_tuple_empty_tuple;
extern PyObject *const_str_plain_Options;
static PyObject *const_str_plain_load_default_certs;
static PyObject *const_str_plain_PROTO_TLSv1;
static PyObject *const_str_digest_0f22ebe362b5851039539f32087f48b3;
static PyObject *const_str_plain__wrap_socket;
static PyObject *const_str_plain_verify_client_post_handshake;
extern PyObject *const_str_plain_repr;
extern PyObject *const_tuple_none_none_none_tuple;
static PyObject *const_str_plain_fromnid;
static PyObject *const_str_plain_SSLWantReadError;
static PyObject *const_str_plain_recvmsg;
static PyObject *const_str_plain_binary_form;
static PyObject *const_str_digest_59e9ef293dda2862f98a224ced32fcd6;
static PyObject *const_str_digest_00d07f74b29f8afb5fd73d7e9c08e6c3;
static PyObject *const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple;
extern PyObject *const_str_plain___debug__;
extern PyObject *const_str_plain_timeout;
static PyObject *const_str_digest_11ed960077872fa0d08c8c433b669058;
extern PyObject *const_str_plain_errno;
extern PyObject *const_str_plain_time;
static PyObject *const_tuple_str_plain_self_str_plain_value_str_plain___class___tuple;
extern PyObject *const_str_plain_flags;
static PyObject *const_str_plain_HAS_NPN;
static PyObject *const_str_digest_89945f27978b3c4970283807e6649ec5;
static PyObject *const_str_plain_load_verify_locations;
static PyObject *const_str_plain_ssl_version;
extern PyObject *const_str_plain_str;
static PyObject *const_str_plain_inet_aton;
static PyObject *const_str_plain_socket_error;
extern PyObject *const_str_plain__closed;
static PyObject *const_tuple_str_plain_self_str_plain_addr_tuple;
static PyObject *const_str_plain_recvmsg_into;
extern PyObject *const_str_plain_sock;
extern PyObject *const_str_plain_path;
static PyObject *const_str_plain__encode_hostname;
static PyObject *const_str_plain_ctx;
extern PyObject *const_str_plain_IntEnum;
static PyObject *const_str_digest_f3590796fc6a572064ab68e58c2e47b2;
extern PyObject *const_str_plain_base64;
static PyObject *const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_v_tuple;
static PyObject *const_str_digest_bd00534ecca984542679be9e93bb7f91;
static PyObject *const_str_plain_PROTOCOL_SSLv2;
static PyObject *const_str_digest_d9ecb2d1bd7c2c654c39bebb9c4b95c7;
extern PyObject *const_tuple_str_dot_tuple;
static PyObject *const_str_digest_04681951689da94a8b8ef39f2d829632;
static PyObject *const_str_plain_HAS_SSLv2;
extern PyObject *const_str_plain_Feb;
extern PyObject *const_str_plain_settimeout;
static PyObject *const_str_digest_0f3e3cca38e905dbbeef437e4cc1b13f;
extern PyObject *const_str_plain_calendar;
static PyObject *const_str_digest_b1639321a9474ecb1b885a74076648f9;
static PyObject *const_str_plain_MemoryBIO;
extern PyObject *const_str_plain_name;
static PyObject *const_str_digest_e00eea51626e2d416545145e0341879e;
static PyObject *const_str_plain_pem_cert_string;
static PyObject *const_tuple_str_plain_strptime_tuple;
extern PyObject *const_str_plain_endswith;
extern PyObject *const_tuple_str_plain_name_str_plain_value_tuple;
static PyObject *const_tuple_a6e5b7213d740be0ae002af3220b2e2c_tuple;
static PyObject *const_str_digest_4f58dc80390e8e62e2885e34b814c3ae;
static PyObject *const_str_digest_e1cb74300b7a6f137d7d5aaa4117b8b1;
static PyObject *const_str_plain_DER_cert_to_PEM_cert;
static PyObject *const_str_plain_OP_NO_SSLv3;
static PyObject *const_tuple_284226fe448516f5ff39ffa684da9193_tuple;
static PyObject *const_str_digest_46ab2be535dad9a4eb021b9ed0399647;
extern PyObject *const_tuple_int_0_tuple;
static PyObject *const_str_digest_b414a1b63ea6dd23ea915006aafd2a8f;
extern PyObject *const_str_plain_map;
extern PyObject *const_str_plain_False;
static PyObject *const_str_digest_d1654dbcf9c06006c0b37bb1c5c65ca0;
static PyObject *const_str_plain_verify_flags;
extern PyObject *const_str_plain___new__;
static PyObject *const_str_plain_HAS_SSLv3;
static PyObject *const_str_digest_ce00e64da7d82f6241d1726b2fac3925;
static PyObject *const_str_plain_servername;
static PyObject *const_str_digest_a90f1c250f0693c766ae942c46747dfd;
static PyObject *const_str_digest_ef46d7df3260d10040c06b56d31e4b9b;
static PyObject *const_str_digest_f6dd8c5e9e919cb24a1de58b3da498d7;
extern PyObject *const_int_0;
static PyObject *const_str_digest_0376a15beee26a285b06cab589a6a7cd;
extern PyObject *const_str_plain___members__;
static PyObject *const_tuple_f08ce5d2099609de7b2c444c551dc980_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain___class___tuple;
static PyObject *const_str_plain__real_connect;
static PyObject *const_str_plain_selected_npn_protocol;
static PyObject *const_str_digest_c126f313dbab329c6eb48d2d248e63ab;
extern PyObject *const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
extern PyObject *const_str_plain_B;
static PyObject *const_str_plain_ipname;
static PyObject *const_str_plain_SSLObject;
static PyObject *const_str_digest_5e9c5dde7d44f504eb1a9ddf508d33f1;
extern PyObject *const_str_plain__IntEnum;
static PyObject *const_tuple_5abcd7abdaa8ad06f264854390b827e9_tuple;
extern PyObject *const_int_pos_64;
static PyObject *const_str_plain_hostname_checks_common_name;
static PyObject *const_tuple_str_plain_subjectAltName_tuple_empty_tuple;
extern PyObject *const_str_plain_recv;
static PyObject *const_str_digest_4abc699b5da7389d367032b57dc69eb3;
extern PyObject *const_str_plain_type;
static PyObject *const_str_digest_c5de37dcc49253fe34f7e237641f0f0d;
extern PyObject *const_str_plain_sendfile;
static PyObject *const_tuple_fc7bac9f346b6c5e0ab564aacc7d281d_tuple;
extern PyObject *const_str_plain___cached__;
static PyObject *const_str_plain_incoming;
extern PyObject *const_tuple_none_tuple;
static PyObject *const_str_digest_9ad09f827f7176b447bf061c19122ff5;
static PyObject *const_str_plain_SSLSession;
static PyObject *const_str_plain__txt2obj;
static PyObject *const_str_digest_1483b01ecabadd2ef5d4b9c2cb9cbd6a;
extern PyObject *const_str_plain_Jun;
static PyObject *const_str_digest_32a9d7692d4036821acb38d0089e4f7d;
static PyObject *const_str_digest_7acec48d7f5243b63c0fc27885a59467;
extern PyObject *const_str_plain_AF_INET6;
static PyObject *const_tuple_str_plain_VERIFY__tuple;
static PyObject *const_tuple_aa341dc2e3c74f72a385182dcb9b8959_tuple;
extern PyObject *const_str_plain_wrap_socket;
static PyObject *const_tuple_38d407af55640de8f78848442bfee914_tuple;
static PyObject *const_str_plain_cafile;
static PyObject *const_str_plain_flags_or_addr;
static PyObject *const_str_plain_enum_crls;
static PyObject *const_str_digest_f26217c45eb3dee86d08318942000832;
extern PyObject *const_int_pos_1;
extern PyObject *const_str_plain_port;
static PyObject *const_str_digest_e76c9d31e090b0229a44427e90c726c0;
static PyObject *const_tuple_str_plain_enum_certificates_str_plain_enum_crls_tuple;
static PyObject *const_str_plain__sslobj;
static PyObject *const_str_digest_3248563d58214c71a4c9da2c5bedaa28;
extern PyObject *const_str_plain_how;
static PyObject *const_str_digest_b8a96526c0c1047e3727ab8306b2c0b6;
static PyObject *const_str_plain_getpeercert;
extern PyObject *const_tuple_str_plain_self_str_plain_data_tuple;
extern PyObject *const_str_plain_getpeername;
extern PyObject *const_str_plain___prepare__;
static PyObject *const_str_plain_trust;
static PyObject *const_str_plain__connected;
static PyObject *const_str_plain_HAS_TLSv1_2;
static PyObject *const_str_plain_Purpose;
extern PyObject *const_str_plain_write;
static PyObject *const_str_digest_eb88db45ef5928fe9d291865fa2c3133;
extern PyObject *const_str_plain_AF_INET;
static PyObject *const_str_plain_MINIMUM_SUPPORTED;
static PyObject *const_tuple_str_plain_self_str_plain_purpose_str_plain_storename_tuple;
static PyObject *const_str_digest_b0a77916798fd37c9cee67fc494763a2;
static PyObject *const_str_plain__set_alpn_protocols;
extern PyObject *const_str_plain_kwargs;
static PyObject *const_str_plain_sslobj;
static PyObject *const_str_plain__inet_paton;
static PyObject *const_str_digest_4fb5691c9145cd18b6bc6017c9a5b8c6;
static PyObject *const_str_digest_8c034cf983cd380cdbc5f3747143f35a;
static PyObject *const_str_digest_826765c7ea5b1e2da81cc031af37a88e;
extern PyObject *const_str_plain_format;
static PyObject *const_str_digest_a4d6f3a910ee9d9d33781f7776fa0650;
static PyObject *const_tuple_str_plain_timegm_tuple;
extern PyObject *const_str_plain_startswith;
extern PyObject *const_str_plain_property;
static PyObject *const_tuple_97d33b1871b78e86b4d3116dd7c89853_tuple;
static PyObject *const_str_plain_PROTO_TLSv1_3;
static PyObject *const_str_plain__OPENSSL_API_VERSION;
static PyObject *const_str_plain_CA;
static PyObject *const_str_digest_32e7fb4c0950e94f71a622b4bef91a91;
static PyObject *const_str_plain_wrap_bio;
static PyObject *const_tuple_str_plain_ipname_str_plain_host_ip_str_plain_ip_tuple;
extern PyObject *const_str_plain_index;
static PyObject *const_str_digest_fe4ba6fdabf4a04ac73d126c6842f5da;
static PyObject *const_str_plain_create_default_context;
static PyObject *const_str_plain_get_server_certificate;
static PyObject *const_str_plain_enum_certificates;
static PyObject *const_str_digest_90dcfb0c5b2e395585c44f2c6f8db8bf;
extern PyObject *const_str_plain___file__;
extern PyObject *const_str_plain_setter;
extern PyObject *const_str_plain_unwrap;
static PyObject *const_str_plain_san;
static PyObject *const_str_plain__SSLv2_IF_EXISTS;
static PyObject *const_str_digest_7d6cdae49b3a41339758fb29bb72d243;
static PyObject *const_str_digest_c450fc9edb672e51af4935d607b84f7d;
static PyObject *const_str_plain_CHANNEL_BINDING_TYPES;
static PyObject *const_tuple_str_plain_self_str_plain_ctx_tuple;
static PyObject *const_str_plain_VerifyMode;
static PyObject *const_str_digest_a8d27a0e9b66d922ecd6eaf962f1e7ac;
static PyObject *const_str_digest_7612dba174ee645b8f9d8c3109227a4c;
static PyObject *const_str_digest_04a99d395c987ae1e95aaa52fcd9f5b1;
static PyObject *const_str_plain_set_servername_callback;
static PyObject *const_str_digest_f80b04da9426dc3c6eb61b2e2c8cefdc;
static PyObject *const_str_plain_HAS_TLSv1;
static PyObject *const_tuple_str_plain_self_str_plain_how_str_plain___class___tuple;
static PyObject *const_str_digest_5d916050d0a708334c1549a93d19962a;
extern PyObject *const_str_plain_strip;
static PyObject *const_str_plain__ipaddress_match;
static PyObject *const_str_plain_match_hostname;
static PyObject *const_str_digest_c9952bf55f4165e8dd5c4f498af92c1c;
static PyObject *const_str_plain_ciphers;
static PyObject *const_tuple_67e83e4c1a580aa75b711d7b7e138e06_tuple;
extern PyObject *const_str_plain_read;
static PyObject *const_str_digest_cb937a135d1407a4127cb28ad691044b;
extern PyObject *const_str_plain_platform;
extern PyObject *const_str_plain_connect;
static PyObject *const_tuple_str_plain_ALERT_DESCRIPTION__tuple;
static PyObject *const_str_digest_8ccc1038eb9505b2eb128b6c50cf7933;
extern PyObject *const_str_plain_lower;
static PyObject *const_tuple_8f4a9ecee5b69684c6422c4623b74375_tuple;
extern PyObject *const_str_plain___orig_bases__;
static PyObject *const_str_digest_8929e5696096b1b3a769926d596fd01d;
static PyObject *const_tuple_str_plain_pem_cert_string_str_plain_d_tuple;
extern PyObject *const_str_plain_close;
static PyObject *const_str_digest_b80e22ff8ef58437a3cdcf9966f6ec5d;
static PyObject *const_str_plain_dn_remainder;
static PyObject *const_str_digest_0e5d7991443807262ff75d28a8d3aab1;
extern PyObject *const_str_plain___qualname__;
static PyObject *const_str_digest_4807acc2340e0a598c0f10463503adbb;
static PyObject *const_str_plain_nid;
extern PyObject *const_str_plain_value;
extern PyObject *const_str_plain_collections;
static PyObject *const_str_plain_DNS;
static PyObject *const_tuple_str_digest_d9ecb2d1bd7c2c654c39bebb9c4b95c7_tuple;
extern PyObject *const_str_plain_e;
static PyObject *const_str_plain_PROTO_TLSv1_1;
extern PyObject *const_str_plain_context;
static PyObject *const_str_digest_8f0f33542a5d07b827a3c15795f1bcd3;
extern PyObject *const_str_plain_decodebytes;
static PyObject *const_str_plain__dnsname_match;
static PyObject *const_str_digest_225bcc70c32be5d588e199b061dc20c4;
static PyObject *const_str_digest_a94b2028d7a56b84bcb25adb9dde5120;
static PyObject *const_tuple_str_plain_Enum_str_plain_IntEnum_str_plain_IntFlag_tuple;
extern PyObject *const_str_plain_IntFlag;
static PyObject *const_tuple_int_pos_1024_none_tuple;
static PyObject *const_str_digest_8646af1ebee17c0c9f3fc9ba01d5d9b4;
static PyObject *const_str_digest_f27b9bf56c746e209815ef274ec83cd3;
extern PyObject *const_tuple_str_plain_self_str_plain_value_tuple;
static PyObject *const_str_digest_8d25e8341eff71b65c9386d4018600c9;
static PyObject *const_tuple_str_digest_89945f27978b3c4970283807e6649ec5_tuple;
static PyObject *const_str_plain_storename;
extern PyObject *const_str_plain_verify_mode;
extern PyObject *const_str_plain_timegm;
static PyObject *const_str_digest_3093a3b7e6ad2e3ac70240f1b5e28199;
static PyObject *const_str_plain_SSLv3;
static PyObject *const_str_plain_PROTOCOL_TLS;
extern PyObject *const_str_plain_proto;
static PyObject *const_tuple_str_plain_cls_str_plain_name_str_plain___class___tuple;
extern PyObject *const_str_plain_ip;
extern PyObject *const_str_plain_decode;
extern PyObject *const_str_plain_buffer;
extern PyObject *const_str_plain___getitem__;
extern PyObject *const_str_plain_f;
static PyObject *const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple;
extern PyObject *const_str_plain_ss;
extern PyObject *const_str_plain_memoryview;
static PyObject *const_str_plain_capath;
extern PyObject *const_slice_none_int_pos_3_none;
static PyObject *const_tuple_str_digest_b8a3e24bd480f9d749e7f38794d9a804_tuple;
extern PyObject *const_str_plain_rc;
static PyObject *const_str_digest_0b796367a64c49cc2aaf578dcf85fdf5;
extern PyObject *const_str_plain_server_hostname;
static PyObject *const_str_digest_7024ed96f0952bfda665eb960a91de44;
static PyObject *const_str_plain__DEFAULT_CIPHERS;
extern PyObject *const_str_plain_subject;
static PyObject *const_str_plain_do_handshake;
extern PyObject *const_str_plain_origin;
static PyObject *const_tuple_str_plain_cls_str_plain_nid_str_plain___class___tuple;
extern PyObject *const_tuple_none_int_0_tuple;
static PyObject *const_str_digest_9350c794d641bf1e05d2d5f369964cf4;
extern PyObject *const_str_digest_75fd71b1edada749c2ef7ac810062295;
static PyObject *const_str_digest_3b35d51050a71678e6a91f8af50bcd6c;
static PyObject *const_str_plain_CERT_;
static PyObject *const_str_plain_dn;
extern PyObject *const_str_plain_namedtuple;
static PyObject *const_tuple_39aff8525553a45d78a58dd13ef2a06a_tuple;
static PyObject *const_str_plain_ENOTCONN;
static PyObject *const_tuple_a840e2093a227646419041bdd371a27b_tuple;
extern PyObject *const_str_plain_CERT_NONE;
extern PyObject *const_str_plain_d;
static PyObject *const_str_digest_435b76333d08b4e4e629143b740aa218;
extern PyObject *const_str_plain_v;
static PyObject *const_str_digest_4cf3e4c966a8b447aeec91c80c53ce91;
static PyObject *const_str_digest_cee8a0917b60d1bd22f94d241f22b50b;
static PyObject *const_str_plain_HAS_TLSv1_3;
static PyObject *const_str_digest_b57613816b83a6d5e901aa481a5f48e3;
static PyObject *const_tuple_str_plain_i_str_plain_f_tuple;
static PyObject *const_str_plain_subjectAltName;
extern PyObject *const_str_plain_sys;
extern PyObject *const_str_plain_dup;
extern PyObject *const_str_plain_Dec;
static PyObject *const_str_digest_951e41b571762ac2eab94889431d0c17;
extern PyObject *const_str_plain_socket;
static PyObject *const_str_plain_cert_time;
static PyObject *const_str_digest_c1de6fe860a671d1e1fb4f389bb9c11f;
static PyObject *const_str_digest_223a8a47fa4e201be7d43aff732dd6e1;
static PyObject *const_str_digest_4fc88bc781b6216d197d14984f6b65eb;
extern PyObject *const_str_plain_hostname;
extern PyObject *const_str_plain_key;
extern PyObject *const_str_plain___init__;
static PyObject *const_str_digest_e8ba3556e5c659d7313d4a7290713be4;
static PyObject *const_str_digest_fa76902b0955d1f1a4101fca59e6c5f4;
static PyObject *const_tuple_7473acf6d330ed226a15523988ec3e21_tuple;
static PyObject *const_str_digest_456481dfc3cfeda5b8ffadc3f499a1a7;
static PyObject *const_str_plain_recvfrom_into;
static PyObject *const_str_plain_keyfile;
static PyObject *const_tuple_str_plain_self_str_plain_ncs_tuple;
extern PyObject *const_str_plain_has_location;
extern PyObject *const_str_plain_check_hostname;
extern PyObject *const_str_plain_version;
static PyObject *const_str_plain_SSLCertVerificationError;
extern PyObject *const_str_plain_ascii;
static PyObject *const_str_digest_c9db670f24eb7241cf3b613e4b11a252;
static PyObject *const_str_plain_getsockopt;
static PyObject *const_str_plain__RESTRICTED_SERVER_CIPHERS;
extern PyObject *const_str_empty;
extern PyObject *const_float_0_0;
static PyObject *const_str_plain_PEM_FOOTER;
static PyObject *const_tuple_str_plain_txt2obj_str_plain_nid2obj_tuple;
static PyObject *const_tuple_false_true_true_none_none_none_tuple;
static PyObject *const_tuple_730fbfff731a79523b12989c446f00e5_tuple;
static PyObject *const_tuple_fd5b2cb4c7284fdcd887df9c923ef28a_tuple;
static PyObject *const_str_digest_222811c1d4bf55fcbb49085a180f5432;
static PyObject *const_tuple_str_plain_self_str_plain_hostname_tuple;
static PyObject *const_dict_f68e37ae246dcd2f55c6ccbc7f9fbda7;
extern PyObject *const_str_plain_load_cert_chain;
static PyObject *const_str_plain_MAXIMUM_SUPPORTED;
static PyObject *const_str_digest_2827a02148585180db385ecab4334673;
extern PyObject *const_str_plain_sep;
static PyObject *const_str_plain__PROTOCOL_NAMES;
extern PyObject *const_str_plain_nbytes;
static PyObject *const_str_plain_CertificateError;
static PyObject *const_str_plain_dnsnames;
static PyObject *const_str_digest_57a4d671eaa11e961fe988b76b7923cd;
static PyObject *const_tuple_str_plain__DEFAULT_CIPHERS_str_plain__OPENSSL_API_VERSION_tuple;
static PyObject *const_str_plain_set_npn_protocols;
static PyObject *const_str_digest_b6fbb08e38a8d1423a7161f4ef2729f2;
static PyObject *const_str_digest_f3568165cd86b32f3e6c65bf9c020450;
static PyObject *const_str_digest_369cd8552536fc20754a282ea727c715;
extern PyObject *const_tuple_str_chr_42_tuple;
static PyObject *const_str_digest_d348e50cee6b156ae47b722599f9ef5e;
extern PyObject *const_str_plain__socket;
static PyObject *const_str_plain_PROTO_TLSv1_2;
static PyObject *const_tuple_str_plain_der_cert_bytes_str_plain_f_str_plain_ss_tuple;
static PyObject *const_str_plain_set_default_verify_paths;
static PyObject *const_str_plain_host_ip;
static PyObject *const_tuple_str_plain_cls_str_plain_oid_str_plain___class___tuple;
static PyObject *const_str_digest_2f5b04e7ff781fc829fd1336b1bac5d6;
static PyObject *const_tuple_str_plain_parts_str_plain_cafile_str_plain_capath_tuple;
static PyObject *const_str_plain_server_side;
static PyObject *const_str_digest_7a9028390fde6cbc9e4e83008c224f13;
static PyObject *const_str_plain_ncs;
extern PyObject *const_str_plain_classmethod;
static PyObject *const_slice_int_pos_2_int_pos_6_none;
static PyObject *const_str_plain_OPENSSL_VERSION;
static PyObject *const_str_plain_OPENSSL_VERSION_INFO;
static PyObject *const_str_digest_e4e3c476682898be85f27f17e066582d;
static PyObject *const_str_plain__nid2obj;
extern PyObject *const_str_plain_detach;
static PyObject *const_tuple_str_plain_B_tuple;
static PyObject *const_str_digest_f21776754563ee820956e9eca7440392;
static PyObject *const_tuple_false_true_true_none_none_tuple;
static PyObject *const_tuple_294dabb5a2c5ba151197a7c7ec901527_tuple;
static PyObject *const_str_plain__wrap_bio;
extern PyObject *const_tuple_true_tuple;
static PyObject *const_tuple_1aab3e41f37d07b6590ecac751f85fc1_tuple;
static PyObject *const_str_plain_session_reused;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_digest_87cdc7b3da2a01efa67fc002f5f9e93d;
static PyObject *const_str_plain_block;
extern PyObject *const_str_plain_extend;
static PyObject *const_str_plain_hostname_leftmost;
static PyObject *const_str_plain_CERT_REQUIRED;
static PyObject *const_list_str_digest_554140970ff737b96d003bcbb3246411_list;
extern PyObject *const_str_plain_data;
extern PyObject *const_str_plain_options;
extern PyObject *const_tuple_str_plain_ascii_tuple;
static PyObject *const_str_plain_time_format;
extern PyObject *const_str_plain_s;
extern PyObject *const_str_plain_warnings;
static PyObject *const_str_digest_264d5c6db8f5a84d0fe413b3a21dca69;
extern PyObject *const_tuple_str_plain_namedtuple_tuple;
static PyObject *const_str_digest_3b82cb8ef6775b0d84aaa035b45db24a;
static PyObject *const_str_plain_TLSv1_3;
extern PyObject *const_str_plain_recv_into;
static PyObject *const_str_plain_buflen;
static PyObject *const_str_plain_SSLContext;
extern PyObject *const_str_plain__context;
static PyObject *const_str_plain_PROTO_MAXIMUM_SUPPORTED;
static PyObject *const_str_plain_txt2obj;
static PyObject *const_str_digest_04ce73b765f1cc9fc45cba5d95755307;
static PyObject *const_str_plain_dercert;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_str_digest_0eae601715bd5c30805ac496fbcd9992;
static PyObject *const_tuple_8cbc413f7ba377eb28c3c8de0f0a31a6_tuple;
extern PyObject *const_str_plain_sendto;
static PyObject *const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple;
extern PyObject *const_tuple_false_none_none_tuple;
static PyObject *const_str_plain_alpn_protocols;
static PyObject *const_str_digest_f66ea29fd347bd1e1c153f7fc85b4c4d;
static PyObject *const_str_digest_d419c0cfda05a6c7cddfa9e5ecabff66;
static PyObject *const_str_plain_VERIFY_;
static PyObject *const_str_plain_set_ciphers;
static PyObject *const_str_plain_purpose;
extern PyObject *const_tuple_str_plain_idna_tuple;
extern PyObject *const_tuple_empty;
static PyObject *const_str_digest_d88b1a2ff0cfef8fd6528c6cef0c98c5;
extern PyObject *const_str_plain_append;
static PyObject *const_str_digest_6bb5243f02b53df7c631337cce5d1e63;
static PyObject *const_str_plain_SSLErrorNumber;
static PyObject *const_tuple_str_plain_SSL_ERROR__tuple;
static PyObject *const_str_plain_session;
static PyObject *const_str_digest_9efba2909c944f0cd3b20389eca3a9de;
static PyObject *const_str_plain_HOSTFLAG_NEVER_CHECK_SUBJECT;
static PyObject *const_str_plain_SSLZeroReturnError;
static PyObject *const_str_digest_21bb40eac1bbe9900e4b65be65bdbc0d;
extern PyObject *const_str_plain_b;
static PyObject *const_str_plain_RAND_bytes;
static PyObject *const_tuple_str_plain_RAND_egd_tuple;
static PyObject *const_str_plain_get_channel_binding;
extern PyObject *const_tuple_type_OSError_type_ValueError_tuple;
static PyObject *const_str_plain_AlertDescription;
static PyObject *const_str_digest_a30bfbfaff6053905e0182626560596e;
static PyObject *const_str_plain_PEM_HEADER;
extern PyObject *const_str_plain_ssl;
static PyObject *const_str_digest_c9e0ace64f4cd2826bb360e8a68ae1a8;
static PyObject *const_str_plain_do_handshake_on_connect;
static PyObject *const_str_digest_4d5300aa45c1f4e7d70a328a278e2af4;
static PyObject *const_str_digest_a4e634bd5e8eac5aa83cadc1f04fa575;
static PyObject *const_tuple_09c2d80bf2e47e0bc7f1c9dc811cecbd_tuple;
extern PyObject *const_str_plain_msg;
extern PyObject *const_str_plain_hasattr;
static PyObject *const_str_plain__create_unverified_context;
static PyObject *const_str_digest_80ae286fde266c9ce3eea805317b53e8;
extern PyObject *const_str_plain___slots__;
static PyObject *const_tuple_str_plain_self_str_plain_block_str_plain_timeout_tuple;
extern PyObject *const_str_plain__checkClosed;
static PyObject *const_str_plain_cert_reqs;
static PyObject *const_str_digest_753f93511d826caab3f92515b0253a28;
static PyObject *const_str_plain_OPENSSL_VERSION_NUMBER;
static PyObject *const_str_plain_SSL_ERROR_EOF;
extern PyObject *const_str_plain_x;
static PyObject *const_str_digest_3a1a2ed1355dcbc368d7b0eae97a5e62;
static PyObject *const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple;
static PyObject *const_str_plain_SSLWantWriteError;
static PyObject *const_str_digest_970482a40f2631f2b534044dbb186357;
static PyObject *const_str_plain_get_protocol_name;
static PyObject *const_tuple_28913759521d1747f612e333c98e07aa_tuple;
static PyObject *const_str_plain_cast;
static PyObject *const_str_digest_149ca022cd253208621db7e23b6370d3;
extern PyObject *const_str_plain_ASCII;
static PyObject *const_tuple_9007a0386d0b02e640600397a1fbac86_tuple;
static PyObject *const_str_digest_bb9901570b2b538ad6494c6c3dc8a9be;
extern PyObject *const_str_plain__convert;
static PyObject *const_str_plain_cb_type;
extern PyObject *const_str_plain___class__;
static PyObject *const_str_plain__SSLMethod;
static PyObject *const_str_digest_51317cfcec4946ff79f4fa2f128efe4d;
static PyObject *const_str_digest_9b02e8f66087246f5290f408cd07f8d6;
static PyObject *const_str_digest_fcd4e210c82bde6da13a3f919066e7a3;
static PyObject *const_tuple_str_plain_ASCII_str_plain_strict_tuple;
extern PyObject *const_str_plain___module__;
extern PyObject *const_str_plain_source;
static PyObject *const_str_plain_protocol_code;
static PyObject *const_tuple_439f0f01aa96458b63f3c1913f75c97b_tuple;
extern PyObject *const_str_plain_idna;
static PyObject *const_str_digest_b8a3e24bd480f9d749e7f38794d9a804;
static PyObject *const_tuple_d0e8e14d58a1064421ad37c78bfe9656_tuple;
static PyObject *const_tuple_str_digest_bb9901570b2b538ad6494c6c3dc8a9be_tuple;
static PyObject *const_str_plain__SSLContext;
static PyObject *const_str_digest_407044a0a44e7edcc517eceddb07768e;
static PyObject *const_str_digest_fdb327d09a1abb4e12c500a6d5b181cc;
static PyObject *const_tuple_3835b204829c945e05cb7681afc63bf9_tuple;
static PyObject *const_str_plain_ROOT;
extern PyObject *const_str_plain_Nov;
static PyObject *const_str_plain_PROTOCOL_;
static PyObject *const_str_plain_hostname_remainder;
static PyObject *const_tuple_str_plain_SSLObject_tuple_empty_tuple;
extern PyObject *const_str_plain_enum;
extern PyObject *const_str_plain_create_connection;
static PyObject *const_str_plain_x509_asn;
static PyObject *const_tuple_str_plain_OP__tuple;
static PyObject *const_tuple_e0867d1d1bdc1b09db9831d078cf5291_tuple;
static PyObject *const_str_plain_protos;
extern PyObject *const_str_plain_Jul;
static PyObject *const_str_plain_newsock;
static PyObject *const_str_plain__check_connected;
extern PyObject *const_str_plain_get;
static PyObject *const_str_plain_connect_ex;
static PyObject *const_str_plain_TLSVersion;
static PyObject *const_str_plain__windows_cert_stores;
static PyObject *const_tuple_str_digest_554140970ff737b96d003bcbb3246411_tuple;
static PyObject *const_str_plain_RAND_add;
static PyObject *const_str_plain_certfile;
static PyObject *const_tuple_false_none_none_none_tuple;
static PyObject *const_str_plain_TLSv1_1;
static PyObject *const_tuple_str_plain_protocol_code_tuple;
static PyObject *const_str_plain_SSLError;
extern PyObject *const_str_plain_win32;
static PyObject *const_str_digest_0e477d4fd7854861d3a3e53f3c18df7a;
extern PyObject *const_str_plain_shutdown;
static PyObject *const_str_plain_RAND_egd;
static PyObject *const_str_plain_SO_TYPE;
extern PyObject *const_str_plain_Oct;
static PyObject *const_str_plain_PEM_cert_to_DER_cert;
static PyObject *const_str_plain___set__;
extern PyObject *const_str_angle_dictcontraction;
extern PyObject *const_str_plain_warn;
static PyObject *const_str_plain_CLIENT_AUTH;
extern PyObject *const_str_plain_metaclass;
extern PyObject *const_str_plain_addr;
static PyObject *const_str_plain_certs;
static PyObject *const_str_plain__load_windows_store_certs;
static PyObject *const_str_angle_unknown;
static PyObject *const_str_digest_7860efcfc68c94064108f332b0e7ea2b;
static PyObject *const_str_plain_ALERT_DESCRIPTION_;
static PyObject *const_str_digest_dd8dbc1762dbe3e65f1ad22cbe807685;
extern PyObject *const_tuple_str_plain___class___tuple;
extern PyObject *const_tuple_false_tuple;
extern PyObject *const_str_angle_metaclass;
static PyObject *const_str_digest_3aecc77c85cde288c70f925a7ff0779e;
static PyObject *const_str_digest_0fb7a77c6d8e8842d00fc65591c86f2b;
static PyObject *const_tuple_str_plain_CERT__tuple;
static PyObject *const_str_plain_SERVER_AUTH;
extern PyObject *const_str_plain_offset;
extern PyObject *const_str_plain_args;
static PyObject *const_str_plain_HAS_SNI;
extern PyObject *const_str_plain___exit__;
extern PyObject *const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple;
static PyObject *const_tuple_str_plain_PROTOCOL__tuple;
static PyObject *const_str_digest_d168cf6508757f44c350431e0146bcff;
static PyObject *const_str_digest_a81fde8cd3c79156638379a671de86c9;
static PyObject *const_str_digest_1deb9ad8da903aa02d0662894e4e5d19;
static PyObject *const_str_digest_02add5f1196bf0982325724e556ddbe7;
static PyObject *const_str_digest_554140970ff737b96d003bcbb3246411;
static PyObject *const_str_digest_50b5c2eaada4a849fea984fb96dc55f1;
extern PyObject *const_str_plain_protocol;
extern PyObject *const_str_plain_items;
extern PyObject *const_str_plain__sendfile_use_send;
static PyObject *const_str_digest_dddcbf0d2d0cc36b841a5401bf4b26d0;
static PyObject *const_str_digest_66cbc636bc9077e66f69e97ca6e2f8dc;
extern PyObject *const_str_plain_sub;
extern PyObject *const_int_pos_6;
static PyObject *const_tuple_str_plain_SOL_SOCKET_str_plain_SO_TYPE_tuple;
static PyObject *const_str_digest_8571c784ae144b6aa943c631c479aeb3;
extern PyObject *const_slice_int_pos_3_none_none;
static PyObject *const_tuple_5eefc4a79eaaa5a3d617b77219790036_tuple;
static PyObject *const_str_plain_month_number;
static PyObject *const_str_plain_get_default_verify_paths;
extern PyObject *const_str_plain___enter__;
extern PyObject *const_str_plain_isfile;
static PyObject *const_str_plain_VerifyFlags;
extern PyObject *const_str_plain_cls;
static PyObject *const_str_digest_d2f106a7c85896a5d2d135f72c5b78b7;
extern PyObject *const_int_pos_1024;
static PyObject *const_str_plain_SSLEOFError;
extern PyObject *const_str_plain_Mar;
static PyObject *const_str_digest_cb9fea72893243c85d3f8a7fa5745fd1;
extern PyObject *const_str_plain_join;
static PyObject *const_str_digest_b2d667c37f49b62a93484716e8b4da43;
static PyObject *const_str_digest_5792c6e630cc995ac06314e738846670;
static PyObject *const_str_plain_npn_protocols;
static PyObject *const_str_plain_TLSv1;
static PyObject *const_str_digest_678b55cb9e2bbf2e94eb06e9ceb20edc;
extern PyObject *const_str_dot;
static PyObject *const_str_digest_0658b8b82bf1e6709c574f4d2869db22;
static PyObject *const_str_digest_13a57eb57bd6e3598d5407c5d5c65a2c;
static PyObject *const_tuple_str_plain_ipname_tuple;
static PyObject *const_str_plain_oid;
extern PyObject *const_str_plain_environ;
static PyObject *const_str_plain_standard_b64encode;
static PyObject *const_str_digest_8b455849c74cb8521c58441c05e67f30;
extern PyObject *const_str_plain_len;
extern PyObject *const_str_plain_partition;
static PyObject *const_str_digest_123738711ea439506bcf12b2e47bd0ba;
static PyObject *const_str_digest_baf3113a8ef52750e55aaa38049d03e1;
static PyObject *const_str_plain_maximum_version;
extern PyObject *const_str_plain_sendall;
extern PyObject *const_str_plain__real_close;
static PyObject *const_tuple_str_plain_CA_str_plain_ROOT_tuple;
extern PyObject *const_tuple_int_0_none_tuple;
extern PyObject *const_str_plain_host;
static PyObject *const_str_digest_ec2adfb37273b3eee2296f564999ae55;
static PyObject *const_str_plain_HAS_ECDH;
static PyObject *const_str_digest_0b3815e873a7a8f2437fdb42dbe60fbf;
static PyObject *const_str_plain__host_flags;
static PyObject *const_str_digest_2444bca47c3e4bf63ad35ca166c38217;
static PyObject *const_str_digest_4271da0b33163508c03517c8a66c3ca2;
static PyObject *const_tuple_int_pos_1024_int_0_tuple;
static PyObject *const_str_plain_server_name_callback;
static PyObject *const_str_digest_02a360a134c6bbb34ce8a608f7da370d;
static PyObject *const_str_plain_shim_cb;
extern PyObject *const_str_plain_owner;
extern PyObject *const_str_plain_SOCK_STREAM;
static PyObject *const_str_digest_5b11666b6324b89e4fc385fb93a3c5a5;
static PyObject *const_str_plain_nid2obj;
static PyObject *const_str_plain_sslobject_class;
static PyObject *const_str_digest_180e88c045483f282cc9d36d7ae789f2;
static PyObject *const_str_digest_f042bcd35862fbe10a0a40d4f034fbdc;
extern PyObject *const_str_plain_parts;
static PyObject *const_str_digest_0cf93d32ee4dc8845c885030fe30aef6;
extern PyObject *const_str_plain_strptime;
static PyObject *const_str_plain_TLSv1_2;
static PyObject *const_str_digest_f76ed44c3c7f75a52e9e990d67888b38;
static PyObject *const_str_plain_SSLSocket;
static PyObject *const_tuple_da309a4929ea4a4af6aee082c29fb449_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_msg_tuple;
extern PyObject *const_str_plain_title;
static PyObject *const_str_plain_dn_leftmost;
static PyObject *const_str_plain_der_cert_bytes;
static PyObject *const_str_plain_byte_view;
static PyObject *const_str_digest_6d4e3117ce2e396558d0d26361294da1;
extern PyObject *const_str_plain_send;
static PyObject *const_str_digest_c0263368b21f5075dd51002a02eed279;
extern PyObject *const_str_plain_Apr;
static PyObject *const_str_digest_6ca8402699116cba8121763dd25b997a;
extern PyObject *const_str_plain_Sep;
static PyObject *const_str_digest_8b4af18647c3b6e36880d4732ff55e63;
static PyObject *const_str_plain_PROTO_MINIMUM_SUPPORTED;
static PyObject *const_str_plain_cert;
static PyObject *const_str_plain_sslsocket_class;
static PyObject *const_str_plain_cadata;
static PyObject *const_str_digest_193178a81b56eec77a885bf7ab4dceb1;
extern PyObject *const_str_plain_tt;
extern PyObject *const_str_plain_strict;
static PyObject *const_str_digest_49f919db6f48720fb21b9178605834a0;
static PyObject *const_str_plain_minimum_version;
static PyObject *const_str_digest_a3d78346cd2f65fd6e9e17d7199e08b2;
extern PyObject *const_str_plain_encoding;
extern PyObject *const_str_plain_count;
extern PyObject *const_str_plain_May;
static PyObject *const_str_digest_2021457612f445845421aa4f7c76fecb;
static PyObject *const_str_digest_f7f5e69e32188905b76a51140481c41c;
static PyObject *const_str_plain_outgoing;
extern PyObject *const_str_plain__create;
static PyObject *const_str_digest_578daa481dfc5d6804fc66ea53284c53;
static PyObject *const_str_plain_RAND_status;
static PyObject *const_str_digest_8c05d508622896570bf3da8f7e6eb9cb;
static PyObject *const_str_digest_9d03fd1f2eedc7fbd45f8a10e06e8ab5;
static PyObject *const_str_plain_shared_ciphers;
extern PyObject *const_str_angle_listcomp;
static PyObject *const_str_digest_31df743f2ce3fe988549bc25f2c8482c;
extern PyObject *const_str_plain_pending;
static PyObject *const_str_plain_SSL_ERROR_;
extern PyObject *const_str_angle_lambda;
static PyObject *const_str_plain__ssl;
extern PyObject *const_bytes_empty;
static PyObject *const_str_plain_PROTO_SSLv3;
static PyObject *const_str_digest_d301f91992faa4f4f10ac91822e37e3a;
extern PyObject *const_str_plain_Enum;
static PyObject *const_str_plain_cert_time_to_seconds;
static PyObject *const_str_plain_HAS_TLSv1_1;
static PyObject *const_str_plain_RAND_pseudo_bytes;
static PyObject *const_tuple_str_plain_self_str_plain_binary_form_tuple;
static PyObject *const_str_plain_selected_alpn_protocol;
static PyObject *const_str_plain_PROTOCOL_SSLv23;
static PyObject *const_tuple_str_plain_self_str_plain_session_tuple;
static PyObject *const_str_plain_inet_pton;
static PyObject *const_str_plain_HAS_ALPN;
static PyObject *const_str_plain_set_alpn_protocols;
extern PyObject *const_str_plain_accept;
extern PyObject *const_str_plain_Jan;
static PyObject *const_str_digest_4741f80d59d6685d72d119c884a60415;
extern PyObject *const_str_plain_recvfrom;
static PyObject *const_str_plain__create_stdlib_context;
static PyObject *const_str_plain_ca_certs;
extern PyObject *const_str_plain_Aug;
static PyObject *const_str_digest_29e692b3bed0448c0fbf90eb672dc2f9;
static PyObject *const_dict_cd6cfa3585e1c44ad0bb320b3a2f22a4;
extern PyObject *const_str_newline;
extern PyObject *const_int_pos_3;
static PyObject *const_str_digest_f3ad832901b185e93d30c52a67b18042;
static PyObject *const_str_plain_SSLSyscallError;
extern PyObject *const_str_plain_SOL_SOCKET;
extern PyObject *const_int_pos_255;
static PyObject *const_str_digest_014d24052ac75a4b7ea7a7f030f06442;
extern PyObject *const_str_plain_self;
extern PyObject *const_str_plain_rstrip;
extern PyObject *const_tuple_str_plain_name_tuple;
static PyObject *const_str_digest_a9f301e988a5655ce88c2b95e37f72a0;
static PyObject *const_str_plain_sslctx;
static PyObject *const_str_plain_HAS_NEVER_CHECK_COMMON_NAME;
static PyObject *const_str_digest_aa8ad6ac7f5bb3b9bf58d630a5df3b73;
static PyObject *const_str_digest_76d751ede7bd087f9346e5a615d3c397;
static PyObject *const_tuple_6211085d7c55211a934ca9ed6de6668a_tuple;
static PyObject *const_str_plain_fromname;
static PyObject *const_str_plain_amount;
static PyObject *const_str_plain_wildcards;
extern PyObject *const_int_pos_2;
extern PyObject *const_str_plain_months;
extern PyObject *const_tuple_str_plain_self_str_plain_s_tuple;
static PyObject *const_str_plain__IntFlag;
static PyObject *const_str_digest_37015d915e90c3fed8a792f94c4aad8d;
static PyObject *const_str_digest_af3afbb4c11be74ecd4b8a361dc5a331;
extern PyObject *const_str_plain__create_default_https_context;
extern PyObject *const_str_plain_file;
static PyObject *const_str_digest_3e31e526fa6bfed4b24004be62ec2a41;
static PyObject *const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_x_tuple;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants( void )
{
    const_str_plain__Enum = UNSTREAM_STRING_ASCII( &constant_bin[ 1027361 ], 5, 1 );
    const_str_plain_connected = UNSTREAM_STRING_ASCII( &constant_bin[ 361545 ], 9, 1 );
    const_str_plain__set_npn_protocols = UNSTREAM_STRING_ASCII( &constant_bin[ 1027366 ], 18, 1 );
    const_str_digest_c7fd72035abc3711f49929c6db8a5d90 = UNSTREAM_STRING_ASCII( &constant_bin[ 1027384 ], 21, 0 );
    const_str_plain_suppress_ragged_eofs = UNSTREAM_STRING_ASCII( &constant_bin[ 1027405 ], 20, 1 );
    const_tuple_fa0db5e4cde953f91817f4436d4446fe_tuple = PyTuple_New( 3 );
    const_str_plain_OPENSSL_VERSION_NUMBER = UNSTREAM_STRING_ASCII( &constant_bin[ 1027425 ], 22, 1 );
    PyTuple_SET_ITEM( const_tuple_fa0db5e4cde953f91817f4436d4446fe_tuple, 0, const_str_plain_OPENSSL_VERSION_NUMBER ); Py_INCREF( const_str_plain_OPENSSL_VERSION_NUMBER );
    const_str_plain_OPENSSL_VERSION_INFO = UNSTREAM_STRING_ASCII( &constant_bin[ 1027447 ], 20, 1 );
    PyTuple_SET_ITEM( const_tuple_fa0db5e4cde953f91817f4436d4446fe_tuple, 1, const_str_plain_OPENSSL_VERSION_INFO ); Py_INCREF( const_str_plain_OPENSSL_VERSION_INFO );
    const_str_plain_OPENSSL_VERSION = UNSTREAM_STRING_ASCII( &constant_bin[ 1027425 ], 15, 1 );
    PyTuple_SET_ITEM( const_tuple_fa0db5e4cde953f91817f4436d4446fe_tuple, 2, const_str_plain_OPENSSL_VERSION ); Py_INCREF( const_str_plain_OPENSSL_VERSION );
    const_str_digest_086013992ea1d11747aa99e000896ea7 = UNSTREAM_STRING_ASCII( &constant_bin[ 1027467 ], 169, 0 );
    const_tuple_str_plain_self_str_plain_cb_type_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cb_type_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_cb_type = UNSTREAM_STRING_ASCII( &constant_bin[ 75969 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cb_type_tuple, 1, const_str_plain_cb_type ); Py_INCREF( const_str_plain_cb_type );
    const_str_digest_bf85e7fd1bca2b2685cec66cc7c88826 = UNSTREAM_STRING_ASCII( &constant_bin[ 1027636 ], 21, 0 );
    const_str_plain_DefaultVerifyPaths = UNSTREAM_STRING_ASCII( &constant_bin[ 1027657 ], 18, 1 );
    const_tuple_67f07609e3644b8c19de10c902eeeb48_tuple = PyTuple_New( 8 );
    const_str_plain_cert = UNSTREAM_STRING_ASCII( &constant_bin[ 41186 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_67f07609e3644b8c19de10c902eeeb48_tuple, 0, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_67f07609e3644b8c19de10c902eeeb48_tuple, 1, const_str_plain_hostname ); Py_INCREF( const_str_plain_hostname );
    const_str_plain_host_ip = UNSTREAM_STRING_ASCII( &constant_bin[ 1027675 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_67f07609e3644b8c19de10c902eeeb48_tuple, 2, const_str_plain_host_ip ); Py_INCREF( const_str_plain_host_ip );
    const_str_plain_dnsnames = UNSTREAM_STRING_ASCII( &constant_bin[ 1027682 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_67f07609e3644b8c19de10c902eeeb48_tuple, 3, const_str_plain_dnsnames ); Py_INCREF( const_str_plain_dnsnames );
    const_str_plain_san = UNSTREAM_STRING_ASCII( &constant_bin[ 582 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_67f07609e3644b8c19de10c902eeeb48_tuple, 4, const_str_plain_san ); Py_INCREF( const_str_plain_san );
    PyTuple_SET_ITEM( const_tuple_67f07609e3644b8c19de10c902eeeb48_tuple, 5, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    PyTuple_SET_ITEM( const_tuple_67f07609e3644b8c19de10c902eeeb48_tuple, 6, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_67f07609e3644b8c19de10c902eeeb48_tuple, 7, const_str_plain_sub ); Py_INCREF( const_str_plain_sub );
    const_str_plain_OP_ = UNSTREAM_STRING_ASCII( &constant_bin[ 357879 ], 3, 1 );
    const_str_plain_commonName = UNSTREAM_STRING_ASCII( &constant_bin[ 1027690 ], 10, 1 );
    const_str_digest_2b5d4e1e8c4b95888f9c32cd5e107a2a = UNSTREAM_STRING_ASCII( &constant_bin[ 1027700 ], 24, 0 );
    const_str_plain__session = UNSTREAM_STRING_ASCII( &constant_bin[ 1027724 ], 8, 1 );
    const_str_plain_sni_callback = UNSTREAM_STRING_ASCII( &constant_bin[ 1027732 ], 12, 1 );
    const_dict_a4af7150f3c5b467e93a8aa2f6959c6a = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_a4af7150f3c5b467e93a8aa2f6959c6a, const_str_plain_name, Py_False );
    assert( PyDict_Size( const_dict_a4af7150f3c5b467e93a8aa2f6959c6a ) == 1 );
    const_str_plain_sendmsg = UNSTREAM_STRING_ASCII( &constant_bin[ 1027744 ], 7, 1 );
    const_str_plain_cipher = UNSTREAM_STRING_ASCII( &constant_bin[ 1027751 ], 6, 1 );
    const_str_plain_sslsock = UNSTREAM_STRING_ASCII( &constant_bin[ 1027757 ], 7, 1 );
    const_str_plain__ASN1Object = UNSTREAM_STRING_ASCII( &constant_bin[ 1027764 ], 11, 1 );
    const_tuple_str_plain_subject_tuple_empty_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_subject_tuple_empty_tuple, 0, const_str_plain_subject ); Py_INCREF( const_str_plain_subject );
    PyTuple_SET_ITEM( const_tuple_str_plain_subject_tuple_empty_tuple, 1, const_tuple_empty ); Py_INCREF( const_tuple_empty );
    const_str_plain_load_default_certs = UNSTREAM_STRING_ASCII( &constant_bin[ 1027775 ], 18, 1 );
    const_str_plain_PROTO_TLSv1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1027793 ], 11, 1 );
    const_str_digest_0f22ebe362b5851039539f32087f48b3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1027804 ], 22, 0 );
    const_str_plain__wrap_socket = UNSTREAM_STRING_ASCII( &constant_bin[ 1027826 ], 12, 1 );
    const_str_plain_verify_client_post_handshake = UNSTREAM_STRING_ASCII( &constant_bin[ 1027838 ], 28, 1 );
    const_str_plain_fromnid = UNSTREAM_STRING_ASCII( &constant_bin[ 1027866 ], 7, 1 );
    const_str_plain_SSLWantReadError = UNSTREAM_STRING_ASCII( &constant_bin[ 1027873 ], 16, 1 );
    const_str_plain_recvmsg = UNSTREAM_STRING_ASCII( &constant_bin[ 1027889 ], 7, 1 );
    const_str_plain_binary_form = UNSTREAM_STRING_ASCII( &constant_bin[ 1027896 ], 11, 1 );
    const_str_digest_59e9ef293dda2862f98a224ced32fcd6 = UNSTREAM_STRING_ASCII( &constant_bin[ 1027907 ], 171, 0 );
    const_str_digest_00d07f74b29f8afb5fd73d7e9c08e6c3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1028078 ], 19, 0 );
    const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple = PyTuple_New( 12 );
    PyTuple_SET_ITEM( const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple, 0, const_str_plain_Jan ); Py_INCREF( const_str_plain_Jan );
    PyTuple_SET_ITEM( const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple, 1, const_str_plain_Feb ); Py_INCREF( const_str_plain_Feb );
    PyTuple_SET_ITEM( const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple, 2, const_str_plain_Mar ); Py_INCREF( const_str_plain_Mar );
    PyTuple_SET_ITEM( const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple, 3, const_str_plain_Apr ); Py_INCREF( const_str_plain_Apr );
    PyTuple_SET_ITEM( const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple, 4, const_str_plain_May ); Py_INCREF( const_str_plain_May );
    PyTuple_SET_ITEM( const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple, 5, const_str_plain_Jun ); Py_INCREF( const_str_plain_Jun );
    PyTuple_SET_ITEM( const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple, 6, const_str_plain_Jul ); Py_INCREF( const_str_plain_Jul );
    PyTuple_SET_ITEM( const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple, 7, const_str_plain_Aug ); Py_INCREF( const_str_plain_Aug );
    PyTuple_SET_ITEM( const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple, 8, const_str_plain_Sep ); Py_INCREF( const_str_plain_Sep );
    PyTuple_SET_ITEM( const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple, 9, const_str_plain_Oct ); Py_INCREF( const_str_plain_Oct );
    PyTuple_SET_ITEM( const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple, 10, const_str_plain_Nov ); Py_INCREF( const_str_plain_Nov );
    PyTuple_SET_ITEM( const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple, 11, const_str_plain_Dec ); Py_INCREF( const_str_plain_Dec );
    const_str_digest_11ed960077872fa0d08c8c433b669058 = UNSTREAM_STRING_ASCII( &constant_bin[ 1028097 ], 20, 0 );
    const_tuple_str_plain_self_str_plain_value_str_plain___class___tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_value_str_plain___class___tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_value_str_plain___class___tuple, 1, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_value_str_plain___class___tuple, 2, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_str_plain_HAS_NPN = UNSTREAM_STRING_ASCII( &constant_bin[ 1028117 ], 7, 1 );
    const_str_digest_89945f27978b3c4970283807e6649ec5 = UNSTREAM_STRING_ASCII( &constant_bin[ 1028124 ], 40, 0 );
    const_str_plain_load_verify_locations = UNSTREAM_STRING_ASCII( &constant_bin[ 1028164 ], 21, 1 );
    const_str_plain_ssl_version = UNSTREAM_STRING_ASCII( &constant_bin[ 1028185 ], 11, 1 );
    const_str_plain_inet_aton = UNSTREAM_STRING_ASCII( &constant_bin[ 1010910 ], 9, 1 );
    const_str_plain_socket_error = UNSTREAM_STRING_ASCII( &constant_bin[ 1028196 ], 12, 1 );
    const_tuple_str_plain_self_str_plain_addr_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_addr_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_addr_tuple, 1, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    const_str_plain_recvmsg_into = UNSTREAM_STRING_ASCII( &constant_bin[ 1028208 ], 12, 1 );
    const_str_plain__encode_hostname = UNSTREAM_STRING_ASCII( &constant_bin[ 1028220 ], 16, 1 );
    const_str_plain_ctx = UNSTREAM_STRING_ASCII( &constant_bin[ 33894 ], 3, 1 );
    const_str_digest_f3590796fc6a572064ab68e58c2e47b2 = UNSTREAM_STRING_ASCII( &constant_bin[ 1028236 ], 47, 0 );
    const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_v_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_v_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_v_tuple, 1, const_str_plain_len ); Py_INCREF( const_str_plain_len );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_v_tuple, 2, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_v_tuple, 3, const_str_plain_v ); Py_INCREF( const_str_plain_v );
    const_str_digest_bd00534ecca984542679be9e93bb7f91 = UNSTREAM_STRING_ASCII( &constant_bin[ 1028283 ], 24, 0 );
    const_str_plain_PROTOCOL_SSLv2 = UNSTREAM_STRING_ASCII( &constant_bin[ 1028307 ], 14, 1 );
    const_str_digest_d9ecb2d1bd7c2c654c39bebb9c4b95c7 = UNSTREAM_STRING_ASCII( &constant_bin[ 1028321 ], 45, 0 );
    const_str_digest_04681951689da94a8b8ef39f2d829632 = UNSTREAM_STRING_ASCII( &constant_bin[ 1028366 ], 219, 0 );
    const_str_plain_HAS_SSLv2 = UNSTREAM_STRING_ASCII( &constant_bin[ 1028585 ], 9, 1 );
    const_str_digest_0f3e3cca38e905dbbeef437e4cc1b13f = UNSTREAM_STRING_ASCII( &constant_bin[ 1028594 ], 228, 0 );
    const_str_digest_b1639321a9474ecb1b885a74076648f9 = UNSTREAM_STRING_ASCII( &constant_bin[ 1028822 ], 420, 0 );
    const_str_plain_MemoryBIO = UNSTREAM_STRING_ASCII( &constant_bin[ 1029242 ], 9, 1 );
    const_str_digest_e00eea51626e2d416545145e0341879e = UNSTREAM_STRING_ASCII( &constant_bin[ 1029251 ], 104, 0 );
    const_str_plain_pem_cert_string = UNSTREAM_STRING_ASCII( &constant_bin[ 1029355 ], 15, 1 );
    const_tuple_str_plain_strptime_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_strptime_tuple, 0, const_str_plain_strptime ); Py_INCREF( const_str_plain_strptime );
    const_tuple_a6e5b7213d740be0ae002af3220b2e2c_tuple = PyTuple_New( 5 );
    const_str_plain_purpose = UNSTREAM_STRING_ASCII( &constant_bin[ 100953 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_a6e5b7213d740be0ae002af3220b2e2c_tuple, 0, const_str_plain_purpose ); Py_INCREF( const_str_plain_purpose );
    const_str_plain_cafile = UNSTREAM_STRING_ASCII( &constant_bin[ 1029370 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_a6e5b7213d740be0ae002af3220b2e2c_tuple, 1, const_str_plain_cafile ); Py_INCREF( const_str_plain_cafile );
    const_str_plain_capath = UNSTREAM_STRING_ASCII( &constant_bin[ 1029376 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_a6e5b7213d740be0ae002af3220b2e2c_tuple, 2, const_str_plain_capath ); Py_INCREF( const_str_plain_capath );
    const_str_plain_cadata = UNSTREAM_STRING_ASCII( &constant_bin[ 1029382 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_a6e5b7213d740be0ae002af3220b2e2c_tuple, 3, const_str_plain_cadata ); Py_INCREF( const_str_plain_cadata );
    PyTuple_SET_ITEM( const_tuple_a6e5b7213d740be0ae002af3220b2e2c_tuple, 4, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    const_str_digest_4f58dc80390e8e62e2885e34b814c3ae = UNSTREAM_STRING_ASCII( &constant_bin[ 1029388 ], 39, 0 );
    const_str_digest_e1cb74300b7a6f137d7d5aaa4117b8b1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1029427 ], 29, 0 );
    const_str_plain_DER_cert_to_PEM_cert = UNSTREAM_STRING_ASCII( &constant_bin[ 1029456 ], 20, 1 );
    const_str_plain_OP_NO_SSLv3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1029476 ], 11, 1 );
    const_tuple_284226fe448516f5ff39ffa684da9193_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_284226fe448516f5ff39ffa684da9193_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_284226fe448516f5ff39ffa684da9193_tuple, 1, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_284226fe448516f5ff39ffa684da9193_tuple, 2, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    PyTuple_SET_ITEM( const_tuple_284226fe448516f5ff39ffa684da9193_tuple, 3, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_str_digest_46ab2be535dad9a4eb021b9ed0399647 = UNSTREAM_STRING_ASCII( &constant_bin[ 1029487 ], 17, 0 );
    const_str_digest_b414a1b63ea6dd23ea915006aafd2a8f = UNSTREAM_STRING_ASCII( &constant_bin[ 1029504 ], 19, 0 );
    const_str_digest_d1654dbcf9c06006c0b37bb1c5c65ca0 = UNSTREAM_STRING_ASCII( &constant_bin[ 1029523 ], 56, 0 );
    const_str_plain_verify_flags = UNSTREAM_STRING_ASCII( &constant_bin[ 1029579 ], 12, 1 );
    const_str_plain_HAS_SSLv3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1029591 ], 9, 1 );
    const_str_digest_ce00e64da7d82f6241d1726b2fac3925 = UNSTREAM_STRING_ASCII( &constant_bin[ 1029600 ], 17, 0 );
    const_str_plain_servername = UNSTREAM_STRING_ASCII( &constant_bin[ 1029617 ], 10, 1 );
    const_str_digest_a90f1c250f0693c766ae942c46747dfd = UNSTREAM_STRING_ASCII( &constant_bin[ 1029627 ], 303, 0 );
    const_str_digest_ef46d7df3260d10040c06b56d31e4b9b = UNSTREAM_STRING_ASCII( &constant_bin[ 1029930 ], 2795, 0 );
    const_str_digest_f6dd8c5e9e919cb24a1de58b3da498d7 = UNSTREAM_STRING_ASCII( &constant_bin[ 1032725 ], 225, 0 );
    const_str_digest_0376a15beee26a285b06cab589a6a7cd = UNSTREAM_STRING_ASCII( &constant_bin[ 1032950 ], 17, 0 );
    const_tuple_f08ce5d2099609de7b2c444c551dc980_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_f08ce5d2099609de7b2c444c551dc980_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f08ce5d2099609de7b2c444c551dc980_tuple, 1, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    const_str_plain_connect_ex = UNSTREAM_STRING_ASCII( &constant_bin[ 1032967 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_f08ce5d2099609de7b2c444c551dc980_tuple, 2, const_str_plain_connect_ex ); Py_INCREF( const_str_plain_connect_ex );
    PyTuple_SET_ITEM( const_tuple_f08ce5d2099609de7b2c444c551dc980_tuple, 3, const_str_plain_rc ); Py_INCREF( const_str_plain_rc );
    PyTuple_SET_ITEM( const_tuple_f08ce5d2099609de7b2c444c551dc980_tuple, 4, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_str_plain__real_connect = UNSTREAM_STRING_ASCII( &constant_bin[ 1032977 ], 13, 1 );
    const_str_plain_selected_npn_protocol = UNSTREAM_STRING_ASCII( &constant_bin[ 1032990 ], 21, 1 );
    const_str_digest_c126f313dbab329c6eb48d2d248e63ab = UNSTREAM_STRING_ASCII( &constant_bin[ 1033011 ], 26, 0 );
    const_str_plain_ipname = UNSTREAM_STRING_ASCII( &constant_bin[ 1033037 ], 6, 1 );
    const_str_plain_SSLObject = UNSTREAM_STRING_ASCII( &constant_bin[ 1028283 ], 9, 1 );
    const_str_digest_5e9c5dde7d44f504eb1a9ddf508d33f1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033043 ], 31, 0 );
    const_tuple_5abcd7abdaa8ad06f264854390b827e9_tuple = PyTuple_New( 8 );
    const_str_plain_dn = UNSTREAM_STRING_ASCII( &constant_bin[ 4174 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_5abcd7abdaa8ad06f264854390b827e9_tuple, 0, const_str_plain_dn ); Py_INCREF( const_str_plain_dn );
    PyTuple_SET_ITEM( const_tuple_5abcd7abdaa8ad06f264854390b827e9_tuple, 1, const_str_plain_hostname ); Py_INCREF( const_str_plain_hostname );
    const_str_plain_wildcards = UNSTREAM_STRING_ASCII( &constant_bin[ 294940 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_5abcd7abdaa8ad06f264854390b827e9_tuple, 2, const_str_plain_wildcards ); Py_INCREF( const_str_plain_wildcards );
    const_str_plain_dn_leftmost = UNSTREAM_STRING_ASCII( &constant_bin[ 1033074 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_5abcd7abdaa8ad06f264854390b827e9_tuple, 3, const_str_plain_dn_leftmost ); Py_INCREF( const_str_plain_dn_leftmost );
    PyTuple_SET_ITEM( const_tuple_5abcd7abdaa8ad06f264854390b827e9_tuple, 4, const_str_plain_sep ); Py_INCREF( const_str_plain_sep );
    const_str_plain_dn_remainder = UNSTREAM_STRING_ASCII( &constant_bin[ 1033085 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_5abcd7abdaa8ad06f264854390b827e9_tuple, 5, const_str_plain_dn_remainder ); Py_INCREF( const_str_plain_dn_remainder );
    const_str_plain_hostname_leftmost = UNSTREAM_STRING_ASCII( &constant_bin[ 1033097 ], 17, 1 );
    PyTuple_SET_ITEM( const_tuple_5abcd7abdaa8ad06f264854390b827e9_tuple, 6, const_str_plain_hostname_leftmost ); Py_INCREF( const_str_plain_hostname_leftmost );
    const_str_plain_hostname_remainder = UNSTREAM_STRING_ASCII( &constant_bin[ 1033114 ], 18, 1 );
    PyTuple_SET_ITEM( const_tuple_5abcd7abdaa8ad06f264854390b827e9_tuple, 7, const_str_plain_hostname_remainder ); Py_INCREF( const_str_plain_hostname_remainder );
    const_str_plain_hostname_checks_common_name = UNSTREAM_STRING_ASCII( &constant_bin[ 1033132 ], 27, 1 );
    const_tuple_str_plain_subjectAltName_tuple_empty_tuple = PyTuple_New( 2 );
    const_str_plain_subjectAltName = UNSTREAM_STRING_ASCII( &constant_bin[ 1033159 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_subjectAltName_tuple_empty_tuple, 0, const_str_plain_subjectAltName ); Py_INCREF( const_str_plain_subjectAltName );
    PyTuple_SET_ITEM( const_tuple_str_plain_subjectAltName_tuple_empty_tuple, 1, const_tuple_empty ); Py_INCREF( const_tuple_empty );
    const_str_digest_4abc699b5da7389d367032b57dc69eb3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033173 ], 191, 0 );
    const_str_digest_c5de37dcc49253fe34f7e237641f0f0d = UNSTREAM_STRING_ASCII( &constant_bin[ 1033364 ], 18, 0 );
    const_tuple_fc7bac9f346b6c5e0ab564aacc7d281d_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_fc7bac9f346b6c5e0ab564aacc7d281d_tuple, 0, const_str_plain_socket ); Py_INCREF( const_str_plain_socket );
    PyTuple_SET_ITEM( const_tuple_fc7bac9f346b6c5e0ab564aacc7d281d_tuple, 1, const_str_plain_AF_INET ); Py_INCREF( const_str_plain_AF_INET );
    PyTuple_SET_ITEM( const_tuple_fc7bac9f346b6c5e0ab564aacc7d281d_tuple, 2, const_str_plain_SOCK_STREAM ); Py_INCREF( const_str_plain_SOCK_STREAM );
    PyTuple_SET_ITEM( const_tuple_fc7bac9f346b6c5e0ab564aacc7d281d_tuple, 3, const_str_plain_create_connection ); Py_INCREF( const_str_plain_create_connection );
    const_str_plain_incoming = UNSTREAM_STRING_ASCII( &constant_bin[ 1006198 ], 8, 1 );
    const_str_digest_9ad09f827f7176b447bf061c19122ff5 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033382 ], 15, 0 );
    const_str_plain_SSLSession = UNSTREAM_STRING_ASCII( &constant_bin[ 1033397 ], 10, 1 );
    const_str_plain__txt2obj = UNSTREAM_STRING_ASCII( &constant_bin[ 1033407 ], 8, 1 );
    const_str_digest_1483b01ecabadd2ef5d4b9c2cb9cbd6a = UNSTREAM_STRING_ASCII( &constant_bin[ 1033415 ], 12, 0 );
    const_str_digest_32a9d7692d4036821acb38d0089e4f7d = UNSTREAM_STRING_ASCII( &constant_bin[ 1033427 ], 133, 0 );
    const_str_digest_7acec48d7f5243b63c0fc27885a59467 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033560 ], 33, 0 );
    const_tuple_str_plain_VERIFY__tuple = PyTuple_New( 1 );
    const_str_plain_VERIFY_ = UNSTREAM_STRING_ASCII( &constant_bin[ 1033593 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_VERIFY__tuple, 0, const_str_plain_VERIFY_ ); Py_INCREF( const_str_plain_VERIFY_ );
    const_tuple_aa341dc2e3c74f72a385182dcb9b8959_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_aa341dc2e3c74f72a385182dcb9b8959_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_alpn_protocols = UNSTREAM_STRING_ASCII( &constant_bin[ 1033600 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_aa341dc2e3c74f72a385182dcb9b8959_tuple, 1, const_str_plain_alpn_protocols ); Py_INCREF( const_str_plain_alpn_protocols );
    const_str_plain_protos = UNSTREAM_STRING_ASCII( &constant_bin[ 1033614 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_aa341dc2e3c74f72a385182dcb9b8959_tuple, 2, const_str_plain_protos ); Py_INCREF( const_str_plain_protos );
    PyTuple_SET_ITEM( const_tuple_aa341dc2e3c74f72a385182dcb9b8959_tuple, 3, const_str_plain_protocol ); Py_INCREF( const_str_plain_protocol );
    PyTuple_SET_ITEM( const_tuple_aa341dc2e3c74f72a385182dcb9b8959_tuple, 4, const_str_plain_b ); Py_INCREF( const_str_plain_b );
    const_tuple_38d407af55640de8f78848442bfee914_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_38d407af55640de8f78848442bfee914_tuple, 0, const_str_plain_protocol ); Py_INCREF( const_str_plain_protocol );
    const_str_plain_cert_reqs = UNSTREAM_STRING_ASCII( &constant_bin[ 1033620 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_38d407af55640de8f78848442bfee914_tuple, 1, const_str_plain_cert_reqs ); Py_INCREF( const_str_plain_cert_reqs );
    PyTuple_SET_ITEM( const_tuple_38d407af55640de8f78848442bfee914_tuple, 2, const_str_plain_check_hostname ); Py_INCREF( const_str_plain_check_hostname );
    PyTuple_SET_ITEM( const_tuple_38d407af55640de8f78848442bfee914_tuple, 3, const_str_plain_purpose ); Py_INCREF( const_str_plain_purpose );
    const_str_plain_certfile = UNSTREAM_STRING_ASCII( &constant_bin[ 1033629 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_38d407af55640de8f78848442bfee914_tuple, 4, const_str_plain_certfile ); Py_INCREF( const_str_plain_certfile );
    const_str_plain_keyfile = UNSTREAM_STRING_ASCII( &constant_bin[ 1033637 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_38d407af55640de8f78848442bfee914_tuple, 5, const_str_plain_keyfile ); Py_INCREF( const_str_plain_keyfile );
    PyTuple_SET_ITEM( const_tuple_38d407af55640de8f78848442bfee914_tuple, 6, const_str_plain_cafile ); Py_INCREF( const_str_plain_cafile );
    PyTuple_SET_ITEM( const_tuple_38d407af55640de8f78848442bfee914_tuple, 7, const_str_plain_capath ); Py_INCREF( const_str_plain_capath );
    PyTuple_SET_ITEM( const_tuple_38d407af55640de8f78848442bfee914_tuple, 8, const_str_plain_cadata ); Py_INCREF( const_str_plain_cadata );
    PyTuple_SET_ITEM( const_tuple_38d407af55640de8f78848442bfee914_tuple, 9, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    const_str_plain_flags_or_addr = UNSTREAM_STRING_ASCII( &constant_bin[ 1033644 ], 13, 1 );
    const_str_plain_enum_crls = UNSTREAM_STRING_ASCII( &constant_bin[ 1033657 ], 9, 1 );
    const_str_digest_f26217c45eb3dee86d08318942000832 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033666 ], 28, 0 );
    const_str_digest_e76c9d31e090b0229a44427e90c726c0 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033694 ], 17, 0 );
    const_tuple_str_plain_enum_certificates_str_plain_enum_crls_tuple = PyTuple_New( 2 );
    const_str_plain_enum_certificates = UNSTREAM_STRING_ASCII( &constant_bin[ 1033711 ], 17, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_enum_certificates_str_plain_enum_crls_tuple, 0, const_str_plain_enum_certificates ); Py_INCREF( const_str_plain_enum_certificates );
    PyTuple_SET_ITEM( const_tuple_str_plain_enum_certificates_str_plain_enum_crls_tuple, 1, const_str_plain_enum_crls ); Py_INCREF( const_str_plain_enum_crls );
    const_str_plain__sslobj = UNSTREAM_STRING_ASCII( &constant_bin[ 1033728 ], 7, 1 );
    const_str_digest_3248563d58214c71a4c9da2c5bedaa28 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033735 ], 33, 0 );
    const_str_digest_b8a96526c0c1047e3727ab8306b2c0b6 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033768 ], 49, 0 );
    const_str_plain_getpeercert = UNSTREAM_STRING_ASCII( &constant_bin[ 1027394 ], 11, 1 );
    const_str_plain_trust = UNSTREAM_STRING_ASCII( &constant_bin[ 490114 ], 5, 1 );
    const_str_plain__connected = UNSTREAM_STRING_ASCII( &constant_bin[ 1033027 ], 10, 1 );
    const_str_plain_HAS_TLSv1_2 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033817 ], 11, 1 );
    const_str_plain_Purpose = UNSTREAM_STRING_ASCII( &constant_bin[ 1033828 ], 7, 1 );
    const_str_digest_eb88db45ef5928fe9d291865fa2c3133 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033835 ], 40, 0 );
    const_str_plain_MINIMUM_SUPPORTED = UNSTREAM_STRING_ASCII( &constant_bin[ 1033875 ], 17, 1 );
    const_tuple_str_plain_self_str_plain_purpose_str_plain_storename_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_purpose_str_plain_storename_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_purpose_str_plain_storename_tuple, 1, const_str_plain_purpose ); Py_INCREF( const_str_plain_purpose );
    const_str_plain_storename = UNSTREAM_STRING_ASCII( &constant_bin[ 1033892 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_purpose_str_plain_storename_tuple, 2, const_str_plain_storename ); Py_INCREF( const_str_plain_storename );
    const_str_digest_b0a77916798fd37c9cee67fc494763a2 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033901 ], 40, 0 );
    const_str_plain__set_alpn_protocols = UNSTREAM_STRING_ASCII( &constant_bin[ 1033941 ], 19, 1 );
    const_str_plain_sslobj = UNSTREAM_STRING_ASCII( &constant_bin[ 1033729 ], 6, 1 );
    const_str_plain__inet_paton = UNSTREAM_STRING_ASCII( &constant_bin[ 1033960 ], 11, 1 );
    const_str_digest_4fb5691c9145cd18b6bc6017c9a5b8c6 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033971 ], 26, 0 );
    const_str_digest_8c034cf983cd380cdbc5f3747143f35a = UNSTREAM_STRING_ASCII( &constant_bin[ 1033997 ], 29, 0 );
    const_str_digest_826765c7ea5b1e2da81cc031af37a88e = UNSTREAM_STRING_ASCII( &constant_bin[ 1034026 ], 18, 0 );
    const_str_digest_a4d6f3a910ee9d9d33781f7776fa0650 = UNSTREAM_STRING_ASCII( &constant_bin[ 1034044 ], 42, 0 );
    const_tuple_str_plain_timegm_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_timegm_tuple, 0, const_str_plain_timegm ); Py_INCREF( const_str_plain_timegm );
    const_tuple_97d33b1871b78e86b4d3116dd7c89853_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_97d33b1871b78e86b4d3116dd7c89853_tuple, 0, const_str_plain_sslobj ); Py_INCREF( const_str_plain_sslobj );
    PyTuple_SET_ITEM( const_tuple_97d33b1871b78e86b4d3116dd7c89853_tuple, 1, const_str_plain_servername ); Py_INCREF( const_str_plain_servername );
    const_str_plain_sslctx = UNSTREAM_STRING_ASCII( &constant_bin[ 1034086 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_97d33b1871b78e86b4d3116dd7c89853_tuple, 2, const_str_plain_sslctx ); Py_INCREF( const_str_plain_sslctx );
    PyTuple_SET_ITEM( const_tuple_97d33b1871b78e86b4d3116dd7c89853_tuple, 3, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_server_name_callback = UNSTREAM_STRING_ASCII( &constant_bin[ 1034092 ], 20, 1 );
    PyTuple_SET_ITEM( const_tuple_97d33b1871b78e86b4d3116dd7c89853_tuple, 4, const_str_plain_server_name_callback ); Py_INCREF( const_str_plain_server_name_callback );
    const_str_plain_PROTO_TLSv1_3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1034112 ], 13, 1 );
    const_str_plain__OPENSSL_API_VERSION = UNSTREAM_STRING_ASCII( &constant_bin[ 1034125 ], 20, 1 );
    const_str_plain_CA = UNSTREAM_STRING_ASCII( &constant_bin[ 14657 ], 2, 1 );
    const_str_digest_32e7fb4c0950e94f71a622b4bef91a91 = UNSTREAM_STRING_ASCII( &constant_bin[ 1034145 ], 38, 0 );
    const_str_plain_wrap_bio = UNSTREAM_STRING_ASCII( &constant_bin[ 1028089 ], 8, 1 );
    const_tuple_str_plain_ipname_str_plain_host_ip_str_plain_ip_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ipname_str_plain_host_ip_str_plain_ip_tuple, 0, const_str_plain_ipname ); Py_INCREF( const_str_plain_ipname );
    PyTuple_SET_ITEM( const_tuple_str_plain_ipname_str_plain_host_ip_str_plain_ip_tuple, 1, const_str_plain_host_ip ); Py_INCREF( const_str_plain_host_ip );
    PyTuple_SET_ITEM( const_tuple_str_plain_ipname_str_plain_host_ip_str_plain_ip_tuple, 2, const_str_plain_ip ); Py_INCREF( const_str_plain_ip );
    const_str_digest_fe4ba6fdabf4a04ac73d126c6842f5da = UNSTREAM_STRING_ASCII( &constant_bin[ 1034183 ], 23, 0 );
    const_str_plain_create_default_context = UNSTREAM_STRING_ASCII( &constant_bin[ 1029859 ], 22, 1 );
    const_str_plain_get_server_certificate = UNSTREAM_STRING_ASCII( &constant_bin[ 1034206 ], 22, 1 );
    const_str_digest_90dcfb0c5b2e395585c44f2c6f8db8bf = UNSTREAM_STRING_ASCII( &constant_bin[ 1034228 ], 22, 0 );
    const_str_plain__SSLv2_IF_EXISTS = UNSTREAM_STRING_ASCII( &constant_bin[ 1034250 ], 16, 1 );
    const_str_digest_7d6cdae49b3a41339758fb29bb72d243 = UNSTREAM_STRING_ASCII( &constant_bin[ 1034266 ], 21, 0 );
    const_str_digest_c450fc9edb672e51af4935d607b84f7d = UNSTREAM_STRING_ASCII( &constant_bin[ 1034287 ], 133, 0 );
    const_str_plain_CHANNEL_BINDING_TYPES = UNSTREAM_STRING_ASCII( &constant_bin[ 1034420 ], 21, 1 );
    const_tuple_str_plain_self_str_plain_ctx_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ctx_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ctx_tuple, 1, const_str_plain_ctx ); Py_INCREF( const_str_plain_ctx );
    const_str_plain_VerifyMode = UNSTREAM_STRING_ASCII( &constant_bin[ 1034441 ], 10, 1 );
    const_str_digest_a8d27a0e9b66d922ecd6eaf962f1e7ac = UNSTREAM_STRING_ASCII( &constant_bin[ 1034451 ], 26, 0 );
    const_str_digest_7612dba174ee645b8f9d8c3109227a4c = UNSTREAM_STRING_ASCII( &constant_bin[ 1034477 ], 28, 0 );
    const_str_digest_04a99d395c987ae1e95aaa52fcd9f5b1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1034505 ], 88, 0 );
    const_str_plain_set_servername_callback = UNSTREAM_STRING_ASCII( &constant_bin[ 1034593 ], 23, 1 );
    const_str_digest_f80b04da9426dc3c6eb61b2e2c8cefdc = UNSTREAM_STRING_ASCII( &constant_bin[ 1034616 ], 17, 0 );
    const_str_plain_HAS_TLSv1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1033817 ], 9, 1 );
    const_tuple_str_plain_self_str_plain_how_str_plain___class___tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_how_str_plain___class___tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_how_str_plain___class___tuple, 1, const_str_plain_how ); Py_INCREF( const_str_plain_how );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_how_str_plain___class___tuple, 2, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_str_digest_5d916050d0a708334c1549a93d19962a = UNSTREAM_STRING_ASCII( &constant_bin[ 1034633 ], 43, 0 );
    const_str_plain__ipaddress_match = UNSTREAM_STRING_ASCII( &constant_bin[ 1034676 ], 16, 1 );
    const_str_plain_match_hostname = UNSTREAM_STRING_ASCII( &constant_bin[ 1034692 ], 14, 1 );
    const_str_digest_c9952bf55f4165e8dd5c4f498af92c1c = UNSTREAM_STRING_ASCII( &constant_bin[ 1034706 ], 57, 0 );
    const_str_plain_ciphers = UNSTREAM_STRING_ASCII( &constant_bin[ 1027751 ], 7, 1 );
    const_tuple_67e83e4c1a580aa75b711d7b7e138e06_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_67e83e4c1a580aa75b711d7b7e138e06_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_67e83e4c1a580aa75b711d7b7e138e06_tuple, 1, const_str_plain_file ); Py_INCREF( const_str_plain_file );
    PyTuple_SET_ITEM( const_tuple_67e83e4c1a580aa75b711d7b7e138e06_tuple, 2, const_str_plain_offset ); Py_INCREF( const_str_plain_offset );
    PyTuple_SET_ITEM( const_tuple_67e83e4c1a580aa75b711d7b7e138e06_tuple, 3, const_str_plain_count ); Py_INCREF( const_str_plain_count );
    PyTuple_SET_ITEM( const_tuple_67e83e4c1a580aa75b711d7b7e138e06_tuple, 4, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_str_digest_cb937a135d1407a4127cb28ad691044b = UNSTREAM_STRING_ASCII( &constant_bin[ 1034763 ], 22, 0 );
    const_tuple_str_plain_ALERT_DESCRIPTION__tuple = PyTuple_New( 1 );
    const_str_plain_ALERT_DESCRIPTION_ = UNSTREAM_STRING_ASCII( &constant_bin[ 1031735 ], 18, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ALERT_DESCRIPTION__tuple, 0, const_str_plain_ALERT_DESCRIPTION_ ); Py_INCREF( const_str_plain_ALERT_DESCRIPTION_ );
    const_str_digest_8ccc1038eb9505b2eb128b6c50cf7933 = UNSTREAM_STRING_ASCII( &constant_bin[ 1034785 ], 44, 0 );
    const_tuple_8f4a9ecee5b69684c6422c4623b74375_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_8f4a9ecee5b69684c6422c4623b74375_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_8f4a9ecee5b69684c6422c4623b74375_tuple, 1, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_8f4a9ecee5b69684c6422c4623b74375_tuple, 2, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    PyTuple_SET_ITEM( const_tuple_8f4a9ecee5b69684c6422c4623b74375_tuple, 3, const_str_plain_count ); Py_INCREF( const_str_plain_count );
    PyTuple_SET_ITEM( const_tuple_8f4a9ecee5b69684c6422c4623b74375_tuple, 4, const_str_plain_view ); Py_INCREF( const_str_plain_view );
    const_str_plain_byte_view = UNSTREAM_STRING_ASCII( &constant_bin[ 1034829 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_8f4a9ecee5b69684c6422c4623b74375_tuple, 5, const_str_plain_byte_view ); Py_INCREF( const_str_plain_byte_view );
    const_str_plain_amount = UNSTREAM_STRING_ASCII( &constant_bin[ 357981 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_8f4a9ecee5b69684c6422c4623b74375_tuple, 6, const_str_plain_amount ); Py_INCREF( const_str_plain_amount );
    PyTuple_SET_ITEM( const_tuple_8f4a9ecee5b69684c6422c4623b74375_tuple, 7, const_str_plain_v ); Py_INCREF( const_str_plain_v );
    PyTuple_SET_ITEM( const_tuple_8f4a9ecee5b69684c6422c4623b74375_tuple, 8, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_str_digest_8929e5696096b1b3a769926d596fd01d = UNSTREAM_STRING_ASCII( &constant_bin[ 1034838 ], 18, 0 );
    const_tuple_str_plain_pem_cert_string_str_plain_d_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_pem_cert_string_str_plain_d_tuple, 0, const_str_plain_pem_cert_string ); Py_INCREF( const_str_plain_pem_cert_string );
    PyTuple_SET_ITEM( const_tuple_str_plain_pem_cert_string_str_plain_d_tuple, 1, const_str_plain_d ); Py_INCREF( const_str_plain_d );
    const_str_digest_b80e22ff8ef58437a3cdcf9966f6ec5d = UNSTREAM_STRING_ASCII( &constant_bin[ 1034856 ], 37, 0 );
    const_str_digest_0e5d7991443807262ff75d28a8d3aab1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1034893 ], 46, 0 );
    const_str_digest_4807acc2340e0a598c0f10463503adbb = UNSTREAM_STRING_ASCII( &constant_bin[ 1034939 ], 18, 0 );
    const_str_plain_nid = UNSTREAM_STRING_ASCII( &constant_bin[ 131848 ], 3, 1 );
    const_str_plain_DNS = UNSTREAM_STRING_ASCII( &constant_bin[ 1010611 ], 3, 1 );
    const_tuple_str_digest_d9ecb2d1bd7c2c654c39bebb9c4b95c7_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_d9ecb2d1bd7c2c654c39bebb9c4b95c7_tuple, 0, const_str_digest_d9ecb2d1bd7c2c654c39bebb9c4b95c7 ); Py_INCREF( const_str_digest_d9ecb2d1bd7c2c654c39bebb9c4b95c7 );
    const_str_plain_PROTO_TLSv1_1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1034957 ], 13, 1 );
    const_str_digest_8f0f33542a5d07b827a3c15795f1bcd3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1034970 ], 17, 0 );
    const_str_plain__dnsname_match = UNSTREAM_STRING_ASCII( &constant_bin[ 1034987 ], 14, 1 );
    const_str_digest_225bcc70c32be5d588e199b061dc20c4 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035001 ], 16, 0 );
    const_str_digest_a94b2028d7a56b84bcb25adb9dde5120 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035017 ], 53, 0 );
    const_tuple_str_plain_Enum_str_plain_IntEnum_str_plain_IntFlag_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_Enum_str_plain_IntEnum_str_plain_IntFlag_tuple, 0, const_str_plain_Enum ); Py_INCREF( const_str_plain_Enum );
    PyTuple_SET_ITEM( const_tuple_str_plain_Enum_str_plain_IntEnum_str_plain_IntFlag_tuple, 1, const_str_plain_IntEnum ); Py_INCREF( const_str_plain_IntEnum );
    PyTuple_SET_ITEM( const_tuple_str_plain_Enum_str_plain_IntEnum_str_plain_IntFlag_tuple, 2, const_str_plain_IntFlag ); Py_INCREF( const_str_plain_IntFlag );
    const_tuple_int_pos_1024_none_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_int_pos_1024_none_tuple, 0, const_int_pos_1024 ); Py_INCREF( const_int_pos_1024 );
    PyTuple_SET_ITEM( const_tuple_int_pos_1024_none_tuple, 1, Py_None ); Py_INCREF( Py_None );
    const_str_digest_8646af1ebee17c0c9f3fc9ba01d5d9b4 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035070 ], 91, 0 );
    const_str_digest_f27b9bf56c746e209815ef274ec83cd3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035161 ], 17, 0 );
    const_str_digest_8d25e8341eff71b65c9386d4018600c9 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035178 ], 38, 0 );
    const_tuple_str_digest_89945f27978b3c4970283807e6649ec5_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_89945f27978b3c4970283807e6649ec5_tuple, 0, const_str_digest_89945f27978b3c4970283807e6649ec5 ); Py_INCREF( const_str_digest_89945f27978b3c4970283807e6649ec5 );
    const_str_digest_3093a3b7e6ad2e3ac70240f1b5e28199 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035216 ], 19, 0 );
    const_str_plain_SSLv3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1029482 ], 5, 1 );
    const_str_plain_PROTOCOL_TLS = UNSTREAM_STRING_ASCII( &constant_bin[ 1031469 ], 12, 1 );
    const_tuple_str_plain_cls_str_plain_name_str_plain___class___tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_name_str_plain___class___tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_name_str_plain___class___tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_name_str_plain___class___tuple, 2, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple, 0, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    PyTuple_SET_ITEM( const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple, 1, const_str_plain_ssl_version ); Py_INCREF( const_str_plain_ssl_version );
    const_str_plain_ca_certs = UNSTREAM_STRING_ASCII( &constant_bin[ 1035235 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple, 2, const_str_plain_ca_certs ); Py_INCREF( const_str_plain_ca_certs );
    PyTuple_SET_ITEM( const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple, 3, const_str_plain_host ); Py_INCREF( const_str_plain_host );
    PyTuple_SET_ITEM( const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple, 4, const_str_plain_port ); Py_INCREF( const_str_plain_port );
    PyTuple_SET_ITEM( const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple, 5, const_str_plain_cert_reqs ); Py_INCREF( const_str_plain_cert_reqs );
    PyTuple_SET_ITEM( const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple, 6, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    PyTuple_SET_ITEM( const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple, 7, const_str_plain_sock ); Py_INCREF( const_str_plain_sock );
    PyTuple_SET_ITEM( const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple, 8, const_str_plain_sslsock ); Py_INCREF( const_str_plain_sslsock );
    const_str_plain_dercert = UNSTREAM_STRING_ASCII( &constant_bin[ 1035243 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple, 9, const_str_plain_dercert ); Py_INCREF( const_str_plain_dercert );
    const_tuple_str_digest_b8a3e24bd480f9d749e7f38794d9a804_tuple = PyTuple_New( 1 );
    const_str_digest_b8a3e24bd480f9d749e7f38794d9a804 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035250 ], 61, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_b8a3e24bd480f9d749e7f38794d9a804_tuple, 0, const_str_digest_b8a3e24bd480f9d749e7f38794d9a804 ); Py_INCREF( const_str_digest_b8a3e24bd480f9d749e7f38794d9a804 );
    const_str_digest_0b796367a64c49cc2aaf578dcf85fdf5 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035311 ], 51, 0 );
    const_str_digest_7024ed96f0952bfda665eb960a91de44 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035362 ], 44, 0 );
    const_str_plain__DEFAULT_CIPHERS = UNSTREAM_STRING_ASCII( &constant_bin[ 1035406 ], 16, 1 );
    const_str_plain_do_handshake = UNSTREAM_STRING_ASCII( &constant_bin[ 1035422 ], 12, 1 );
    const_tuple_str_plain_cls_str_plain_nid_str_plain___class___tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_nid_str_plain___class___tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_nid_str_plain___class___tuple, 1, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_nid_str_plain___class___tuple, 2, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_str_digest_9350c794d641bf1e05d2d5f369964cf4 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035434 ], 28, 0 );
    const_str_digest_3b35d51050a71678e6a91f8af50bcd6c = UNSTREAM_STRING_ASCII( &constant_bin[ 1035462 ], 38, 0 );
    const_str_plain_CERT_ = UNSTREAM_STRING_ASCII( &constant_bin[ 364722 ], 5, 1 );
    const_tuple_39aff8525553a45d78a58dd13ef2a06a_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_39aff8525553a45d78a58dd13ef2a06a_tuple, 0, const_str_plain__ASN1Object ); Py_INCREF( const_str_plain__ASN1Object );
    PyTuple_SET_ITEM( const_tuple_39aff8525553a45d78a58dd13ef2a06a_tuple, 1, const_str_digest_a8d27a0e9b66d922ecd6eaf962f1e7ac ); Py_INCREF( const_str_digest_a8d27a0e9b66d922ecd6eaf962f1e7ac );
    const_str_plain_ENOTCONN = UNSTREAM_STRING_ASCII( &constant_bin[ 1035500 ], 8, 1 );
    const_tuple_a840e2093a227646419041bdd371a27b_tuple = PyTuple_New( 10 );
    const_str_plain_HAS_SNI = UNSTREAM_STRING_ASCII( &constant_bin[ 1035508 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_a840e2093a227646419041bdd371a27b_tuple, 0, const_str_plain_HAS_SNI ); Py_INCREF( const_str_plain_HAS_SNI );
    const_str_plain_HAS_ECDH = UNSTREAM_STRING_ASCII( &constant_bin[ 1035515 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_a840e2093a227646419041bdd371a27b_tuple, 1, const_str_plain_HAS_ECDH ); Py_INCREF( const_str_plain_HAS_ECDH );
    PyTuple_SET_ITEM( const_tuple_a840e2093a227646419041bdd371a27b_tuple, 2, const_str_plain_HAS_NPN ); Py_INCREF( const_str_plain_HAS_NPN );
    const_str_plain_HAS_ALPN = UNSTREAM_STRING_ASCII( &constant_bin[ 1035523 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_a840e2093a227646419041bdd371a27b_tuple, 3, const_str_plain_HAS_ALPN ); Py_INCREF( const_str_plain_HAS_ALPN );
    PyTuple_SET_ITEM( const_tuple_a840e2093a227646419041bdd371a27b_tuple, 4, const_str_plain_HAS_SSLv2 ); Py_INCREF( const_str_plain_HAS_SSLv2 );
    PyTuple_SET_ITEM( const_tuple_a840e2093a227646419041bdd371a27b_tuple, 5, const_str_plain_HAS_SSLv3 ); Py_INCREF( const_str_plain_HAS_SSLv3 );
    PyTuple_SET_ITEM( const_tuple_a840e2093a227646419041bdd371a27b_tuple, 6, const_str_plain_HAS_TLSv1 ); Py_INCREF( const_str_plain_HAS_TLSv1 );
    const_str_plain_HAS_TLSv1_1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035531 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_a840e2093a227646419041bdd371a27b_tuple, 7, const_str_plain_HAS_TLSv1_1 ); Py_INCREF( const_str_plain_HAS_TLSv1_1 );
    PyTuple_SET_ITEM( const_tuple_a840e2093a227646419041bdd371a27b_tuple, 8, const_str_plain_HAS_TLSv1_2 ); Py_INCREF( const_str_plain_HAS_TLSv1_2 );
    const_str_plain_HAS_TLSv1_3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035542 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_a840e2093a227646419041bdd371a27b_tuple, 9, const_str_plain_HAS_TLSv1_3 ); Py_INCREF( const_str_plain_HAS_TLSv1_3 );
    const_str_digest_435b76333d08b4e4e629143b740aa218 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035553 ], 247, 0 );
    const_str_digest_4cf3e4c966a8b447aeec91c80c53ce91 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035800 ], 20, 0 );
    const_str_digest_cee8a0917b60d1bd22f94d241f22b50b = UNSTREAM_STRING_ASCII( &constant_bin[ 1035820 ], 136, 0 );
    const_str_digest_b57613816b83a6d5e901aa481a5f48e3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035956 ], 27, 0 );
    const_tuple_str_plain_i_str_plain_f_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_i_str_plain_f_tuple, 0, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_str_plain_i_str_plain_f_tuple, 1, const_str_plain_f ); Py_INCREF( const_str_plain_f );
    const_str_digest_951e41b571762ac2eab94889431d0c17 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035983 ], 36, 0 );
    const_str_plain_cert_time = UNSTREAM_STRING_ASCII( &constant_bin[ 1030149 ], 9, 1 );
    const_str_digest_c1de6fe860a671d1e1fb4f389bb9c11f = UNSTREAM_STRING_ASCII( &constant_bin[ 1036019 ], 17, 0 );
    const_str_digest_223a8a47fa4e201be7d43aff732dd6e1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1036036 ], 22, 0 );
    const_str_digest_4fc88bc781b6216d197d14984f6b65eb = UNSTREAM_STRING_ASCII( &constant_bin[ 1036058 ], 24, 0 );
    const_str_digest_e8ba3556e5c659d7313d4a7290713be4 = UNSTREAM_STRING_ASCII( &constant_bin[ 1036082 ], 85, 0 );
    const_str_digest_fa76902b0955d1f1a4101fca59e6c5f4 = UNSTREAM_STRING_ASCII( &constant_bin[ 1036167 ], 19, 0 );
    const_tuple_7473acf6d330ed226a15523988ec3e21_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_7473acf6d330ed226a15523988ec3e21_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_npn_protocols = UNSTREAM_STRING_ASCII( &constant_bin[ 1027371 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_7473acf6d330ed226a15523988ec3e21_tuple, 1, const_str_plain_npn_protocols ); Py_INCREF( const_str_plain_npn_protocols );
    PyTuple_SET_ITEM( const_tuple_7473acf6d330ed226a15523988ec3e21_tuple, 2, const_str_plain_protos ); Py_INCREF( const_str_plain_protos );
    PyTuple_SET_ITEM( const_tuple_7473acf6d330ed226a15523988ec3e21_tuple, 3, const_str_plain_protocol ); Py_INCREF( const_str_plain_protocol );
    PyTuple_SET_ITEM( const_tuple_7473acf6d330ed226a15523988ec3e21_tuple, 4, const_str_plain_b ); Py_INCREF( const_str_plain_b );
    const_str_digest_456481dfc3cfeda5b8ffadc3f499a1a7 = UNSTREAM_STRING_ASCII( &constant_bin[ 1036186 ], 31, 0 );
    const_str_plain_recvfrom_into = UNSTREAM_STRING_ASCII( &constant_bin[ 1034785 ], 13, 1 );
    const_tuple_str_plain_self_str_plain_ncs_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ncs_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_ncs = UNSTREAM_STRING_ASCII( &constant_bin[ 343301 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ncs_tuple, 1, const_str_plain_ncs ); Py_INCREF( const_str_plain_ncs );
    const_str_plain_SSLCertVerificationError = UNSTREAM_STRING_ASCII( &constant_bin[ 1036217 ], 24, 1 );
    const_str_digest_c9db670f24eb7241cf3b613e4b11a252 = UNSTREAM_STRING_ASCII( &constant_bin[ 1036241 ], 15, 0 );
    const_str_plain_getsockopt = UNSTREAM_STRING_ASCII( &constant_bin[ 1011771 ], 10, 1 );
    const_str_plain__RESTRICTED_SERVER_CIPHERS = UNSTREAM_STRING_ASCII( &constant_bin[ 1036256 ], 26, 1 );
    const_str_plain_PEM_FOOTER = UNSTREAM_STRING_ASCII( &constant_bin[ 1036282 ], 10, 1 );
    const_tuple_str_plain_txt2obj_str_plain_nid2obj_tuple = PyTuple_New( 2 );
    const_str_plain_txt2obj = UNSTREAM_STRING_ASCII( &constant_bin[ 1033408 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_txt2obj_str_plain_nid2obj_tuple, 0, const_str_plain_txt2obj ); Py_INCREF( const_str_plain_txt2obj );
    const_str_plain_nid2obj = UNSTREAM_STRING_ASCII( &constant_bin[ 1036292 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_txt2obj_str_plain_nid2obj_tuple, 1, const_str_plain_nid2obj ); Py_INCREF( const_str_plain_nid2obj );
    const_tuple_false_true_true_none_none_none_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_false_true_true_none_none_none_tuple, 0, Py_False ); Py_INCREF( Py_False );
    PyTuple_SET_ITEM( const_tuple_false_true_true_none_none_none_tuple, 1, Py_True ); Py_INCREF( Py_True );
    PyTuple_SET_ITEM( const_tuple_false_true_true_none_none_none_tuple, 2, Py_True ); Py_INCREF( Py_True );
    PyTuple_SET_ITEM( const_tuple_false_true_true_none_none_none_tuple, 3, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_false_true_true_none_none_none_tuple, 4, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_false_true_true_none_none_none_tuple, 5, Py_None ); Py_INCREF( Py_None );
    const_tuple_730fbfff731a79523b12989c446f00e5_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_730fbfff731a79523b12989c446f00e5_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_730fbfff731a79523b12989c446f00e5_tuple, 1, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_730fbfff731a79523b12989c446f00e5_tuple, 2, const_str_plain_flags_or_addr ); Py_INCREF( const_str_plain_flags_or_addr );
    PyTuple_SET_ITEM( const_tuple_730fbfff731a79523b12989c446f00e5_tuple, 3, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    PyTuple_SET_ITEM( const_tuple_730fbfff731a79523b12989c446f00e5_tuple, 4, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_tuple_fd5b2cb4c7284fdcd887df9c923ef28a_tuple = PyTuple_New( 3 );
    const_str_plain__SSLContext = UNSTREAM_STRING_ASCII( &constant_bin[ 1036299 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_fd5b2cb4c7284fdcd887df9c923ef28a_tuple, 0, const_str_plain__SSLContext ); Py_INCREF( const_str_plain__SSLContext );
    PyTuple_SET_ITEM( const_tuple_fd5b2cb4c7284fdcd887df9c923ef28a_tuple, 1, const_str_plain_MemoryBIO ); Py_INCREF( const_str_plain_MemoryBIO );
    PyTuple_SET_ITEM( const_tuple_fd5b2cb4c7284fdcd887df9c923ef28a_tuple, 2, const_str_plain_SSLSession ); Py_INCREF( const_str_plain_SSLSession );
    const_str_digest_222811c1d4bf55fcbb49085a180f5432 = UNSTREAM_STRING_ASCII( &constant_bin[ 1034838 ], 14, 0 );
    const_tuple_str_plain_self_str_plain_hostname_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_hostname_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_hostname_tuple, 1, const_str_plain_hostname ); Py_INCREF( const_str_plain_hostname );
    const_dict_f68e37ae246dcd2f55c6ccbc7f9fbda7 = _PyDict_NewPresized( 3 );
    PyDict_SetItem( const_dict_f68e37ae246dcd2f55c6ccbc7f9fbda7, const_str_plain_cafile, Py_None );
    PyDict_SetItem( const_dict_f68e37ae246dcd2f55c6ccbc7f9fbda7, const_str_plain_capath, Py_None );
    PyDict_SetItem( const_dict_f68e37ae246dcd2f55c6ccbc7f9fbda7, const_str_plain_cadata, Py_None );
    assert( PyDict_Size( const_dict_f68e37ae246dcd2f55c6ccbc7f9fbda7 ) == 3 );
    const_str_plain_MAXIMUM_SUPPORTED = UNSTREAM_STRING_ASCII( &constant_bin[ 1036310 ], 17, 1 );
    const_str_digest_2827a02148585180db385ecab4334673 = UNSTREAM_STRING_ASCII( &constant_bin[ 1036327 ], 28, 0 );
    const_str_plain__PROTOCOL_NAMES = UNSTREAM_STRING_ASCII( &constant_bin[ 1036355 ], 15, 1 );
    const_str_plain_CertificateError = UNSTREAM_STRING_ASCII( &constant_bin[ 1029158 ], 16, 1 );
    const_str_digest_57a4d671eaa11e961fe988b76b7923cd = UNSTREAM_STRING_ASCII( &constant_bin[ 1036370 ], 47, 0 );
    const_tuple_str_plain__DEFAULT_CIPHERS_str_plain__OPENSSL_API_VERSION_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain__DEFAULT_CIPHERS_str_plain__OPENSSL_API_VERSION_tuple, 0, const_str_plain__DEFAULT_CIPHERS ); Py_INCREF( const_str_plain__DEFAULT_CIPHERS );
    PyTuple_SET_ITEM( const_tuple_str_plain__DEFAULT_CIPHERS_str_plain__OPENSSL_API_VERSION_tuple, 1, const_str_plain__OPENSSL_API_VERSION ); Py_INCREF( const_str_plain__OPENSSL_API_VERSION );
    const_str_plain_set_npn_protocols = UNSTREAM_STRING_ASCII( &constant_bin[ 1027367 ], 17, 1 );
    const_str_digest_b6fbb08e38a8d1423a7161f4ef2729f2 = UNSTREAM_STRING_ASCII( &constant_bin[ 1036417 ], 776, 0 );
    const_str_digest_f3568165cd86b32f3e6c65bf9c020450 = UNSTREAM_STRING_ASCII( &constant_bin[ 1037193 ], 24, 0 );
    const_str_digest_369cd8552536fc20754a282ea727c715 = UNSTREAM_STRING_ASCII( &constant_bin[ 1037217 ], 17, 0 );
    const_str_digest_d348e50cee6b156ae47b722599f9ef5e = UNSTREAM_STRING_ASCII( &constant_bin[ 1037234 ], 28, 0 );
    const_str_plain_PROTO_TLSv1_2 = UNSTREAM_STRING_ASCII( &constant_bin[ 1037262 ], 13, 1 );
    const_tuple_str_plain_der_cert_bytes_str_plain_f_str_plain_ss_tuple = PyTuple_New( 3 );
    const_str_plain_der_cert_bytes = UNSTREAM_STRING_ASCII( &constant_bin[ 1037275 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_der_cert_bytes_str_plain_f_str_plain_ss_tuple, 0, const_str_plain_der_cert_bytes ); Py_INCREF( const_str_plain_der_cert_bytes );
    PyTuple_SET_ITEM( const_tuple_str_plain_der_cert_bytes_str_plain_f_str_plain_ss_tuple, 1, const_str_plain_f ); Py_INCREF( const_str_plain_f );
    PyTuple_SET_ITEM( const_tuple_str_plain_der_cert_bytes_str_plain_f_str_plain_ss_tuple, 2, const_str_plain_ss ); Py_INCREF( const_str_plain_ss );
    const_str_plain_set_default_verify_paths = UNSTREAM_STRING_ASCII( &constant_bin[ 1037289 ], 24, 1 );
    const_tuple_str_plain_cls_str_plain_oid_str_plain___class___tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_oid_str_plain___class___tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_plain_oid = UNSTREAM_STRING_ASCII( &constant_bin[ 78767 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_oid_str_plain___class___tuple, 1, const_str_plain_oid ); Py_INCREF( const_str_plain_oid );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_oid_str_plain___class___tuple, 2, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_str_digest_2f5b04e7ff781fc829fd1336b1bac5d6 = UNSTREAM_STRING_ASCII( &constant_bin[ 1037313 ], 32, 0 );
    const_tuple_str_plain_parts_str_plain_cafile_str_plain_capath_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_parts_str_plain_cafile_str_plain_capath_tuple, 0, const_str_plain_parts ); Py_INCREF( const_str_plain_parts );
    PyTuple_SET_ITEM( const_tuple_str_plain_parts_str_plain_cafile_str_plain_capath_tuple, 1, const_str_plain_cafile ); Py_INCREF( const_str_plain_cafile );
    PyTuple_SET_ITEM( const_tuple_str_plain_parts_str_plain_cafile_str_plain_capath_tuple, 2, const_str_plain_capath ); Py_INCREF( const_str_plain_capath );
    const_str_plain_server_side = UNSTREAM_STRING_ASCII( &constant_bin[ 1037345 ], 11, 1 );
    const_str_digest_7a9028390fde6cbc9e4e83008c224f13 = UNSTREAM_STRING_ASCII( &constant_bin[ 1037356 ], 169, 0 );
    const_slice_int_pos_2_int_pos_6_none = PySlice_New( const_int_pos_2, const_int_pos_6, Py_None );
    const_str_digest_e4e3c476682898be85f27f17e066582d = UNSTREAM_STRING_ASCII( &constant_bin[ 1037525 ], 18, 0 );
    const_str_plain__nid2obj = UNSTREAM_STRING_ASCII( &constant_bin[ 1037543 ], 8, 1 );
    const_tuple_str_plain_B_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_B_tuple, 0, const_str_plain_B ); Py_INCREF( const_str_plain_B );
    const_str_digest_f21776754563ee820956e9eca7440392 = UNSTREAM_STRING_ASCII( &constant_bin[ 1037551 ], 104, 0 );
    const_tuple_false_true_true_none_none_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_false_true_true_none_none_tuple, 0, Py_False ); Py_INCREF( Py_False );
    PyTuple_SET_ITEM( const_tuple_false_true_true_none_none_tuple, 1, Py_True ); Py_INCREF( Py_True );
    PyTuple_SET_ITEM( const_tuple_false_true_true_none_none_tuple, 2, Py_True ); Py_INCREF( Py_True );
    PyTuple_SET_ITEM( const_tuple_false_true_true_none_none_tuple, 3, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_false_true_true_none_none_tuple, 4, Py_None ); Py_INCREF( Py_None );
    const_tuple_294dabb5a2c5ba151197a7c7ec901527_tuple = PyTuple_New( 7 );
    const_str_plain_SSLError = UNSTREAM_STRING_ASCII( &constant_bin[ 1030090 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_294dabb5a2c5ba151197a7c7ec901527_tuple, 0, const_str_plain_SSLError ); Py_INCREF( const_str_plain_SSLError );
    const_str_plain_SSLZeroReturnError = UNSTREAM_STRING_ASCII( &constant_bin[ 1037655 ], 18, 1 );
    PyTuple_SET_ITEM( const_tuple_294dabb5a2c5ba151197a7c7ec901527_tuple, 1, const_str_plain_SSLZeroReturnError ); Py_INCREF( const_str_plain_SSLZeroReturnError );
    PyTuple_SET_ITEM( const_tuple_294dabb5a2c5ba151197a7c7ec901527_tuple, 2, const_str_plain_SSLWantReadError ); Py_INCREF( const_str_plain_SSLWantReadError );
    const_str_plain_SSLWantWriteError = UNSTREAM_STRING_ASCII( &constant_bin[ 1037673 ], 17, 1 );
    PyTuple_SET_ITEM( const_tuple_294dabb5a2c5ba151197a7c7ec901527_tuple, 3, const_str_plain_SSLWantWriteError ); Py_INCREF( const_str_plain_SSLWantWriteError );
    const_str_plain_SSLSyscallError = UNSTREAM_STRING_ASCII( &constant_bin[ 1037690 ], 15, 1 );
    PyTuple_SET_ITEM( const_tuple_294dabb5a2c5ba151197a7c7ec901527_tuple, 4, const_str_plain_SSLSyscallError ); Py_INCREF( const_str_plain_SSLSyscallError );
    const_str_plain_SSLEOFError = UNSTREAM_STRING_ASCII( &constant_bin[ 1037705 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_294dabb5a2c5ba151197a7c7ec901527_tuple, 5, const_str_plain_SSLEOFError ); Py_INCREF( const_str_plain_SSLEOFError );
    PyTuple_SET_ITEM( const_tuple_294dabb5a2c5ba151197a7c7ec901527_tuple, 6, const_str_plain_SSLCertVerificationError ); Py_INCREF( const_str_plain_SSLCertVerificationError );
    const_str_plain__wrap_bio = UNSTREAM_STRING_ASCII( &constant_bin[ 1037716 ], 9, 1 );
    const_tuple_1aab3e41f37d07b6590ecac751f85fc1_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_1aab3e41f37d07b6590ecac751f85fc1_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_1aab3e41f37d07b6590ecac751f85fc1_tuple, 1, const_str_plain_sock ); Py_INCREF( const_str_plain_sock );
    PyTuple_SET_ITEM( const_tuple_1aab3e41f37d07b6590ecac751f85fc1_tuple, 2, const_str_plain_server_side ); Py_INCREF( const_str_plain_server_side );
    const_str_plain_do_handshake_on_connect = UNSTREAM_STRING_ASCII( &constant_bin[ 1037123 ], 23, 1 );
    PyTuple_SET_ITEM( const_tuple_1aab3e41f37d07b6590ecac751f85fc1_tuple, 3, const_str_plain_do_handshake_on_connect ); Py_INCREF( const_str_plain_do_handshake_on_connect );
    PyTuple_SET_ITEM( const_tuple_1aab3e41f37d07b6590ecac751f85fc1_tuple, 4, const_str_plain_suppress_ragged_eofs ); Py_INCREF( const_str_plain_suppress_ragged_eofs );
    PyTuple_SET_ITEM( const_tuple_1aab3e41f37d07b6590ecac751f85fc1_tuple, 5, const_str_plain_server_hostname ); Py_INCREF( const_str_plain_server_hostname );
    const_str_plain_session = UNSTREAM_STRING_ASCII( &constant_bin[ 8723 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_1aab3e41f37d07b6590ecac751f85fc1_tuple, 6, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    const_str_plain_session_reused = UNSTREAM_STRING_ASCII( &constant_bin[ 1027710 ], 14, 1 );
    const_str_digest_87cdc7b3da2a01efa67fc002f5f9e93d = UNSTREAM_STRING_ASCII( &constant_bin[ 1037725 ], 17, 0 );
    const_str_plain_block = UNSTREAM_STRING_ASCII( &constant_bin[ 39419 ], 5, 1 );
    const_str_plain_CERT_REQUIRED = UNSTREAM_STRING_ASCII( &constant_bin[ 364739 ], 13, 1 );
    const_list_str_digest_554140970ff737b96d003bcbb3246411_list = PyList_New( 1 );
    const_str_digest_554140970ff737b96d003bcbb3246411 = UNSTREAM_STRING_ASCII( &constant_bin[ 1037742 ], 10, 0 );
    PyList_SET_ITEM( const_list_str_digest_554140970ff737b96d003bcbb3246411_list, 0, const_str_digest_554140970ff737b96d003bcbb3246411 ); Py_INCREF( const_str_digest_554140970ff737b96d003bcbb3246411 );
    const_str_plain_time_format = UNSTREAM_STRING_ASCII( &constant_bin[ 408105 ], 11, 1 );
    const_str_digest_264d5c6db8f5a84d0fe413b3a21dca69 = UNSTREAM_STRING_ASCII( &constant_bin[ 1037752 ], 140, 0 );
    const_str_digest_3b82cb8ef6775b0d84aaa035b45db24a = UNSTREAM_STRING_ASCII( &constant_bin[ 1037892 ], 90, 0 );
    const_str_plain_TLSv1_3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1034118 ], 7, 1 );
    const_str_plain_buflen = UNSTREAM_STRING_ASCII( &constant_bin[ 293903 ], 6, 1 );
    const_str_plain_SSLContext = UNSTREAM_STRING_ASCII( &constant_bin[ 1027804 ], 10, 1 );
    const_str_plain_PROTO_MAXIMUM_SUPPORTED = UNSTREAM_STRING_ASCII( &constant_bin[ 1037982 ], 23, 1 );
    const_str_digest_04ce73b765f1cc9fc45cba5d95755307 = UNSTREAM_STRING_ASCII( &constant_bin[ 1038005 ], 182, 0 );
    const_str_digest_0eae601715bd5c30805ac496fbcd9992 = UNSTREAM_STRING_ASCII( &constant_bin[ 1038187 ], 146, 0 );
    const_tuple_8cbc413f7ba377eb28c3c8de0f0a31a6_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_8cbc413f7ba377eb28c3c8de0f0a31a6_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_8cbc413f7ba377eb28c3c8de0f0a31a6_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_8cbc413f7ba377eb28c3c8de0f0a31a6_tuple, 2, const_str_plain_nbytes ); Py_INCREF( const_str_plain_nbytes );
    PyTuple_SET_ITEM( const_tuple_8cbc413f7ba377eb28c3c8de0f0a31a6_tuple, 3, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    PyTuple_SET_ITEM( const_tuple_8cbc413f7ba377eb28c3c8de0f0a31a6_tuple, 4, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple = PyTuple_New( 14 );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 1, const_str_plain_sock ); Py_INCREF( const_str_plain_sock );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 2, const_str_plain_server_side ); Py_INCREF( const_str_plain_server_side );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 3, const_str_plain_do_handshake_on_connect ); Py_INCREF( const_str_plain_do_handshake_on_connect );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 4, const_str_plain_suppress_ragged_eofs ); Py_INCREF( const_str_plain_suppress_ragged_eofs );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 5, const_str_plain_server_hostname ); Py_INCREF( const_str_plain_server_hostname );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 6, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 7, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 8, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 9, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 10, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 11, const_str_plain_connected ); Py_INCREF( const_str_plain_connected );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 12, const_str_plain_timeout ); Py_INCREF( const_str_plain_timeout );
    PyTuple_SET_ITEM( const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 13, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_str_digest_f66ea29fd347bd1e1c153f7fc85b4c4d = UNSTREAM_STRING_ASCII( &constant_bin[ 1038333 ], 116, 0 );
    const_str_digest_d419c0cfda05a6c7cddfa9e5ecabff66 = UNSTREAM_STRING_ASCII( &constant_bin[ 1038449 ], 60, 0 );
    const_str_plain_set_ciphers = UNSTREAM_STRING_ASCII( &constant_bin[ 1038509 ], 11, 1 );
    const_str_digest_d88b1a2ff0cfef8fd6528c6cef0c98c5 = UNSTREAM_STRING_ASCII( &constant_bin[ 1038520 ], 51, 0 );
    const_str_digest_6bb5243f02b53df7c631337cce5d1e63 = UNSTREAM_STRING_ASCII( &constant_bin[ 1038571 ], 16, 0 );
    const_str_plain_SSLErrorNumber = UNSTREAM_STRING_ASCII( &constant_bin[ 1038587 ], 14, 1 );
    const_tuple_str_plain_SSL_ERROR__tuple = PyTuple_New( 1 );
    const_str_plain_SSL_ERROR_ = UNSTREAM_STRING_ASCII( &constant_bin[ 1030643 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_SSL_ERROR__tuple, 0, const_str_plain_SSL_ERROR_ ); Py_INCREF( const_str_plain_SSL_ERROR_ );
    const_str_digest_9efba2909c944f0cd3b20389eca3a9de = UNSTREAM_STRING_ASCII( &constant_bin[ 1038601 ], 19, 0 );
    const_str_plain_HOSTFLAG_NEVER_CHECK_SUBJECT = UNSTREAM_STRING_ASCII( &constant_bin[ 1038620 ], 28, 1 );
    const_str_digest_21bb40eac1bbe9900e4b65be65bdbc0d = UNSTREAM_STRING_ASCII( &constant_bin[ 1038648 ], 124, 0 );
    const_str_plain_RAND_bytes = UNSTREAM_STRING_ASCII( &constant_bin[ 1038772 ], 10, 1 );
    const_tuple_str_plain_RAND_egd_tuple = PyTuple_New( 1 );
    const_str_plain_RAND_egd = UNSTREAM_STRING_ASCII( &constant_bin[ 1038782 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_RAND_egd_tuple, 0, const_str_plain_RAND_egd ); Py_INCREF( const_str_plain_RAND_egd );
    const_str_plain_get_channel_binding = UNSTREAM_STRING_ASCII( &constant_bin[ 1029437 ], 19, 1 );
    const_str_plain_AlertDescription = UNSTREAM_STRING_ASCII( &constant_bin[ 1038790 ], 16, 1 );
    const_str_digest_a30bfbfaff6053905e0182626560596e = UNSTREAM_STRING_ASCII( &constant_bin[ 1038806 ], 22, 0 );
    const_str_plain_PEM_HEADER = UNSTREAM_STRING_ASCII( &constant_bin[ 1038828 ], 10, 1 );
    const_str_digest_c9e0ace64f4cd2826bb360e8a68ae1a8 = UNSTREAM_STRING_ASCII( &constant_bin[ 1038838 ], 25, 0 );
    const_str_digest_4d5300aa45c1f4e7d70a328a278e2af4 = UNSTREAM_STRING_ASCII( &constant_bin[ 1038863 ], 72, 0 );
    const_str_digest_a4e634bd5e8eac5aa83cadc1f04fa575 = UNSTREAM_STRING_ASCII( &constant_bin[ 1038935 ], 24, 0 );
    const_tuple_09c2d80bf2e47e0bc7f1c9dc811cecbd_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_09c2d80bf2e47e0bc7f1c9dc811cecbd_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_09c2d80bf2e47e0bc7f1c9dc811cecbd_tuple, 1, const_str_plain_incoming ); Py_INCREF( const_str_plain_incoming );
    const_str_plain_outgoing = UNSTREAM_STRING_ASCII( &constant_bin[ 1038959 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_09c2d80bf2e47e0bc7f1c9dc811cecbd_tuple, 2, const_str_plain_outgoing ); Py_INCREF( const_str_plain_outgoing );
    PyTuple_SET_ITEM( const_tuple_09c2d80bf2e47e0bc7f1c9dc811cecbd_tuple, 3, const_str_plain_server_side ); Py_INCREF( const_str_plain_server_side );
    PyTuple_SET_ITEM( const_tuple_09c2d80bf2e47e0bc7f1c9dc811cecbd_tuple, 4, const_str_plain_server_hostname ); Py_INCREF( const_str_plain_server_hostname );
    PyTuple_SET_ITEM( const_tuple_09c2d80bf2e47e0bc7f1c9dc811cecbd_tuple, 5, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    const_str_plain__create_unverified_context = UNSTREAM_STRING_ASCII( &constant_bin[ 1038967 ], 26, 1 );
    const_str_digest_80ae286fde266c9ce3eea805317b53e8 = UNSTREAM_STRING_ASCII( &constant_bin[ 1038993 ], 393, 0 );
    const_tuple_str_plain_self_str_plain_block_str_plain_timeout_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_block_str_plain_timeout_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_block_str_plain_timeout_tuple, 1, const_str_plain_block ); Py_INCREF( const_str_plain_block );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_block_str_plain_timeout_tuple, 2, const_str_plain_timeout ); Py_INCREF( const_str_plain_timeout );
    const_str_digest_753f93511d826caab3f92515b0253a28 = UNSTREAM_STRING_ASCII( &constant_bin[ 1039386 ], 16, 0 );
    const_str_plain_SSL_ERROR_EOF = UNSTREAM_STRING_ASCII( &constant_bin[ 1030789 ], 13, 1 );
    const_str_digest_3a1a2ed1355dcbc368d7b0eae97a5e62 = UNSTREAM_STRING_ASCII( &constant_bin[ 1039402 ], 14, 0 );
    const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple = PyTuple_New( 11 );
    PyTuple_SET_ITEM( const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple, 0, const_str_plain_sock ); Py_INCREF( const_str_plain_sock );
    PyTuple_SET_ITEM( const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple, 1, const_str_plain_keyfile ); Py_INCREF( const_str_plain_keyfile );
    PyTuple_SET_ITEM( const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple, 2, const_str_plain_certfile ); Py_INCREF( const_str_plain_certfile );
    PyTuple_SET_ITEM( const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple, 3, const_str_plain_server_side ); Py_INCREF( const_str_plain_server_side );
    PyTuple_SET_ITEM( const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple, 4, const_str_plain_cert_reqs ); Py_INCREF( const_str_plain_cert_reqs );
    PyTuple_SET_ITEM( const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple, 5, const_str_plain_ssl_version ); Py_INCREF( const_str_plain_ssl_version );
    PyTuple_SET_ITEM( const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple, 6, const_str_plain_ca_certs ); Py_INCREF( const_str_plain_ca_certs );
    PyTuple_SET_ITEM( const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple, 7, const_str_plain_do_handshake_on_connect ); Py_INCREF( const_str_plain_do_handshake_on_connect );
    PyTuple_SET_ITEM( const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple, 8, const_str_plain_suppress_ragged_eofs ); Py_INCREF( const_str_plain_suppress_ragged_eofs );
    PyTuple_SET_ITEM( const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple, 9, const_str_plain_ciphers ); Py_INCREF( const_str_plain_ciphers );
    PyTuple_SET_ITEM( const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple, 10, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    const_str_digest_970482a40f2631f2b534044dbb186357 = UNSTREAM_STRING_ASCII( &constant_bin[ 1039416 ], 38, 0 );
    const_str_plain_get_protocol_name = UNSTREAM_STRING_ASCII( &constant_bin[ 1039454 ], 17, 1 );
    const_tuple_28913759521d1747f612e333c98e07aa_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_28913759521d1747f612e333c98e07aa_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_28913759521d1747f612e333c98e07aa_tuple, 1, const_str_plain_incoming ); Py_INCREF( const_str_plain_incoming );
    PyTuple_SET_ITEM( const_tuple_28913759521d1747f612e333c98e07aa_tuple, 2, const_str_plain_outgoing ); Py_INCREF( const_str_plain_outgoing );
    PyTuple_SET_ITEM( const_tuple_28913759521d1747f612e333c98e07aa_tuple, 3, const_str_plain_server_side ); Py_INCREF( const_str_plain_server_side );
    PyTuple_SET_ITEM( const_tuple_28913759521d1747f612e333c98e07aa_tuple, 4, const_str_plain_server_hostname ); Py_INCREF( const_str_plain_server_hostname );
    PyTuple_SET_ITEM( const_tuple_28913759521d1747f612e333c98e07aa_tuple, 5, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    PyTuple_SET_ITEM( const_tuple_28913759521d1747f612e333c98e07aa_tuple, 6, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    PyTuple_SET_ITEM( const_tuple_28913759521d1747f612e333c98e07aa_tuple, 7, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_28913759521d1747f612e333c98e07aa_tuple, 8, const_str_plain_sslobj ); Py_INCREF( const_str_plain_sslobj );
    const_str_plain_cast = UNSTREAM_STRING_ASCII( &constant_bin[ 1002936 ], 4, 1 );
    const_str_digest_149ca022cd253208621db7e23b6370d3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1039471 ], 23, 0 );
    const_tuple_9007a0386d0b02e640600397a1fbac86_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_9007a0386d0b02e640600397a1fbac86_tuple, 0, const_str_plain_DefaultVerifyPaths ); Py_INCREF( const_str_plain_DefaultVerifyPaths );
    const_str_digest_6d4e3117ce2e396558d0d26361294da1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1039494 ], 81, 0 );
    PyTuple_SET_ITEM( const_tuple_9007a0386d0b02e640600397a1fbac86_tuple, 1, const_str_digest_6d4e3117ce2e396558d0d26361294da1 ); Py_INCREF( const_str_digest_6d4e3117ce2e396558d0d26361294da1 );
    const_str_digest_bb9901570b2b538ad6494c6c3dc8a9be = UNSTREAM_STRING_ASCII( &constant_bin[ 1039575 ], 41, 0 );
    const_str_plain__SSLMethod = UNSTREAM_STRING_ASCII( &constant_bin[ 1039616 ], 10, 1 );
    const_str_digest_51317cfcec4946ff79f4fa2f128efe4d = UNSTREAM_STRING_ASCII( &constant_bin[ 1039626 ], 32, 0 );
    const_str_digest_9b02e8f66087246f5290f408cd07f8d6 = UNSTREAM_STRING_ASCII( &constant_bin[ 1039658 ], 27, 0 );
    const_str_digest_fcd4e210c82bde6da13a3f919066e7a3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1039685 ], 13, 0 );
    const_tuple_str_plain_ASCII_str_plain_strict_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ASCII_str_plain_strict_tuple, 0, const_str_plain_ASCII ); Py_INCREF( const_str_plain_ASCII );
    PyTuple_SET_ITEM( const_tuple_str_plain_ASCII_str_plain_strict_tuple, 1, const_str_plain_strict ); Py_INCREF( const_str_plain_strict );
    const_str_plain_protocol_code = UNSTREAM_STRING_ASCII( &constant_bin[ 1039698 ], 13, 1 );
    const_tuple_439f0f01aa96458b63f3c1913f75c97b_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_439f0f01aa96458b63f3c1913f75c97b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_439f0f01aa96458b63f3c1913f75c97b_tuple, 1, const_str_plain_server_name_callback ); Py_INCREF( const_str_plain_server_name_callback );
    const_str_plain_shim_cb = UNSTREAM_STRING_ASCII( &constant_bin[ 1039711 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_439f0f01aa96458b63f3c1913f75c97b_tuple, 2, const_str_plain_shim_cb ); Py_INCREF( const_str_plain_shim_cb );
    const_tuple_d0e8e14d58a1064421ad37c78bfe9656_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_d0e8e14d58a1064421ad37c78bfe9656_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_newsock = UNSTREAM_STRING_ASCII( &constant_bin[ 1039718 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_d0e8e14d58a1064421ad37c78bfe9656_tuple, 1, const_str_plain_newsock ); Py_INCREF( const_str_plain_newsock );
    PyTuple_SET_ITEM( const_tuple_d0e8e14d58a1064421ad37c78bfe9656_tuple, 2, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    PyTuple_SET_ITEM( const_tuple_d0e8e14d58a1064421ad37c78bfe9656_tuple, 3, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_tuple_str_digest_bb9901570b2b538ad6494c6c3dc8a9be_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_bb9901570b2b538ad6494c6c3dc8a9be_tuple, 0, const_str_digest_bb9901570b2b538ad6494c6c3dc8a9be ); Py_INCREF( const_str_digest_bb9901570b2b538ad6494c6c3dc8a9be );
    const_str_digest_407044a0a44e7edcc517eceddb07768e = UNSTREAM_STRING_ASCII( &constant_bin[ 1039725 ], 79, 0 );
    const_str_digest_fdb327d09a1abb4e12c500a6d5b181cc = UNSTREAM_STRING_ASCII( &constant_bin[ 1039804 ], 26, 0 );
    const_tuple_3835b204829c945e05cb7681afc63bf9_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_3835b204829c945e05cb7681afc63bf9_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_3835b204829c945e05cb7681afc63bf9_tuple, 1, const_str_plain_storename ); Py_INCREF( const_str_plain_storename );
    PyTuple_SET_ITEM( const_tuple_3835b204829c945e05cb7681afc63bf9_tuple, 2, const_str_plain_purpose ); Py_INCREF( const_str_plain_purpose );
    const_str_plain_certs = UNSTREAM_STRING_ASCII( &constant_bin[ 1027401 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_3835b204829c945e05cb7681afc63bf9_tuple, 3, const_str_plain_certs ); Py_INCREF( const_str_plain_certs );
    PyTuple_SET_ITEM( const_tuple_3835b204829c945e05cb7681afc63bf9_tuple, 4, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_3835b204829c945e05cb7681afc63bf9_tuple, 5, const_str_plain_encoding ); Py_INCREF( const_str_plain_encoding );
    PyTuple_SET_ITEM( const_tuple_3835b204829c945e05cb7681afc63bf9_tuple, 6, const_str_plain_trust ); Py_INCREF( const_str_plain_trust );
    const_str_plain_ROOT = UNSTREAM_STRING_ASCII( &constant_bin[ 436980 ], 4, 1 );
    const_str_plain_PROTOCOL_ = UNSTREAM_STRING_ASCII( &constant_bin[ 1028307 ], 9, 1 );
    const_tuple_str_plain_SSLObject_tuple_empty_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_SSLObject_tuple_empty_tuple, 0, const_str_plain_SSLObject ); Py_INCREF( const_str_plain_SSLObject );
    PyTuple_SET_ITEM( const_tuple_str_plain_SSLObject_tuple_empty_tuple, 1, const_tuple_empty ); Py_INCREF( const_tuple_empty );
    const_str_plain_x509_asn = UNSTREAM_STRING_ASCII( &constant_bin[ 1039830 ], 8, 1 );
    const_tuple_str_plain_OP__tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_OP__tuple, 0, const_str_plain_OP_ ); Py_INCREF( const_str_plain_OP_ );
    const_tuple_e0867d1d1bdc1b09db9831d078cf5291_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_e0867d1d1bdc1b09db9831d078cf5291_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_e0867d1d1bdc1b09db9831d078cf5291_tuple, 1, const_str_plain_buflen ); Py_INCREF( const_str_plain_buflen );
    PyTuple_SET_ITEM( const_tuple_e0867d1d1bdc1b09db9831d078cf5291_tuple, 2, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    PyTuple_SET_ITEM( const_tuple_e0867d1d1bdc1b09db9831d078cf5291_tuple, 3, const_str_plain___class__ ); Py_INCREF( const_str_plain___class__ );
    const_str_plain__check_connected = UNSTREAM_STRING_ASCII( &constant_bin[ 1033021 ], 16, 1 );
    const_str_plain_TLSVersion = UNSTREAM_STRING_ASCII( &constant_bin[ 1039838 ], 10, 1 );
    const_str_plain__windows_cert_stores = UNSTREAM_STRING_ASCII( &constant_bin[ 1039848 ], 20, 1 );
    const_tuple_str_digest_554140970ff737b96d003bcbb3246411_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_554140970ff737b96d003bcbb3246411_tuple, 0, const_str_digest_554140970ff737b96d003bcbb3246411 ); Py_INCREF( const_str_digest_554140970ff737b96d003bcbb3246411 );
    const_str_plain_RAND_add = UNSTREAM_STRING_ASCII( &constant_bin[ 1039868 ], 8, 1 );
    const_tuple_false_none_none_none_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_false_none_none_none_tuple, 0, Py_False ); Py_INCREF( Py_False );
    PyTuple_SET_ITEM( const_tuple_false_none_none_none_tuple, 1, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_false_none_none_none_tuple, 2, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_false_none_none_none_tuple, 3, Py_None ); Py_INCREF( Py_None );
    const_str_plain_TLSv1_1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1031546 ], 7, 1 );
    const_tuple_str_plain_protocol_code_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_protocol_code_tuple, 0, const_str_plain_protocol_code ); Py_INCREF( const_str_plain_protocol_code );
    const_str_digest_0e477d4fd7854861d3a3e53f3c18df7a = UNSTREAM_STRING_ASCII( &constant_bin[ 1039876 ], 16, 0 );
    const_str_plain_SO_TYPE = UNSTREAM_STRING_ASCII( &constant_bin[ 1039892 ], 7, 1 );
    const_str_plain_PEM_cert_to_DER_cert = UNSTREAM_STRING_ASCII( &constant_bin[ 1039899 ], 20, 1 );
    const_str_plain___set__ = UNSTREAM_STRING_ASCII( &constant_bin[ 575300 ], 7, 1 );
    const_str_plain_CLIENT_AUTH = UNSTREAM_STRING_ASCII( &constant_bin[ 1039919 ], 11, 1 );
    const_str_plain__load_windows_store_certs = UNSTREAM_STRING_ASCII( &constant_bin[ 1035994 ], 25, 1 );
    const_str_angle_unknown = UNSTREAM_STRING_ASCII( &constant_bin[ 1039930 ], 9, 0 );
    const_str_digest_7860efcfc68c94064108f332b0e7ea2b = UNSTREAM_STRING_ASCII( &constant_bin[ 1039939 ], 25, 0 );
    const_str_digest_dd8dbc1762dbe3e65f1ad22cbe807685 = UNSTREAM_STRING_ASCII( &constant_bin[ 1027700 ], 17, 0 );
    const_str_digest_3aecc77c85cde288c70f925a7ff0779e = UNSTREAM_STRING_ASCII( &constant_bin[ 1039964 ], 6, 0 );
    const_str_digest_0fb7a77c6d8e8842d00fc65591c86f2b = UNSTREAM_STRING_ASCII( &constant_bin[ 1039970 ], 17, 0 );
    const_tuple_str_plain_CERT__tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_CERT__tuple, 0, const_str_plain_CERT_ ); Py_INCREF( const_str_plain_CERT_ );
    const_str_plain_SERVER_AUTH = UNSTREAM_STRING_ASCII( &constant_bin[ 1039987 ], 11, 1 );
    const_tuple_str_plain_PROTOCOL__tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_PROTOCOL__tuple, 0, const_str_plain_PROTOCOL_ ); Py_INCREF( const_str_plain_PROTOCOL_ );
    const_str_digest_d168cf6508757f44c350431e0146bcff = UNSTREAM_STRING_ASCII( &constant_bin[ 1039998 ], 151, 0 );
    const_str_digest_a81fde8cd3c79156638379a671de86c9 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040149 ], 21, 0 );
    const_str_digest_1deb9ad8da903aa02d0662894e4e5d19 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040170 ], 22, 0 );
    const_str_digest_02add5f1196bf0982325724e556ddbe7 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040192 ], 39, 0 );
    const_str_digest_50b5c2eaada4a849fea984fb96dc55f1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040231 ], 38, 0 );
    const_str_digest_dddcbf0d2d0cc36b841a5401bf4b26d0 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040269 ], 21, 0 );
    const_str_digest_66cbc636bc9077e66f69e97ca6e2f8dc = UNSTREAM_STRING_ASCII( &constant_bin[ 1040290 ], 40, 0 );
    const_tuple_str_plain_SOL_SOCKET_str_plain_SO_TYPE_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_SOL_SOCKET_str_plain_SO_TYPE_tuple, 0, const_str_plain_SOL_SOCKET ); Py_INCREF( const_str_plain_SOL_SOCKET );
    PyTuple_SET_ITEM( const_tuple_str_plain_SOL_SOCKET_str_plain_SO_TYPE_tuple, 1, const_str_plain_SO_TYPE ); Py_INCREF( const_str_plain_SO_TYPE );
    const_str_digest_8571c784ae144b6aa943c631c479aeb3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040330 ], 51, 0 );
    const_tuple_5eefc4a79eaaa5a3d617b77219790036_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_5eefc4a79eaaa5a3d617b77219790036_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_5eefc4a79eaaa5a3d617b77219790036_tuple, 1, const_str_plain_protocol ); Py_INCREF( const_str_plain_protocol );
    PyTuple_SET_ITEM( const_tuple_5eefc4a79eaaa5a3d617b77219790036_tuple, 2, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_5eefc4a79eaaa5a3d617b77219790036_tuple, 3, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_5eefc4a79eaaa5a3d617b77219790036_tuple, 4, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_month_number = UNSTREAM_STRING_ASCII( &constant_bin[ 1040381 ], 12, 1 );
    const_str_plain_get_default_verify_paths = UNSTREAM_STRING_ASCII( &constant_bin[ 1040393 ], 24, 1 );
    const_str_plain_VerifyFlags = UNSTREAM_STRING_ASCII( &constant_bin[ 1040417 ], 11, 1 );
    const_str_digest_d2f106a7c85896a5d2d135f72c5b78b7 = UNSTREAM_STRING_ASCII( &constant_bin[ 1035017 ], 26, 0 );
    const_str_digest_cb9fea72893243c85d3f8a7fa5745fd1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040428 ], 61, 0 );
    const_str_digest_b2d667c37f49b62a93484716e8b4da43 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040489 ], 23, 0 );
    const_str_digest_5792c6e630cc995ac06314e738846670 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040512 ], 54, 0 );
    const_str_plain_TLSv1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1027799 ], 5, 1 );
    const_str_digest_678b55cb9e2bbf2e94eb06e9ceb20edc = UNSTREAM_STRING_ASCII( &constant_bin[ 1040566 ], 18, 0 );
    const_str_digest_0658b8b82bf1e6709c574f4d2869db22 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040584 ], 56, 0 );
    const_str_digest_13a57eb57bd6e3598d5407c5d5c65a2c = UNSTREAM_STRING_ASCII( &constant_bin[ 1040640 ], 16, 0 );
    const_tuple_str_plain_ipname_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ipname_tuple, 0, const_str_plain_ipname ); Py_INCREF( const_str_plain_ipname );
    const_str_plain_standard_b64encode = UNSTREAM_STRING_ASCII( &constant_bin[ 1040656 ], 18, 1 );
    const_str_digest_8b455849c74cb8521c58441c05e67f30 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040674 ], 39, 0 );
    const_str_digest_123738711ea439506bcf12b2e47bd0ba = UNSTREAM_STRING_ASCII( &constant_bin[ 1040713 ], 62, 0 );
    const_str_digest_baf3113a8ef52750e55aaa38049d03e1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040775 ], 40, 0 );
    const_str_plain_maximum_version = UNSTREAM_STRING_ASCII( &constant_bin[ 1039815 ], 15, 1 );
    const_tuple_str_plain_CA_str_plain_ROOT_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_CA_str_plain_ROOT_tuple, 0, const_str_plain_CA ); Py_INCREF( const_str_plain_CA );
    PyTuple_SET_ITEM( const_tuple_str_plain_CA_str_plain_ROOT_tuple, 1, const_str_plain_ROOT ); Py_INCREF( const_str_plain_ROOT );
    const_str_digest_ec2adfb37273b3eee2296f564999ae55 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040815 ], 81, 0 );
    const_str_digest_0b3815e873a7a8f2437fdb42dbe60fbf = UNSTREAM_STRING_ASCII( &constant_bin[ 1040896 ], 52, 0 );
    const_str_plain__host_flags = UNSTREAM_STRING_ASCII( &constant_bin[ 1040948 ], 11, 1 );
    const_str_digest_2444bca47c3e4bf63ad35ca166c38217 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040959 ], 38, 0 );
    const_str_digest_4271da0b33163508c03517c8a66c3ca2 = UNSTREAM_STRING_ASCII( &constant_bin[ 1040330 ], 34, 0 );
    const_tuple_int_pos_1024_int_0_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_int_pos_1024_int_0_tuple, 0, const_int_pos_1024 ); Py_INCREF( const_int_pos_1024 );
    PyTuple_SET_ITEM( const_tuple_int_pos_1024_int_0_tuple, 1, const_int_0 ); Py_INCREF( const_int_0 );
    const_str_digest_02a360a134c6bbb34ce8a608f7da370d = UNSTREAM_STRING_ASCII( &constant_bin[ 1040997 ], 16, 0 );
    const_str_digest_5b11666b6324b89e4fc385fb93a3c5a5 = UNSTREAM_STRING_ASCII( &constant_bin[ 1041013 ], 21, 0 );
    const_str_plain_sslobject_class = UNSTREAM_STRING_ASCII( &constant_bin[ 1041034 ], 15, 1 );
    const_str_digest_180e88c045483f282cc9d36d7ae789f2 = UNSTREAM_STRING_ASCII( &constant_bin[ 1041049 ], 35, 0 );
    const_str_digest_f042bcd35862fbe10a0a40d4f034fbdc = UNSTREAM_STRING_ASCII( &constant_bin[ 1041084 ], 17, 0 );
    const_str_digest_0cf93d32ee4dc8845c885030fe30aef6 = UNSTREAM_STRING_ASCII( &constant_bin[ 1037193 ], 17, 0 );
    const_str_plain_TLSv1_2 = UNSTREAM_STRING_ASCII( &constant_bin[ 1031563 ], 7, 1 );
    const_str_digest_f76ed44c3c7f75a52e9e990d67888b38 = UNSTREAM_STRING_ASCII( &constant_bin[ 1041101 ], 235, 0 );
    const_str_plain_SSLSocket = UNSTREAM_STRING_ASCII( &constant_bin[ 1027384 ], 9, 1 );
    const_tuple_da309a4929ea4a4af6aee082c29fb449_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_da309a4929ea4a4af6aee082c29fb449_tuple, 0, const_str_plain_cert_time ); Py_INCREF( const_str_plain_cert_time );
    PyTuple_SET_ITEM( const_tuple_da309a4929ea4a4af6aee082c29fb449_tuple, 1, const_str_plain_strptime ); Py_INCREF( const_str_plain_strptime );
    PyTuple_SET_ITEM( const_tuple_da309a4929ea4a4af6aee082c29fb449_tuple, 2, const_str_plain_timegm ); Py_INCREF( const_str_plain_timegm );
    PyTuple_SET_ITEM( const_tuple_da309a4929ea4a4af6aee082c29fb449_tuple, 3, const_str_plain_months ); Py_INCREF( const_str_plain_months );
    PyTuple_SET_ITEM( const_tuple_da309a4929ea4a4af6aee082c29fb449_tuple, 4, const_str_plain_time_format ); Py_INCREF( const_str_plain_time_format );
    PyTuple_SET_ITEM( const_tuple_da309a4929ea4a4af6aee082c29fb449_tuple, 5, const_str_plain_month_number ); Py_INCREF( const_str_plain_month_number );
    PyTuple_SET_ITEM( const_tuple_da309a4929ea4a4af6aee082c29fb449_tuple, 6, const_str_plain_tt ); Py_INCREF( const_str_plain_tt );
    const_str_digest_c0263368b21f5075dd51002a02eed279 = UNSTREAM_STRING_ASCII( &constant_bin[ 1041336 ], 17, 0 );
    const_str_digest_6ca8402699116cba8121763dd25b997a = UNSTREAM_STRING_ASCII( &constant_bin[ 1041353 ], 33, 0 );
    const_str_digest_8b4af18647c3b6e36880d4732ff55e63 = UNSTREAM_STRING_ASCII( &constant_bin[ 1041386 ], 29, 0 );
    const_str_plain_PROTO_MINIMUM_SUPPORTED = UNSTREAM_STRING_ASCII( &constant_bin[ 1041415 ], 23, 1 );
    const_str_plain_sslsocket_class = UNSTREAM_STRING_ASCII( &constant_bin[ 1041438 ], 15, 1 );
    const_str_digest_193178a81b56eec77a885bf7ab4dceb1 = UNSTREAM_STRING_ASCII( &constant_bin[ 1041453 ], 43, 0 );
    const_str_digest_49f919db6f48720fb21b9178605834a0 = UNSTREAM_STRING_ASCII( &constant_bin[ 1041496 ], 14, 0 );
    const_str_plain_minimum_version = UNSTREAM_STRING_ASCII( &constant_bin[ 1033982 ], 15, 1 );
    const_str_digest_a3d78346cd2f65fd6e9e17d7199e08b2 = UNSTREAM_STRING_ASCII( &constant_bin[ 1041510 ], 17, 0 );
    const_str_digest_2021457612f445845421aa4f7c76fecb = UNSTREAM_STRING_ASCII( &constant_bin[ 1041527 ], 151, 0 );
    const_str_digest_f7f5e69e32188905b76a51140481c41c = UNSTREAM_STRING_ASCII( &constant_bin[ 1041678 ], 29, 0 );
    const_str_digest_578daa481dfc5d6804fc66ea53284c53 = UNSTREAM_STRING_ASCII( &constant_bin[ 1041707 ], 21, 0 );
    const_str_plain_RAND_status = UNSTREAM_STRING_ASCII( &constant_bin[ 1041728 ], 11, 1 );
    const_str_digest_8c05d508622896570bf3da8f7e6eb9cb = UNSTREAM_STRING_ASCII( &constant_bin[ 1041739 ], 51, 0 );
    const_str_digest_9d03fd1f2eedc7fbd45f8a10e06e8ab5 = UNSTREAM_STRING_ASCII( &constant_bin[ 1041790 ], 37, 0 );
    const_str_plain_shared_ciphers = UNSTREAM_STRING_ASCII( &constant_bin[ 1028293 ], 14, 1 );
    const_str_digest_31df743f2ce3fe988549bc25f2c8482c = UNSTREAM_STRING_ASCII( &constant_bin[ 1041827 ], 22, 0 );
    const_str_plain__ssl = UNSTREAM_STRING_ASCII( &constant_bin[ 1033728 ], 4, 1 );
    const_str_plain_PROTO_SSLv3 = UNSTREAM_STRING_ASCII( &constant_bin[ 1041849 ], 11, 1 );
    const_str_digest_d301f91992faa4f4f10ac91822e37e3a = UNSTREAM_STRING_ASCII( &constant_bin[ 1041860 ], 493, 0 );
    const_str_plain_cert_time_to_seconds = UNSTREAM_STRING_ASCII( &constant_bin[ 1030149 ], 20, 1 );
    const_str_plain_RAND_pseudo_bytes = UNSTREAM_STRING_ASCII( &constant_bin[ 1042353 ], 17, 1 );
    const_tuple_str_plain_self_str_plain_binary_form_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_binary_form_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_binary_form_tuple, 1, const_str_plain_binary_form ); Py_INCREF( const_str_plain_binary_form );
    const_str_plain_selected_alpn_protocol = UNSTREAM_STRING_ASCII( &constant_bin[ 1037323 ], 22, 1 );
    const_str_plain_PROTOCOL_SSLv23 = UNSTREAM_STRING_ASCII( &constant_bin[ 1031453 ], 15, 1 );
    const_tuple_str_plain_self_str_plain_session_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_tuple, 1, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    const_str_plain_inet_pton = UNSTREAM_STRING_ASCII( &constant_bin[ 1042247 ], 9, 1 );
    const_str_plain_set_alpn_protocols = UNSTREAM_STRING_ASCII( &constant_bin[ 1033942 ], 18, 1 );
    const_str_digest_4741f80d59d6685d72d119c884a60415 = UNSTREAM_STRING_ASCII( &constant_bin[ 1042370 ], 95, 0 );
    const_str_plain__create_stdlib_context = UNSTREAM_STRING_ASCII( &constant_bin[ 1042465 ], 22, 1 );
    const_str_digest_29e692b3bed0448c0fbf90eb672dc2f9 = UNSTREAM_STRING_ASCII( &constant_bin[ 1042487 ], 18, 0 );
    const_dict_cd6cfa3585e1c44ad0bb320b3a2f22a4 = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_cd6cfa3585e1c44ad0bb320b3a2f22a4, const_str_plain_name, Py_True );
    assert( PyDict_Size( const_dict_cd6cfa3585e1c44ad0bb320b3a2f22a4 ) == 1 );
    const_str_digest_f3ad832901b185e93d30c52a67b18042 = UNSTREAM_STRING_ASCII( &constant_bin[ 1042505 ], 38, 0 );
    const_str_digest_014d24052ac75a4b7ea7a7f030f06442 = UNSTREAM_STRING_ASCII( &constant_bin[ 1042543 ], 237, 0 );
    const_str_digest_a9f301e988a5655ce88c2b95e37f72a0 = UNSTREAM_STRING_ASCII( &constant_bin[ 1042780 ], 19, 0 );
    const_str_plain_HAS_NEVER_CHECK_COMMON_NAME = UNSTREAM_STRING_ASCII( &constant_bin[ 1042799 ], 27, 1 );
    const_str_digest_aa8ad6ac7f5bb3b9bf58d630a5df3b73 = UNSTREAM_STRING_ASCII( &constant_bin[ 1042826 ], 33, 0 );
    const_str_digest_76d751ede7bd087f9346e5a615d3c397 = UNSTREAM_STRING_ASCII( &constant_bin[ 1042859 ], 10, 0 );
    const_tuple_6211085d7c55211a934ca9ed6de6668a_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_6211085d7c55211a934ca9ed6de6668a_tuple, 0, const_str_plain_RAND_status ); Py_INCREF( const_str_plain_RAND_status );
    PyTuple_SET_ITEM( const_tuple_6211085d7c55211a934ca9ed6de6668a_tuple, 1, const_str_plain_RAND_add ); Py_INCREF( const_str_plain_RAND_add );
    PyTuple_SET_ITEM( const_tuple_6211085d7c55211a934ca9ed6de6668a_tuple, 2, const_str_plain_RAND_bytes ); Py_INCREF( const_str_plain_RAND_bytes );
    PyTuple_SET_ITEM( const_tuple_6211085d7c55211a934ca9ed6de6668a_tuple, 3, const_str_plain_RAND_pseudo_bytes ); Py_INCREF( const_str_plain_RAND_pseudo_bytes );
    const_str_plain_fromname = UNSTREAM_STRING_ASCII( &constant_bin[ 1028109 ], 8, 1 );
    const_str_plain__IntFlag = UNSTREAM_STRING_ASCII( &constant_bin[ 1042869 ], 8, 1 );
    const_str_digest_37015d915e90c3fed8a792f94c4aad8d = UNSTREAM_STRING_ASCII( &constant_bin[ 1042877 ], 68, 0 );
    const_str_digest_af3afbb4c11be74ecd4b8a361dc5a331 = UNSTREAM_STRING_ASCII( &constant_bin[ 1042945 ], 93, 0 );
    const_str_digest_3e31e526fa6bfed4b24004be62ec2a41 = UNSTREAM_STRING_ASCII( &constant_bin[ 1029487 ], 14, 0 );
    const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_x_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_x_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_x_tuple, 1, const_str_plain_len ); Py_INCREF( const_str_plain_len );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_x_tuple, 2, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_x_tuple, 3, const_str_plain_x ); Py_INCREF( const_str_plain_x );

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_ssl( void )
{
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_4e4f09e7416371c39d6e683dfaa31b44;
static PyCodeObject *codeobj_8b2169752a1cafe1c590b905bc1817cf;
static PyCodeObject *codeobj_d8ef087d29dce5b7809ac49cd68adf25;
static PyCodeObject *codeobj_4ea3aebfeea4b0fb696d8e3f751bb569;
static PyCodeObject *codeobj_57ad0ee0b24514877328827449ed6d3d;
static PyCodeObject *codeobj_3fd973b4394bbb87224fe4972ac062b2;
static PyCodeObject *codeobj_e78ac027ae2374cae8fee268e861e6b6;
static PyCodeObject *codeobj_9e2248c3806a82f029138496cc7533f5;
static PyCodeObject *codeobj_5fd67fa0e731842652c5161aa118e079;
static PyCodeObject *codeobj_f0ee1f5fb95d4844854b515739861369;
static PyCodeObject *codeobj_d8e122175713d41c07a5a5cfce696240;
static PyCodeObject *codeobj_cbc8eb4c7a80f833eeff58accc81965e;
static PyCodeObject *codeobj_2f3dc3967a43757d07b0bed3cdf75e71;
static PyCodeObject *codeobj_ca8bc35da6fc8bd12302bc56dc472f30;
static PyCodeObject *codeobj_283e017a64c5286699e9bc9396685a36;
static PyCodeObject *codeobj_5ecbd54808c422e093f59660e1c05923;
static PyCodeObject *codeobj_032aecff3336d18805e71dad2af1bc06;
static PyCodeObject *codeobj_8a26c3fb8c2d5b0dc5ca8006ca18f426;
static PyCodeObject *codeobj_6a15f1fb4e124c5cd5441c67dd7b8e26;
static PyCodeObject *codeobj_387d510b0de4869ce257c4fd150c3e1d;
static PyCodeObject *codeobj_c25b78dcc70e44b70350d3078f666eb1;
static PyCodeObject *codeobj_9f169d4682c81eb3da6d59c1ded46e8f;
static PyCodeObject *codeobj_b5f510e6cb81eab7bc9dba35574f0396;
static PyCodeObject *codeobj_78af8d33dbb832741c0ebdb2e3d0021a;
static PyCodeObject *codeobj_5d3f549a94129cada014514f247e56ae;
static PyCodeObject *codeobj_e4273329f84da578e5b0c2c0ef1fb7e3;
static PyCodeObject *codeobj_a5072bf1a063c9f1c49782fa3c262d40;
static PyCodeObject *codeobj_5ff02ef703e17041cf7c28f0f9774842;
static PyCodeObject *codeobj_d8eebab0541bfa74aca42926ef69ef86;
static PyCodeObject *codeobj_27463743bde98a64c19721f228ebca83;
static PyCodeObject *codeobj_c3c87c308de5f0caba95e34d2a75cff3;
static PyCodeObject *codeobj_84c36608fe52cf263db57111bd71529a;
static PyCodeObject *codeobj_ce20ccea364a64a500bf53152ecbb3df;
static PyCodeObject *codeobj_3ddc9f7565e4886cd4a659572d70f974;
static PyCodeObject *codeobj_f0d4a14b639c208b031798e88d64dcf8;
static PyCodeObject *codeobj_09f1bb5201b8ef073955738188ca32ac;
static PyCodeObject *codeobj_8d5372b515e339fede7165b142e8a13c;
static PyCodeObject *codeobj_c84cff19f5ca70203b24d6ffa781b6c6;
static PyCodeObject *codeobj_c86b13db4689f046ff5f1afeb5710181;
static PyCodeObject *codeobj_e55c77de5189f075a317b4725d964bc7;
static PyCodeObject *codeobj_a86b95352fc9c8cca13ec96f3cf3e648;
static PyCodeObject *codeobj_155bafd0723162e3e798ef484b14cd90;
static PyCodeObject *codeobj_b025c5ada52dfc27ae3723ad4341ada3;
static PyCodeObject *codeobj_6a50350fea64982993f4c32f68ed6a2a;
static PyCodeObject *codeobj_0abbe3d29d94097de2b4cca44b79ff1d;
static PyCodeObject *codeobj_964b4ff49a75adfde8eac32fd1579b15;
static PyCodeObject *codeobj_85a48a901c551db5360868c6ff2fcbe0;
static PyCodeObject *codeobj_732e9b90c8c97c0d936101eda76a8170;
static PyCodeObject *codeobj_a9707a26dabb530d65fb63614a8bfaf3;
static PyCodeObject *codeobj_d56e86ad148a7f35b220cc951f739bf5;
static PyCodeObject *codeobj_6a9f24714f01965dd94fca0f0e8d2494;
static PyCodeObject *codeobj_df41c359df46e3b95ae46ee541469c12;
static PyCodeObject *codeobj_0adca387694c9d0d05e6dcf361654043;
static PyCodeObject *codeobj_f4b142c4d615bce9c4fa208111063de1;
static PyCodeObject *codeobj_0fefcbe6be1b7672f9495fe2d2c2b520;
static PyCodeObject *codeobj_49a3d9e5040ae940801c3d349086f58b;
static PyCodeObject *codeobj_0afdd5e99178c32be659fdceadf23330;
static PyCodeObject *codeobj_40f8c9a48268243d506769f5f3c9f87c;
static PyCodeObject *codeobj_86ffcc5f322eb9e45b49c1aab256e2b5;
static PyCodeObject *codeobj_8005450d1390ccb1db96bde8f18ccbc5;
static PyCodeObject *codeobj_9eb5b4d9d73d171312d06b89742db6dc;
static PyCodeObject *codeobj_bd31b2b0b29be68fb348a8509700aacb;
static PyCodeObject *codeobj_b22e2653cdc93fd04980c249351d9dc3;
static PyCodeObject *codeobj_1fa2afa1f2001c76009fa3bd74739a02;
static PyCodeObject *codeobj_dd245307a21868517b26333004071afc;
static PyCodeObject *codeobj_c741f20b5460a44d8f7d1a1ec0524090;
static PyCodeObject *codeobj_9c140cba594376b13de36d0b9d2cf41b;
static PyCodeObject *codeobj_e577eeee712faf011eac0a90d5a335cd;
static PyCodeObject *codeobj_d0ddd3c583ea0f70fd2c3f13c292f8d8;
static PyCodeObject *codeobj_3ecf3a2c062154f40f3b43857fadfa1b;
static PyCodeObject *codeobj_c9ee113a8b3a2d7e49dd2e5a09a16c0a;
static PyCodeObject *codeobj_e90beb192a2d45b154b787dd334a641a;
static PyCodeObject *codeobj_83f840bc627e14b2df37f66978eee02e;
static PyCodeObject *codeobj_bc55c6947047d12d73c6cf85fd31316d;
static PyCodeObject *codeobj_3e272a599979dddb2106eeb0ca82341b;
static PyCodeObject *codeobj_54a01adef0ac9e521553dadf12222313;
static PyCodeObject *codeobj_d836e52222fa765674eb7fabb95e256a;
static PyCodeObject *codeobj_102787f65a848b0f5ef93c552b2754a8;
static PyCodeObject *codeobj_6753233f97c67ba60fed48cd037a5da1;
static PyCodeObject *codeobj_b9c49bf51fd490ce845154517abf5afe;
static PyCodeObject *codeobj_0efd15d2dbf254a6a5ea212c2e808164;
static PyCodeObject *codeobj_d2bc38bd2c275ba26d06739a8be65121;
static PyCodeObject *codeobj_d5b89644963ce7577c3e54aec3b26352;
static PyCodeObject *codeobj_9946f25858fede3b1b6536c2d85f8023;
static PyCodeObject *codeobj_04c7d04cc1994e94386698ea320f0a34;
static PyCodeObject *codeobj_6f2722bf3b4b9cc66de9b446db7a9e02;
static PyCodeObject *codeobj_b6715770c57c475edff269e2bfce93b7;
static PyCodeObject *codeobj_d919d033f6f5ba6049cfa7306704c4e1;
static PyCodeObject *codeobj_7d99f84954cc8e5a491c234fdf7ba84c;
static PyCodeObject *codeobj_148ded5e31bfc43993a6f070cc228356;
static PyCodeObject *codeobj_af887c87284bed61555d654364a46bbc;
static PyCodeObject *codeobj_150a7fc04f06617735354ee03a3a1379;
static PyCodeObject *codeobj_0cab748c09d01cef1fc04469feb036ab;
static PyCodeObject *codeobj_f436d72429baf7d16ba6a700826ecce2;
static PyCodeObject *codeobj_81b99666473d5e4c99b07c76650d6532;
static PyCodeObject *codeobj_3d426fcde832f96f9fefe61110c3597f;
static PyCodeObject *codeobj_854fbf8c0d35e06c7abf19e23c21f425;
static PyCodeObject *codeobj_e33384d5e86c4c6b681e06b935a1eccd;
static PyCodeObject *codeobj_c315ec050432736c21843c7f8970ed99;
static PyCodeObject *codeobj_6362b4ab8ff4a74ff389af21e2831505;
static PyCodeObject *codeobj_4c16b3b8e78753d108f56368b6107e65;
static PyCodeObject *codeobj_6720aa3c1b1df68a0d363d84d0591c66;
static PyCodeObject *codeobj_c9128c1053ef6f473a6bfd7f36ba0b37;
static PyCodeObject *codeobj_b581a977e97c824d653f0d91e1864d5a;
static PyCodeObject *codeobj_8299ff8d044f5af021c11f1525c08864;
static PyCodeObject *codeobj_f30c98b20585ea45248d54a7a131cbd6;
static PyCodeObject *codeobj_7fef2a19fae27d1b2e8f283d57279247;
static PyCodeObject *codeobj_c308f005c60a48850ddc38c70cfc9e4a;
static PyCodeObject *codeobj_6eddcfd3501f9e6e8ff360a6e9e07ace;
static PyCodeObject *codeobj_a798b36ecbdc4799a3ed88ea793f49cf;
static PyCodeObject *codeobj_cd07790829b56e8f6715d0e2df0d1b17;
static PyCodeObject *codeobj_58499782b4566c6282fbc531bfb08ebf;
static PyCodeObject *codeobj_074ad722ef8e6ac8cf69c8739de2b3f8;
static PyCodeObject *codeobj_431602757d87c0ffb4cfc07c16f40c0f;
static PyCodeObject *codeobj_5f141f0f9a51bec2ef519041ccab0132;
static PyCodeObject *codeobj_5e4ce0716b248a14e09f49928b12effa;
static PyCodeObject *codeobj_e52a48e17e348b81afa21bb0833b5cee;
static PyCodeObject *codeobj_4bc9b1ac077eede44b66bfacb2b34b9c;
static PyCodeObject *codeobj_2116eb980de7dd12514dc72c39fd3f4d;

static void createModuleCodeObjects(void)
{
    module_filename_obj = MAKE_RELATIVE_PATH( const_str_digest_3aecc77c85cde288c70f925a7ff0779e );
    codeobj_4e4f09e7416371c39d6e683dfaa31b44 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_dictcontraction, 153, const_tuple_str_plain_name_str_plain_value_tuple, 1, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_8b2169752a1cafe1c590b905bc1817cf = MAKE_CODEOBJ( module_filename_obj, const_str_angle_lambda, 124, const_tuple_str_plain_name_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d8ef087d29dce5b7809ac49cd68adf25 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_lambda, 129, const_tuple_str_plain_name_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4ea3aebfeea4b0fb696d8e3f751bb569 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_lambda, 134, const_tuple_str_plain_name_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_57ad0ee0b24514877328827449ed6d3d = MAKE_CODEOBJ( module_filename_obj, const_str_angle_lambda, 139, const_tuple_str_plain_name_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3fd973b4394bbb87224fe4972ac062b2 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_lambda, 144, const_tuple_str_plain_name_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e78ac027ae2374cae8fee268e861e6b6 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_lambda, 149, const_tuple_str_plain_name_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9e2248c3806a82f029138496cc7533f5 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_listcomp, 1266, const_tuple_str_plain_i_str_plain_f_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5fd67fa0e731842652c5161aa118e079 = MAKE_CODEOBJ( module_filename_obj, const_str_digest_1483b01ecabadd2ef5d4b9c2cb9cbd6a, 1, const_tuple_empty, 0, 0, CO_NOFREE );
    codeobj_f0ee1f5fb95d4844854b515739861369 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_DER_cert_to_PEM_cert, 1260, const_tuple_str_plain_der_cert_bytes_str_plain_f_str_plain_ss_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d8e122175713d41c07a5a5cfce696240 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PEM_cert_to_DER_cert, 1270, const_tuple_str_plain_pem_cert_string_str_plain_d_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cbc8eb4c7a80f833eeff58accc81965e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_Purpose, 372, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_2f3dc3967a43757d07b0bed3cdf75e71 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_SSLContext, 379, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_ca8bc35da6fc8bd12302bc56dc472f30 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_SSLObject, 631, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_283e017a64c5286699e9bc9396685a36 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_SSLSocket, 784, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_5ecbd54808c422e093f59660e1c05923 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_TLSVersion, 158, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_032aecff3336d18805e71dad2af1bc06 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__ASN1Object, 351, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_8a26c3fb8c2d5b0dc5ca8006ca18f426 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 646, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_6a15f1fb4e124c5cd5441c67dd7b8e26 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 789, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_387d510b0de4869ce257c4fd150c3e1d = MAKE_CODEOBJ( module_filename_obj, const_str_plain___new__, 356, const_tuple_str_plain_cls_str_plain_oid_str_plain___class___tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_c25b78dcc70e44b70350d3078f666eb1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___new__, 387, const_tuple_5eefc4a79eaaa5a3d617b77219790036_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_9f169d4682c81eb3da6d59c1ded46e8f = MAKE_CODEOBJ( module_filename_obj, const_str_plain__checkClosed, 890, const_tuple_str_plain_self_str_plain_msg_tuple, 2, 0, CO_NOFREE );
    codeobj_b5f510e6cb81eab7bc9dba35574f0396 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__check_connected, 894, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_78af8d33dbb832741c0ebdb2e3d0021a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__create, 652, const_tuple_28913759521d1747f612e333c98e07aa_tuple, 7, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5d3f549a94129cada014514f247e56ae = MAKE_CODEOBJ( module_filename_obj, const_str_plain__create, 796, const_tuple_56e592c58f70bd4da1ab6b8edb21a6ce_tuple, 8, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_e4273329f84da578e5b0c2c0ef1fb7e3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__create_unverified_context, 581, const_tuple_38d407af55640de8f78848442bfee914_tuple, 1, 8, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a5072bf1a063c9f1c49782fa3c262d40 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__dnsname_match, 191, const_tuple_5abcd7abdaa8ad06f264854390b827e9_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5ff02ef703e17041cf7c28f0f9774842 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__encode_hostname, 391, const_tuple_str_plain_self_str_plain_hostname_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d8eebab0541bfa74aca42926ef69ef86 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__inet_paton, 240, const_tuple_str_plain_ipname_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_27463743bde98a64c19721f228ebca83 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__ipaddress_match, 265, const_tuple_str_plain_ipname_str_plain_host_ip_str_plain_ip_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c3c87c308de5f0caba95e34d2a75cff3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__load_windows_store_certs, 460, const_tuple_3835b204829c945e05cb7681afc63bf9_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_84c36608fe52cf263db57111bd71529a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__real_close, 1106, const_tuple_str_plain_self_str_plain___class___tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_ce20ccea364a64a500bf53152ecbb3df = MAKE_CODEOBJ( module_filename_obj, const_str_plain__real_connect, 1121, const_tuple_f08ce5d2099609de7b2c444c551dc980_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_3ddc9f7565e4886cd4a659572d70f974 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_accept, 1157, const_tuple_d0e8e14d58a1064421ad37c78bfe9656_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_f0d4a14b639c208b031798e88d64dcf8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_cert_time_to_seconds, 1227, const_tuple_da309a4929ea4a4af6aee082c29fb449_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_09f1bb5201b8ef073955738188ca32ac = MAKE_CODEOBJ( module_filename_obj, const_str_plain_cipher, 741, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8d5372b515e339fede7165b142e8a13c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_cipher, 956, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c84cff19f5ca70203b24d6ffa781b6c6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_compression, 752, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c86b13db4689f046ff5f1afeb5710181 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_compression, 970, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e55c77de5189f075a317b4725d964bc7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_connect, 1147, const_tuple_str_plain_self_str_plain_addr_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a86b95352fc9c8cca13ec96f3cf3e648 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_connect_ex, 1152, const_tuple_str_plain_self_str_plain_addr_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_155bafd0723162e3e798ef484b14cd90 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_context, 664, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b025c5ada52dfc27ae3723ad4341ada3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_context, 669, const_tuple_str_plain_self_str_plain_ctx_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6a50350fea64982993f4c32f68ed6a2a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_context, 859, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0abbe3d29d94097de2b4cca44b79ff1d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_context, 863, const_tuple_str_plain_self_str_plain_ctx_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_964b4ff49a75adfde8eac32fd1579b15 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_create_default_context, 551, const_tuple_a6e5b7213d740be0ae002af3220b2e2c_tuple, 1, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_85a48a901c551db5360868c6ff2fcbe0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_do_handshake, 761, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_732e9b90c8c97c0d936101eda76a8170 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_do_handshake, 1110, const_tuple_str_plain_self_str_plain_block_str_plain_timeout_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a9707a26dabb530d65fb63614a8bfaf3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_dup, 886, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d56e86ad148a7f35b220cc951f739bf5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_fromname, 365, const_tuple_str_plain_cls_str_plain_name_str_plain___class___tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_6a9f24714f01965dd94fca0f0e8d2494 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_fromnid, 359, const_tuple_str_plain_cls_str_plain_nid_str_plain___class___tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_df41c359df46e3b95ae46ee541469c12 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_channel_binding, 769, const_tuple_str_plain_self_str_plain_cb_type_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0adca387694c9d0d05e6dcf361654043 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_channel_binding, 1169, const_tuple_str_plain_self_str_plain_cb_type_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f4b142c4d615bce9c4fa208111063de1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_default_verify_paths, 337, const_tuple_str_plain_parts_str_plain_cafile_str_plain_capath_tuple, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0fefcbe6be1b7672f9495fe2d2c2b520 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_protocol_name, 1302, const_tuple_str_plain_protocol_code_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_49a3d9e5040ae940801c3d349086f58b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_server_certificate, 1283, const_tuple_61f907a50f134b71eafa1ea291b414b8_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0afdd5e99178c32be659fdceadf23330 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getpeercert, 718, const_tuple_str_plain_self_str_plain_binary_form_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_40f8c9a48268243d506769f5f3c9f87c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getpeercert, 932, const_tuple_str_plain_self_str_plain_binary_form_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_86ffcc5f322eb9e45b49c1aab256e2b5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hostname_checks_common_name, 510, const_tuple_str_plain_self_str_plain_ncs_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8005450d1390ccb1db96bde8f18ccbc5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hostname_checks_common_name, 515, const_tuple_str_plain_self_str_plain_value_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9eb5b4d9d73d171312d06b89742db6dc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hostname_checks_common_name, 522, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bd31b2b0b29be68fb348a8509700aacb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_default_certs, 474, const_tuple_str_plain_self_str_plain_purpose_str_plain_storename_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b22e2653cdc93fd04980c249351d9dc3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_match_hostname, 276, const_tuple_67f07609e3644b8c19de10c902eeeb48_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1fa2afa1f2001c76009fa3bd74739a02 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_maximum_version, 493, const_tuple_str_plain_self_str_plain___class___tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_dd245307a21868517b26333004071afc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_maximum_version, 497, const_tuple_str_plain_self_str_plain_value_str_plain___class___tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_c741f20b5460a44d8f7d1a1ec0524090 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_minimum_version, 483, const_tuple_str_plain_self_str_plain___class___tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_9c140cba594376b13de36d0b9d2cf41b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_minimum_version, 487, const_tuple_str_plain_self_str_plain_value_str_plain___class___tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_e577eeee712faf011eac0a90d5a335cd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_options, 501, const_tuple_str_plain_self_str_plain___class___tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_d0ddd3c583ea0f70fd2c3f13c292f8d8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_options, 505, const_tuple_str_plain_self_str_plain_value_str_plain___class___tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_3ecf3a2c062154f40f3b43857fadfa1b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pending, 757, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c9ee113a8b3a2d7e49dd2e5a09a16c0a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pending, 1080, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e90beb192a2d45b154b787dd334a641a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_protocol, 526, const_tuple_str_plain_self_str_plain___class___tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_83f840bc627e14b2df37f66978eee02e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_read, 698, const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_v_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bc55c6947047d12d73c6cf85fd31316d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_read, 902, const_tuple_str_plain_self_str_plain_len_str_plain_buffer_str_plain_x_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3e272a599979dddb2106eeb0ca82341b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_recv, 1030, const_tuple_e0867d1d1bdc1b09db9831d078cf5291_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_54a01adef0ac9e521553dadf12222313 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_recv_into, 1041, const_tuple_8cbc413f7ba377eb28c3c8de0f0a31a6_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_d836e52222fa765674eb7fabb95e256a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_recvfrom, 1056, const_tuple_e0867d1d1bdc1b09db9831d078cf5291_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_102787f65a848b0f5ef93c552b2754a8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_recvfrom_into, 1064, const_tuple_8cbc413f7ba377eb28c3c8de0f0a31a6_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_6753233f97c67ba60fed48cd037a5da1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_recvmsg, 1072, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_b9c49bf51fd490ce845154517abf5afe = MAKE_CODEOBJ( module_filename_obj, const_str_plain_recvmsg_into, 1076, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_0efd15d2dbf254a6a5ea212c2e808164 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_selected_alpn_protocol, 734, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d2bc38bd2c275ba26d06739a8be65121 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_selected_alpn_protocol, 949, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d5b89644963ce7577c3e54aec3b26352 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_selected_npn_protocol, 727, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9946f25858fede3b1b6536c2d85f8023 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_selected_npn_protocol, 942, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_04c7d04cc1994e94386698ea320f0a34 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_send, 977, const_tuple_284226fe448516f5ff39ffa684da9193_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_6f2722bf3b4b9cc66de9b446db7a9e02 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sendall, 1004, const_tuple_8f4a9ecee5b69684c6422c4623b74375_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_b6715770c57c475edff269e2bfce93b7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sendfile, 1020, const_tuple_67e83e4c1a580aa75b711d7b7e138e06_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_d919d033f6f5ba6049cfa7306704c4e1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sendmsg, 998, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_7d99f84954cc8e5a491c234fdf7ba84c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sendto, 988, const_tuple_730fbfff731a79523b12989c446f00e5_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_148ded5e31bfc43993a6f070cc228356 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_server_hostname, 692, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_af887c87284bed61555d654364a46bbc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_server_side, 687, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_150a7fc04f06617735354ee03a3a1379 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_session, 673, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0cab748c09d01cef1fc04469feb036ab = MAKE_CODEOBJ( module_filename_obj, const_str_plain_session, 678, const_tuple_str_plain_self_str_plain_session_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f436d72429baf7d16ba6a700826ecce2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_session, 868, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_81b99666473d5e4c99b07c76650d6532 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_session, 874, const_tuple_str_plain_self_str_plain_session_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3d426fcde832f96f9fefe61110c3597f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_session_reused, 682, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_854fbf8c0d35e06c7abf19e23c21f425 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_session_reused, 880, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e33384d5e86c4c6b681e06b935a1eccd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_alpn_protocols, 449, const_tuple_aa341dc2e3c74f72a385182dcb9b8959_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c315ec050432736c21843c7f8970ed99 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_npn_protocols, 425, const_tuple_7473acf6d330ed226a15523988ec3e21_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6362b4ab8ff4a74ff389af21e2831505 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_servername_callback, 436, const_tuple_439f0f01aa96458b63f3c1913f75c97b_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4c16b3b8e78753d108f56368b6107e65 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shared_ciphers, 746, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6720aa3c1b1df68a0d363d84d0591c66 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shared_ciphers, 963, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c9128c1053ef6f473a6bfd7f36ba0b37 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shim_cb, 443, const_tuple_97d33b1871b78e86b4d3116dd7c89853_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_b581a977e97c824d653f0d91e1864d5a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shutdown, 1087, const_tuple_str_plain_self_str_plain_how_str_plain___class___tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_8299ff8d044f5af021c11f1525c08864 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_unwrap, 765, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f30c98b20585ea45248d54a7a131cbd6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_unwrap, 1092, const_tuple_str_plain_self_str_plain_s_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7fef2a19fae27d1b2e8f283d57279247 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify_client_post_handshake, 780, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c308f005c60a48850ddc38c70cfc9e4a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify_client_post_handshake, 1100, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6eddcfd3501f9e6e8ff360a6e9e07ace = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify_flags, 530, const_tuple_str_plain_self_str_plain___class___tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_a798b36ecbdc4799a3ed88ea793f49cf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify_flags, 534, const_tuple_str_plain_self_str_plain_value_str_plain___class___tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_cd07790829b56e8f6715d0e2df0d1b17 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify_mode, 538, const_tuple_str_plain_self_str_plain_value_str_plain___class___tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_58499782b4566c6282fbc531bfb08ebf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify_mode, 546, const_tuple_str_plain_self_str_plain_value_str_plain___class___tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_074ad722ef8e6ac8cf69c8739de2b3f8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_version, 775, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_431602757d87c0ffb4cfc07c16f40c0f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_version, 1183, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5f141f0f9a51bec2ef519041ccab0132 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrap_bio, 415, const_tuple_09c2d80bf2e47e0bc7f1c9dc811cecbd_tuple, 6, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5e4ce0716b248a14e09f49928b12effa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrap_socket, 399, const_tuple_1aab3e41f37d07b6590ecac751f85fc1_tuple, 7, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e52a48e17e348b81afa21bb0833b5cee = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrap_socket, 1199, const_tuple_234e5bfe107e65bfa1e117de9c8f6602_tuple, 10, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4bc9b1ac077eede44b66bfacb2b34b9c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_write, 710, const_tuple_str_plain_self_str_plain_data_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2116eb980de7dd12514dc72c39fd3f4d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_write, 923, const_tuple_str_plain_self_str_plain_data_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
}

// The module function declarations.
NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_1__mro_entries_conversion( PyObject **python_pars );


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_4_complex_call_helper_pos_star_list( PyObject **python_pars );


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_12_complex_call_helper_pos_star_dict( PyObject **python_pars );


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_9_complex_call_helper_star_dict( PyObject **python_pars );


static PyObject *MAKE_FUNCTION_ssl$$$function_100_connect_ex(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_101_accept(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_102_get_channel_binding( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_103_version(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_104_wrap_socket( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_105_cert_time_to_seconds(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_106_DER_cert_to_PEM_cert(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_107_PEM_cert_to_DER_cert(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_108_get_server_certificate( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_109_get_protocol_name(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_10_match_hostname(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_11_get_default_verify_paths(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_12___new__(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_13_fromnid(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_14_fromname(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_15___new__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_16__encode_hostname(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_17_wrap_socket( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_18_wrap_bio( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_19_set_npn_protocols(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_1_lambda(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_20_set_servername_callback(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_20_set_servername_callback$$$function_1_shim_cb(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_21_set_alpn_protocols(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_22__load_windows_store_certs(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_23_load_default_certs( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_24_minimum_version(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_25_minimum_version(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_26_maximum_version(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_27_maximum_version(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_28_options(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_29_options(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_2_lambda(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_30_hostname_checks_common_name(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_31_hostname_checks_common_name(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_32_hostname_checks_common_name(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_33_protocol(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_34_verify_flags(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_35_verify_flags(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_36_verify_mode(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_37_verify_mode(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_38_create_default_context( PyObject *defaults, PyObject *kw_defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_39__create_unverified_context( PyObject *defaults, PyObject *kw_defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_3_lambda(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_40___init__(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_41__create( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_42_context(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_43_context(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_44_session(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_45_session(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_46_session_reused(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_47_server_side(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_48_server_hostname(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_49_read( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_4_lambda(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_50_write(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_51_getpeercert( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_52_selected_npn_protocol(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_53_selected_alpn_protocol(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_54_cipher(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_55_shared_ciphers(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_56_compression(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_57_pending(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_58_do_handshake(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_59_unwrap(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_5_lambda(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_60_get_channel_binding( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_61_version(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_62_verify_client_post_handshake(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_63___init__(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_64__create( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_65_context(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_66_context(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_67_session(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_68_session(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_69_session_reused(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_6_lambda(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_70_dup(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_71__checkClosed( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_72__check_connected(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_73_read( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_74_write(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_75_getpeercert( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_76_selected_npn_protocol(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_77_selected_alpn_protocol(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_78_cipher(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_79_shared_ciphers(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_7__dnsname_match(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_80_compression(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_81_send( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_82_sendto( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_83_sendmsg(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_84_sendall( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_85_sendfile( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_86_recv( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_87_recv_into( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_88_recvfrom( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_89_recvfrom_into( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_8__inet_paton(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_90_recvmsg(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_91_recvmsg_into(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_92_pending(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_93_shutdown(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_94_unwrap(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_95_verify_client_post_handshake(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_96__real_close(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_97_do_handshake( PyObject *defaults );


static PyObject *MAKE_FUNCTION_ssl$$$function_98__real_connect(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_99_connect(  );


static PyObject *MAKE_FUNCTION_ssl$$$function_9__ipaddress_match(  );


// The module function definitions.
static PyObject *impl_ssl$$$function_1_lambda( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_name = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_8b2169752a1cafe1c590b905bc1817cf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8b2169752a1cafe1c590b905bc1817cf = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8b2169752a1cafe1c590b905bc1817cf, codeobj_8b2169752a1cafe1c590b905bc1817cf, module_ssl, sizeof(void *) );
    frame_8b2169752a1cafe1c590b905bc1817cf = cache_frame_8b2169752a1cafe1c590b905bc1817cf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8b2169752a1cafe1c590b905bc1817cf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8b2169752a1cafe1c590b905bc1817cf ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_name );
        tmp_called_instance_1 = par_name;
        frame_8b2169752a1cafe1c590b905bc1817cf->m_frame.f_lineno = 124;
        tmp_and_left_value_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_startswith, &PyTuple_GET_ITEM( const_tuple_str_plain_PROTOCOL__tuple, 0 ) );

        if ( tmp_and_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 124;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 124;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_name );
        tmp_compexpr_left_1 = par_name;
        tmp_compexpr_right_1 = const_str_plain_PROTOCOL_SSLv23;
        tmp_and_right_value_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 124;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8b2169752a1cafe1c590b905bc1817cf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8b2169752a1cafe1c590b905bc1817cf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8b2169752a1cafe1c590b905bc1817cf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8b2169752a1cafe1c590b905bc1817cf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8b2169752a1cafe1c590b905bc1817cf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8b2169752a1cafe1c590b905bc1817cf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8b2169752a1cafe1c590b905bc1817cf,
        type_description_1,
        par_name
    );


    // Release cached frame.
    if ( frame_8b2169752a1cafe1c590b905bc1817cf == cache_frame_8b2169752a1cafe1c590b905bc1817cf )
    {
        Py_DECREF( frame_8b2169752a1cafe1c590b905bc1817cf );
    }
    cache_frame_8b2169752a1cafe1c590b905bc1817cf = NULL;

    assertFrameObject( frame_8b2169752a1cafe1c590b905bc1817cf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_1_lambda );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_1_lambda );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_2_lambda( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_name = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d8ef087d29dce5b7809ac49cd68adf25;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d8ef087d29dce5b7809ac49cd68adf25 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d8ef087d29dce5b7809ac49cd68adf25, codeobj_d8ef087d29dce5b7809ac49cd68adf25, module_ssl, sizeof(void *) );
    frame_d8ef087d29dce5b7809ac49cd68adf25 = cache_frame_d8ef087d29dce5b7809ac49cd68adf25;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d8ef087d29dce5b7809ac49cd68adf25 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d8ef087d29dce5b7809ac49cd68adf25 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_name );
        tmp_called_instance_1 = par_name;
        frame_d8ef087d29dce5b7809ac49cd68adf25->m_frame.f_lineno = 129;
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_startswith, &PyTuple_GET_ITEM( const_tuple_str_plain_OP__tuple, 0 ) );

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 129;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d8ef087d29dce5b7809ac49cd68adf25 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d8ef087d29dce5b7809ac49cd68adf25 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d8ef087d29dce5b7809ac49cd68adf25 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d8ef087d29dce5b7809ac49cd68adf25, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d8ef087d29dce5b7809ac49cd68adf25->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d8ef087d29dce5b7809ac49cd68adf25, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d8ef087d29dce5b7809ac49cd68adf25,
        type_description_1,
        par_name
    );


    // Release cached frame.
    if ( frame_d8ef087d29dce5b7809ac49cd68adf25 == cache_frame_d8ef087d29dce5b7809ac49cd68adf25 )
    {
        Py_DECREF( frame_d8ef087d29dce5b7809ac49cd68adf25 );
    }
    cache_frame_d8ef087d29dce5b7809ac49cd68adf25 = NULL;

    assertFrameObject( frame_d8ef087d29dce5b7809ac49cd68adf25 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_2_lambda );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_2_lambda );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_3_lambda( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_name = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_4ea3aebfeea4b0fb696d8e3f751bb569;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4ea3aebfeea4b0fb696d8e3f751bb569 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4ea3aebfeea4b0fb696d8e3f751bb569, codeobj_4ea3aebfeea4b0fb696d8e3f751bb569, module_ssl, sizeof(void *) );
    frame_4ea3aebfeea4b0fb696d8e3f751bb569 = cache_frame_4ea3aebfeea4b0fb696d8e3f751bb569;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4ea3aebfeea4b0fb696d8e3f751bb569 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4ea3aebfeea4b0fb696d8e3f751bb569 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_name );
        tmp_called_instance_1 = par_name;
        frame_4ea3aebfeea4b0fb696d8e3f751bb569->m_frame.f_lineno = 134;
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_startswith, &PyTuple_GET_ITEM( const_tuple_str_plain_ALERT_DESCRIPTION__tuple, 0 ) );

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 134;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4ea3aebfeea4b0fb696d8e3f751bb569 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4ea3aebfeea4b0fb696d8e3f751bb569 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4ea3aebfeea4b0fb696d8e3f751bb569 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4ea3aebfeea4b0fb696d8e3f751bb569, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4ea3aebfeea4b0fb696d8e3f751bb569->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4ea3aebfeea4b0fb696d8e3f751bb569, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4ea3aebfeea4b0fb696d8e3f751bb569,
        type_description_1,
        par_name
    );


    // Release cached frame.
    if ( frame_4ea3aebfeea4b0fb696d8e3f751bb569 == cache_frame_4ea3aebfeea4b0fb696d8e3f751bb569 )
    {
        Py_DECREF( frame_4ea3aebfeea4b0fb696d8e3f751bb569 );
    }
    cache_frame_4ea3aebfeea4b0fb696d8e3f751bb569 = NULL;

    assertFrameObject( frame_4ea3aebfeea4b0fb696d8e3f751bb569 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_3_lambda );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_3_lambda );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_4_lambda( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_name = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_57ad0ee0b24514877328827449ed6d3d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_57ad0ee0b24514877328827449ed6d3d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_57ad0ee0b24514877328827449ed6d3d, codeobj_57ad0ee0b24514877328827449ed6d3d, module_ssl, sizeof(void *) );
    frame_57ad0ee0b24514877328827449ed6d3d = cache_frame_57ad0ee0b24514877328827449ed6d3d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_57ad0ee0b24514877328827449ed6d3d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_57ad0ee0b24514877328827449ed6d3d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_name );
        tmp_called_instance_1 = par_name;
        frame_57ad0ee0b24514877328827449ed6d3d->m_frame.f_lineno = 139;
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_startswith, &PyTuple_GET_ITEM( const_tuple_str_plain_SSL_ERROR__tuple, 0 ) );

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 139;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_57ad0ee0b24514877328827449ed6d3d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_57ad0ee0b24514877328827449ed6d3d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_57ad0ee0b24514877328827449ed6d3d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_57ad0ee0b24514877328827449ed6d3d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_57ad0ee0b24514877328827449ed6d3d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_57ad0ee0b24514877328827449ed6d3d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_57ad0ee0b24514877328827449ed6d3d,
        type_description_1,
        par_name
    );


    // Release cached frame.
    if ( frame_57ad0ee0b24514877328827449ed6d3d == cache_frame_57ad0ee0b24514877328827449ed6d3d )
    {
        Py_DECREF( frame_57ad0ee0b24514877328827449ed6d3d );
    }
    cache_frame_57ad0ee0b24514877328827449ed6d3d = NULL;

    assertFrameObject( frame_57ad0ee0b24514877328827449ed6d3d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_4_lambda );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_4_lambda );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_5_lambda( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_name = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_3fd973b4394bbb87224fe4972ac062b2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3fd973b4394bbb87224fe4972ac062b2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3fd973b4394bbb87224fe4972ac062b2, codeobj_3fd973b4394bbb87224fe4972ac062b2, module_ssl, sizeof(void *) );
    frame_3fd973b4394bbb87224fe4972ac062b2 = cache_frame_3fd973b4394bbb87224fe4972ac062b2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3fd973b4394bbb87224fe4972ac062b2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3fd973b4394bbb87224fe4972ac062b2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_name );
        tmp_called_instance_1 = par_name;
        frame_3fd973b4394bbb87224fe4972ac062b2->m_frame.f_lineno = 144;
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_startswith, &PyTuple_GET_ITEM( const_tuple_str_plain_VERIFY__tuple, 0 ) );

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 144;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3fd973b4394bbb87224fe4972ac062b2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3fd973b4394bbb87224fe4972ac062b2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3fd973b4394bbb87224fe4972ac062b2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3fd973b4394bbb87224fe4972ac062b2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3fd973b4394bbb87224fe4972ac062b2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3fd973b4394bbb87224fe4972ac062b2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3fd973b4394bbb87224fe4972ac062b2,
        type_description_1,
        par_name
    );


    // Release cached frame.
    if ( frame_3fd973b4394bbb87224fe4972ac062b2 == cache_frame_3fd973b4394bbb87224fe4972ac062b2 )
    {
        Py_DECREF( frame_3fd973b4394bbb87224fe4972ac062b2 );
    }
    cache_frame_3fd973b4394bbb87224fe4972ac062b2 = NULL;

    assertFrameObject( frame_3fd973b4394bbb87224fe4972ac062b2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_5_lambda );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_5_lambda );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_6_lambda( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_name = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_e78ac027ae2374cae8fee268e861e6b6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e78ac027ae2374cae8fee268e861e6b6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e78ac027ae2374cae8fee268e861e6b6, codeobj_e78ac027ae2374cae8fee268e861e6b6, module_ssl, sizeof(void *) );
    frame_e78ac027ae2374cae8fee268e861e6b6 = cache_frame_e78ac027ae2374cae8fee268e861e6b6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e78ac027ae2374cae8fee268e861e6b6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e78ac027ae2374cae8fee268e861e6b6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_name );
        tmp_called_instance_1 = par_name;
        frame_e78ac027ae2374cae8fee268e861e6b6->m_frame.f_lineno = 149;
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_startswith, &PyTuple_GET_ITEM( const_tuple_str_plain_CERT__tuple, 0 ) );

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 149;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e78ac027ae2374cae8fee268e861e6b6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e78ac027ae2374cae8fee268e861e6b6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e78ac027ae2374cae8fee268e861e6b6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e78ac027ae2374cae8fee268e861e6b6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e78ac027ae2374cae8fee268e861e6b6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e78ac027ae2374cae8fee268e861e6b6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e78ac027ae2374cae8fee268e861e6b6,
        type_description_1,
        par_name
    );


    // Release cached frame.
    if ( frame_e78ac027ae2374cae8fee268e861e6b6 == cache_frame_e78ac027ae2374cae8fee268e861e6b6 )
    {
        Py_DECREF( frame_e78ac027ae2374cae8fee268e861e6b6 );
    }
    cache_frame_e78ac027ae2374cae8fee268e861e6b6 = NULL;

    assertFrameObject( frame_e78ac027ae2374cae8fee268e861e6b6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_6_lambda );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_6_lambda );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_7__dnsname_match( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_dn = python_pars[ 0 ];
    PyObject *par_hostname = python_pars[ 1 ];
    PyObject *var_wildcards = NULL;
    PyObject *var_dn_leftmost = NULL;
    PyObject *var_sep = NULL;
    PyObject *var_dn_remainder = NULL;
    PyObject *var_hostname_leftmost = NULL;
    PyObject *var_hostname_remainder = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_2__element_1 = NULL;
    PyObject *tmp_tuple_unpack_2__element_2 = NULL;
    PyObject *tmp_tuple_unpack_2__element_3 = NULL;
    PyObject *tmp_tuple_unpack_2__source_iter = NULL;
    struct Nuitka_FrameObject *frame_a5072bf1a063c9f1c49782fa3c262d40;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    static struct Nuitka_FrameObject *cache_frame_a5072bf1a063c9f1c49782fa3c262d40 = NULL;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a5072bf1a063c9f1c49782fa3c262d40, codeobj_a5072bf1a063c9f1c49782fa3c262d40, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a5072bf1a063c9f1c49782fa3c262d40 = cache_frame_a5072bf1a063c9f1c49782fa3c262d40;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a5072bf1a063c9f1c49782fa3c262d40 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a5072bf1a063c9f1c49782fa3c262d40 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( par_dn );
        tmp_operand_name_1 = par_dn;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 201;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_dn );
        tmp_called_instance_1 = par_dn;
        frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 204;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_count, &PyTuple_GET_ITEM( const_tuple_str_chr_42_tuple, 0 ) );

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 204;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_wildcards == NULL );
        var_wildcards = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_wildcards );
        tmp_operand_name_2 = var_wildcards;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 206;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_called_instance_3;
            CHECK_OBJECT( par_dn );
            tmp_called_instance_2 = par_dn;
            frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 207;
            tmp_compexpr_left_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_lower );
            if ( tmp_compexpr_left_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 207;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_hostname );
            tmp_called_instance_3 = par_hostname;
            frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 207;
            tmp_compexpr_right_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_lower );
            if ( tmp_compexpr_right_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_1 );

                exception_lineno = 207;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
            Py_DECREF( tmp_compexpr_left_1 );
            Py_DECREF( tmp_compexpr_right_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 207;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( var_wildcards );
        tmp_compexpr_left_2 = var_wildcards;
        tmp_compexpr_right_2 = const_int_pos_1;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 209;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_called_instance_4;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CertificateError );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CertificateError );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CertificateError" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 210;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            tmp_called_instance_4 = const_str_digest_b8a96526c0c1047e3727ab8306b2c0b6;
            CHECK_OBJECT( par_dn );
            tmp_args_element_name_2 = par_dn;
            frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 211;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_format, call_args );
            }

            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 211;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 210;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 210;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 210;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_instance_5;
        CHECK_OBJECT( par_dn );
        tmp_called_instance_5 = par_dn;
        frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 213;
        tmp_iter_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_partition, &PyTuple_GET_ITEM( const_tuple_str_dot_tuple, 0 ) );

        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 213;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_assign_source_2 = MAKE_UNPACK_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 213;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        assert( tmp_tuple_unpack_1__source_iter == NULL );
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_2;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_1, 0, 3 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooooo";
            exception_lineno = 213;
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__element_1 == NULL );
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_2, 1, 3 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooooo";
            exception_lineno = 213;
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__element_2 == NULL );
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_unpack_3;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_3 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_5 = UNPACK_NEXT( tmp_unpack_3, 2, 3 );
        if ( tmp_assign_source_5 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooooo";
            exception_lineno = 213;
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__element_3 == NULL );
        tmp_tuple_unpack_1__element_3 = tmp_assign_source_5;
    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "oooooooo";
                    exception_lineno = 213;
                    goto try_except_handler_3;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "oooooooo";
            exception_lineno = 213;
            goto try_except_handler_3;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_3 );
    tmp_tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_6 = tmp_tuple_unpack_1__element_1;
        assert( var_dn_leftmost == NULL );
        Py_INCREF( tmp_assign_source_6 );
        var_dn_leftmost = tmp_assign_source_6;
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_7;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_7 = tmp_tuple_unpack_1__element_2;
        assert( var_sep == NULL );
        Py_INCREF( tmp_assign_source_7 );
        var_sep = tmp_assign_source_7;
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        PyObject *tmp_assign_source_8;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_3 );
        tmp_assign_source_8 = tmp_tuple_unpack_1__element_3;
        assert( var_dn_remainder == NULL );
        Py_INCREF( tmp_assign_source_8 );
        var_dn_remainder = tmp_assign_source_8;
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_3 );
    tmp_tuple_unpack_1__element_3 = NULL;

    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = const_str_chr_42;
        CHECK_OBJECT( var_dn_remainder );
        tmp_compexpr_right_3 = var_dn_remainder;
        tmp_res = PySequence_Contains( tmp_compexpr_right_3, tmp_compexpr_left_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 215;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_called_instance_6;
            PyObject *tmp_args_element_name_4;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CertificateError );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CertificateError );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CertificateError" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 217;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_2;
            tmp_called_instance_6 = const_str_digest_c9952bf55f4165e8dd5c4f498af92c1c;
            CHECK_OBJECT( par_dn );
            tmp_args_element_name_4 = par_dn;
            frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 218;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_format, call_args );
            }

            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 218;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 217;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_args_element_name_3 );
            if ( tmp_raise_type_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 217;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_2;
            exception_lineno = 217;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_operand_name_3;
        CHECK_OBJECT( var_sep );
        tmp_operand_name_3 = var_sep;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 221;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_called_instance_7;
            PyObject *tmp_args_element_name_6;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CertificateError );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CertificateError );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CertificateError" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 223;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_3;
            tmp_called_instance_7 = const_str_digest_123738711ea439506bcf12b2e47bd0ba;
            CHECK_OBJECT( par_dn );
            tmp_args_element_name_6 = par_dn;
            frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 224;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_args_element_name_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_format, call_args );
            }

            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 224;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 223;
            {
                PyObject *call_args[] = { tmp_args_element_name_5 };
                tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_raise_type_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 223;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_3;
            exception_lineno = 223;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_5:;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        CHECK_OBJECT( var_dn_leftmost );
        tmp_compexpr_left_4 = var_dn_leftmost;
        tmp_compexpr_right_4 = const_str_chr_42;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 227;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_raise_type_4;
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_called_instance_8;
            PyObject *tmp_args_element_name_8;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CertificateError );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CertificateError );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CertificateError" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 229;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_4;
            tmp_called_instance_8 = const_str_digest_d419c0cfda05a6c7cddfa9e5ecabff66;
            CHECK_OBJECT( par_dn );
            tmp_args_element_name_8 = par_dn;
            frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 230;
            {
                PyObject *call_args[] = { tmp_args_element_name_8 };
                tmp_args_element_name_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_8, const_str_plain_format, call_args );
            }

            if ( tmp_args_element_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 230;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 229;
            {
                PyObject *call_args[] = { tmp_args_element_name_7 };
                tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
            }

            Py_DECREF( tmp_args_element_name_7 );
            if ( tmp_raise_type_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 229;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_4;
            exception_lineno = 229;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_6:;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_iter_arg_2;
        PyObject *tmp_called_instance_9;
        CHECK_OBJECT( par_hostname );
        tmp_called_instance_9 = par_hostname;
        frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 233;
        tmp_iter_arg_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_9, const_str_plain_partition, &PyTuple_GET_ITEM( const_tuple_str_dot_tuple, 0 ) );

        if ( tmp_iter_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 233;
            type_description_1 = "oooooooo";
            goto try_except_handler_4;
        }
        tmp_assign_source_9 = MAKE_UNPACK_ITERATOR( tmp_iter_arg_2 );
        Py_DECREF( tmp_iter_arg_2 );
        if ( tmp_assign_source_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 233;
            type_description_1 = "oooooooo";
            goto try_except_handler_4;
        }
        assert( tmp_tuple_unpack_2__source_iter == NULL );
        tmp_tuple_unpack_2__source_iter = tmp_assign_source_9;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_unpack_4;
        CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
        tmp_unpack_4 = tmp_tuple_unpack_2__source_iter;
        tmp_assign_source_10 = UNPACK_NEXT( tmp_unpack_4, 0, 3 );
        if ( tmp_assign_source_10 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooooo";
            exception_lineno = 233;
            goto try_except_handler_5;
        }
        assert( tmp_tuple_unpack_2__element_1 == NULL );
        tmp_tuple_unpack_2__element_1 = tmp_assign_source_10;
    }
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_unpack_5;
        CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
        tmp_unpack_5 = tmp_tuple_unpack_2__source_iter;
        tmp_assign_source_11 = UNPACK_NEXT( tmp_unpack_5, 1, 3 );
        if ( tmp_assign_source_11 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooooo";
            exception_lineno = 233;
            goto try_except_handler_5;
        }
        assert( tmp_tuple_unpack_2__element_2 == NULL );
        tmp_tuple_unpack_2__element_2 = tmp_assign_source_11;
    }
    {
        PyObject *tmp_assign_source_12;
        PyObject *tmp_unpack_6;
        CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
        tmp_unpack_6 = tmp_tuple_unpack_2__source_iter;
        tmp_assign_source_12 = UNPACK_NEXT( tmp_unpack_6, 2, 3 );
        if ( tmp_assign_source_12 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooooo";
            exception_lineno = 233;
            goto try_except_handler_5;
        }
        assert( tmp_tuple_unpack_2__element_3 == NULL );
        tmp_tuple_unpack_2__element_3 = tmp_assign_source_12;
    }
    {
        PyObject *tmp_iterator_name_2;
        CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
        tmp_iterator_name_2 = tmp_tuple_unpack_2__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_2 ); assert( HAS_ITERNEXT( tmp_iterator_name_2 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_2 )->tp_iternext)( tmp_iterator_name_2 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "oooooooo";
                    exception_lineno = 233;
                    goto try_except_handler_5;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "oooooooo";
            exception_lineno = 233;
            goto try_except_handler_5;
        }
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
    Py_DECREF( tmp_tuple_unpack_2__source_iter );
    tmp_tuple_unpack_2__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_4;
    // End of try:
    try_end_3:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_2__element_1 );
    tmp_tuple_unpack_2__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_2__element_2 );
    tmp_tuple_unpack_2__element_2 = NULL;

    Py_XDECREF( tmp_tuple_unpack_2__element_3 );
    tmp_tuple_unpack_2__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
    Py_DECREF( tmp_tuple_unpack_2__source_iter );
    tmp_tuple_unpack_2__source_iter = NULL;

    {
        PyObject *tmp_assign_source_13;
        CHECK_OBJECT( tmp_tuple_unpack_2__element_1 );
        tmp_assign_source_13 = tmp_tuple_unpack_2__element_1;
        assert( var_hostname_leftmost == NULL );
        Py_INCREF( tmp_assign_source_13 );
        var_hostname_leftmost = tmp_assign_source_13;
    }
    Py_XDECREF( tmp_tuple_unpack_2__element_1 );
    tmp_tuple_unpack_2__element_1 = NULL;

    {
        PyObject *tmp_assign_source_14;
        CHECK_OBJECT( tmp_tuple_unpack_2__element_2 );
        tmp_assign_source_14 = tmp_tuple_unpack_2__element_2;
        {
            PyObject *old = var_sep;
            assert( old != NULL );
            var_sep = tmp_assign_source_14;
            Py_INCREF( var_sep );
            Py_DECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_2__element_2 );
    tmp_tuple_unpack_2__element_2 = NULL;

    {
        PyObject *tmp_assign_source_15;
        CHECK_OBJECT( tmp_tuple_unpack_2__element_3 );
        tmp_assign_source_15 = tmp_tuple_unpack_2__element_3;
        assert( var_hostname_remainder == NULL );
        Py_INCREF( tmp_assign_source_15 );
        var_hostname_remainder = tmp_assign_source_15;
    }
    Py_XDECREF( tmp_tuple_unpack_2__element_3 );
    tmp_tuple_unpack_2__element_3 = NULL;

    {
        nuitka_bool tmp_condition_result_7;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_operand_name_4;
        PyObject *tmp_operand_name_5;
        CHECK_OBJECT( var_hostname_leftmost );
        tmp_operand_name_4 = var_hostname_leftmost;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 234;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( var_sep );
        tmp_operand_name_5 = var_sep;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 234;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_7 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_7 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_7:;
    }
    {
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_called_instance_10;
        PyObject *tmp_called_instance_11;
        CHECK_OBJECT( var_dn_remainder );
        tmp_called_instance_10 = var_dn_remainder;
        frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 237;
        tmp_compexpr_left_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_10, const_str_plain_lower );
        if ( tmp_compexpr_left_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 237;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_hostname_remainder );
        tmp_called_instance_11 = var_hostname_remainder;
        frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame.f_lineno = 237;
        tmp_compexpr_right_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_11, const_str_plain_lower );
        if ( tmp_compexpr_right_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_5 );

            exception_lineno = 237;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
        Py_DECREF( tmp_compexpr_left_5 );
        Py_DECREF( tmp_compexpr_right_5 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 237;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a5072bf1a063c9f1c49782fa3c262d40 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a5072bf1a063c9f1c49782fa3c262d40 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a5072bf1a063c9f1c49782fa3c262d40 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a5072bf1a063c9f1c49782fa3c262d40, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a5072bf1a063c9f1c49782fa3c262d40->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a5072bf1a063c9f1c49782fa3c262d40, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a5072bf1a063c9f1c49782fa3c262d40,
        type_description_1,
        par_dn,
        par_hostname,
        var_wildcards,
        var_dn_leftmost,
        var_sep,
        var_dn_remainder,
        var_hostname_leftmost,
        var_hostname_remainder
    );


    // Release cached frame.
    if ( frame_a5072bf1a063c9f1c49782fa3c262d40 == cache_frame_a5072bf1a063c9f1c49782fa3c262d40 )
    {
        Py_DECREF( frame_a5072bf1a063c9f1c49782fa3c262d40 );
    }
    cache_frame_a5072bf1a063c9f1c49782fa3c262d40 = NULL;

    assertFrameObject( frame_a5072bf1a063c9f1c49782fa3c262d40 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_7__dnsname_match );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dn );
    Py_DECREF( par_dn );
    par_dn = NULL;

    CHECK_OBJECT( (PyObject *)par_hostname );
    Py_DECREF( par_hostname );
    par_hostname = NULL;

    Py_XDECREF( var_wildcards );
    var_wildcards = NULL;

    Py_XDECREF( var_dn_leftmost );
    var_dn_leftmost = NULL;

    Py_XDECREF( var_sep );
    var_sep = NULL;

    Py_XDECREF( var_dn_remainder );
    var_dn_remainder = NULL;

    Py_XDECREF( var_hostname_leftmost );
    var_hostname_leftmost = NULL;

    Py_XDECREF( var_hostname_remainder );
    var_hostname_remainder = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dn );
    Py_DECREF( par_dn );
    par_dn = NULL;

    CHECK_OBJECT( (PyObject *)par_hostname );
    Py_DECREF( par_hostname );
    par_hostname = NULL;

    Py_XDECREF( var_wildcards );
    var_wildcards = NULL;

    Py_XDECREF( var_dn_leftmost );
    var_dn_leftmost = NULL;

    Py_XDECREF( var_sep );
    var_sep = NULL;

    Py_XDECREF( var_dn_remainder );
    var_dn_remainder = NULL;

    Py_XDECREF( var_hostname_leftmost );
    var_hostname_leftmost = NULL;

    Py_XDECREF( var_hostname_remainder );
    var_hostname_remainder = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_7__dnsname_match );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_8__inet_paton( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ipname = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d8eebab0541bfa74aca42926ef69ef86;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_preserved_type_2;
    PyObject *exception_preserved_value_2;
    PyTracebackObject *exception_preserved_tb_2;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    static struct Nuitka_FrameObject *cache_frame_d8eebab0541bfa74aca42926ef69ef86 = NULL;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d8eebab0541bfa74aca42926ef69ef86, codeobj_d8eebab0541bfa74aca42926ef69ef86, module_ssl, sizeof(void *) );
    frame_d8eebab0541bfa74aca42926ef69ef86 = cache_frame_d8eebab0541bfa74aca42926ef69ef86;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d8eebab0541bfa74aca42926ef69ef86 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d8eebab0541bfa74aca42926ef69ef86 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_ipname );
        tmp_called_instance_1 = par_ipname;
        frame_d8eebab0541bfa74aca42926ef69ef86->m_frame.f_lineno = 247;
        tmp_compexpr_left_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_count, &PyTuple_GET_ITEM( const_tuple_str_dot_tuple, 0 ) );

        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 247;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_3;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 247;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        // Tried code:
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__socket );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__socket );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_socket" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 249;
                type_description_1 = "o";
                goto try_except_handler_2;
            }

            tmp_called_instance_2 = tmp_mvar_value_1;
            CHECK_OBJECT( par_ipname );
            tmp_args_element_name_1 = par_ipname;
            frame_d8eebab0541bfa74aca42926ef69ef86->m_frame.f_lineno = 249;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_inet_aton, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 249;
                type_description_1 = "o";
                goto try_except_handler_2;
            }
            goto frame_return_exit_1;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl$$$function_8__inet_paton );
        return NULL;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_type_1 );
        exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_value_1 );
        exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
        Py_XINCREF( exception_preserved_tb_1 );

        if ( exception_keeper_tb_1 == NULL )
        {
            exception_keeper_tb_1 = MAKE_TRACEBACK( frame_d8eebab0541bfa74aca42926ef69ef86, exception_keeper_lineno_1 );
        }
        else if ( exception_keeper_lineno_1 != 0 )
        {
            exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_d8eebab0541bfa74aca42926ef69ef86, exception_keeper_lineno_1 );
        }

        NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
        PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        // Tried code:
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
            tmp_compexpr_right_2 = PyExc_OSError;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 250;
                type_description_1 = "o";
                goto try_except_handler_3;
            }
            tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 250;
                type_description_1 = "o";
                goto try_except_handler_3;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 248;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_d8eebab0541bfa74aca42926ef69ef86->m_frame) frame_d8eebab0541bfa74aca42926ef69ef86->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "o";
            goto try_except_handler_3;
            branch_no_2:;
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Restore previous exception.
        SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto frame_exception_exit_1;
        // End of try:
        try_end_1:;
        // Restore previous exception.
        SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
        goto try_end_2;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl$$$function_8__inet_paton );
        return NULL;
        // End of try:
        try_end_2:;
        branch_no_1:;
    }
    // Tried code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__socket );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__socket );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_socket" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 254;
            type_description_1 = "o";
            goto try_except_handler_4;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_inet_pton );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 254;
            type_description_1 = "o";
            goto try_except_handler_4;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__socket );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__socket );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_socket" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 254;
            type_description_1 = "o";
            goto try_except_handler_4;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_AF_INET6 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 254;
            type_description_1 = "o";
            goto try_except_handler_4;
        }
        CHECK_OBJECT( par_ipname );
        tmp_args_element_name_3 = par_ipname;
        frame_d8eebab0541bfa74aca42926ef69ef86->m_frame.f_lineno = 254;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 254;
            type_description_1 = "o";
            goto try_except_handler_4;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_8__inet_paton );
    return NULL;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_2 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_2 );
    exception_preserved_value_2 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_2 );
    exception_preserved_tb_2 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_2 );

    if ( exception_keeper_tb_3 == NULL )
    {
        exception_keeper_tb_3 = MAKE_TRACEBACK( frame_d8eebab0541bfa74aca42926ef69ef86, exception_keeper_lineno_3 );
    }
    else if ( exception_keeper_lineno_3 != 0 )
    {
        exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_d8eebab0541bfa74aca42926ef69ef86, exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    PyException_SetTraceback( exception_keeper_value_3, (PyObject *)exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_OSError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 255;
            type_description_1 = "o";
            goto try_except_handler_5;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_called_instance_3;
            PyObject *tmp_args_element_name_4;
            tmp_called_instance_3 = const_str_digest_5d916050d0a708334c1549a93d19962a;
            CHECK_OBJECT( par_ipname );
            tmp_args_element_name_4 = par_ipname;
            frame_d8eebab0541bfa74aca42926ef69ef86->m_frame.f_lineno = 256;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_make_exception_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_format, call_args );
            }

            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 256;
                type_description_1 = "o";
                goto try_except_handler_5;
            }
            frame_d8eebab0541bfa74aca42926ef69ef86->m_frame.f_lineno = 256;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 256;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "o";
            goto try_except_handler_5;
        }
        goto branch_end_3;
        branch_no_3:;
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_operand_name_2;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            tmp_compexpr_left_4 = EXC_TYPE(PyThreadState_GET());
            tmp_compexpr_right_4 = PyExc_AttributeError;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 258;
                type_description_1 = "o";
                goto try_except_handler_5;
            }
            tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 258;
                type_description_1 = "o";
                goto try_except_handler_5;
            }
            tmp_condition_result_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 253;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_d8eebab0541bfa74aca42926ef69ef86->m_frame) frame_d8eebab0541bfa74aca42926ef69ef86->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "o";
            goto try_except_handler_5;
            branch_no_4:;
        }
        branch_end_3:;
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_2, exception_preserved_value_2, exception_preserved_tb_2 );
    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_2, exception_preserved_value_2, exception_preserved_tb_2 );
    goto try_end_4;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_8__inet_paton );
    return NULL;
    // End of try:
    try_end_4:;
    {
        PyObject *tmp_raise_type_2;
        PyObject *tmp_make_exception_arg_2;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_args_element_name_5;
        tmp_called_instance_4 = const_str_digest_f26217c45eb3dee86d08318942000832;
        CHECK_OBJECT( par_ipname );
        tmp_args_element_name_5 = par_ipname;
        frame_d8eebab0541bfa74aca42926ef69ef86->m_frame.f_lineno = 262;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_make_exception_arg_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_format, call_args );
        }

        if ( tmp_make_exception_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 262;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_d8eebab0541bfa74aca42926ef69ef86->m_frame.f_lineno = 262;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_2 };
            tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_2 );
        assert( !(tmp_raise_type_2 == NULL) );
        exception_type = tmp_raise_type_2;
        exception_lineno = 262;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d8eebab0541bfa74aca42926ef69ef86 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d8eebab0541bfa74aca42926ef69ef86 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d8eebab0541bfa74aca42926ef69ef86 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d8eebab0541bfa74aca42926ef69ef86, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d8eebab0541bfa74aca42926ef69ef86->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d8eebab0541bfa74aca42926ef69ef86, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d8eebab0541bfa74aca42926ef69ef86,
        type_description_1,
        par_ipname
    );


    // Release cached frame.
    if ( frame_d8eebab0541bfa74aca42926ef69ef86 == cache_frame_d8eebab0541bfa74aca42926ef69ef86 )
    {
        Py_DECREF( frame_d8eebab0541bfa74aca42926ef69ef86 );
    }
    cache_frame_d8eebab0541bfa74aca42926ef69ef86 = NULL;

    assertFrameObject( frame_d8eebab0541bfa74aca42926ef69ef86 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_8__inet_paton );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ipname );
    Py_DECREF( par_ipname );
    par_ipname = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ipname );
    Py_DECREF( par_ipname );
    par_ipname = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_8__inet_paton );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_9__ipaddress_match( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ipname = python_pars[ 0 ];
    PyObject *par_host_ip = python_pars[ 1 ];
    PyObject *var_ip = NULL;
    struct Nuitka_FrameObject *frame_27463743bde98a64c19721f228ebca83;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_27463743bde98a64c19721f228ebca83 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_27463743bde98a64c19721f228ebca83, codeobj_27463743bde98a64c19721f228ebca83, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_27463743bde98a64c19721f228ebca83 = cache_frame_27463743bde98a64c19721f228ebca83;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_27463743bde98a64c19721f228ebca83 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_27463743bde98a64c19721f228ebca83 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__inet_paton );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__inet_paton );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_inet_paton" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 272;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ipname );
        tmp_called_instance_1 = par_ipname;
        frame_27463743bde98a64c19721f228ebca83->m_frame.f_lineno = 272;
        tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_rstrip );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 272;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_27463743bde98a64c19721f228ebca83->m_frame.f_lineno = 272;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 272;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_ip == NULL );
        var_ip = tmp_assign_source_1;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_ip );
        tmp_compexpr_left_1 = var_ip;
        CHECK_OBJECT( par_host_ip );
        tmp_compexpr_right_1 = par_host_ip;
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 273;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27463743bde98a64c19721f228ebca83 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_27463743bde98a64c19721f228ebca83 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27463743bde98a64c19721f228ebca83 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_27463743bde98a64c19721f228ebca83, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_27463743bde98a64c19721f228ebca83->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_27463743bde98a64c19721f228ebca83, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_27463743bde98a64c19721f228ebca83,
        type_description_1,
        par_ipname,
        par_host_ip,
        var_ip
    );


    // Release cached frame.
    if ( frame_27463743bde98a64c19721f228ebca83 == cache_frame_27463743bde98a64c19721f228ebca83 )
    {
        Py_DECREF( frame_27463743bde98a64c19721f228ebca83 );
    }
    cache_frame_27463743bde98a64c19721f228ebca83 = NULL;

    assertFrameObject( frame_27463743bde98a64c19721f228ebca83 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_9__ipaddress_match );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ipname );
    Py_DECREF( par_ipname );
    par_ipname = NULL;

    CHECK_OBJECT( (PyObject *)par_host_ip );
    Py_DECREF( par_host_ip );
    par_host_ip = NULL;

    CHECK_OBJECT( (PyObject *)var_ip );
    Py_DECREF( var_ip );
    var_ip = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ipname );
    Py_DECREF( par_ipname );
    par_ipname = NULL;

    CHECK_OBJECT( (PyObject *)par_host_ip );
    Py_DECREF( par_host_ip );
    par_host_ip = NULL;

    Py_XDECREF( var_ip );
    var_ip = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_9__ipaddress_match );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_10_match_hostname( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cert = python_pars[ 0 ];
    PyObject *par_hostname = python_pars[ 1 ];
    PyObject *var_host_ip = NULL;
    PyObject *var_dnsnames = NULL;
    PyObject *var_san = NULL;
    PyObject *var_key = NULL;
    PyObject *var_value = NULL;
    PyObject *var_sub = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *tmp_for_loop_3__for_iterator = NULL;
    PyObject *tmp_for_loop_3__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_2__element_1 = NULL;
    PyObject *tmp_tuple_unpack_2__element_2 = NULL;
    PyObject *tmp_tuple_unpack_2__source_iter = NULL;
    struct Nuitka_FrameObject *frame_b22e2653cdc93fd04980c249351d9dc3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    static struct Nuitka_FrameObject *cache_frame_b22e2653cdc93fd04980c249351d9dc3 = NULL;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b22e2653cdc93fd04980c249351d9dc3, codeobj_b22e2653cdc93fd04980c249351d9dc3, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b22e2653cdc93fd04980c249351d9dc3 = cache_frame_b22e2653cdc93fd04980c249351d9dc3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b22e2653cdc93fd04980c249351d9dc3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b22e2653cdc93fd04980c249351d9dc3 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( par_cert );
        tmp_operand_name_1 = par_cert;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 289;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_f66ea29fd347bd1e1c153f7fc85b4c4d;
            frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 290;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 290;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__inet_paton );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__inet_paton );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_inet_paton" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 294;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_hostname );
        tmp_args_element_name_1 = par_hostname;
        frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 294;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 294;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        assert( var_host_ip == NULL );
        var_host_ip = tmp_assign_source_1;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_b22e2653cdc93fd04980c249351d9dc3, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_b22e2653cdc93fd04980c249351d9dc3, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_ValueError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 295;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_2;
            tmp_assign_source_2 = Py_None;
            assert( var_host_ip == NULL );
            Py_INCREF( tmp_assign_source_2 );
            var_host_ip = tmp_assign_source_2;
        }
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 293;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_b22e2653cdc93fd04980c249351d9dc3->m_frame) frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooo";
        goto try_except_handler_3;
        branch_end_2:;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_10_match_hostname );
    return NULL;
    // End of try:
    try_end_1:;
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = PyList_New( 0 );
        assert( var_dnsnames == NULL );
        var_dnsnames = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_cert );
        tmp_called_instance_1 = par_cert;
        frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 299;
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_get, &PyTuple_GET_ITEM( const_tuple_str_plain_subjectAltName_tuple_empty_tuple, 0 ) );

        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 299;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_san == NULL );
        var_san = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( var_san );
        tmp_iter_arg_1 = var_san;
        tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 300;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_5;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_6 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_6 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooo";
                exception_lineno = 300;
                goto try_except_handler_4;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_iter_arg_2;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_iter_arg_2 = tmp_for_loop_1__iter_value;
        tmp_assign_source_7 = MAKE_UNPACK_ITERATOR( tmp_iter_arg_2 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 300;
            type_description_1 = "oooooooo";
            goto try_except_handler_5;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__source_iter;
            tmp_tuple_unpack_1__source_iter = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_8 = UNPACK_NEXT( tmp_unpack_1, 0, 2 );
        if ( tmp_assign_source_8 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooooo";
            exception_lineno = 300;
            goto try_except_handler_6;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_1;
            tmp_tuple_unpack_1__element_1 = tmp_assign_source_8;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_9 = UNPACK_NEXT( tmp_unpack_2, 1, 2 );
        if ( tmp_assign_source_9 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooooo";
            exception_lineno = 300;
            goto try_except_handler_6;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_2;
            tmp_tuple_unpack_1__element_2 = tmp_assign_source_9;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "oooooooo";
                    exception_lineno = 300;
                    goto try_except_handler_6;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "oooooooo";
            exception_lineno = 300;
            goto try_except_handler_6;
        }
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_5;
    // End of try:
    try_end_3:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto try_except_handler_4;
    // End of try:
    try_end_4:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_10;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_10 = tmp_tuple_unpack_1__element_1;
        {
            PyObject *old = var_key;
            var_key = tmp_assign_source_10;
            Py_INCREF( var_key );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_11;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_11 = tmp_tuple_unpack_1__element_2;
        {
            PyObject *old = var_value;
            var_value = tmp_assign_source_11;
            Py_INCREF( var_value );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( var_key );
        tmp_compexpr_left_2 = var_key;
        tmp_compexpr_right_2 = const_str_plain_DNS;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;
            type_description_1 = "oooooooo";
            goto try_except_handler_4;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            nuitka_bool tmp_condition_result_4;
            int tmp_and_left_truth_1;
            nuitka_bool tmp_and_left_value_1;
            nuitka_bool tmp_and_right_value_1;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            int tmp_truth_name_1;
            if ( var_host_ip == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "host_ip" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 302;
                type_description_1 = "oooooooo";
                goto try_except_handler_4;
            }

            tmp_compexpr_left_3 = var_host_ip;
            tmp_compexpr_right_3 = Py_None;
            tmp_and_left_value_1 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_1 == 1 )
            {
                goto and_right_1;
            }
            else
            {
                goto and_left_1;
            }
            and_right_1:;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__dnsname_match );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__dnsname_match );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_dnsname_match" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 302;
                type_description_1 = "oooooooo";
                goto try_except_handler_4;
            }

            tmp_called_name_2 = tmp_mvar_value_2;
            CHECK_OBJECT( var_value );
            tmp_args_element_name_2 = var_value;
            CHECK_OBJECT( par_hostname );
            tmp_args_element_name_3 = par_hostname;
            frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 302;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 302;
                type_description_1 = "oooooooo";
                goto try_except_handler_4;
            }
            tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
            if ( tmp_truth_name_1 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_call_result_1 );

                exception_lineno = 302;
                type_description_1 = "oooooooo";
                goto try_except_handler_4;
            }
            tmp_and_right_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_call_result_1 );
            tmp_condition_result_4 = tmp_and_right_value_1;
            goto and_end_1;
            and_left_1:;
            tmp_condition_result_4 = tmp_and_left_value_1;
            and_end_1:;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            tmp_return_value = Py_None;
            Py_INCREF( tmp_return_value );
            goto try_return_handler_4;
            branch_no_4:;
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_4;
            CHECK_OBJECT( var_dnsnames );
            tmp_called_instance_2 = var_dnsnames;
            CHECK_OBJECT( var_value );
            tmp_args_element_name_4 = var_value;
            frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 304;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_append, call_args );
            }

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 304;
                type_description_1 = "oooooooo";
                goto try_except_handler_4;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        goto branch_end_3;
        branch_no_3:;
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            CHECK_OBJECT( var_key );
            tmp_compexpr_left_4 = var_key;
            tmp_compexpr_right_4 = const_str_digest_76d751ede7bd087f9346e5a615d3c397;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 305;
                type_description_1 = "oooooooo";
                goto try_except_handler_4;
            }
            tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_5;
            }
            else
            {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                nuitka_bool tmp_condition_result_6;
                int tmp_and_left_truth_2;
                nuitka_bool tmp_and_left_value_2;
                nuitka_bool tmp_and_right_value_2;
                PyObject *tmp_compexpr_left_5;
                PyObject *tmp_compexpr_right_5;
                PyObject *tmp_called_name_3;
                PyObject *tmp_mvar_value_3;
                PyObject *tmp_call_result_3;
                PyObject *tmp_args_element_name_5;
                PyObject *tmp_args_element_name_6;
                int tmp_truth_name_2;
                if ( var_host_ip == NULL )
                {

                    exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "host_ip" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 306;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_4;
                }

                tmp_compexpr_left_5 = var_host_ip;
                tmp_compexpr_right_5 = Py_None;
                tmp_and_left_value_2 = ( tmp_compexpr_left_5 != tmp_compexpr_right_5 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
                if ( tmp_and_left_truth_2 == 1 )
                {
                    goto and_right_2;
                }
                else
                {
                    goto and_left_2;
                }
                and_right_2:;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ipaddress_match );

                if (unlikely( tmp_mvar_value_3 == NULL ))
                {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ipaddress_match );
                }

                if ( tmp_mvar_value_3 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ipaddress_match" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 306;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_4;
                }

                tmp_called_name_3 = tmp_mvar_value_3;
                CHECK_OBJECT( var_value );
                tmp_args_element_name_5 = var_value;
                if ( var_host_ip == NULL )
                {

                    exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "host_ip" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 306;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_4;
                }

                tmp_args_element_name_6 = var_host_ip;
                frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 306;
                {
                    PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
                    tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
                }

                if ( tmp_call_result_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 306;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_4;
                }
                tmp_truth_name_2 = CHECK_IF_TRUE( tmp_call_result_3 );
                if ( tmp_truth_name_2 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_call_result_3 );

                    exception_lineno = 306;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_4;
                }
                tmp_and_right_value_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                Py_DECREF( tmp_call_result_3 );
                tmp_condition_result_6 = tmp_and_right_value_2;
                goto and_end_2;
                and_left_2:;
                tmp_condition_result_6 = tmp_and_left_value_2;
                and_end_2:;
                if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_6;
                }
                else
                {
                    goto branch_no_6;
                }
                branch_yes_6:;
                tmp_return_value = Py_None;
                Py_INCREF( tmp_return_value );
                goto try_return_handler_4;
                branch_no_6:;
            }
            {
                PyObject *tmp_called_instance_3;
                PyObject *tmp_call_result_4;
                PyObject *tmp_args_element_name_7;
                CHECK_OBJECT( var_dnsnames );
                tmp_called_instance_3 = var_dnsnames;
                CHECK_OBJECT( var_value );
                tmp_args_element_name_7 = var_value;
                frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 308;
                {
                    PyObject *call_args[] = { tmp_args_element_name_7 };
                    tmp_call_result_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_append, call_args );
                }

                if ( tmp_call_result_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 308;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_4;
                }
                Py_DECREF( tmp_call_result_4 );
            }
            branch_no_5:;
        }
        branch_end_3:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 300;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_5;
    // Return handler code:
    try_return_handler_4:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__iter_value );
    Py_DECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_dnsnames );
        tmp_operand_name_2 = var_dnsnames;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 309;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_7 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        {
            PyObject *tmp_assign_source_12;
            PyObject *tmp_iter_arg_3;
            PyObject *tmp_called_instance_4;
            CHECK_OBJECT( par_cert );
            tmp_called_instance_4 = par_cert;
            frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 312;
            tmp_iter_arg_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_4, const_str_plain_get, &PyTuple_GET_ITEM( const_tuple_str_plain_subject_tuple_empty_tuple, 0 ) );

            if ( tmp_iter_arg_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 312;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_12 = MAKE_ITERATOR( tmp_iter_arg_3 );
            Py_DECREF( tmp_iter_arg_3 );
            if ( tmp_assign_source_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 312;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_2__for_iterator == NULL );
            tmp_for_loop_2__for_iterator = tmp_assign_source_12;
        }
        // Tried code:
        loop_start_2:;
        {
            PyObject *tmp_next_source_2;
            PyObject *tmp_assign_source_13;
            CHECK_OBJECT( tmp_for_loop_2__for_iterator );
            tmp_next_source_2 = tmp_for_loop_2__for_iterator;
            tmp_assign_source_13 = ITERATOR_NEXT( tmp_next_source_2 );
            if ( tmp_assign_source_13 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_2;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooooooo";
                    exception_lineno = 312;
                    goto try_except_handler_7;
                }
            }

            {
                PyObject *old = tmp_for_loop_2__iter_value;
                tmp_for_loop_2__iter_value = tmp_assign_source_13;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_14;
            CHECK_OBJECT( tmp_for_loop_2__iter_value );
            tmp_assign_source_14 = tmp_for_loop_2__iter_value;
            {
                PyObject *old = var_sub;
                var_sub = tmp_assign_source_14;
                Py_INCREF( var_sub );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_15;
            PyObject *tmp_iter_arg_4;
            CHECK_OBJECT( var_sub );
            tmp_iter_arg_4 = var_sub;
            tmp_assign_source_15 = MAKE_ITERATOR( tmp_iter_arg_4 );
            if ( tmp_assign_source_15 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 313;
                type_description_1 = "oooooooo";
                goto try_except_handler_7;
            }
            {
                PyObject *old = tmp_for_loop_3__for_iterator;
                tmp_for_loop_3__for_iterator = tmp_assign_source_15;
                Py_XDECREF( old );
            }

        }
        // Tried code:
        loop_start_3:;
        {
            PyObject *tmp_next_source_3;
            PyObject *tmp_assign_source_16;
            CHECK_OBJECT( tmp_for_loop_3__for_iterator );
            tmp_next_source_3 = tmp_for_loop_3__for_iterator;
            tmp_assign_source_16 = ITERATOR_NEXT( tmp_next_source_3 );
            if ( tmp_assign_source_16 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_3;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooooooo";
                    exception_lineno = 313;
                    goto try_except_handler_8;
                }
            }

            {
                PyObject *old = tmp_for_loop_3__iter_value;
                tmp_for_loop_3__iter_value = tmp_assign_source_16;
                Py_XDECREF( old );
            }

        }
        // Tried code:
        {
            PyObject *tmp_assign_source_17;
            PyObject *tmp_iter_arg_5;
            CHECK_OBJECT( tmp_for_loop_3__iter_value );
            tmp_iter_arg_5 = tmp_for_loop_3__iter_value;
            tmp_assign_source_17 = MAKE_UNPACK_ITERATOR( tmp_iter_arg_5 );
            if ( tmp_assign_source_17 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 313;
                type_description_1 = "oooooooo";
                goto try_except_handler_9;
            }
            {
                PyObject *old = tmp_tuple_unpack_2__source_iter;
                tmp_tuple_unpack_2__source_iter = tmp_assign_source_17;
                Py_XDECREF( old );
            }

        }
        // Tried code:
        {
            PyObject *tmp_assign_source_18;
            PyObject *tmp_unpack_3;
            CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
            tmp_unpack_3 = tmp_tuple_unpack_2__source_iter;
            tmp_assign_source_18 = UNPACK_NEXT( tmp_unpack_3, 0, 2 );
            if ( tmp_assign_source_18 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "oooooooo";
                exception_lineno = 313;
                goto try_except_handler_10;
            }
            {
                PyObject *old = tmp_tuple_unpack_2__element_1;
                tmp_tuple_unpack_2__element_1 = tmp_assign_source_18;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_19;
            PyObject *tmp_unpack_4;
            CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
            tmp_unpack_4 = tmp_tuple_unpack_2__source_iter;
            tmp_assign_source_19 = UNPACK_NEXT( tmp_unpack_4, 1, 2 );
            if ( tmp_assign_source_19 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "oooooooo";
                exception_lineno = 313;
                goto try_except_handler_10;
            }
            {
                PyObject *old = tmp_tuple_unpack_2__element_2;
                tmp_tuple_unpack_2__element_2 = tmp_assign_source_19;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_iterator_name_2;
            CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
            tmp_iterator_name_2 = tmp_tuple_unpack_2__source_iter;
            // Check if iterator has left-over elements.
            CHECK_OBJECT( tmp_iterator_name_2 ); assert( HAS_ITERNEXT( tmp_iterator_name_2 ) );

            tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_2 )->tp_iternext)( tmp_iterator_name_2 );

            if (likely( tmp_iterator_attempt == NULL ))
            {
                PyObject *error = GET_ERROR_OCCURRED();

                if ( error != NULL )
                {
                    if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                    {
                        CLEAR_ERROR_OCCURRED();
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                        type_description_1 = "oooooooo";
                        exception_lineno = 313;
                        goto try_except_handler_10;
                    }
                }
            }
            else
            {
                Py_DECREF( tmp_iterator_attempt );

                // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "oooooooo";
                exception_lineno = 313;
                goto try_except_handler_10;
            }
        }
        goto try_end_6;
        // Exception handler code:
        try_except_handler_10:;
        exception_keeper_type_6 = exception_type;
        exception_keeper_value_6 = exception_value;
        exception_keeper_tb_6 = exception_tb;
        exception_keeper_lineno_6 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
        Py_DECREF( tmp_tuple_unpack_2__source_iter );
        tmp_tuple_unpack_2__source_iter = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_6;
        exception_value = exception_keeper_value_6;
        exception_tb = exception_keeper_tb_6;
        exception_lineno = exception_keeper_lineno_6;

        goto try_except_handler_9;
        // End of try:
        try_end_6:;
        goto try_end_7;
        // Exception handler code:
        try_except_handler_9:;
        exception_keeper_type_7 = exception_type;
        exception_keeper_value_7 = exception_value;
        exception_keeper_tb_7 = exception_tb;
        exception_keeper_lineno_7 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_tuple_unpack_2__element_1 );
        tmp_tuple_unpack_2__element_1 = NULL;

        Py_XDECREF( tmp_tuple_unpack_2__element_2 );
        tmp_tuple_unpack_2__element_2 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_7;
        exception_value = exception_keeper_value_7;
        exception_tb = exception_keeper_tb_7;
        exception_lineno = exception_keeper_lineno_7;

        goto try_except_handler_8;
        // End of try:
        try_end_7:;
        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
        Py_DECREF( tmp_tuple_unpack_2__source_iter );
        tmp_tuple_unpack_2__source_iter = NULL;

        {
            PyObject *tmp_assign_source_20;
            CHECK_OBJECT( tmp_tuple_unpack_2__element_1 );
            tmp_assign_source_20 = tmp_tuple_unpack_2__element_1;
            {
                PyObject *old = var_key;
                var_key = tmp_assign_source_20;
                Py_INCREF( var_key );
                Py_XDECREF( old );
            }

        }
        Py_XDECREF( tmp_tuple_unpack_2__element_1 );
        tmp_tuple_unpack_2__element_1 = NULL;

        {
            PyObject *tmp_assign_source_21;
            CHECK_OBJECT( tmp_tuple_unpack_2__element_2 );
            tmp_assign_source_21 = tmp_tuple_unpack_2__element_2;
            {
                PyObject *old = var_value;
                var_value = tmp_assign_source_21;
                Py_INCREF( var_value );
                Py_XDECREF( old );
            }

        }
        Py_XDECREF( tmp_tuple_unpack_2__element_2 );
        tmp_tuple_unpack_2__element_2 = NULL;

        {
            nuitka_bool tmp_condition_result_8;
            PyObject *tmp_compexpr_left_6;
            PyObject *tmp_compexpr_right_6;
            CHECK_OBJECT( var_key );
            tmp_compexpr_left_6 = var_key;
            tmp_compexpr_right_6 = const_str_plain_commonName;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 316;
                type_description_1 = "oooooooo";
                goto try_except_handler_8;
            }
            tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_8;
            }
            else
            {
                goto branch_no_8;
            }
            branch_yes_8:;
            {
                nuitka_bool tmp_condition_result_9;
                PyObject *tmp_called_name_4;
                PyObject *tmp_mvar_value_4;
                PyObject *tmp_call_result_5;
                PyObject *tmp_args_element_name_8;
                PyObject *tmp_args_element_name_9;
                int tmp_truth_name_3;
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__dnsname_match );

                if (unlikely( tmp_mvar_value_4 == NULL ))
                {
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__dnsname_match );
                }

                if ( tmp_mvar_value_4 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_dnsname_match" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 317;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_8;
                }

                tmp_called_name_4 = tmp_mvar_value_4;
                CHECK_OBJECT( var_value );
                tmp_args_element_name_8 = var_value;
                CHECK_OBJECT( par_hostname );
                tmp_args_element_name_9 = par_hostname;
                frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 317;
                {
                    PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
                    tmp_call_result_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
                }

                if ( tmp_call_result_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 317;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_8;
                }
                tmp_truth_name_3 = CHECK_IF_TRUE( tmp_call_result_5 );
                if ( tmp_truth_name_3 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_call_result_5 );

                    exception_lineno = 317;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_8;
                }
                tmp_condition_result_9 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                Py_DECREF( tmp_call_result_5 );
                if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_9;
                }
                else
                {
                    goto branch_no_9;
                }
                branch_yes_9:;
                tmp_return_value = Py_None;
                Py_INCREF( tmp_return_value );
                goto try_return_handler_8;
                branch_no_9:;
            }
            {
                PyObject *tmp_called_instance_5;
                PyObject *tmp_call_result_6;
                PyObject *tmp_args_element_name_10;
                CHECK_OBJECT( var_dnsnames );
                tmp_called_instance_5 = var_dnsnames;
                CHECK_OBJECT( var_value );
                tmp_args_element_name_10 = var_value;
                frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 319;
                {
                    PyObject *call_args[] = { tmp_args_element_name_10 };
                    tmp_call_result_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_append, call_args );
                }

                if ( tmp_call_result_6 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 319;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_8;
                }
                Py_DECREF( tmp_call_result_6 );
            }
            branch_no_8:;
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 313;
            type_description_1 = "oooooooo";
            goto try_except_handler_8;
        }
        goto loop_start_3;
        loop_end_3:;
        goto try_end_8;
        // Return handler code:
        try_return_handler_8:;
        CHECK_OBJECT( (PyObject *)tmp_for_loop_3__iter_value );
        Py_DECREF( tmp_for_loop_3__iter_value );
        tmp_for_loop_3__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_3__for_iterator );
        Py_DECREF( tmp_for_loop_3__for_iterator );
        tmp_for_loop_3__for_iterator = NULL;

        goto try_return_handler_7;
        // Exception handler code:
        try_except_handler_8:;
        exception_keeper_type_8 = exception_type;
        exception_keeper_value_8 = exception_value;
        exception_keeper_tb_8 = exception_tb;
        exception_keeper_lineno_8 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_3__iter_value );
        tmp_for_loop_3__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_3__for_iterator );
        Py_DECREF( tmp_for_loop_3__for_iterator );
        tmp_for_loop_3__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_8;
        exception_value = exception_keeper_value_8;
        exception_tb = exception_keeper_tb_8;
        exception_lineno = exception_keeper_lineno_8;

        goto try_except_handler_7;
        // End of try:
        try_end_8:;
        Py_XDECREF( tmp_for_loop_3__iter_value );
        tmp_for_loop_3__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_3__for_iterator );
        Py_DECREF( tmp_for_loop_3__for_iterator );
        tmp_for_loop_3__for_iterator = NULL;

        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 312;
            type_description_1 = "oooooooo";
            goto try_except_handler_7;
        }
        goto loop_start_2;
        loop_end_2:;
        goto try_end_9;
        // Return handler code:
        try_return_handler_7:;
        CHECK_OBJECT( (PyObject *)tmp_for_loop_2__iter_value );
        Py_DECREF( tmp_for_loop_2__iter_value );
        tmp_for_loop_2__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
        Py_DECREF( tmp_for_loop_2__for_iterator );
        tmp_for_loop_2__for_iterator = NULL;

        goto frame_return_exit_1;
        // Exception handler code:
        try_except_handler_7:;
        exception_keeper_type_9 = exception_type;
        exception_keeper_value_9 = exception_value;
        exception_keeper_tb_9 = exception_tb;
        exception_keeper_lineno_9 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_2__iter_value );
        tmp_for_loop_2__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
        Py_DECREF( tmp_for_loop_2__for_iterator );
        tmp_for_loop_2__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_9;
        exception_value = exception_keeper_value_9;
        exception_tb = exception_keeper_tb_9;
        exception_lineno = exception_keeper_lineno_9;

        goto frame_exception_exit_1;
        // End of try:
        try_end_9:;
        Py_XDECREF( tmp_for_loop_2__iter_value );
        tmp_for_loop_2__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
        Py_DECREF( tmp_for_loop_2__for_iterator );
        tmp_for_loop_2__for_iterator = NULL;

        branch_no_7:;
    }
    {
        nuitka_bool tmp_condition_result_10;
        PyObject *tmp_compexpr_left_7;
        PyObject *tmp_compexpr_right_7;
        PyObject *tmp_len_arg_1;
        CHECK_OBJECT( var_dnsnames );
        tmp_len_arg_1 = var_dnsnames;
        tmp_compexpr_left_7 = BUILTIN_LEN( tmp_len_arg_1 );
        assert( !(tmp_compexpr_left_7 == NULL) );
        tmp_compexpr_right_7 = const_int_pos_1;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_7, tmp_compexpr_right_7 );
        Py_DECREF( tmp_compexpr_left_7 );
        assert( !(tmp_res == -1) );
        tmp_condition_result_10 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_10;
        }
        else
        {
            goto branch_no_10;
        }
        branch_yes_10:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_called_name_5;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_6;
            PyObject *tmp_source_name_1;
            PyObject *tmp_args_element_name_12;
            PyObject *tmp_called_name_7;
            PyObject *tmp_args_element_name_13;
            PyObject *tmp_args_element_name_14;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CertificateError );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CertificateError );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CertificateError" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 321;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_5 = tmp_mvar_value_5;
            tmp_left_name_1 = const_str_digest_3b35d51050a71678e6a91f8af50bcd6c;
            CHECK_OBJECT( par_hostname );
            tmp_tuple_element_1 = par_hostname;
            tmp_right_name_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            tmp_source_name_1 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
            tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_join );
            assert( !(tmp_called_name_6 == NULL) );
            tmp_called_name_7 = (PyObject *)&PyMap_Type;
            tmp_args_element_name_13 = LOOKUP_BUILTIN( const_str_plain_repr );
            assert( tmp_args_element_name_13 != NULL );
            CHECK_OBJECT( var_dnsnames );
            tmp_args_element_name_14 = var_dnsnames;
            frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 323;
            {
                PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
                tmp_args_element_name_12 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
            }

            if ( tmp_args_element_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_right_name_1 );
                Py_DECREF( tmp_called_name_6 );

                exception_lineno = 323;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 323;
            {
                PyObject *call_args[] = { tmp_args_element_name_12 };
                tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
            }

            Py_DECREF( tmp_called_name_6 );
            Py_DECREF( tmp_args_element_name_12 );
            if ( tmp_tuple_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_right_name_1 );

                exception_lineno = 323;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            tmp_args_element_name_11 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_args_element_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 321;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 321;
            {
                PyObject *call_args[] = { tmp_args_element_name_11 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
            }

            Py_DECREF( tmp_args_element_name_11 );
            if ( tmp_raise_type_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 321;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_2;
            exception_lineno = 321;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        goto branch_end_10;
        branch_no_10:;
        {
            nuitka_bool tmp_condition_result_11;
            PyObject *tmp_compexpr_left_8;
            PyObject *tmp_compexpr_right_8;
            PyObject *tmp_len_arg_2;
            CHECK_OBJECT( var_dnsnames );
            tmp_len_arg_2 = var_dnsnames;
            tmp_compexpr_left_8 = BUILTIN_LEN( tmp_len_arg_2 );
            assert( !(tmp_compexpr_left_8 == NULL) );
            tmp_compexpr_right_8 = const_int_pos_1;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_8, tmp_compexpr_right_8 );
            Py_DECREF( tmp_compexpr_left_8 );
            assert( !(tmp_res == -1) );
            tmp_condition_result_11 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_11;
            }
            else
            {
                goto branch_no_11;
            }
            branch_yes_11:;
            {
                PyObject *tmp_raise_type_3;
                PyObject *tmp_called_name_8;
                PyObject *tmp_mvar_value_6;
                PyObject *tmp_args_element_name_15;
                PyObject *tmp_left_name_2;
                PyObject *tmp_right_name_2;
                PyObject *tmp_tuple_element_2;
                PyObject *tmp_subscribed_name_1;
                PyObject *tmp_subscript_name_1;
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CertificateError );

                if (unlikely( tmp_mvar_value_6 == NULL ))
                {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CertificateError );
                }

                if ( tmp_mvar_value_6 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CertificateError" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 325;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_8 = tmp_mvar_value_6;
                tmp_left_name_2 = const_str_digest_2827a02148585180db385ecab4334673;
                CHECK_OBJECT( par_hostname );
                tmp_tuple_element_2 = par_hostname;
                tmp_right_name_2 = PyTuple_New( 2 );
                Py_INCREF( tmp_tuple_element_2 );
                PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_2 );
                CHECK_OBJECT( var_dnsnames );
                tmp_subscribed_name_1 = var_dnsnames;
                tmp_subscript_name_1 = const_int_0;
                tmp_tuple_element_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
                if ( tmp_tuple_element_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_2 );

                    exception_lineno = 327;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_2 );
                tmp_args_element_name_15 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
                Py_DECREF( tmp_right_name_2 );
                if ( tmp_args_element_name_15 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 325;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 325;
                {
                    PyObject *call_args[] = { tmp_args_element_name_15 };
                    tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
                }

                Py_DECREF( tmp_args_element_name_15 );
                if ( tmp_raise_type_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 325;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_3;
                exception_lineno = 325;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            goto branch_end_11;
            branch_no_11:;
            {
                PyObject *tmp_raise_type_4;
                PyObject *tmp_called_name_9;
                PyObject *tmp_mvar_value_7;
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CertificateError );

                if (unlikely( tmp_mvar_value_7 == NULL ))
                {
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CertificateError );
                }

                if ( tmp_mvar_value_7 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CertificateError" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 329;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_9 = tmp_mvar_value_7;
                frame_b22e2653cdc93fd04980c249351d9dc3->m_frame.f_lineno = 329;
                tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, &PyTuple_GET_ITEM( const_tuple_str_digest_b8a3e24bd480f9d749e7f38794d9a804_tuple, 0 ) );

                if ( tmp_raise_type_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 329;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_4;
                exception_lineno = 329;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            branch_end_11:;
        }
        branch_end_10:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b22e2653cdc93fd04980c249351d9dc3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b22e2653cdc93fd04980c249351d9dc3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b22e2653cdc93fd04980c249351d9dc3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b22e2653cdc93fd04980c249351d9dc3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b22e2653cdc93fd04980c249351d9dc3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b22e2653cdc93fd04980c249351d9dc3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b22e2653cdc93fd04980c249351d9dc3,
        type_description_1,
        par_cert,
        par_hostname,
        var_host_ip,
        var_dnsnames,
        var_san,
        var_key,
        var_value,
        var_sub
    );


    // Release cached frame.
    if ( frame_b22e2653cdc93fd04980c249351d9dc3 == cache_frame_b22e2653cdc93fd04980c249351d9dc3 )
    {
        Py_DECREF( frame_b22e2653cdc93fd04980c249351d9dc3 );
    }
    cache_frame_b22e2653cdc93fd04980c249351d9dc3 = NULL;

    assertFrameObject( frame_b22e2653cdc93fd04980c249351d9dc3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_10_match_hostname );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_hostname );
    Py_DECREF( par_hostname );
    par_hostname = NULL;

    Py_XDECREF( var_host_ip );
    var_host_ip = NULL;

    CHECK_OBJECT( (PyObject *)var_dnsnames );
    Py_DECREF( var_dnsnames );
    var_dnsnames = NULL;

    CHECK_OBJECT( (PyObject *)var_san );
    Py_DECREF( var_san );
    var_san = NULL;

    CHECK_OBJECT( (PyObject *)var_key );
    Py_DECREF( var_key );
    var_key = NULL;

    CHECK_OBJECT( (PyObject *)var_value );
    Py_DECREF( var_value );
    var_value = NULL;

    Py_XDECREF( var_sub );
    var_sub = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_10 = exception_type;
    exception_keeper_value_10 = exception_value;
    exception_keeper_tb_10 = exception_tb;
    exception_keeper_lineno_10 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_hostname );
    Py_DECREF( par_hostname );
    par_hostname = NULL;

    Py_XDECREF( var_host_ip );
    var_host_ip = NULL;

    Py_XDECREF( var_dnsnames );
    var_dnsnames = NULL;

    Py_XDECREF( var_san );
    var_san = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( var_sub );
    var_sub = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_10;
    exception_value = exception_keeper_value_10;
    exception_tb = exception_keeper_tb_10;
    exception_lineno = exception_keeper_lineno_10;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_10_match_hostname );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_11_get_default_verify_paths( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_parts = NULL;
    PyObject *var_cafile = NULL;
    PyObject *var_capath = NULL;
    struct Nuitka_FrameObject *frame_f4b142c4d615bce9c4fa208111063de1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f4b142c4d615bce9c4fa208111063de1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f4b142c4d615bce9c4fa208111063de1, codeobj_f4b142c4d615bce9c4fa208111063de1, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f4b142c4d615bce9c4fa208111063de1 = cache_frame_f4b142c4d615bce9c4fa208111063de1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f4b142c4d615bce9c4fa208111063de1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f4b142c4d615bce9c4fa208111063de1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 340;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_f4b142c4d615bce9c4fa208111063de1->m_frame.f_lineno = 340;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_get_default_verify_paths );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 340;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_parts == NULL );
        var_parts = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_os );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "os" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_environ );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_get );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_parts );
        tmp_subscribed_name_1 = var_parts;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_parts );
        tmp_subscribed_name_2 = var_parts;
        tmp_subscript_name_2 = const_int_pos_1;
        tmp_args_element_name_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 1 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_f4b142c4d615bce9c4fa208111063de1->m_frame.f_lineno = 343;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_cafile == NULL );
        var_cafile = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_subscript_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_os );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "os" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 344;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_environ );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 344;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_get );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 344;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_parts );
        tmp_subscribed_name_3 = var_parts;
        tmp_subscript_name_3 = const_int_pos_2;
        tmp_args_element_name_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 2 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 344;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_parts );
        tmp_subscribed_name_4 = var_parts;
        tmp_subscript_name_4 = const_int_pos_3;
        tmp_args_element_name_4 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 3 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 344;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_f4b142c4d615bce9c4fa208111063de1->m_frame.f_lineno = 344;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 344;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_capath == NULL );
        var_capath = tmp_assign_source_3;
    }
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        int tmp_truth_name_1;
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_6;
        int tmp_truth_name_2;
        PyObject *tmp_dircall_arg3_1;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_DefaultVerifyPaths );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DefaultVerifyPaths );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "DefaultVerifyPaths" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_dircall_arg1_1 = tmp_mvar_value_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_os );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "os" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_path );
        if ( tmp_called_instance_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_cafile );
        tmp_args_element_name_5 = var_cafile;
        frame_f4b142c4d615bce9c4fa208111063de1->m_frame.f_lineno = 346;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_isfile, call_args );
        }

        Py_DECREF( tmp_called_instance_2 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_call_result_1 );

            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_1;
        }
        else
        {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT( var_cafile );
        tmp_tuple_element_1 = var_cafile;
        goto condexpr_end_1;
        condexpr_false_1:;
        tmp_tuple_element_1 = Py_None;
        condexpr_end_1:;
        tmp_dircall_arg2_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_os );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_dircall_arg2_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "os" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_path );
        if ( tmp_called_instance_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg2_1 );

            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_capath );
        tmp_args_element_name_6 = var_capath;
        frame_f4b142c4d615bce9c4fa208111063de1->m_frame.f_lineno = 347;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_isdir, call_args );
        }

        Py_DECREF( tmp_called_instance_3 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg2_1 );

            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_2 = CHECK_IF_TRUE( tmp_call_result_2 );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg2_1 );
            Py_DECREF( tmp_call_result_2 );

            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_2 );
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_2;
        }
        else
        {
            goto condexpr_false_2;
        }
        condexpr_true_2:;
        CHECK_OBJECT( var_capath );
        tmp_tuple_element_1 = var_capath;
        goto condexpr_end_2;
        condexpr_false_2:;
        tmp_tuple_element_1 = Py_None;
        condexpr_end_2:;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( var_parts );
        tmp_dircall_arg3_1 = var_parts;
        Py_INCREF( tmp_dircall_arg1_1 );
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_list( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f4b142c4d615bce9c4fa208111063de1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f4b142c4d615bce9c4fa208111063de1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f4b142c4d615bce9c4fa208111063de1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f4b142c4d615bce9c4fa208111063de1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f4b142c4d615bce9c4fa208111063de1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f4b142c4d615bce9c4fa208111063de1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f4b142c4d615bce9c4fa208111063de1,
        type_description_1,
        var_parts,
        var_cafile,
        var_capath
    );


    // Release cached frame.
    if ( frame_f4b142c4d615bce9c4fa208111063de1 == cache_frame_f4b142c4d615bce9c4fa208111063de1 )
    {
        Py_DECREF( frame_f4b142c4d615bce9c4fa208111063de1 );
    }
    cache_frame_f4b142c4d615bce9c4fa208111063de1 = NULL;

    assertFrameObject( frame_f4b142c4d615bce9c4fa208111063de1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_11_get_default_verify_paths );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_parts );
    Py_DECREF( var_parts );
    var_parts = NULL;

    CHECK_OBJECT( (PyObject *)var_cafile );
    Py_DECREF( var_cafile );
    var_cafile = NULL;

    CHECK_OBJECT( (PyObject *)var_capath );
    Py_DECREF( var_capath );
    var_capath = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_parts );
    var_parts = NULL;

    Py_XDECREF( var_cafile );
    var_cafile = NULL;

    Py_XDECREF( var_capath );
    var_capath = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_11_get_default_verify_paths );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_12___new__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_oid = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_387d510b0de4869ce257c4fd150c3e1d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_387d510b0de4869ce257c4fd150c3e1d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_387d510b0de4869ce257c4fd150c3e1d, codeobj_387d510b0de4869ce257c4fd150c3e1d, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_387d510b0de4869ce257c4fd150c3e1d = cache_frame_387d510b0de4869ce257c4fd150c3e1d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_387d510b0de4869ce257c4fd150c3e1d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_387d510b0de4869ce257c4fd150c3e1d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_kw_name_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 357;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_cls );
        tmp_object_name_1 = par_cls;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 357;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 357;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cls );
        tmp_tuple_element_1 = par_cls;
        tmp_dircall_arg2_1 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__txt2obj );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__txt2obj );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_dircall_arg1_1 );
            Py_DECREF( tmp_dircall_arg2_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_txt2obj" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 357;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_oid );
        tmp_tuple_element_2 = par_oid;
        tmp_args_name_1 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_2 );
        tmp_kw_name_1 = PyDict_Copy( const_dict_a4af7150f3c5b467e93a8aa2f6959c6a );
        frame_387d510b0de4869ce257c4fd150c3e1d->m_frame.f_lineno = 357;
        tmp_dircall_arg3_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_dircall_arg3_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg1_1 );
            Py_DECREF( tmp_dircall_arg2_1 );

            exception_lineno = 357;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_list( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 357;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_387d510b0de4869ce257c4fd150c3e1d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_387d510b0de4869ce257c4fd150c3e1d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_387d510b0de4869ce257c4fd150c3e1d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_387d510b0de4869ce257c4fd150c3e1d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_387d510b0de4869ce257c4fd150c3e1d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_387d510b0de4869ce257c4fd150c3e1d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_387d510b0de4869ce257c4fd150c3e1d,
        type_description_1,
        par_cls,
        par_oid,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_387d510b0de4869ce257c4fd150c3e1d == cache_frame_387d510b0de4869ce257c4fd150c3e1d )
    {
        Py_DECREF( frame_387d510b0de4869ce257c4fd150c3e1d );
    }
    cache_frame_387d510b0de4869ce257c4fd150c3e1d = NULL;

    assertFrameObject( frame_387d510b0de4869ce257c4fd150c3e1d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_12___new__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_oid );
    Py_DECREF( par_oid );
    par_oid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_oid );
    Py_DECREF( par_oid );
    par_oid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_12___new__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_13_fromnid( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_nid = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_6a9f24714f01965dd94fca0f0e8d2494;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6a9f24714f01965dd94fca0f0e8d2494 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6a9f24714f01965dd94fca0f0e8d2494, codeobj_6a9f24714f01965dd94fca0f0e8d2494, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6a9f24714f01965dd94fca0f0e8d2494 = cache_frame_6a9f24714f01965dd94fca0f0e8d2494;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6a9f24714f01965dd94fca0f0e8d2494 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6a9f24714f01965dd94fca0f0e8d2494 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 363;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_cls );
        tmp_object_name_1 = par_cls;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 363;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 363;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cls );
        tmp_tuple_element_1 = par_cls;
        tmp_dircall_arg2_1 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__nid2obj );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__nid2obj );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_dircall_arg1_1 );
            Py_DECREF( tmp_dircall_arg2_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_nid2obj" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 363;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_nid );
        tmp_args_element_name_1 = par_nid;
        frame_6a9f24714f01965dd94fca0f0e8d2494->m_frame.f_lineno = 363;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_dircall_arg3_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_dircall_arg3_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg1_1 );
            Py_DECREF( tmp_dircall_arg2_1 );

            exception_lineno = 363;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_list( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 363;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a9f24714f01965dd94fca0f0e8d2494 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a9f24714f01965dd94fca0f0e8d2494 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a9f24714f01965dd94fca0f0e8d2494 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6a9f24714f01965dd94fca0f0e8d2494, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6a9f24714f01965dd94fca0f0e8d2494->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6a9f24714f01965dd94fca0f0e8d2494, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6a9f24714f01965dd94fca0f0e8d2494,
        type_description_1,
        par_cls,
        par_nid,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_6a9f24714f01965dd94fca0f0e8d2494 == cache_frame_6a9f24714f01965dd94fca0f0e8d2494 )
    {
        Py_DECREF( frame_6a9f24714f01965dd94fca0f0e8d2494 );
    }
    cache_frame_6a9f24714f01965dd94fca0f0e8d2494 = NULL;

    assertFrameObject( frame_6a9f24714f01965dd94fca0f0e8d2494 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_13_fromnid );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_nid );
    Py_DECREF( par_nid );
    par_nid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_nid );
    Py_DECREF( par_nid );
    par_nid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_13_fromnid );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_14_fromname( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_d56e86ad148a7f35b220cc951f739bf5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d56e86ad148a7f35b220cc951f739bf5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d56e86ad148a7f35b220cc951f739bf5, codeobj_d56e86ad148a7f35b220cc951f739bf5, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d56e86ad148a7f35b220cc951f739bf5 = cache_frame_d56e86ad148a7f35b220cc951f739bf5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d56e86ad148a7f35b220cc951f739bf5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d56e86ad148a7f35b220cc951f739bf5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_kw_name_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 369;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_cls );
        tmp_object_name_1 = par_cls;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 369;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 369;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cls );
        tmp_tuple_element_1 = par_cls;
        tmp_dircall_arg2_1 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__txt2obj );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__txt2obj );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_dircall_arg1_1 );
            Py_DECREF( tmp_dircall_arg2_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_txt2obj" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 369;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_name );
        tmp_tuple_element_2 = par_name;
        tmp_args_name_1 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_2 );
        tmp_kw_name_1 = PyDict_Copy( const_dict_cd6cfa3585e1c44ad0bb320b3a2f22a4 );
        frame_d56e86ad148a7f35b220cc951f739bf5->m_frame.f_lineno = 369;
        tmp_dircall_arg3_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_dircall_arg3_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg1_1 );
            Py_DECREF( tmp_dircall_arg2_1 );

            exception_lineno = 369;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_list( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 369;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d56e86ad148a7f35b220cc951f739bf5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d56e86ad148a7f35b220cc951f739bf5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d56e86ad148a7f35b220cc951f739bf5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d56e86ad148a7f35b220cc951f739bf5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d56e86ad148a7f35b220cc951f739bf5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d56e86ad148a7f35b220cc951f739bf5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d56e86ad148a7f35b220cc951f739bf5,
        type_description_1,
        par_cls,
        par_name,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_d56e86ad148a7f35b220cc951f739bf5 == cache_frame_d56e86ad148a7f35b220cc951f739bf5 )
    {
        Py_DECREF( frame_d56e86ad148a7f35b220cc951f739bf5 );
    }
    cache_frame_d56e86ad148a7f35b220cc951f739bf5 = NULL;

    assertFrameObject( frame_d56e86ad148a7f35b220cc951f739bf5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_14_fromname );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_14_fromname );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_15___new__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_protocol = python_pars[ 1 ];
    PyObject *par_args = python_pars[ 2 ];
    PyObject *par_kwargs = python_pars[ 3 ];
    PyObject *var_self = NULL;
    struct Nuitka_FrameObject *frame_c25b78dcc70e44b70350d3078f666eb1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c25b78dcc70e44b70350d3078f666eb1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c25b78dcc70e44b70350d3078f666eb1, codeobj_c25b78dcc70e44b70350d3078f666eb1, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c25b78dcc70e44b70350d3078f666eb1 = cache_frame_c25b78dcc70e44b70350d3078f666eb1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c25b78dcc70e44b70350d3078f666eb1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c25b78dcc70e44b70350d3078f666eb1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__SSLContext );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__SSLContext );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 388;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_cls );
        tmp_args_element_name_1 = par_cls;
        CHECK_OBJECT( par_protocol );
        tmp_args_element_name_2 = par_protocol;
        frame_c25b78dcc70e44b70350d3078f666eb1->m_frame.f_lineno = 388;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___new__, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 388;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_self == NULL );
        var_self = tmp_assign_source_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c25b78dcc70e44b70350d3078f666eb1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c25b78dcc70e44b70350d3078f666eb1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c25b78dcc70e44b70350d3078f666eb1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c25b78dcc70e44b70350d3078f666eb1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c25b78dcc70e44b70350d3078f666eb1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c25b78dcc70e44b70350d3078f666eb1,
        type_description_1,
        par_cls,
        par_protocol,
        par_args,
        par_kwargs,
        var_self
    );


    // Release cached frame.
    if ( frame_c25b78dcc70e44b70350d3078f666eb1 == cache_frame_c25b78dcc70e44b70350d3078f666eb1 )
    {
        Py_DECREF( frame_c25b78dcc70e44b70350d3078f666eb1 );
    }
    cache_frame_c25b78dcc70e44b70350d3078f666eb1 = NULL;

    assertFrameObject( frame_c25b78dcc70e44b70350d3078f666eb1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_self );
    tmp_return_value = var_self;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_15___new__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_protocol );
    Py_DECREF( par_protocol );
    par_protocol = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)var_self );
    Py_DECREF( var_self );
    var_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_protocol );
    Py_DECREF( par_protocol );
    par_protocol = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_15___new__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_16__encode_hostname( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_hostname = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_5ff02ef703e17041cf7c28f0f9774842;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5ff02ef703e17041cf7c28f0f9774842 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5ff02ef703e17041cf7c28f0f9774842, codeobj_5ff02ef703e17041cf7c28f0f9774842, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_5ff02ef703e17041cf7c28f0f9774842 = cache_frame_5ff02ef703e17041cf7c28f0f9774842;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5ff02ef703e17041cf7c28f0f9774842 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5ff02ef703e17041cf7c28f0f9774842 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_hostname );
        tmp_compexpr_left_1 = par_hostname;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            CHECK_OBJECT( par_hostname );
            tmp_isinstance_inst_1 = par_hostname;
            tmp_isinstance_cls_1 = (PyObject *)&PyUnicode_Type;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 394;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_1;
                PyObject *tmp_called_instance_2;
                CHECK_OBJECT( par_hostname );
                tmp_called_instance_2 = par_hostname;
                frame_5ff02ef703e17041cf7c28f0f9774842->m_frame.f_lineno = 395;
                tmp_called_instance_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_idna_tuple, 0 ) );

                if ( tmp_called_instance_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 395;
                    type_description_1 = "oo";
                    goto frame_exception_exit_1;
                }
                frame_5ff02ef703e17041cf7c28f0f9774842->m_frame.f_lineno = 395;
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

                Py_DECREF( tmp_called_instance_1 );
                if ( tmp_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 395;
                    type_description_1 = "oo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_called_instance_3;
                CHECK_OBJECT( par_hostname );
                tmp_called_instance_3 = par_hostname;
                frame_5ff02ef703e17041cf7c28f0f9774842->m_frame.f_lineno = 397;
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

                if ( tmp_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 397;
                    type_description_1 = "oo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ff02ef703e17041cf7c28f0f9774842 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ff02ef703e17041cf7c28f0f9774842 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ff02ef703e17041cf7c28f0f9774842 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5ff02ef703e17041cf7c28f0f9774842, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5ff02ef703e17041cf7c28f0f9774842->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5ff02ef703e17041cf7c28f0f9774842, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5ff02ef703e17041cf7c28f0f9774842,
        type_description_1,
        par_self,
        par_hostname
    );


    // Release cached frame.
    if ( frame_5ff02ef703e17041cf7c28f0f9774842 == cache_frame_5ff02ef703e17041cf7c28f0f9774842 )
    {
        Py_DECREF( frame_5ff02ef703e17041cf7c28f0f9774842 );
    }
    cache_frame_5ff02ef703e17041cf7c28f0f9774842 = NULL;

    assertFrameObject( frame_5ff02ef703e17041cf7c28f0f9774842 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_16__encode_hostname );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_hostname );
    Py_DECREF( par_hostname );
    par_hostname = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_hostname );
    Py_DECREF( par_hostname );
    par_hostname = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_16__encode_hostname );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_17_wrap_socket( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_sock = python_pars[ 1 ];
    PyObject *par_server_side = python_pars[ 2 ];
    PyObject *par_do_handshake_on_connect = python_pars[ 3 ];
    PyObject *par_suppress_ragged_eofs = python_pars[ 4 ];
    PyObject *par_server_hostname = python_pars[ 5 ];
    PyObject *par_session = python_pars[ 6 ];
    struct Nuitka_FrameObject *frame_5e4ce0716b248a14e09f49928b12effa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_5e4ce0716b248a14e09f49928b12effa = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5e4ce0716b248a14e09f49928b12effa, codeobj_5e4ce0716b248a14e09f49928b12effa, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5e4ce0716b248a14e09f49928b12effa = cache_frame_5e4ce0716b248a14e09f49928b12effa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5e4ce0716b248a14e09f49928b12effa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5e4ce0716b248a14e09f49928b12effa ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        PyObject *tmp_dict_key_5;
        PyObject *tmp_dict_value_5;
        PyObject *tmp_dict_key_6;
        PyObject *tmp_dict_value_6;
        PyObject *tmp_dict_key_7;
        PyObject *tmp_dict_value_7;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_sslsocket_class );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 405;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__create );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 405;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_sock;
        CHECK_OBJECT( par_sock );
        tmp_dict_value_1 = par_sock;
        tmp_kw_name_1 = _PyDict_NewPresized( 7 );
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_2 = const_str_plain_server_side;
        CHECK_OBJECT( par_server_side );
        tmp_dict_value_2 = par_server_side;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_3 = const_str_plain_do_handshake_on_connect;
        CHECK_OBJECT( par_do_handshake_on_connect );
        tmp_dict_value_3 = par_do_handshake_on_connect;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_4 = const_str_plain_suppress_ragged_eofs;
        CHECK_OBJECT( par_suppress_ragged_eofs );
        tmp_dict_value_4 = par_suppress_ragged_eofs;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_5 = const_str_plain_server_hostname;
        CHECK_OBJECT( par_server_hostname );
        tmp_dict_value_5 = par_server_hostname;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_5, tmp_dict_value_5 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_6 = const_str_plain_context;
        CHECK_OBJECT( par_self );
        tmp_dict_value_6 = par_self;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_6, tmp_dict_value_6 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_7 = const_str_plain_session;
        CHECK_OBJECT( par_session );
        tmp_dict_value_7 = par_session;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_7, tmp_dict_value_7 );
        assert( !(tmp_res != 0) );
        frame_5e4ce0716b248a14e09f49928b12effa->m_frame.f_lineno = 405;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 405;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5e4ce0716b248a14e09f49928b12effa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5e4ce0716b248a14e09f49928b12effa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5e4ce0716b248a14e09f49928b12effa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5e4ce0716b248a14e09f49928b12effa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5e4ce0716b248a14e09f49928b12effa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5e4ce0716b248a14e09f49928b12effa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5e4ce0716b248a14e09f49928b12effa,
        type_description_1,
        par_self,
        par_sock,
        par_server_side,
        par_do_handshake_on_connect,
        par_suppress_ragged_eofs,
        par_server_hostname,
        par_session
    );


    // Release cached frame.
    if ( frame_5e4ce0716b248a14e09f49928b12effa == cache_frame_5e4ce0716b248a14e09f49928b12effa )
    {
        Py_DECREF( frame_5e4ce0716b248a14e09f49928b12effa );
    }
    cache_frame_5e4ce0716b248a14e09f49928b12effa = NULL;

    assertFrameObject( frame_5e4ce0716b248a14e09f49928b12effa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_17_wrap_socket );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_sock );
    Py_DECREF( par_sock );
    par_sock = NULL;

    CHECK_OBJECT( (PyObject *)par_server_side );
    Py_DECREF( par_server_side );
    par_server_side = NULL;

    CHECK_OBJECT( (PyObject *)par_do_handshake_on_connect );
    Py_DECREF( par_do_handshake_on_connect );
    par_do_handshake_on_connect = NULL;

    CHECK_OBJECT( (PyObject *)par_suppress_ragged_eofs );
    Py_DECREF( par_suppress_ragged_eofs );
    par_suppress_ragged_eofs = NULL;

    CHECK_OBJECT( (PyObject *)par_server_hostname );
    Py_DECREF( par_server_hostname );
    par_server_hostname = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_sock );
    Py_DECREF( par_sock );
    par_sock = NULL;

    CHECK_OBJECT( (PyObject *)par_server_side );
    Py_DECREF( par_server_side );
    par_server_side = NULL;

    CHECK_OBJECT( (PyObject *)par_do_handshake_on_connect );
    Py_DECREF( par_do_handshake_on_connect );
    par_do_handshake_on_connect = NULL;

    CHECK_OBJECT( (PyObject *)par_suppress_ragged_eofs );
    Py_DECREF( par_suppress_ragged_eofs );
    par_suppress_ragged_eofs = NULL;

    CHECK_OBJECT( (PyObject *)par_server_hostname );
    Py_DECREF( par_server_hostname );
    par_server_hostname = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_17_wrap_socket );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_18_wrap_bio( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_incoming = python_pars[ 1 ];
    PyObject *par_outgoing = python_pars[ 2 ];
    PyObject *par_server_side = python_pars[ 3 ];
    PyObject *par_server_hostname = python_pars[ 4 ];
    PyObject *par_session = python_pars[ 5 ];
    struct Nuitka_FrameObject *frame_5f141f0f9a51bec2ef519041ccab0132;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_5f141f0f9a51bec2ef519041ccab0132 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5f141f0f9a51bec2ef519041ccab0132, codeobj_5f141f0f9a51bec2ef519041ccab0132, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5f141f0f9a51bec2ef519041ccab0132 = cache_frame_5f141f0f9a51bec2ef519041ccab0132;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5f141f0f9a51bec2ef519041ccab0132 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5f141f0f9a51bec2ef519041ccab0132 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_sslobject_class );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 419;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__create );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 419;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_incoming );
        tmp_tuple_element_1 = par_incoming;
        tmp_args_name_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_outgoing );
        tmp_tuple_element_1 = par_outgoing;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
        tmp_dict_key_1 = const_str_plain_server_side;
        CHECK_OBJECT( par_server_side );
        tmp_dict_value_1 = par_server_side;
        tmp_kw_name_1 = _PyDict_NewPresized( 4 );
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_2 = const_str_plain_server_hostname;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_server_hostname );
        tmp_args_element_name_1 = par_server_hostname;
        frame_5f141f0f9a51bec2ef519041ccab0132->m_frame.f_lineno = 421;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_dict_value_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__encode_hostname, call_args );
        }

        if ( tmp_dict_value_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );
            Py_DECREF( tmp_kw_name_1 );

            exception_lineno = 421;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
        Py_DECREF( tmp_dict_value_2 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_3 = const_str_plain_session;
        CHECK_OBJECT( par_session );
        tmp_dict_value_3 = par_session;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_4 = const_str_plain_context;
        CHECK_OBJECT( par_self );
        tmp_dict_value_4 = par_self;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
        assert( !(tmp_res != 0) );
        frame_5f141f0f9a51bec2ef519041ccab0132->m_frame.f_lineno = 419;
        tmp_return_value = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 419;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5f141f0f9a51bec2ef519041ccab0132 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5f141f0f9a51bec2ef519041ccab0132 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5f141f0f9a51bec2ef519041ccab0132 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5f141f0f9a51bec2ef519041ccab0132, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5f141f0f9a51bec2ef519041ccab0132->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5f141f0f9a51bec2ef519041ccab0132, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5f141f0f9a51bec2ef519041ccab0132,
        type_description_1,
        par_self,
        par_incoming,
        par_outgoing,
        par_server_side,
        par_server_hostname,
        par_session
    );


    // Release cached frame.
    if ( frame_5f141f0f9a51bec2ef519041ccab0132 == cache_frame_5f141f0f9a51bec2ef519041ccab0132 )
    {
        Py_DECREF( frame_5f141f0f9a51bec2ef519041ccab0132 );
    }
    cache_frame_5f141f0f9a51bec2ef519041ccab0132 = NULL;

    assertFrameObject( frame_5f141f0f9a51bec2ef519041ccab0132 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_18_wrap_bio );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_incoming );
    Py_DECREF( par_incoming );
    par_incoming = NULL;

    CHECK_OBJECT( (PyObject *)par_outgoing );
    Py_DECREF( par_outgoing );
    par_outgoing = NULL;

    CHECK_OBJECT( (PyObject *)par_server_side );
    Py_DECREF( par_server_side );
    par_server_side = NULL;

    CHECK_OBJECT( (PyObject *)par_server_hostname );
    Py_DECREF( par_server_hostname );
    par_server_hostname = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_incoming );
    Py_DECREF( par_incoming );
    par_incoming = NULL;

    CHECK_OBJECT( (PyObject *)par_outgoing );
    Py_DECREF( par_outgoing );
    par_outgoing = NULL;

    CHECK_OBJECT( (PyObject *)par_server_side );
    Py_DECREF( par_server_side );
    par_server_side = NULL;

    CHECK_OBJECT( (PyObject *)par_server_hostname );
    Py_DECREF( par_server_hostname );
    par_server_hostname = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_18_wrap_bio );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_19_set_npn_protocols( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_npn_protocols = python_pars[ 1 ];
    PyObject *var_protos = NULL;
    PyObject *var_protocol = NULL;
    PyObject *var_b = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_c315ec050432736c21843c7f8970ed99;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_c315ec050432736c21843c7f8970ed99 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = BYTEARRAY_COPY( const_bytearray_72cdf64f605ef12d57287fc4b61c2b5e );
        assert( var_protos == NULL );
        var_protos = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c315ec050432736c21843c7f8970ed99, codeobj_c315ec050432736c21843c7f8970ed99, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c315ec050432736c21843c7f8970ed99 = cache_frame_c315ec050432736c21843c7f8970ed99;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c315ec050432736c21843c7f8970ed99 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c315ec050432736c21843c7f8970ed99 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_npn_protocols );
        tmp_iter_arg_1 = par_npn_protocols;
        tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 427;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooo";
                exception_lineno = 427;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_protocol;
            var_protocol = tmp_assign_source_4;
            Py_INCREF( var_protocol );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_bytes_arg_1;
        PyObject *tmp_bytes_encoding_1;
        CHECK_OBJECT( var_protocol );
        tmp_bytes_arg_1 = var_protocol;
        tmp_bytes_encoding_1 = const_str_plain_ascii;
        tmp_assign_source_5 = BUILTIN_BYTES3( tmp_bytes_arg_1, tmp_bytes_encoding_1, NULL );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 428;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_b;
            var_b = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_len_arg_2;
        CHECK_OBJECT( var_b );
        tmp_len_arg_1 = var_b;
        tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
        assert( !(tmp_compexpr_left_1 == NULL) );
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        assert( !(tmp_res == -1) );
        tmp_or_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( var_b );
        tmp_len_arg_2 = var_b;
        tmp_compexpr_left_2 = BUILTIN_LEN( tmp_len_arg_2 );
        assert( !(tmp_compexpr_left_2 == NULL) );
        tmp_compexpr_right_2 = const_int_pos_255;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        assert( !(tmp_res == -1) );
        tmp_or_right_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_1 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLError );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLError );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLError" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 430;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            frame_c315ec050432736c21843c7f8970ed99->m_frame.f_lineno = 430;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_str_digest_89945f27978b3c4970283807e6649ec5_tuple, 0 ) );

            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 430;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 430;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_len_arg_3;
        CHECK_OBJECT( var_protos );
        tmp_source_name_1 = var_protos;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 431;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_b );
        tmp_len_arg_3 = var_b;
        tmp_args_element_name_1 = BUILTIN_LEN( tmp_len_arg_3 );
        assert( !(tmp_args_element_name_1 == NULL) );
        frame_c315ec050432736c21843c7f8970ed99->m_frame.f_lineno = 431;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 431;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( var_protos );
        tmp_called_instance_1 = var_protos;
        CHECK_OBJECT( var_b );
        tmp_args_element_name_2 = var_b;
        frame_c315ec050432736c21843c7f8970ed99->m_frame.f_lineno = 432;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_extend, call_args );
        }

        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 432;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 427;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        CHECK_OBJECT( var_protos );
        tmp_args_element_name_3 = var_protos;
        frame_c315ec050432736c21843c7f8970ed99->m_frame.f_lineno = 434;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__set_npn_protocols, call_args );
        }

        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 434;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c315ec050432736c21843c7f8970ed99 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c315ec050432736c21843c7f8970ed99 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c315ec050432736c21843c7f8970ed99, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c315ec050432736c21843c7f8970ed99->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c315ec050432736c21843c7f8970ed99, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c315ec050432736c21843c7f8970ed99,
        type_description_1,
        par_self,
        par_npn_protocols,
        var_protos,
        var_protocol,
        var_b
    );


    // Release cached frame.
    if ( frame_c315ec050432736c21843c7f8970ed99 == cache_frame_c315ec050432736c21843c7f8970ed99 )
    {
        Py_DECREF( frame_c315ec050432736c21843c7f8970ed99 );
    }
    cache_frame_c315ec050432736c21843c7f8970ed99 = NULL;

    assertFrameObject( frame_c315ec050432736c21843c7f8970ed99 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_19_set_npn_protocols );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_npn_protocols );
    Py_DECREF( par_npn_protocols );
    par_npn_protocols = NULL;

    CHECK_OBJECT( (PyObject *)var_protos );
    Py_DECREF( var_protos );
    var_protos = NULL;

    Py_XDECREF( var_protocol );
    var_protocol = NULL;

    Py_XDECREF( var_b );
    var_b = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_npn_protocols );
    Py_DECREF( par_npn_protocols );
    par_npn_protocols = NULL;

    CHECK_OBJECT( (PyObject *)var_protos );
    Py_DECREF( var_protos );
    var_protos = NULL;

    Py_XDECREF( var_protocol );
    var_protocol = NULL;

    Py_XDECREF( var_b );
    var_b = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_19_set_npn_protocols );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_20_set_servername_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_server_name_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_shim_cb = NULL;
    struct Nuitka_FrameObject *frame_6362b4ab8ff4a74ff389af21e2831505;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_6362b4ab8ff4a74ff389af21e2831505 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6362b4ab8ff4a74ff389af21e2831505, codeobj_6362b4ab8ff4a74ff389af21e2831505, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6362b4ab8ff4a74ff389af21e2831505 = cache_frame_6362b4ab8ff4a74ff389af21e2831505;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6362b4ab8ff4a74ff389af21e2831505 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6362b4ab8ff4a74ff389af21e2831505 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( PyCell_GET( par_server_name_callback ) );
        tmp_compexpr_left_1 = PyCell_GET( par_server_name_callback );
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            tmp_assattr_name_1 = Py_None;
            CHECK_OBJECT( PyCell_GET( par_self ) );
            tmp_assattr_target_1 = PyCell_GET( par_self );
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_sni_callback, tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 438;
                type_description_1 = "cco";
                goto frame_exception_exit_1;
            }
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_args_element_name_1;
            tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_callable );
            assert( tmp_called_name_1 != NULL );
            CHECK_OBJECT( PyCell_GET( par_server_name_callback ) );
            tmp_args_element_name_1 = PyCell_GET( par_server_name_callback );
            frame_6362b4ab8ff4a74ff389af21e2831505->m_frame.f_lineno = 440;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_operand_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            if ( tmp_operand_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 440;
                type_description_1 = "cco";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            Py_DECREF( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 440;
                type_description_1 = "cco";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_bf85e7fd1bca2b2685cec66cc7c88826;
                frame_6362b4ab8ff4a74ff389af21e2831505->m_frame.f_lineno = 441;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 441;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "cco";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        {
            PyObject *tmp_assign_source_1;
            tmp_assign_source_1 = MAKE_FUNCTION_ssl$$$function_20_set_servername_callback$$$function_1_shim_cb(  );

            ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] = par_self;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] );
            ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] = par_server_name_callback;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] );


            assert( var_shim_cb == NULL );
            var_shim_cb = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT( var_shim_cb );
            tmp_assattr_name_2 = var_shim_cb;
            CHECK_OBJECT( PyCell_GET( par_self ) );
            tmp_assattr_target_2 = PyCell_GET( par_self );
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_sni_callback, tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 447;
                type_description_1 = "cco";
                goto frame_exception_exit_1;
            }
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6362b4ab8ff4a74ff389af21e2831505 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6362b4ab8ff4a74ff389af21e2831505 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6362b4ab8ff4a74ff389af21e2831505, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6362b4ab8ff4a74ff389af21e2831505->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6362b4ab8ff4a74ff389af21e2831505, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6362b4ab8ff4a74ff389af21e2831505,
        type_description_1,
        par_self,
        par_server_name_callback,
        var_shim_cb
    );


    // Release cached frame.
    if ( frame_6362b4ab8ff4a74ff389af21e2831505 == cache_frame_6362b4ab8ff4a74ff389af21e2831505 )
    {
        Py_DECREF( frame_6362b4ab8ff4a74ff389af21e2831505 );
    }
    cache_frame_6362b4ab8ff4a74ff389af21e2831505 = NULL;

    assertFrameObject( frame_6362b4ab8ff4a74ff389af21e2831505 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_20_set_servername_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_server_name_callback );
    Py_DECREF( par_server_name_callback );
    par_server_name_callback = NULL;

    Py_XDECREF( var_shim_cb );
    var_shim_cb = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_server_name_callback );
    Py_DECREF( par_server_name_callback );
    par_server_name_callback = NULL;

    Py_XDECREF( var_shim_cb );
    var_shim_cb = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_20_set_servername_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_20_set_servername_callback$$$function_1_shim_cb( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_sslobj = python_pars[ 0 ];
    PyObject *par_servername = python_pars[ 1 ];
    PyObject *par_sslctx = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_c9128c1053ef6f473a6bfd7f36ba0b37;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c9128c1053ef6f473a6bfd7f36ba0b37 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c9128c1053ef6f473a6bfd7f36ba0b37, codeobj_c9128c1053ef6f473a6bfd7f36ba0b37, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c9128c1053ef6f473a6bfd7f36ba0b37 = cache_frame_c9128c1053ef6f473a6bfd7f36ba0b37;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c9128c1053ef6f473a6bfd7f36ba0b37 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c9128c1053ef6f473a6bfd7f36ba0b37 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 444;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_servername );
        tmp_args_element_name_1 = par_servername;
        frame_c9128c1053ef6f473a6bfd7f36ba0b37->m_frame.f_lineno = 444;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__encode_hostname, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 444;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_servername;
            assert( old != NULL );
            par_servername = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        if ( PyCell_GET( self->m_closure[1] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "server_name_callback" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 445;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = PyCell_GET( self->m_closure[1] );
        CHECK_OBJECT( par_sslobj );
        tmp_args_element_name_2 = par_sslobj;
        CHECK_OBJECT( par_servername );
        tmp_args_element_name_3 = par_servername;
        CHECK_OBJECT( par_sslctx );
        tmp_args_element_name_4 = par_sslctx;
        frame_c9128c1053ef6f473a6bfd7f36ba0b37->m_frame.f_lineno = 445;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 445;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c9128c1053ef6f473a6bfd7f36ba0b37 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c9128c1053ef6f473a6bfd7f36ba0b37 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c9128c1053ef6f473a6bfd7f36ba0b37 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c9128c1053ef6f473a6bfd7f36ba0b37, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c9128c1053ef6f473a6bfd7f36ba0b37->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c9128c1053ef6f473a6bfd7f36ba0b37, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c9128c1053ef6f473a6bfd7f36ba0b37,
        type_description_1,
        par_sslobj,
        par_servername,
        par_sslctx,
        self->m_closure[0],
        self->m_closure[1]
    );


    // Release cached frame.
    if ( frame_c9128c1053ef6f473a6bfd7f36ba0b37 == cache_frame_c9128c1053ef6f473a6bfd7f36ba0b37 )
    {
        Py_DECREF( frame_c9128c1053ef6f473a6bfd7f36ba0b37 );
    }
    cache_frame_c9128c1053ef6f473a6bfd7f36ba0b37 = NULL;

    assertFrameObject( frame_c9128c1053ef6f473a6bfd7f36ba0b37 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_20_set_servername_callback$$$function_1_shim_cb );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_sslobj );
    Py_DECREF( par_sslobj );
    par_sslobj = NULL;

    CHECK_OBJECT( (PyObject *)par_servername );
    Py_DECREF( par_servername );
    par_servername = NULL;

    CHECK_OBJECT( (PyObject *)par_sslctx );
    Py_DECREF( par_sslctx );
    par_sslctx = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_sslobj );
    Py_DECREF( par_sslobj );
    par_sslobj = NULL;

    CHECK_OBJECT( (PyObject *)par_servername );
    Py_DECREF( par_servername );
    par_servername = NULL;

    CHECK_OBJECT( (PyObject *)par_sslctx );
    Py_DECREF( par_sslctx );
    par_sslctx = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_20_set_servername_callback$$$function_1_shim_cb );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_21_set_alpn_protocols( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_alpn_protocols = python_pars[ 1 ];
    PyObject *var_protos = NULL;
    PyObject *var_protocol = NULL;
    PyObject *var_b = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_e33384d5e86c4c6b681e06b935a1eccd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_e33384d5e86c4c6b681e06b935a1eccd = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = BYTEARRAY_COPY( const_bytearray_72cdf64f605ef12d57287fc4b61c2b5e );
        assert( var_protos == NULL );
        var_protos = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e33384d5e86c4c6b681e06b935a1eccd, codeobj_e33384d5e86c4c6b681e06b935a1eccd, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e33384d5e86c4c6b681e06b935a1eccd = cache_frame_e33384d5e86c4c6b681e06b935a1eccd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e33384d5e86c4c6b681e06b935a1eccd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e33384d5e86c4c6b681e06b935a1eccd ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_alpn_protocols );
        tmp_iter_arg_1 = par_alpn_protocols;
        tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 451;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooo";
                exception_lineno = 451;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_protocol;
            var_protocol = tmp_assign_source_4;
            Py_INCREF( var_protocol );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_bytes_arg_1;
        PyObject *tmp_bytes_encoding_1;
        CHECK_OBJECT( var_protocol );
        tmp_bytes_arg_1 = var_protocol;
        tmp_bytes_encoding_1 = const_str_plain_ascii;
        tmp_assign_source_5 = BUILTIN_BYTES3( tmp_bytes_arg_1, tmp_bytes_encoding_1, NULL );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 452;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_b;
            var_b = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_len_arg_2;
        CHECK_OBJECT( var_b );
        tmp_len_arg_1 = var_b;
        tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
        assert( !(tmp_compexpr_left_1 == NULL) );
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        assert( !(tmp_res == -1) );
        tmp_or_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( var_b );
        tmp_len_arg_2 = var_b;
        tmp_compexpr_left_2 = BUILTIN_LEN( tmp_len_arg_2 );
        assert( !(tmp_compexpr_left_2 == NULL) );
        tmp_compexpr_right_2 = const_int_pos_255;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        assert( !(tmp_res == -1) );
        tmp_or_right_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_1 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLError );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLError );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLError" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 454;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            frame_e33384d5e86c4c6b681e06b935a1eccd->m_frame.f_lineno = 454;
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_str_digest_bb9901570b2b538ad6494c6c3dc8a9be_tuple, 0 ) );

            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 454;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 454;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_len_arg_3;
        CHECK_OBJECT( var_protos );
        tmp_source_name_1 = var_protos;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 455;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_b );
        tmp_len_arg_3 = var_b;
        tmp_args_element_name_1 = BUILTIN_LEN( tmp_len_arg_3 );
        assert( !(tmp_args_element_name_1 == NULL) );
        frame_e33384d5e86c4c6b681e06b935a1eccd->m_frame.f_lineno = 455;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 455;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( var_protos );
        tmp_called_instance_1 = var_protos;
        CHECK_OBJECT( var_b );
        tmp_args_element_name_2 = var_b;
        frame_e33384d5e86c4c6b681e06b935a1eccd->m_frame.f_lineno = 456;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_extend, call_args );
        }

        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 456;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 451;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        CHECK_OBJECT( var_protos );
        tmp_args_element_name_3 = var_protos;
        frame_e33384d5e86c4c6b681e06b935a1eccd->m_frame.f_lineno = 458;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__set_alpn_protocols, call_args );
        }

        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 458;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e33384d5e86c4c6b681e06b935a1eccd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e33384d5e86c4c6b681e06b935a1eccd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e33384d5e86c4c6b681e06b935a1eccd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e33384d5e86c4c6b681e06b935a1eccd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e33384d5e86c4c6b681e06b935a1eccd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e33384d5e86c4c6b681e06b935a1eccd,
        type_description_1,
        par_self,
        par_alpn_protocols,
        var_protos,
        var_protocol,
        var_b
    );


    // Release cached frame.
    if ( frame_e33384d5e86c4c6b681e06b935a1eccd == cache_frame_e33384d5e86c4c6b681e06b935a1eccd )
    {
        Py_DECREF( frame_e33384d5e86c4c6b681e06b935a1eccd );
    }
    cache_frame_e33384d5e86c4c6b681e06b935a1eccd = NULL;

    assertFrameObject( frame_e33384d5e86c4c6b681e06b935a1eccd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_21_set_alpn_protocols );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_alpn_protocols );
    Py_DECREF( par_alpn_protocols );
    par_alpn_protocols = NULL;

    CHECK_OBJECT( (PyObject *)var_protos );
    Py_DECREF( var_protos );
    var_protos = NULL;

    Py_XDECREF( var_protocol );
    var_protocol = NULL;

    Py_XDECREF( var_b );
    var_b = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_alpn_protocols );
    Py_DECREF( par_alpn_protocols );
    par_alpn_protocols = NULL;

    CHECK_OBJECT( (PyObject *)var_protos );
    Py_DECREF( var_protos );
    var_protos = NULL;

    Py_XDECREF( var_protocol );
    var_protocol = NULL;

    Py_XDECREF( var_b );
    var_b = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_21_set_alpn_protocols );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_22__load_windows_store_certs( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_storename = python_pars[ 1 ];
    PyObject *par_purpose = python_pars[ 2 ];
    PyObject *var_certs = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_encoding = NULL;
    PyObject *var_trust = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_c3c87c308de5f0caba95e34d2a75cff3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    int tmp_res;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    bool tmp_result;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    static struct Nuitka_FrameObject *cache_frame_c3c87c308de5f0caba95e34d2a75cff3 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = BYTEARRAY_COPY( const_bytearray_72cdf64f605ef12d57287fc4b61c2b5e );
        assert( var_certs == NULL );
        var_certs = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c3c87c308de5f0caba95e34d2a75cff3, codeobj_c3c87c308de5f0caba95e34d2a75cff3, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c3c87c308de5f0caba95e34d2a75cff3 = cache_frame_c3c87c308de5f0caba95e34d2a75cff3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c3c87c308de5f0caba95e34d2a75cff3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c3c87c308de5f0caba95e34d2a75cff3 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_enum_certificates );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_enum_certificates );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "enum_certificates" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 463;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_storename );
        tmp_args_element_name_1 = par_storename;
        frame_c3c87c308de5f0caba95e34d2a75cff3->m_frame.f_lineno = 463;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 463;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 463;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooo";
                exception_lineno = 463;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_iter_arg_2;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_iter_arg_2 = tmp_for_loop_1__iter_value;
        tmp_assign_source_4 = MAKE_UNPACK_ITERATOR( tmp_iter_arg_2 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 463;
            type_description_1 = "ooooooo";
            goto try_except_handler_4;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__source_iter;
            tmp_tuple_unpack_1__source_iter = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_5 = UNPACK_NEXT( tmp_unpack_1, 0, 3 );
        if ( tmp_assign_source_5 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "ooooooo";
            exception_lineno = 463;
            goto try_except_handler_5;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_1;
            tmp_tuple_unpack_1__element_1 = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_6 = UNPACK_NEXT( tmp_unpack_2, 1, 3 );
        if ( tmp_assign_source_6 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "ooooooo";
            exception_lineno = 463;
            goto try_except_handler_5;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_2;
            tmp_tuple_unpack_1__element_2 = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_unpack_3;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_3 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_7 = UNPACK_NEXT( tmp_unpack_3, 2, 3 );
        if ( tmp_assign_source_7 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "ooooooo";
            exception_lineno = 463;
            goto try_except_handler_5;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_3;
            tmp_tuple_unpack_1__element_3 = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "ooooooo";
                    exception_lineno = 463;
                    goto try_except_handler_5;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "ooooooo";
            exception_lineno = 463;
            goto try_except_handler_5;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_4;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_3 );
    tmp_tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_3;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_8;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_8 = tmp_tuple_unpack_1__element_1;
        {
            PyObject *old = var_cert;
            var_cert = tmp_assign_source_8;
            Py_INCREF( var_cert );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_9;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_9 = tmp_tuple_unpack_1__element_2;
        {
            PyObject *old = var_encoding;
            var_encoding = tmp_assign_source_9;
            Py_INCREF( var_encoding );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        PyObject *tmp_assign_source_10;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_3 );
        tmp_assign_source_10 = tmp_tuple_unpack_1__element_3;
        {
            PyObject *old = var_trust;
            var_trust = tmp_assign_source_10;
            Py_INCREF( var_trust );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_3 );
    tmp_tuple_unpack_1__element_3 = NULL;

    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_encoding );
        tmp_compexpr_left_1 = var_encoding;
        tmp_compexpr_right_1 = const_str_plain_x509_asn;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 465;
            type_description_1 = "ooooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_condition_result_2;
            int tmp_or_left_truth_1;
            nuitka_bool tmp_or_left_value_1;
            nuitka_bool tmp_or_right_value_1;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_1;
            CHECK_OBJECT( var_trust );
            tmp_compexpr_left_2 = var_trust;
            tmp_compexpr_right_2 = Py_True;
            tmp_or_left_value_1 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_or_left_truth_1 == 1 )
            {
                goto or_left_1;
            }
            else
            {
                goto or_right_1;
            }
            or_right_1:;
            CHECK_OBJECT( par_purpose );
            tmp_source_name_1 = par_purpose;
            tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_oid );
            if ( tmp_compexpr_left_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 466;
                type_description_1 = "ooooooo";
                goto try_except_handler_3;
            }
            CHECK_OBJECT( var_trust );
            tmp_compexpr_right_3 = var_trust;
            tmp_res = PySequence_Contains( tmp_compexpr_right_3, tmp_compexpr_left_3 );
            Py_DECREF( tmp_compexpr_left_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 466;
                type_description_1 = "ooooooo";
                goto try_except_handler_3;
            }
            tmp_or_right_value_1 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_condition_result_2 = tmp_or_right_value_1;
            goto or_end_1;
            or_left_1:;
            tmp_condition_result_2 = tmp_or_left_value_1;
            or_end_1:;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_1;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT( var_certs );
                tmp_called_instance_1 = var_certs;
                CHECK_OBJECT( var_cert );
                tmp_args_element_name_2 = var_cert;
                frame_c3c87c308de5f0caba95e34d2a75cff3->m_frame.f_lineno = 467;
                {
                    PyObject *call_args[] = { tmp_args_element_name_2 };
                    tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_extend, call_args );
                }

                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 467;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_3;
                }
                Py_DECREF( tmp_call_result_1 );
            }
            branch_no_2:;
        }
        branch_no_1:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 463;
        type_description_1 = "ooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_2;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto try_end_4;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_4 == NULL )
    {
        exception_keeper_tb_4 = MAKE_TRACEBACK( frame_c3c87c308de5f0caba95e34d2a75cff3, exception_keeper_lineno_4 );
    }
    else if ( exception_keeper_lineno_4 != 0 )
    {
        exception_keeper_tb_4 = ADD_TRACEBACK( exception_keeper_tb_4, frame_c3c87c308de5f0caba95e34d2a75cff3, exception_keeper_lineno_4 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_4, &exception_keeper_value_4, &exception_keeper_tb_4 );
    PyException_SetTraceback( exception_keeper_value_4, (PyObject *)exception_keeper_tb_4 );
    PUBLISH_EXCEPTION( &exception_keeper_type_4, &exception_keeper_value_4, &exception_keeper_tb_4 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        tmp_compexpr_left_4 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_4 = PyExc_PermissionError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 468;
            type_description_1 = "ooooooo";
            goto try_except_handler_6;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_warnings );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "warnings" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 469;
                type_description_1 = "ooooooo";
                goto try_except_handler_6;
            }

            tmp_called_instance_2 = tmp_mvar_value_2;
            frame_c3c87c308de5f0caba95e34d2a75cff3->m_frame.f_lineno = 469;
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_warn, &PyTuple_GET_ITEM( const_tuple_str_digest_d9ecb2d1bd7c2c654c39bebb9c4b95c7_tuple, 0 ) );

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 469;
                type_description_1 = "ooooooo";
                goto try_except_handler_6;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        goto branch_end_3;
        branch_no_3:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 462;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_c3c87c308de5f0caba95e34d2a75cff3->m_frame) frame_c3c87c308de5f0caba95e34d2a75cff3->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooooooo";
        goto try_except_handler_6;
        branch_end_3:;
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    goto try_end_4;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_22__load_windows_store_certs );
    return NULL;
    // End of try:
    try_end_4:;
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_truth_name_1;
        CHECK_OBJECT( var_certs );
        tmp_truth_name_1 = CHECK_IF_TRUE( var_certs );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 470;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_call_result_3;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_load_verify_locations );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 471;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_cadata;
            CHECK_OBJECT( var_certs );
            tmp_dict_value_1 = var_certs;
            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
            assert( !(tmp_res != 0) );
            frame_c3c87c308de5f0caba95e34d2a75cff3->m_frame.f_lineno = 471;
            tmp_call_result_3 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_kw_name_1 );
            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 471;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        branch_no_4:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c3c87c308de5f0caba95e34d2a75cff3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c3c87c308de5f0caba95e34d2a75cff3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c3c87c308de5f0caba95e34d2a75cff3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c3c87c308de5f0caba95e34d2a75cff3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c3c87c308de5f0caba95e34d2a75cff3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c3c87c308de5f0caba95e34d2a75cff3,
        type_description_1,
        par_self,
        par_storename,
        par_purpose,
        var_certs,
        var_cert,
        var_encoding,
        var_trust
    );


    // Release cached frame.
    if ( frame_c3c87c308de5f0caba95e34d2a75cff3 == cache_frame_c3c87c308de5f0caba95e34d2a75cff3 )
    {
        Py_DECREF( frame_c3c87c308de5f0caba95e34d2a75cff3 );
    }
    cache_frame_c3c87c308de5f0caba95e34d2a75cff3 = NULL;

    assertFrameObject( frame_c3c87c308de5f0caba95e34d2a75cff3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_certs );
    tmp_return_value = var_certs;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_22__load_windows_store_certs );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_storename );
    Py_DECREF( par_storename );
    par_storename = NULL;

    CHECK_OBJECT( (PyObject *)par_purpose );
    Py_DECREF( par_purpose );
    par_purpose = NULL;

    CHECK_OBJECT( (PyObject *)var_certs );
    Py_DECREF( var_certs );
    var_certs = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    Py_XDECREF( var_encoding );
    var_encoding = NULL;

    Py_XDECREF( var_trust );
    var_trust = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_storename );
    Py_DECREF( par_storename );
    par_storename = NULL;

    CHECK_OBJECT( (PyObject *)par_purpose );
    Py_DECREF( par_purpose );
    par_purpose = NULL;

    CHECK_OBJECT( (PyObject *)var_certs );
    Py_DECREF( var_certs );
    var_certs = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    Py_XDECREF( var_encoding );
    var_encoding = NULL;

    Py_XDECREF( var_trust );
    var_trust = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_22__load_windows_store_certs );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_23_load_default_certs( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_purpose = python_pars[ 1 ];
    PyObject *var_storename = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_bd31b2b0b29be68fb348a8509700aacb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_bd31b2b0b29be68fb348a8509700aacb = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bd31b2b0b29be68fb348a8509700aacb, codeobj_bd31b2b0b29be68fb348a8509700aacb, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_bd31b2b0b29be68fb348a8509700aacb = cache_frame_bd31b2b0b29be68fb348a8509700aacb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bd31b2b0b29be68fb348a8509700aacb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bd31b2b0b29be68fb348a8509700aacb ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_purpose );
        tmp_isinstance_inst_1 = par_purpose;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ASN1Object );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ASN1Object );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ASN1Object" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 475;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 475;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 475;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            CHECK_OBJECT( par_purpose );
            tmp_make_exception_arg_1 = par_purpose;
            frame_bd31b2b0b29be68fb348a8509700aacb->m_frame.f_lineno = 476;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 476;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_sys );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 477;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_platform );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 477;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_str_plain_win32;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 477;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__windows_cert_stores );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 478;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 478;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_1__for_iterator == NULL );
            tmp_for_loop_1__for_iterator = tmp_assign_source_1;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_2;
            CHECK_OBJECT( tmp_for_loop_1__for_iterator );
            tmp_next_source_1 = tmp_for_loop_1__for_iterator;
            tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooo";
                    exception_lineno = 478;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_for_loop_1__iter_value;
                tmp_for_loop_1__iter_value = tmp_assign_source_2;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_3;
            CHECK_OBJECT( tmp_for_loop_1__iter_value );
            tmp_assign_source_3 = tmp_for_loop_1__iter_value;
            {
                PyObject *old = var_storename;
                var_storename = tmp_assign_source_3;
                Py_INCREF( var_storename );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( var_storename );
            tmp_args_element_name_1 = var_storename;
            CHECK_OBJECT( par_purpose );
            tmp_args_element_name_2 = par_purpose;
            frame_bd31b2b0b29be68fb348a8509700aacb->m_frame.f_lineno = 479;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain__load_windows_store_certs, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 479;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 478;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        try_end_1:;
        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        branch_no_2:;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        frame_bd31b2b0b29be68fb348a8509700aacb->m_frame.f_lineno = 480;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_set_default_verify_paths );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 480;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bd31b2b0b29be68fb348a8509700aacb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bd31b2b0b29be68fb348a8509700aacb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bd31b2b0b29be68fb348a8509700aacb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bd31b2b0b29be68fb348a8509700aacb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bd31b2b0b29be68fb348a8509700aacb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bd31b2b0b29be68fb348a8509700aacb,
        type_description_1,
        par_self,
        par_purpose,
        var_storename
    );


    // Release cached frame.
    if ( frame_bd31b2b0b29be68fb348a8509700aacb == cache_frame_bd31b2b0b29be68fb348a8509700aacb )
    {
        Py_DECREF( frame_bd31b2b0b29be68fb348a8509700aacb );
    }
    cache_frame_bd31b2b0b29be68fb348a8509700aacb = NULL;

    assertFrameObject( frame_bd31b2b0b29be68fb348a8509700aacb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_23_load_default_certs );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_purpose );
    Py_DECREF( par_purpose );
    par_purpose = NULL;

    Py_XDECREF( var_storename );
    var_storename = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_purpose );
    Py_DECREF( par_purpose );
    par_purpose = NULL;

    Py_XDECREF( var_storename );
    var_storename = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_23_load_default_certs );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_24_minimum_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_c741f20b5460a44d8f7d1a1ec0524090;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c741f20b5460a44d8f7d1a1ec0524090 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c741f20b5460a44d8f7d1a1ec0524090, codeobj_c741f20b5460a44d8f7d1a1ec0524090, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_c741f20b5460a44d8f7d1a1ec0524090 = cache_frame_c741f20b5460a44d8f7d1a1ec0524090;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c741f20b5460a44d8f7d1a1ec0524090 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c741f20b5460a44d8f7d1a1ec0524090 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_object_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_TLSVersion );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSVersion );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "TLSVersion" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 485;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 485;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_self );
        tmp_object_name_1 = par_self;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 485;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_minimum_version );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 485;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        frame_c741f20b5460a44d8f7d1a1ec0524090->m_frame.f_lineno = 485;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 485;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c741f20b5460a44d8f7d1a1ec0524090 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c741f20b5460a44d8f7d1a1ec0524090 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c741f20b5460a44d8f7d1a1ec0524090 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c741f20b5460a44d8f7d1a1ec0524090, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c741f20b5460a44d8f7d1a1ec0524090->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c741f20b5460a44d8f7d1a1ec0524090, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c741f20b5460a44d8f7d1a1ec0524090,
        type_description_1,
        par_self,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_c741f20b5460a44d8f7d1a1ec0524090 == cache_frame_c741f20b5460a44d8f7d1a1ec0524090 )
    {
        Py_DECREF( frame_c741f20b5460a44d8f7d1a1ec0524090 );
    }
    cache_frame_c741f20b5460a44d8f7d1a1ec0524090 = NULL;

    assertFrameObject( frame_c741f20b5460a44d8f7d1a1ec0524090 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_24_minimum_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_24_minimum_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_25_minimum_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_value = python_pars[ 1 ];
    PyObject *tmp_inplace_assign_attr_1__end = NULL;
    PyObject *tmp_inplace_assign_attr_1__start = NULL;
    struct Nuitka_FrameObject *frame_9c140cba594376b13de36d0b9d2cf41b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_9c140cba594376b13de36d0b9d2cf41b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9c140cba594376b13de36d0b9d2cf41b, codeobj_9c140cba594376b13de36d0b9d2cf41b, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9c140cba594376b13de36d0b9d2cf41b = cache_frame_9c140cba594376b13de36d0b9d2cf41b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9c140cba594376b13de36d0b9d2cf41b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9c140cba594376b13de36d0b9d2cf41b ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_value );
        tmp_compexpr_left_1 = par_value;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_TLSVersion );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSVersion );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "TLSVersion" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 489;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSLv3 );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 489;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 489;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_options );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 490;
                type_description_1 = "ooN";
                goto frame_exception_exit_1;
            }
            assert( tmp_inplace_assign_attr_1__start == NULL );
            tmp_inplace_assign_attr_1__start = tmp_assign_source_1;
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT( tmp_inplace_assign_attr_1__start );
            tmp_left_name_1 = tmp_inplace_assign_attr_1__start;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_Options );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Options );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Options" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 490;
                type_description_1 = "ooN";
                goto try_except_handler_2;
            }

            tmp_source_name_3 = tmp_mvar_value_2;
            tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_OP_NO_SSLv3 );
            if ( tmp_operand_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 490;
                type_description_1 = "ooN";
                goto try_except_handler_2;
            }
            tmp_right_name_1 = UNARY_OPERATION( PyNumber_Invert, tmp_operand_name_1 );
            Py_DECREF( tmp_operand_name_1 );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 490;
                type_description_1 = "ooN";
                goto try_except_handler_2;
            }
            tmp_assign_source_2 = BINARY_OPERATION( PyNumber_InPlaceAnd, tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 490;
                type_description_1 = "ooN";
                goto try_except_handler_2;
            }
            assert( tmp_inplace_assign_attr_1__end == NULL );
            tmp_inplace_assign_attr_1__end = tmp_assign_source_2;
        }
        // Tried code:
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            CHECK_OBJECT( tmp_inplace_assign_attr_1__end );
            tmp_assattr_name_1 = tmp_inplace_assign_attr_1__end;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_options, tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 490;
                type_description_1 = "ooN";
                goto try_except_handler_3;
            }
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__end );
        Py_DECREF( tmp_inplace_assign_attr_1__end );
        tmp_inplace_assign_attr_1__end = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto try_except_handler_2;
        // End of try:
        try_end_1:;
        goto try_end_2;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__start );
        Py_DECREF( tmp_inplace_assign_attr_1__start );
        tmp_inplace_assign_attr_1__start = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto frame_exception_exit_1;
        // End of try:
        try_end_2:;
        CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__end );
        Py_DECREF( tmp_inplace_assign_attr_1__end );
        tmp_inplace_assign_attr_1__end = NULL;

        CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__start );
        Py_DECREF( tmp_inplace_assign_attr_1__start );
        tmp_inplace_assign_attr_1__start = NULL;

        branch_no_1:;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_type_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_object_name_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 491;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = tmp_mvar_value_3;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 491;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }

        tmp_object_name_1 = tmp_mvar_value_4;
        tmp_source_name_4 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 491;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_minimum_version );
        Py_DECREF( tmp_source_name_4 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 491;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_value );
        tmp_args_element_name_2 = par_value;
        frame_9c140cba594376b13de36d0b9d2cf41b->m_frame.f_lineno = 491;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___set__, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 491;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c140cba594376b13de36d0b9d2cf41b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c140cba594376b13de36d0b9d2cf41b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9c140cba594376b13de36d0b9d2cf41b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9c140cba594376b13de36d0b9d2cf41b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9c140cba594376b13de36d0b9d2cf41b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9c140cba594376b13de36d0b9d2cf41b,
        type_description_1,
        par_self,
        par_value,
        NULL
    );


    // Release cached frame.
    if ( frame_9c140cba594376b13de36d0b9d2cf41b == cache_frame_9c140cba594376b13de36d0b9d2cf41b )
    {
        Py_DECREF( frame_9c140cba594376b13de36d0b9d2cf41b );
    }
    cache_frame_9c140cba594376b13de36d0b9d2cf41b = NULL;

    assertFrameObject( frame_9c140cba594376b13de36d0b9d2cf41b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_25_minimum_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_25_minimum_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_26_maximum_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_1fa2afa1f2001c76009fa3bd74739a02;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1fa2afa1f2001c76009fa3bd74739a02 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1fa2afa1f2001c76009fa3bd74739a02, codeobj_1fa2afa1f2001c76009fa3bd74739a02, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_1fa2afa1f2001c76009fa3bd74739a02 = cache_frame_1fa2afa1f2001c76009fa3bd74739a02;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1fa2afa1f2001c76009fa3bd74739a02 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1fa2afa1f2001c76009fa3bd74739a02 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_object_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_TLSVersion );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSVersion );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "TLSVersion" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 495;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 495;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_self );
        tmp_object_name_1 = par_self;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 495;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_maximum_version );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 495;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        frame_1fa2afa1f2001c76009fa3bd74739a02->m_frame.f_lineno = 495;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 495;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1fa2afa1f2001c76009fa3bd74739a02 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1fa2afa1f2001c76009fa3bd74739a02 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1fa2afa1f2001c76009fa3bd74739a02 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1fa2afa1f2001c76009fa3bd74739a02, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1fa2afa1f2001c76009fa3bd74739a02->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1fa2afa1f2001c76009fa3bd74739a02, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1fa2afa1f2001c76009fa3bd74739a02,
        type_description_1,
        par_self,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_1fa2afa1f2001c76009fa3bd74739a02 == cache_frame_1fa2afa1f2001c76009fa3bd74739a02 )
    {
        Py_DECREF( frame_1fa2afa1f2001c76009fa3bd74739a02 );
    }
    cache_frame_1fa2afa1f2001c76009fa3bd74739a02 = NULL;

    assertFrameObject( frame_1fa2afa1f2001c76009fa3bd74739a02 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_26_maximum_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_26_maximum_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_27_maximum_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_value = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_dd245307a21868517b26333004071afc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_dd245307a21868517b26333004071afc = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dd245307a21868517b26333004071afc, codeobj_dd245307a21868517b26333004071afc, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_dd245307a21868517b26333004071afc = cache_frame_dd245307a21868517b26333004071afc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dd245307a21868517b26333004071afc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dd245307a21868517b26333004071afc ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 499;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 499;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }

        tmp_object_name_1 = tmp_mvar_value_2;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 499;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_maximum_version );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 499;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_value );
        tmp_args_element_name_2 = par_value;
        frame_dd245307a21868517b26333004071afc->m_frame.f_lineno = 499;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___set__, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 499;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dd245307a21868517b26333004071afc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dd245307a21868517b26333004071afc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dd245307a21868517b26333004071afc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dd245307a21868517b26333004071afc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dd245307a21868517b26333004071afc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dd245307a21868517b26333004071afc,
        type_description_1,
        par_self,
        par_value,
        NULL
    );


    // Release cached frame.
    if ( frame_dd245307a21868517b26333004071afc == cache_frame_dd245307a21868517b26333004071afc )
    {
        Py_DECREF( frame_dd245307a21868517b26333004071afc );
    }
    cache_frame_dd245307a21868517b26333004071afc = NULL;

    assertFrameObject( frame_dd245307a21868517b26333004071afc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_27_maximum_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_27_maximum_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_28_options( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_e577eeee712faf011eac0a90d5a335cd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e577eeee712faf011eac0a90d5a335cd = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e577eeee712faf011eac0a90d5a335cd, codeobj_e577eeee712faf011eac0a90d5a335cd, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_e577eeee712faf011eac0a90d5a335cd = cache_frame_e577eeee712faf011eac0a90d5a335cd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e577eeee712faf011eac0a90d5a335cd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e577eeee712faf011eac0a90d5a335cd ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_object_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_Options );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Options );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Options" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 503;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 503;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_self );
        tmp_object_name_1 = par_self;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 503;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_options );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 503;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        frame_e577eeee712faf011eac0a90d5a335cd->m_frame.f_lineno = 503;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 503;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e577eeee712faf011eac0a90d5a335cd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e577eeee712faf011eac0a90d5a335cd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e577eeee712faf011eac0a90d5a335cd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e577eeee712faf011eac0a90d5a335cd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e577eeee712faf011eac0a90d5a335cd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e577eeee712faf011eac0a90d5a335cd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e577eeee712faf011eac0a90d5a335cd,
        type_description_1,
        par_self,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_e577eeee712faf011eac0a90d5a335cd == cache_frame_e577eeee712faf011eac0a90d5a335cd )
    {
        Py_DECREF( frame_e577eeee712faf011eac0a90d5a335cd );
    }
    cache_frame_e577eeee712faf011eac0a90d5a335cd = NULL;

    assertFrameObject( frame_e577eeee712faf011eac0a90d5a335cd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_28_options );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_28_options );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_29_options( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_value = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_d0ddd3c583ea0f70fd2c3f13c292f8d8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d0ddd3c583ea0f70fd2c3f13c292f8d8 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d0ddd3c583ea0f70fd2c3f13c292f8d8, codeobj_d0ddd3c583ea0f70fd2c3f13c292f8d8, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d0ddd3c583ea0f70fd2c3f13c292f8d8 = cache_frame_d0ddd3c583ea0f70fd2c3f13c292f8d8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d0ddd3c583ea0f70fd2c3f13c292f8d8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d0ddd3c583ea0f70fd2c3f13c292f8d8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 507;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 507;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }

        tmp_object_name_1 = tmp_mvar_value_2;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 507;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_options );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 507;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_value );
        tmp_args_element_name_2 = par_value;
        frame_d0ddd3c583ea0f70fd2c3f13c292f8d8->m_frame.f_lineno = 507;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___set__, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 507;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0ddd3c583ea0f70fd2c3f13c292f8d8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0ddd3c583ea0f70fd2c3f13c292f8d8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d0ddd3c583ea0f70fd2c3f13c292f8d8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d0ddd3c583ea0f70fd2c3f13c292f8d8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d0ddd3c583ea0f70fd2c3f13c292f8d8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d0ddd3c583ea0f70fd2c3f13c292f8d8,
        type_description_1,
        par_self,
        par_value,
        NULL
    );


    // Release cached frame.
    if ( frame_d0ddd3c583ea0f70fd2c3f13c292f8d8 == cache_frame_d0ddd3c583ea0f70fd2c3f13c292f8d8 )
    {
        Py_DECREF( frame_d0ddd3c583ea0f70fd2c3f13c292f8d8 );
    }
    cache_frame_d0ddd3c583ea0f70fd2c3f13c292f8d8 = NULL;

    assertFrameObject( frame_d0ddd3c583ea0f70fd2c3f13c292f8d8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_29_options );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_29_options );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_30_hostname_checks_common_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_ncs = NULL;
    struct Nuitka_FrameObject *frame_86ffcc5f322eb9e45b49c1aab256e2b5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_86ffcc5f322eb9e45b49c1aab256e2b5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_86ffcc5f322eb9e45b49c1aab256e2b5, codeobj_86ffcc5f322eb9e45b49c1aab256e2b5, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_86ffcc5f322eb9e45b49c1aab256e2b5 = cache_frame_86ffcc5f322eb9e45b49c1aab256e2b5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_86ffcc5f322eb9e45b49c1aab256e2b5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_86ffcc5f322eb9e45b49c1aab256e2b5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_left_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__host_flags );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 512;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_left_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 512;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_HOSTFLAG_NEVER_CHECK_SUBJECT );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 512;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = BINARY_OPERATION( PyNumber_And, tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 512;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_ncs == NULL );
        var_ncs = tmp_assign_source_1;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_ncs );
        tmp_compexpr_left_1 = var_ncs;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 513;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_HOSTFLAG_NEVER_CHECK_SUBJECT );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 513;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 513;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_86ffcc5f322eb9e45b49c1aab256e2b5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_86ffcc5f322eb9e45b49c1aab256e2b5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_86ffcc5f322eb9e45b49c1aab256e2b5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_86ffcc5f322eb9e45b49c1aab256e2b5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_86ffcc5f322eb9e45b49c1aab256e2b5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_86ffcc5f322eb9e45b49c1aab256e2b5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_86ffcc5f322eb9e45b49c1aab256e2b5,
        type_description_1,
        par_self,
        var_ncs
    );


    // Release cached frame.
    if ( frame_86ffcc5f322eb9e45b49c1aab256e2b5 == cache_frame_86ffcc5f322eb9e45b49c1aab256e2b5 )
    {
        Py_DECREF( frame_86ffcc5f322eb9e45b49c1aab256e2b5 );
    }
    cache_frame_86ffcc5f322eb9e45b49c1aab256e2b5 = NULL;

    assertFrameObject( frame_86ffcc5f322eb9e45b49c1aab256e2b5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_30_hostname_checks_common_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ncs );
    Py_DECREF( var_ncs );
    var_ncs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ncs );
    var_ncs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_30_hostname_checks_common_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_31_hostname_checks_common_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_value = python_pars[ 1 ];
    PyObject *tmp_inplace_assign_attr_1__end = NULL;
    PyObject *tmp_inplace_assign_attr_1__start = NULL;
    PyObject *tmp_inplace_assign_attr_2__end = NULL;
    PyObject *tmp_inplace_assign_attr_2__start = NULL;
    struct Nuitka_FrameObject *frame_8005450d1390ccb1db96bde8f18ccbc5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    static struct Nuitka_FrameObject *cache_frame_8005450d1390ccb1db96bde8f18ccbc5 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8005450d1390ccb1db96bde8f18ccbc5, codeobj_8005450d1390ccb1db96bde8f18ccbc5, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_8005450d1390ccb1db96bde8f18ccbc5 = cache_frame_8005450d1390ccb1db96bde8f18ccbc5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8005450d1390ccb1db96bde8f18ccbc5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8005450d1390ccb1db96bde8f18ccbc5 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_value );
        tmp_truth_name_1 = CHECK_IF_TRUE( par_value );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 517;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_source_name_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__host_flags );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 518;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert( tmp_inplace_assign_attr_1__start == NULL );
            tmp_inplace_assign_attr_1__start = tmp_assign_source_1;
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT( tmp_inplace_assign_attr_1__start );
            tmp_left_name_1 = tmp_inplace_assign_attr_1__start;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 518;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }

            tmp_source_name_2 = tmp_mvar_value_1;
            tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_HOSTFLAG_NEVER_CHECK_SUBJECT );
            if ( tmp_operand_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 518;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            tmp_right_name_1 = UNARY_OPERATION( PyNumber_Invert, tmp_operand_name_1 );
            Py_DECREF( tmp_operand_name_1 );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 518;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            tmp_assign_source_2 = BINARY_OPERATION( PyNumber_InPlaceAnd, tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 518;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            assert( tmp_inplace_assign_attr_1__end == NULL );
            tmp_inplace_assign_attr_1__end = tmp_assign_source_2;
        }
        // Tried code:
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            CHECK_OBJECT( tmp_inplace_assign_attr_1__end );
            tmp_assattr_name_1 = tmp_inplace_assign_attr_1__end;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__host_flags, tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 518;
                type_description_1 = "oo";
                goto try_except_handler_3;
            }
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__end );
        Py_DECREF( tmp_inplace_assign_attr_1__end );
        tmp_inplace_assign_attr_1__end = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto try_except_handler_2;
        // End of try:
        try_end_1:;
        goto try_end_2;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__start );
        Py_DECREF( tmp_inplace_assign_attr_1__start );
        tmp_inplace_assign_attr_1__start = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto frame_exception_exit_1;
        // End of try:
        try_end_2:;
        CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__end );
        Py_DECREF( tmp_inplace_assign_attr_1__end );
        tmp_inplace_assign_attr_1__end = NULL;

        CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__start );
        Py_DECREF( tmp_inplace_assign_attr_1__start );
        tmp_inplace_assign_attr_1__start = NULL;

        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__host_flags );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 520;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert( tmp_inplace_assign_attr_2__start == NULL );
            tmp_inplace_assign_attr_2__start = tmp_assign_source_3;
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT( tmp_inplace_assign_attr_2__start );
            tmp_left_name_2 = tmp_inplace_assign_attr_2__start;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 520;
                type_description_1 = "oo";
                goto try_except_handler_4;
            }

            tmp_source_name_4 = tmp_mvar_value_2;
            tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_HOSTFLAG_NEVER_CHECK_SUBJECT );
            if ( tmp_right_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 520;
                type_description_1 = "oo";
                goto try_except_handler_4;
            }
            tmp_assign_source_4 = BINARY_OPERATION( PyNumber_InPlaceOr, tmp_left_name_2, tmp_right_name_2 );
            Py_DECREF( tmp_right_name_2 );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 520;
                type_description_1 = "oo";
                goto try_except_handler_4;
            }
            assert( tmp_inplace_assign_attr_2__end == NULL );
            tmp_inplace_assign_attr_2__end = tmp_assign_source_4;
        }
        // Tried code:
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT( tmp_inplace_assign_attr_2__end );
            tmp_assattr_name_2 = tmp_inplace_assign_attr_2__end;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_2 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__host_flags, tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 520;
                type_description_1 = "oo";
                goto try_except_handler_5;
            }
        }
        goto try_end_3;
        // Exception handler code:
        try_except_handler_5:;
        exception_keeper_type_3 = exception_type;
        exception_keeper_value_3 = exception_value;
        exception_keeper_tb_3 = exception_tb;
        exception_keeper_lineno_3 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_2__end );
        Py_DECREF( tmp_inplace_assign_attr_2__end );
        tmp_inplace_assign_attr_2__end = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_3;
        exception_value = exception_keeper_value_3;
        exception_tb = exception_keeper_tb_3;
        exception_lineno = exception_keeper_lineno_3;

        goto try_except_handler_4;
        // End of try:
        try_end_3:;
        goto try_end_4;
        // Exception handler code:
        try_except_handler_4:;
        exception_keeper_type_4 = exception_type;
        exception_keeper_value_4 = exception_value;
        exception_keeper_tb_4 = exception_tb;
        exception_keeper_lineno_4 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_2__start );
        Py_DECREF( tmp_inplace_assign_attr_2__start );
        tmp_inplace_assign_attr_2__start = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_4;
        exception_value = exception_keeper_value_4;
        exception_tb = exception_keeper_tb_4;
        exception_lineno = exception_keeper_lineno_4;

        goto frame_exception_exit_1;
        // End of try:
        try_end_4:;
        CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_2__end );
        Py_DECREF( tmp_inplace_assign_attr_2__end );
        tmp_inplace_assign_attr_2__end = NULL;

        CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_2__start );
        Py_DECREF( tmp_inplace_assign_attr_2__start );
        tmp_inplace_assign_attr_2__start = NULL;

        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8005450d1390ccb1db96bde8f18ccbc5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8005450d1390ccb1db96bde8f18ccbc5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8005450d1390ccb1db96bde8f18ccbc5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8005450d1390ccb1db96bde8f18ccbc5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8005450d1390ccb1db96bde8f18ccbc5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8005450d1390ccb1db96bde8f18ccbc5,
        type_description_1,
        par_self,
        par_value
    );


    // Release cached frame.
    if ( frame_8005450d1390ccb1db96bde8f18ccbc5 == cache_frame_8005450d1390ccb1db96bde8f18ccbc5 )
    {
        Py_DECREF( frame_8005450d1390ccb1db96bde8f18ccbc5 );
    }
    cache_frame_8005450d1390ccb1db96bde8f18ccbc5 = NULL;

    assertFrameObject( frame_8005450d1390ccb1db96bde8f18ccbc5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_31_hostname_checks_common_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_31_hostname_checks_common_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_32_hostname_checks_common_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_32_hostname_checks_common_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_32_hostname_checks_common_name );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_33_protocol( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_e90beb192a2d45b154b787dd334a641a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e90beb192a2d45b154b787dd334a641a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e90beb192a2d45b154b787dd334a641a, codeobj_e90beb192a2d45b154b787dd334a641a, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_e90beb192a2d45b154b787dd334a641a = cache_frame_e90beb192a2d45b154b787dd334a641a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e90beb192a2d45b154b787dd334a641a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e90beb192a2d45b154b787dd334a641a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_object_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__SSLMethod );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__SSLMethod );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_SSLMethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 528;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 528;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_self );
        tmp_object_name_1 = par_self;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 528;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_protocol );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 528;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        frame_e90beb192a2d45b154b787dd334a641a->m_frame.f_lineno = 528;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 528;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e90beb192a2d45b154b787dd334a641a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e90beb192a2d45b154b787dd334a641a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e90beb192a2d45b154b787dd334a641a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e90beb192a2d45b154b787dd334a641a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e90beb192a2d45b154b787dd334a641a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e90beb192a2d45b154b787dd334a641a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e90beb192a2d45b154b787dd334a641a,
        type_description_1,
        par_self,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_e90beb192a2d45b154b787dd334a641a == cache_frame_e90beb192a2d45b154b787dd334a641a )
    {
        Py_DECREF( frame_e90beb192a2d45b154b787dd334a641a );
    }
    cache_frame_e90beb192a2d45b154b787dd334a641a = NULL;

    assertFrameObject( frame_e90beb192a2d45b154b787dd334a641a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_33_protocol );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_33_protocol );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_34_verify_flags( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6eddcfd3501f9e6e8ff360a6e9e07ace;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6eddcfd3501f9e6e8ff360a6e9e07ace = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6eddcfd3501f9e6e8ff360a6e9e07ace, codeobj_6eddcfd3501f9e6e8ff360a6e9e07ace, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_6eddcfd3501f9e6e8ff360a6e9e07ace = cache_frame_6eddcfd3501f9e6e8ff360a6e9e07ace;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6eddcfd3501f9e6e8ff360a6e9e07ace );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6eddcfd3501f9e6e8ff360a6e9e07ace ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_object_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_VerifyFlags );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_VerifyFlags );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "VerifyFlags" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 532;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 532;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_self );
        tmp_object_name_1 = par_self;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 532;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_verify_flags );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 532;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        frame_6eddcfd3501f9e6e8ff360a6e9e07ace->m_frame.f_lineno = 532;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 532;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6eddcfd3501f9e6e8ff360a6e9e07ace );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6eddcfd3501f9e6e8ff360a6e9e07ace );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6eddcfd3501f9e6e8ff360a6e9e07ace );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6eddcfd3501f9e6e8ff360a6e9e07ace, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6eddcfd3501f9e6e8ff360a6e9e07ace->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6eddcfd3501f9e6e8ff360a6e9e07ace, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6eddcfd3501f9e6e8ff360a6e9e07ace,
        type_description_1,
        par_self,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_6eddcfd3501f9e6e8ff360a6e9e07ace == cache_frame_6eddcfd3501f9e6e8ff360a6e9e07ace )
    {
        Py_DECREF( frame_6eddcfd3501f9e6e8ff360a6e9e07ace );
    }
    cache_frame_6eddcfd3501f9e6e8ff360a6e9e07ace = NULL;

    assertFrameObject( frame_6eddcfd3501f9e6e8ff360a6e9e07ace );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_34_verify_flags );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_34_verify_flags );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_35_verify_flags( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_value = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_a798b36ecbdc4799a3ed88ea793f49cf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a798b36ecbdc4799a3ed88ea793f49cf = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a798b36ecbdc4799a3ed88ea793f49cf, codeobj_a798b36ecbdc4799a3ed88ea793f49cf, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a798b36ecbdc4799a3ed88ea793f49cf = cache_frame_a798b36ecbdc4799a3ed88ea793f49cf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a798b36ecbdc4799a3ed88ea793f49cf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a798b36ecbdc4799a3ed88ea793f49cf ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 536;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 536;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }

        tmp_object_name_1 = tmp_mvar_value_2;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 536;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_verify_flags );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 536;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_value );
        tmp_args_element_name_2 = par_value;
        frame_a798b36ecbdc4799a3ed88ea793f49cf->m_frame.f_lineno = 536;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___set__, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 536;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a798b36ecbdc4799a3ed88ea793f49cf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a798b36ecbdc4799a3ed88ea793f49cf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a798b36ecbdc4799a3ed88ea793f49cf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a798b36ecbdc4799a3ed88ea793f49cf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a798b36ecbdc4799a3ed88ea793f49cf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a798b36ecbdc4799a3ed88ea793f49cf,
        type_description_1,
        par_self,
        par_value,
        NULL
    );


    // Release cached frame.
    if ( frame_a798b36ecbdc4799a3ed88ea793f49cf == cache_frame_a798b36ecbdc4799a3ed88ea793f49cf )
    {
        Py_DECREF( frame_a798b36ecbdc4799a3ed88ea793f49cf );
    }
    cache_frame_a798b36ecbdc4799a3ed88ea793f49cf = NULL;

    assertFrameObject( frame_a798b36ecbdc4799a3ed88ea793f49cf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_35_verify_flags );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_35_verify_flags );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_36_verify_mode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_value = NULL;
    struct Nuitka_FrameObject *frame_cd07790829b56e8f6715d0e2df0d1b17;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_cd07790829b56e8f6715d0e2df0d1b17 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cd07790829b56e8f6715d0e2df0d1b17, codeobj_cd07790829b56e8f6715d0e2df0d1b17, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_cd07790829b56e8f6715d0e2df0d1b17 = cache_frame_cd07790829b56e8f6715d0e2df0d1b17;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cd07790829b56e8f6715d0e2df0d1b17 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cd07790829b56e8f6715d0e2df0d1b17 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_object_name_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 540;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_self );
        tmp_object_name_1 = par_self;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 540;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_verify_mode );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 540;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        assert( var_value == NULL );
        var_value = tmp_assign_source_1;
    }
    // Tried code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_VerifyMode );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_VerifyMode );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "VerifyMode" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 542;
            type_description_1 = "ooc";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( var_value );
        tmp_args_element_name_1 = var_value;
        frame_cd07790829b56e8f6715d0e2df0d1b17->m_frame.f_lineno = 542;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 542;
            type_description_1 = "ooc";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_36_verify_mode );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_cd07790829b56e8f6715d0e2df0d1b17, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_cd07790829b56e8f6715d0e2df0d1b17, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_ValueError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 543;
            type_description_1 = "ooc";
            goto try_except_handler_3;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT( var_value );
        tmp_return_value = var_value;
        Py_INCREF( tmp_return_value );
        goto try_return_handler_3;
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 541;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_cd07790829b56e8f6715d0e2df0d1b17->m_frame) frame_cd07790829b56e8f6715d0e2df0d1b17->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooc";
        goto try_except_handler_3;
        branch_end_1:;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_36_verify_mode );
    return NULL;
    // Return handler code:
    try_return_handler_3:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd07790829b56e8f6715d0e2df0d1b17 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd07790829b56e8f6715d0e2df0d1b17 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd07790829b56e8f6715d0e2df0d1b17 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cd07790829b56e8f6715d0e2df0d1b17, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cd07790829b56e8f6715d0e2df0d1b17->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cd07790829b56e8f6715d0e2df0d1b17, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cd07790829b56e8f6715d0e2df0d1b17,
        type_description_1,
        par_self,
        var_value,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_cd07790829b56e8f6715d0e2df0d1b17 == cache_frame_cd07790829b56e8f6715d0e2df0d1b17 )
    {
        Py_DECREF( frame_cd07790829b56e8f6715d0e2df0d1b17 );
    }
    cache_frame_cd07790829b56e8f6715d0e2df0d1b17 = NULL;

    assertFrameObject( frame_cd07790829b56e8f6715d0e2df0d1b17 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_36_verify_mode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_value );
    Py_DECREF( var_value );
    var_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_36_verify_mode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_37_verify_mode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_value = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_58499782b4566c6282fbc531bfb08ebf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_58499782b4566c6282fbc531bfb08ebf = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_58499782b4566c6282fbc531bfb08ebf, codeobj_58499782b4566c6282fbc531bfb08ebf, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_58499782b4566c6282fbc531bfb08ebf = cache_frame_58499782b4566c6282fbc531bfb08ebf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_58499782b4566c6282fbc531bfb08ebf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_58499782b4566c6282fbc531bfb08ebf ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 548;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 548;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }

        tmp_object_name_1 = tmp_mvar_value_2;
        tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 548;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_verify_mode );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 548;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_value );
        tmp_args_element_name_2 = par_value;
        frame_58499782b4566c6282fbc531bfb08ebf->m_frame.f_lineno = 548;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___set__, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 548;
            type_description_1 = "ooN";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_58499782b4566c6282fbc531bfb08ebf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_58499782b4566c6282fbc531bfb08ebf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_58499782b4566c6282fbc531bfb08ebf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_58499782b4566c6282fbc531bfb08ebf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_58499782b4566c6282fbc531bfb08ebf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_58499782b4566c6282fbc531bfb08ebf,
        type_description_1,
        par_self,
        par_value,
        NULL
    );


    // Release cached frame.
    if ( frame_58499782b4566c6282fbc531bfb08ebf == cache_frame_58499782b4566c6282fbc531bfb08ebf )
    {
        Py_DECREF( frame_58499782b4566c6282fbc531bfb08ebf );
    }
    cache_frame_58499782b4566c6282fbc531bfb08ebf = NULL;

    assertFrameObject( frame_58499782b4566c6282fbc531bfb08ebf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_37_verify_mode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_37_verify_mode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_38_create_default_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_purpose = python_pars[ 0 ];
    PyObject *par_cafile = python_pars[ 1 ];
    PyObject *par_capath = python_pars[ 2 ];
    PyObject *par_cadata = python_pars[ 3 ];
    PyObject *var_context = NULL;
    struct Nuitka_FrameObject *frame_964b4ff49a75adfde8eac32fd1579b15;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_964b4ff49a75adfde8eac32fd1579b15 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_964b4ff49a75adfde8eac32fd1579b15, codeobj_964b4ff49a75adfde8eac32fd1579b15, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_964b4ff49a75adfde8eac32fd1579b15 = cache_frame_964b4ff49a75adfde8eac32fd1579b15;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_964b4ff49a75adfde8eac32fd1579b15 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_964b4ff49a75adfde8eac32fd1579b15 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_purpose );
        tmp_isinstance_inst_1 = par_purpose;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ASN1Object );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ASN1Object );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ASN1Object" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            CHECK_OBJECT( par_purpose );
            tmp_make_exception_arg_1 = par_purpose;
            frame_964b4ff49a75adfde8eac32fd1579b15->m_frame.f_lineno = 560;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 560;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 565;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PROTOCOL_TLS );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PROTOCOL_TLS );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PROTOCOL_TLS" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 565;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_3;
        frame_964b4ff49a75adfde8eac32fd1579b15->m_frame.f_lineno = 565;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 565;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_context == NULL );
        var_context = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( par_purpose );
        tmp_compexpr_left_1 = par_purpose;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_Purpose );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Purpose );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Purpose" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 567;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SERVER_AUTH );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 567;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 567;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_assattr_target_1;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CERT_REQUIRED );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CERT_REQUIRED );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CERT_REQUIRED" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 569;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_assattr_name_1 = tmp_mvar_value_5;
            CHECK_OBJECT( var_context );
            tmp_assattr_target_1 = var_context;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_verify_mode, tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 569;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            tmp_assattr_name_2 = Py_True;
            CHECK_OBJECT( var_context );
            tmp_assattr_target_2 = var_context;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_check_hostname, tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 570;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        int tmp_truth_name_1;
        int tmp_or_left_truth_2;
        nuitka_bool tmp_or_left_value_2;
        nuitka_bool tmp_or_right_value_2;
        int tmp_truth_name_2;
        int tmp_truth_name_3;
        CHECK_OBJECT( par_cafile );
        tmp_truth_name_1 = CHECK_IF_TRUE( par_cafile );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 572;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( par_capath );
        tmp_truth_name_2 = CHECK_IF_TRUE( par_capath );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 572;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_2 = tmp_or_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_2 == 1 )
        {
            goto or_left_2;
        }
        else
        {
            goto or_right_2;
        }
        or_right_2:;
        CHECK_OBJECT( par_cadata );
        tmp_truth_name_3 = CHECK_IF_TRUE( par_cadata );
        if ( tmp_truth_name_3 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 572;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_2 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_right_value_1 = tmp_or_right_value_2;
        goto or_end_2;
        or_left_2:;
        tmp_or_right_value_1 = tmp_or_left_value_2;
        or_end_2:;
        tmp_condition_result_3 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_3 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            CHECK_OBJECT( var_context );
            tmp_called_instance_1 = var_context;
            CHECK_OBJECT( par_cafile );
            tmp_args_element_name_2 = par_cafile;
            CHECK_OBJECT( par_capath );
            tmp_args_element_name_3 = par_capath;
            CHECK_OBJECT( par_cadata );
            tmp_args_element_name_4 = par_cadata;
            frame_964b4ff49a75adfde8eac32fd1579b15->m_frame.f_lineno = 573;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_load_verify_locations, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 573;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto branch_end_3;
        branch_no_3:;
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_6;
            CHECK_OBJECT( var_context );
            tmp_source_name_2 = var_context;
            tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_verify_mode );
            if ( tmp_compexpr_left_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 574;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CERT_NONE );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CERT_NONE );
            }

            if ( tmp_mvar_value_6 == NULL )
            {
                Py_DECREF( tmp_compexpr_left_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CERT_NONE" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 574;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_6;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_left_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 574;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_call_result_2;
                PyObject *tmp_args_element_name_5;
                CHECK_OBJECT( var_context );
                tmp_called_instance_2 = var_context;
                CHECK_OBJECT( par_purpose );
                tmp_args_element_name_5 = par_purpose;
                frame_964b4ff49a75adfde8eac32fd1579b15->m_frame.f_lineno = 578;
                {
                    PyObject *call_args[] = { tmp_args_element_name_5 };
                    tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_load_default_certs, call_args );
                }

                if ( tmp_call_result_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 578;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_2 );
            }
            branch_no_4:;
        }
        branch_end_3:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_964b4ff49a75adfde8eac32fd1579b15 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_964b4ff49a75adfde8eac32fd1579b15 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_964b4ff49a75adfde8eac32fd1579b15, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_964b4ff49a75adfde8eac32fd1579b15->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_964b4ff49a75adfde8eac32fd1579b15, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_964b4ff49a75adfde8eac32fd1579b15,
        type_description_1,
        par_purpose,
        par_cafile,
        par_capath,
        par_cadata,
        var_context
    );


    // Release cached frame.
    if ( frame_964b4ff49a75adfde8eac32fd1579b15 == cache_frame_964b4ff49a75adfde8eac32fd1579b15 )
    {
        Py_DECREF( frame_964b4ff49a75adfde8eac32fd1579b15 );
    }
    cache_frame_964b4ff49a75adfde8eac32fd1579b15 = NULL;

    assertFrameObject( frame_964b4ff49a75adfde8eac32fd1579b15 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_context );
    tmp_return_value = var_context;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_38_create_default_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_purpose );
    Py_DECREF( par_purpose );
    par_purpose = NULL;

    CHECK_OBJECT( (PyObject *)par_cafile );
    Py_DECREF( par_cafile );
    par_cafile = NULL;

    CHECK_OBJECT( (PyObject *)par_capath );
    Py_DECREF( par_capath );
    par_capath = NULL;

    CHECK_OBJECT( (PyObject *)par_cadata );
    Py_DECREF( par_cadata );
    par_cadata = NULL;

    CHECK_OBJECT( (PyObject *)var_context );
    Py_DECREF( var_context );
    var_context = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_purpose );
    Py_DECREF( par_purpose );
    par_purpose = NULL;

    CHECK_OBJECT( (PyObject *)par_cafile );
    Py_DECREF( par_cafile );
    par_cafile = NULL;

    CHECK_OBJECT( (PyObject *)par_capath );
    Py_DECREF( par_capath );
    par_capath = NULL;

    CHECK_OBJECT( (PyObject *)par_cadata );
    Py_DECREF( par_cadata );
    par_cadata = NULL;

    Py_XDECREF( var_context );
    var_context = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_38_create_default_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_39__create_unverified_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_protocol = python_pars[ 0 ];
    PyObject *par_cert_reqs = python_pars[ 1 ];
    PyObject *par_check_hostname = python_pars[ 2 ];
    PyObject *par_purpose = python_pars[ 3 ];
    PyObject *par_certfile = python_pars[ 4 ];
    PyObject *par_keyfile = python_pars[ 5 ];
    PyObject *par_cafile = python_pars[ 6 ];
    PyObject *par_capath = python_pars[ 7 ];
    PyObject *par_cadata = python_pars[ 8 ];
    PyObject *var_context = NULL;
    struct Nuitka_FrameObject *frame_e4273329f84da578e5b0c2c0ef1fb7e3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_e4273329f84da578e5b0c2c0ef1fb7e3 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e4273329f84da578e5b0c2c0ef1fb7e3, codeobj_e4273329f84da578e5b0c2c0ef1fb7e3, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e4273329f84da578e5b0c2c0ef1fb7e3 = cache_frame_e4273329f84da578e5b0c2c0ef1fb7e3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e4273329f84da578e5b0c2c0ef1fb7e3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e4273329f84da578e5b0c2c0ef1fb7e3 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_purpose );
        tmp_isinstance_inst_1 = par_purpose;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ASN1Object );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ASN1Object );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ASN1Object" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 592;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 592;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 592;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            CHECK_OBJECT( par_purpose );
            tmp_make_exception_arg_1 = par_purpose;
            frame_e4273329f84da578e5b0c2c0ef1fb7e3->m_frame.f_lineno = 593;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 593;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 598;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_protocol );
        tmp_args_element_name_1 = par_protocol;
        frame_e4273329f84da578e5b0c2c0ef1fb7e3->m_frame.f_lineno = 598;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 598;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_context == NULL );
        var_context = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( par_check_hostname );
        tmp_operand_name_2 = par_check_hostname;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 600;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            tmp_assattr_name_1 = Py_False;
            CHECK_OBJECT( var_context );
            tmp_assattr_target_1 = var_context;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_check_hostname, tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 601;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_cert_reqs );
        tmp_compexpr_left_1 = par_cert_reqs;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_3 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT( par_cert_reqs );
            tmp_assattr_name_2 = par_cert_reqs;
            CHECK_OBJECT( var_context );
            tmp_assattr_target_2 = var_context;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_verify_mode, tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 603;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_check_hostname );
        tmp_truth_name_1 = CHECK_IF_TRUE( par_check_hostname );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 604;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_assattr_name_3;
            PyObject *tmp_assattr_target_3;
            tmp_assattr_name_3 = Py_True;
            CHECK_OBJECT( var_context );
            tmp_assattr_target_3 = var_context;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_check_hostname, tmp_assattr_name_3 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 605;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        int tmp_truth_name_2;
        PyObject *tmp_operand_name_3;
        CHECK_OBJECT( par_keyfile );
        tmp_truth_name_2 = CHECK_IF_TRUE( par_keyfile );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 607;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_certfile );
        tmp_operand_name_3 = par_certfile;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 607;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_5 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_5 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_d2f106a7c85896a5d2d135f72c5b78b7;
            frame_e4273329f84da578e5b0c2c0ef1fb7e3->m_frame.f_lineno = 608;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 608;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_5:;
    }
    {
        nuitka_bool tmp_condition_result_6;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        int tmp_truth_name_3;
        int tmp_truth_name_4;
        CHECK_OBJECT( par_certfile );
        tmp_truth_name_3 = CHECK_IF_TRUE( par_certfile );
        if ( tmp_truth_name_3 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 609;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( par_keyfile );
        tmp_truth_name_4 = CHECK_IF_TRUE( par_keyfile );
        if ( tmp_truth_name_4 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 609;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_1 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_6 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_6 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( var_context );
            tmp_called_instance_1 = var_context;
            CHECK_OBJECT( par_certfile );
            tmp_args_element_name_2 = par_certfile;
            CHECK_OBJECT( par_keyfile );
            tmp_args_element_name_3 = par_keyfile;
            frame_e4273329f84da578e5b0c2c0ef1fb7e3->m_frame.f_lineno = 610;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_load_cert_chain, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 610;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_6:;
    }
    {
        nuitka_bool tmp_condition_result_7;
        int tmp_or_left_truth_2;
        nuitka_bool tmp_or_left_value_2;
        nuitka_bool tmp_or_right_value_2;
        int tmp_truth_name_5;
        int tmp_or_left_truth_3;
        nuitka_bool tmp_or_left_value_3;
        nuitka_bool tmp_or_right_value_3;
        int tmp_truth_name_6;
        int tmp_truth_name_7;
        CHECK_OBJECT( par_cafile );
        tmp_truth_name_5 = CHECK_IF_TRUE( par_cafile );
        if ( tmp_truth_name_5 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 613;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_2 = tmp_truth_name_5 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_2 = tmp_or_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_2 == 1 )
        {
            goto or_left_2;
        }
        else
        {
            goto or_right_2;
        }
        or_right_2:;
        CHECK_OBJECT( par_capath );
        tmp_truth_name_6 = CHECK_IF_TRUE( par_capath );
        if ( tmp_truth_name_6 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 613;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_3 = tmp_truth_name_6 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_3 = tmp_or_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_3 == 1 )
        {
            goto or_left_3;
        }
        else
        {
            goto or_right_3;
        }
        or_right_3:;
        CHECK_OBJECT( par_cadata );
        tmp_truth_name_7 = CHECK_IF_TRUE( par_cadata );
        if ( tmp_truth_name_7 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 613;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_3 = tmp_truth_name_7 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_right_value_2 = tmp_or_right_value_3;
        goto or_end_3;
        or_left_3:;
        tmp_or_right_value_2 = tmp_or_left_value_3;
        or_end_3:;
        tmp_condition_result_7 = tmp_or_right_value_2;
        goto or_end_2;
        or_left_2:;
        tmp_condition_result_7 = tmp_or_left_value_2;
        or_end_2:;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_args_element_name_6;
            CHECK_OBJECT( var_context );
            tmp_called_instance_2 = var_context;
            CHECK_OBJECT( par_cafile );
            tmp_args_element_name_4 = par_cafile;
            CHECK_OBJECT( par_capath );
            tmp_args_element_name_5 = par_capath;
            CHECK_OBJECT( par_cadata );
            tmp_args_element_name_6 = par_cadata;
            frame_e4273329f84da578e5b0c2c0ef1fb7e3->m_frame.f_lineno = 614;
            {
                PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_2, const_str_plain_load_verify_locations, call_args );
            }

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 614;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        goto branch_end_7;
        branch_no_7:;
        {
            nuitka_bool tmp_condition_result_8;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT( var_context );
            tmp_source_name_1 = var_context;
            tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_verify_mode );
            if ( tmp_compexpr_left_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 615;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CERT_NONE );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CERT_NONE );
            }

            if ( tmp_mvar_value_3 == NULL )
            {
                Py_DECREF( tmp_compexpr_left_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CERT_NONE" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 615;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_3;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_left_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 615;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_8;
            }
            else
            {
                goto branch_no_8;
            }
            branch_yes_8:;
            {
                PyObject *tmp_called_instance_3;
                PyObject *tmp_call_result_3;
                PyObject *tmp_args_element_name_7;
                CHECK_OBJECT( var_context );
                tmp_called_instance_3 = var_context;
                CHECK_OBJECT( par_purpose );
                tmp_args_element_name_7 = par_purpose;
                frame_e4273329f84da578e5b0c2c0ef1fb7e3->m_frame.f_lineno = 619;
                {
                    PyObject *call_args[] = { tmp_args_element_name_7 };
                    tmp_call_result_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_load_default_certs, call_args );
                }

                if ( tmp_call_result_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 619;
                    type_description_1 = "oooooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_3 );
            }
            branch_no_8:;
        }
        branch_end_7:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e4273329f84da578e5b0c2c0ef1fb7e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e4273329f84da578e5b0c2c0ef1fb7e3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e4273329f84da578e5b0c2c0ef1fb7e3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e4273329f84da578e5b0c2c0ef1fb7e3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e4273329f84da578e5b0c2c0ef1fb7e3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e4273329f84da578e5b0c2c0ef1fb7e3,
        type_description_1,
        par_protocol,
        par_cert_reqs,
        par_check_hostname,
        par_purpose,
        par_certfile,
        par_keyfile,
        par_cafile,
        par_capath,
        par_cadata,
        var_context
    );


    // Release cached frame.
    if ( frame_e4273329f84da578e5b0c2c0ef1fb7e3 == cache_frame_e4273329f84da578e5b0c2c0ef1fb7e3 )
    {
        Py_DECREF( frame_e4273329f84da578e5b0c2c0ef1fb7e3 );
    }
    cache_frame_e4273329f84da578e5b0c2c0ef1fb7e3 = NULL;

    assertFrameObject( frame_e4273329f84da578e5b0c2c0ef1fb7e3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_context );
    tmp_return_value = var_context;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_39__create_unverified_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_protocol );
    Py_DECREF( par_protocol );
    par_protocol = NULL;

    CHECK_OBJECT( (PyObject *)par_cert_reqs );
    Py_DECREF( par_cert_reqs );
    par_cert_reqs = NULL;

    CHECK_OBJECT( (PyObject *)par_check_hostname );
    Py_DECREF( par_check_hostname );
    par_check_hostname = NULL;

    CHECK_OBJECT( (PyObject *)par_purpose );
    Py_DECREF( par_purpose );
    par_purpose = NULL;

    CHECK_OBJECT( (PyObject *)par_certfile );
    Py_DECREF( par_certfile );
    par_certfile = NULL;

    CHECK_OBJECT( (PyObject *)par_keyfile );
    Py_DECREF( par_keyfile );
    par_keyfile = NULL;

    CHECK_OBJECT( (PyObject *)par_cafile );
    Py_DECREF( par_cafile );
    par_cafile = NULL;

    CHECK_OBJECT( (PyObject *)par_capath );
    Py_DECREF( par_capath );
    par_capath = NULL;

    CHECK_OBJECT( (PyObject *)par_cadata );
    Py_DECREF( par_cadata );
    par_cadata = NULL;

    CHECK_OBJECT( (PyObject *)var_context );
    Py_DECREF( var_context );
    var_context = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_protocol );
    Py_DECREF( par_protocol );
    par_protocol = NULL;

    CHECK_OBJECT( (PyObject *)par_cert_reqs );
    Py_DECREF( par_cert_reqs );
    par_cert_reqs = NULL;

    CHECK_OBJECT( (PyObject *)par_check_hostname );
    Py_DECREF( par_check_hostname );
    par_check_hostname = NULL;

    CHECK_OBJECT( (PyObject *)par_purpose );
    Py_DECREF( par_purpose );
    par_purpose = NULL;

    CHECK_OBJECT( (PyObject *)par_certfile );
    Py_DECREF( par_certfile );
    par_certfile = NULL;

    CHECK_OBJECT( (PyObject *)par_keyfile );
    Py_DECREF( par_keyfile );
    par_keyfile = NULL;

    CHECK_OBJECT( (PyObject *)par_cafile );
    Py_DECREF( par_cafile );
    par_cafile = NULL;

    CHECK_OBJECT( (PyObject *)par_capath );
    Py_DECREF( par_capath );
    par_capath = NULL;

    CHECK_OBJECT( (PyObject *)par_cadata );
    Py_DECREF( par_cadata );
    par_cadata = NULL;

    Py_XDECREF( var_context );
    var_context = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_39__create_unverified_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_40___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_8a26c3fb8c2d5b0dc5ca8006ca18f426;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8a26c3fb8c2d5b0dc5ca8006ca18f426 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8a26c3fb8c2d5b0dc5ca8006ca18f426, codeobj_8a26c3fb8c2d5b0dc5ca8006ca18f426, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8a26c3fb8c2d5b0dc5ca8006ca18f426 = cache_frame_8a26c3fb8c2d5b0dc5ca8006ca18f426;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8a26c3fb8c2d5b0dc5ca8006ca18f426 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8a26c3fb8c2d5b0dc5ca8006ca18f426 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_string_concat_values_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_format_value_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_format_spec_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 648;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_format_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___name__ );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_format_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 648;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_format_spec_1 = const_str_empty;
        tmp_tuple_element_1 = BUILTIN_FORMAT( tmp_format_value_1, tmp_format_spec_1 );
        Py_DECREF( tmp_format_value_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 648;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_string_concat_values_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_string_concat_values_1, 0, tmp_tuple_element_1 );
        tmp_tuple_element_1 = const_str_digest_e8ba3556e5c659d7313d4a7290713be4;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_string_concat_values_1, 1, tmp_tuple_element_1 );
        tmp_make_exception_arg_1 = PyUnicode_Join( const_str_empty, tmp_string_concat_values_1 );
        Py_DECREF( tmp_string_concat_values_1 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 648;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_8a26c3fb8c2d5b0dc5ca8006ca18f426->m_frame.f_lineno = 647;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 647;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a26c3fb8c2d5b0dc5ca8006ca18f426 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a26c3fb8c2d5b0dc5ca8006ca18f426 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8a26c3fb8c2d5b0dc5ca8006ca18f426, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8a26c3fb8c2d5b0dc5ca8006ca18f426->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8a26c3fb8c2d5b0dc5ca8006ca18f426, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8a26c3fb8c2d5b0dc5ca8006ca18f426,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_8a26c3fb8c2d5b0dc5ca8006ca18f426 == cache_frame_8a26c3fb8c2d5b0dc5ca8006ca18f426 )
    {
        Py_DECREF( frame_8a26c3fb8c2d5b0dc5ca8006ca18f426 );
    }
    cache_frame_8a26c3fb8c2d5b0dc5ca8006ca18f426 = NULL;

    assertFrameObject( frame_8a26c3fb8c2d5b0dc5ca8006ca18f426 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_40___init__ );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_40___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_ssl$$$function_41__create( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_incoming = python_pars[ 1 ];
    PyObject *par_outgoing = python_pars[ 2 ];
    PyObject *par_server_side = python_pars[ 3 ];
    PyObject *par_server_hostname = python_pars[ 4 ];
    PyObject *par_session = python_pars[ 5 ];
    PyObject *par_context = python_pars[ 6 ];
    PyObject *var_self = NULL;
    PyObject *var_sslobj = NULL;
    struct Nuitka_FrameObject *frame_78af8d33dbb832741c0ebdb2e3d0021a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_78af8d33dbb832741c0ebdb2e3d0021a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_78af8d33dbb832741c0ebdb2e3d0021a, codeobj_78af8d33dbb832741c0ebdb2e3d0021a, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_78af8d33dbb832741c0ebdb2e3d0021a = cache_frame_78af8d33dbb832741c0ebdb2e3d0021a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_78af8d33dbb832741c0ebdb2e3d0021a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_78af8d33dbb832741c0ebdb2e3d0021a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_cls );
        tmp_called_instance_1 = par_cls;
        CHECK_OBJECT( par_cls );
        tmp_args_element_name_1 = par_cls;
        frame_78af8d33dbb832741c0ebdb2e3d0021a->m_frame.f_lineno = 655;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___new__, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 655;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_self == NULL );
        var_self = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        CHECK_OBJECT( par_context );
        tmp_source_name_1 = par_context;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__wrap_bio );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 656;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_incoming );
        tmp_tuple_element_1 = par_incoming;
        tmp_args_name_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_outgoing );
        tmp_tuple_element_1 = par_outgoing;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
        tmp_dict_key_1 = const_str_plain_server_side;
        CHECK_OBJECT( par_server_side );
        tmp_dict_value_1 = par_server_side;
        tmp_kw_name_1 = _PyDict_NewPresized( 4 );
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_2 = const_str_plain_server_hostname;
        CHECK_OBJECT( par_server_hostname );
        tmp_dict_value_2 = par_server_hostname;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_3 = const_str_plain_owner;
        CHECK_OBJECT( var_self );
        tmp_dict_value_3 = var_self;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_4 = const_str_plain_session;
        CHECK_OBJECT( par_session );
        tmp_dict_value_4 = par_session;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
        assert( !(tmp_res != 0) );
        frame_78af8d33dbb832741c0ebdb2e3d0021a->m_frame.f_lineno = 656;
        tmp_assign_source_2 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 656;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_sslobj == NULL );
        var_sslobj = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( var_sslobj );
        tmp_assattr_name_1 = var_sslobj;
        CHECK_OBJECT( var_self );
        tmp_assattr_target_1 = var_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__sslobj, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 661;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_78af8d33dbb832741c0ebdb2e3d0021a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_78af8d33dbb832741c0ebdb2e3d0021a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_78af8d33dbb832741c0ebdb2e3d0021a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_78af8d33dbb832741c0ebdb2e3d0021a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_78af8d33dbb832741c0ebdb2e3d0021a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_78af8d33dbb832741c0ebdb2e3d0021a,
        type_description_1,
        par_cls,
        par_incoming,
        par_outgoing,
        par_server_side,
        par_server_hostname,
        par_session,
        par_context,
        var_self,
        var_sslobj
    );


    // Release cached frame.
    if ( frame_78af8d33dbb832741c0ebdb2e3d0021a == cache_frame_78af8d33dbb832741c0ebdb2e3d0021a )
    {
        Py_DECREF( frame_78af8d33dbb832741c0ebdb2e3d0021a );
    }
    cache_frame_78af8d33dbb832741c0ebdb2e3d0021a = NULL;

    assertFrameObject( frame_78af8d33dbb832741c0ebdb2e3d0021a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_self );
    tmp_return_value = var_self;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_41__create );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_incoming );
    Py_DECREF( par_incoming );
    par_incoming = NULL;

    CHECK_OBJECT( (PyObject *)par_outgoing );
    Py_DECREF( par_outgoing );
    par_outgoing = NULL;

    CHECK_OBJECT( (PyObject *)par_server_side );
    Py_DECREF( par_server_side );
    par_server_side = NULL;

    CHECK_OBJECT( (PyObject *)par_server_hostname );
    Py_DECREF( par_server_hostname );
    par_server_hostname = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    CHECK_OBJECT( (PyObject *)var_self );
    Py_DECREF( var_self );
    var_self = NULL;

    CHECK_OBJECT( (PyObject *)var_sslobj );
    Py_DECREF( var_sslobj );
    var_sslobj = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_incoming );
    Py_DECREF( par_incoming );
    par_incoming = NULL;

    CHECK_OBJECT( (PyObject *)par_outgoing );
    Py_DECREF( par_outgoing );
    par_outgoing = NULL;

    CHECK_OBJECT( (PyObject *)par_server_side );
    Py_DECREF( par_server_side );
    par_server_side = NULL;

    CHECK_OBJECT( (PyObject *)par_server_hostname );
    Py_DECREF( par_server_hostname );
    par_server_hostname = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    Py_XDECREF( var_self );
    var_self = NULL;

    Py_XDECREF( var_sslobj );
    var_sslobj = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_41__create );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_42_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_155bafd0723162e3e798ef484b14cd90;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_155bafd0723162e3e798ef484b14cd90 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_155bafd0723162e3e798ef484b14cd90, codeobj_155bafd0723162e3e798ef484b14cd90, module_ssl, sizeof(void *) );
    frame_155bafd0723162e3e798ef484b14cd90 = cache_frame_155bafd0723162e3e798ef484b14cd90;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_155bafd0723162e3e798ef484b14cd90 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_155bafd0723162e3e798ef484b14cd90 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 667;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_context );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 667;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_155bafd0723162e3e798ef484b14cd90 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_155bafd0723162e3e798ef484b14cd90 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_155bafd0723162e3e798ef484b14cd90 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_155bafd0723162e3e798ef484b14cd90, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_155bafd0723162e3e798ef484b14cd90->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_155bafd0723162e3e798ef484b14cd90, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_155bafd0723162e3e798ef484b14cd90,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_155bafd0723162e3e798ef484b14cd90 == cache_frame_155bafd0723162e3e798ef484b14cd90 )
    {
        Py_DECREF( frame_155bafd0723162e3e798ef484b14cd90 );
    }
    cache_frame_155bafd0723162e3e798ef484b14cd90 = NULL;

    assertFrameObject( frame_155bafd0723162e3e798ef484b14cd90 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_42_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_42_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_43_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_ctx = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_b025c5ada52dfc27ae3723ad4341ada3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b025c5ada52dfc27ae3723ad4341ada3 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b025c5ada52dfc27ae3723ad4341ada3, codeobj_b025c5ada52dfc27ae3723ad4341ada3, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_b025c5ada52dfc27ae3723ad4341ada3 = cache_frame_b025c5ada52dfc27ae3723ad4341ada3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b025c5ada52dfc27ae3723ad4341ada3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b025c5ada52dfc27ae3723ad4341ada3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_ctx );
        tmp_assattr_name_1 = par_ctx;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_assattr_target_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_assattr_target_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 671;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_context, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_target_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 671;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b025c5ada52dfc27ae3723ad4341ada3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b025c5ada52dfc27ae3723ad4341ada3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b025c5ada52dfc27ae3723ad4341ada3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b025c5ada52dfc27ae3723ad4341ada3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b025c5ada52dfc27ae3723ad4341ada3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b025c5ada52dfc27ae3723ad4341ada3,
        type_description_1,
        par_self,
        par_ctx
    );


    // Release cached frame.
    if ( frame_b025c5ada52dfc27ae3723ad4341ada3 == cache_frame_b025c5ada52dfc27ae3723ad4341ada3 )
    {
        Py_DECREF( frame_b025c5ada52dfc27ae3723ad4341ada3 );
    }
    cache_frame_b025c5ada52dfc27ae3723ad4341ada3 = NULL;

    assertFrameObject( frame_b025c5ada52dfc27ae3723ad4341ada3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_43_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_ctx );
    Py_DECREF( par_ctx );
    par_ctx = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_ctx );
    Py_DECREF( par_ctx );
    par_ctx = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_43_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_44_session( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_150a7fc04f06617735354ee03a3a1379;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_150a7fc04f06617735354ee03a3a1379 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_150a7fc04f06617735354ee03a3a1379, codeobj_150a7fc04f06617735354ee03a3a1379, module_ssl, sizeof(void *) );
    frame_150a7fc04f06617735354ee03a3a1379 = cache_frame_150a7fc04f06617735354ee03a3a1379;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_150a7fc04f06617735354ee03a3a1379 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_150a7fc04f06617735354ee03a3a1379 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 676;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_session );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 676;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_150a7fc04f06617735354ee03a3a1379 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_150a7fc04f06617735354ee03a3a1379 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_150a7fc04f06617735354ee03a3a1379 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_150a7fc04f06617735354ee03a3a1379, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_150a7fc04f06617735354ee03a3a1379->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_150a7fc04f06617735354ee03a3a1379, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_150a7fc04f06617735354ee03a3a1379,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_150a7fc04f06617735354ee03a3a1379 == cache_frame_150a7fc04f06617735354ee03a3a1379 )
    {
        Py_DECREF( frame_150a7fc04f06617735354ee03a3a1379 );
    }
    cache_frame_150a7fc04f06617735354ee03a3a1379 = NULL;

    assertFrameObject( frame_150a7fc04f06617735354ee03a3a1379 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_44_session );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_44_session );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_45_session( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_session = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_0cab748c09d01cef1fc04469feb036ab;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_0cab748c09d01cef1fc04469feb036ab = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0cab748c09d01cef1fc04469feb036ab, codeobj_0cab748c09d01cef1fc04469feb036ab, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_0cab748c09d01cef1fc04469feb036ab = cache_frame_0cab748c09d01cef1fc04469feb036ab;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0cab748c09d01cef1fc04469feb036ab );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0cab748c09d01cef1fc04469feb036ab ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_session );
        tmp_assattr_name_1 = par_session;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_assattr_target_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_assattr_target_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 680;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_session, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_target_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 680;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0cab748c09d01cef1fc04469feb036ab );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0cab748c09d01cef1fc04469feb036ab );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0cab748c09d01cef1fc04469feb036ab, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0cab748c09d01cef1fc04469feb036ab->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0cab748c09d01cef1fc04469feb036ab, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0cab748c09d01cef1fc04469feb036ab,
        type_description_1,
        par_self,
        par_session
    );


    // Release cached frame.
    if ( frame_0cab748c09d01cef1fc04469feb036ab == cache_frame_0cab748c09d01cef1fc04469feb036ab )
    {
        Py_DECREF( frame_0cab748c09d01cef1fc04469feb036ab );
    }
    cache_frame_0cab748c09d01cef1fc04469feb036ab = NULL;

    assertFrameObject( frame_0cab748c09d01cef1fc04469feb036ab );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_45_session );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_45_session );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_46_session_reused( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_3d426fcde832f96f9fefe61110c3597f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3d426fcde832f96f9fefe61110c3597f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3d426fcde832f96f9fefe61110c3597f, codeobj_3d426fcde832f96f9fefe61110c3597f, module_ssl, sizeof(void *) );
    frame_3d426fcde832f96f9fefe61110c3597f = cache_frame_3d426fcde832f96f9fefe61110c3597f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3d426fcde832f96f9fefe61110c3597f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3d426fcde832f96f9fefe61110c3597f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 685;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_session_reused );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 685;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d426fcde832f96f9fefe61110c3597f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d426fcde832f96f9fefe61110c3597f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d426fcde832f96f9fefe61110c3597f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3d426fcde832f96f9fefe61110c3597f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3d426fcde832f96f9fefe61110c3597f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3d426fcde832f96f9fefe61110c3597f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3d426fcde832f96f9fefe61110c3597f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_3d426fcde832f96f9fefe61110c3597f == cache_frame_3d426fcde832f96f9fefe61110c3597f )
    {
        Py_DECREF( frame_3d426fcde832f96f9fefe61110c3597f );
    }
    cache_frame_3d426fcde832f96f9fefe61110c3597f = NULL;

    assertFrameObject( frame_3d426fcde832f96f9fefe61110c3597f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_46_session_reused );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_46_session_reused );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_47_server_side( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_af887c87284bed61555d654364a46bbc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_af887c87284bed61555d654364a46bbc = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_af887c87284bed61555d654364a46bbc, codeobj_af887c87284bed61555d654364a46bbc, module_ssl, sizeof(void *) );
    frame_af887c87284bed61555d654364a46bbc = cache_frame_af887c87284bed61555d654364a46bbc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_af887c87284bed61555d654364a46bbc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_af887c87284bed61555d654364a46bbc ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 690;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_server_side );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 690;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_af887c87284bed61555d654364a46bbc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_af887c87284bed61555d654364a46bbc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_af887c87284bed61555d654364a46bbc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_af887c87284bed61555d654364a46bbc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_af887c87284bed61555d654364a46bbc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_af887c87284bed61555d654364a46bbc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_af887c87284bed61555d654364a46bbc,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_af887c87284bed61555d654364a46bbc == cache_frame_af887c87284bed61555d654364a46bbc )
    {
        Py_DECREF( frame_af887c87284bed61555d654364a46bbc );
    }
    cache_frame_af887c87284bed61555d654364a46bbc = NULL;

    assertFrameObject( frame_af887c87284bed61555d654364a46bbc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_47_server_side );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_47_server_side );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_48_server_hostname( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_148ded5e31bfc43993a6f070cc228356;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_148ded5e31bfc43993a6f070cc228356 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_148ded5e31bfc43993a6f070cc228356, codeobj_148ded5e31bfc43993a6f070cc228356, module_ssl, sizeof(void *) );
    frame_148ded5e31bfc43993a6f070cc228356 = cache_frame_148ded5e31bfc43993a6f070cc228356;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_148ded5e31bfc43993a6f070cc228356 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_148ded5e31bfc43993a6f070cc228356 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 696;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_server_hostname );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 696;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_148ded5e31bfc43993a6f070cc228356 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_148ded5e31bfc43993a6f070cc228356 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_148ded5e31bfc43993a6f070cc228356 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_148ded5e31bfc43993a6f070cc228356, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_148ded5e31bfc43993a6f070cc228356->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_148ded5e31bfc43993a6f070cc228356, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_148ded5e31bfc43993a6f070cc228356,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_148ded5e31bfc43993a6f070cc228356 == cache_frame_148ded5e31bfc43993a6f070cc228356 )
    {
        Py_DECREF( frame_148ded5e31bfc43993a6f070cc228356 );
    }
    cache_frame_148ded5e31bfc43993a6f070cc228356 = NULL;

    assertFrameObject( frame_148ded5e31bfc43993a6f070cc228356 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_48_server_hostname );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_48_server_hostname );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_49_read( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_len = python_pars[ 1 ];
    PyObject *par_buffer = python_pars[ 2 ];
    PyObject *var_v = NULL;
    struct Nuitka_FrameObject *frame_83f840bc627e14b2df37f66978eee02e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_83f840bc627e14b2df37f66978eee02e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_83f840bc627e14b2df37f66978eee02e, codeobj_83f840bc627e14b2df37f66978eee02e, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_83f840bc627e14b2df37f66978eee02e = cache_frame_83f840bc627e14b2df37f66978eee02e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_83f840bc627e14b2df37f66978eee02e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_83f840bc627e14b2df37f66978eee02e ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_buffer );
        tmp_compexpr_left_1 = par_buffer;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 705;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_len );
            tmp_args_element_name_1 = par_len;
            CHECK_OBJECT( par_buffer );
            tmp_args_element_name_2 = par_buffer;
            frame_83f840bc627e14b2df37f66978eee02e->m_frame.f_lineno = 705;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_read, call_args );
            }

            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 705;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_v == NULL );
            var_v = tmp_assign_source_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 707;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_len );
            tmp_args_element_name_3 = par_len;
            frame_83f840bc627e14b2df37f66978eee02e->m_frame.f_lineno = 707;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_read, call_args );
            }

            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 707;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_v == NULL );
            var_v = tmp_assign_source_2;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_83f840bc627e14b2df37f66978eee02e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_83f840bc627e14b2df37f66978eee02e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_83f840bc627e14b2df37f66978eee02e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_83f840bc627e14b2df37f66978eee02e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_83f840bc627e14b2df37f66978eee02e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_83f840bc627e14b2df37f66978eee02e,
        type_description_1,
        par_self,
        par_len,
        par_buffer,
        var_v
    );


    // Release cached frame.
    if ( frame_83f840bc627e14b2df37f66978eee02e == cache_frame_83f840bc627e14b2df37f66978eee02e )
    {
        Py_DECREF( frame_83f840bc627e14b2df37f66978eee02e );
    }
    cache_frame_83f840bc627e14b2df37f66978eee02e = NULL;

    assertFrameObject( frame_83f840bc627e14b2df37f66978eee02e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_v );
    tmp_return_value = var_v;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_49_read );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_len );
    Py_DECREF( par_len );
    par_len = NULL;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_v );
    Py_DECREF( var_v );
    var_v = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_len );
    Py_DECREF( par_len );
    par_len = NULL;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_49_read );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_50_write( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_data = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_4bc9b1ac077eede44b66bfacb2b34b9c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4bc9b1ac077eede44b66bfacb2b34b9c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4bc9b1ac077eede44b66bfacb2b34b9c, codeobj_4bc9b1ac077eede44b66bfacb2b34b9c, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_4bc9b1ac077eede44b66bfacb2b34b9c = cache_frame_4bc9b1ac077eede44b66bfacb2b34b9c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4bc9b1ac077eede44b66bfacb2b34b9c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4bc9b1ac077eede44b66bfacb2b34b9c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 716;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_data );
        tmp_args_element_name_1 = par_data;
        frame_4bc9b1ac077eede44b66bfacb2b34b9c->m_frame.f_lineno = 716;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_write, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 716;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bc9b1ac077eede44b66bfacb2b34b9c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bc9b1ac077eede44b66bfacb2b34b9c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bc9b1ac077eede44b66bfacb2b34b9c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4bc9b1ac077eede44b66bfacb2b34b9c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4bc9b1ac077eede44b66bfacb2b34b9c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4bc9b1ac077eede44b66bfacb2b34b9c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4bc9b1ac077eede44b66bfacb2b34b9c,
        type_description_1,
        par_self,
        par_data
    );


    // Release cached frame.
    if ( frame_4bc9b1ac077eede44b66bfacb2b34b9c == cache_frame_4bc9b1ac077eede44b66bfacb2b34b9c )
    {
        Py_DECREF( frame_4bc9b1ac077eede44b66bfacb2b34b9c );
    }
    cache_frame_4bc9b1ac077eede44b66bfacb2b34b9c = NULL;

    assertFrameObject( frame_4bc9b1ac077eede44b66bfacb2b34b9c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_50_write );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_50_write );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_51_getpeercert( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_binary_form = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_0afdd5e99178c32be659fdceadf23330;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0afdd5e99178c32be659fdceadf23330 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0afdd5e99178c32be659fdceadf23330, codeobj_0afdd5e99178c32be659fdceadf23330, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_0afdd5e99178c32be659fdceadf23330 = cache_frame_0afdd5e99178c32be659fdceadf23330;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0afdd5e99178c32be659fdceadf23330 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0afdd5e99178c32be659fdceadf23330 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 725;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_binary_form );
        tmp_args_element_name_1 = par_binary_form;
        frame_0afdd5e99178c32be659fdceadf23330->m_frame.f_lineno = 725;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_getpeercert, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 725;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0afdd5e99178c32be659fdceadf23330 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0afdd5e99178c32be659fdceadf23330 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0afdd5e99178c32be659fdceadf23330 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0afdd5e99178c32be659fdceadf23330, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0afdd5e99178c32be659fdceadf23330->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0afdd5e99178c32be659fdceadf23330, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0afdd5e99178c32be659fdceadf23330,
        type_description_1,
        par_self,
        par_binary_form
    );


    // Release cached frame.
    if ( frame_0afdd5e99178c32be659fdceadf23330 == cache_frame_0afdd5e99178c32be659fdceadf23330 )
    {
        Py_DECREF( frame_0afdd5e99178c32be659fdceadf23330 );
    }
    cache_frame_0afdd5e99178c32be659fdceadf23330 = NULL;

    assertFrameObject( frame_0afdd5e99178c32be659fdceadf23330 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_51_getpeercert );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_binary_form );
    Py_DECREF( par_binary_form );
    par_binary_form = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_binary_form );
    Py_DECREF( par_binary_form );
    par_binary_form = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_51_getpeercert );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_52_selected_npn_protocol( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d5b89644963ce7577c3e54aec3b26352;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_d5b89644963ce7577c3e54aec3b26352 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d5b89644963ce7577c3e54aec3b26352, codeobj_d5b89644963ce7577c3e54aec3b26352, module_ssl, sizeof(void *) );
    frame_d5b89644963ce7577c3e54aec3b26352 = cache_frame_d5b89644963ce7577c3e54aec3b26352;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d5b89644963ce7577c3e54aec3b26352 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d5b89644963ce7577c3e54aec3b26352 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 731;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_HAS_NPN );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 731;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 731;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 732;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_d5b89644963ce7577c3e54aec3b26352->m_frame.f_lineno = 732;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_selected_npn_protocol );
            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 732;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d5b89644963ce7577c3e54aec3b26352 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d5b89644963ce7577c3e54aec3b26352 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d5b89644963ce7577c3e54aec3b26352 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d5b89644963ce7577c3e54aec3b26352, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d5b89644963ce7577c3e54aec3b26352->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d5b89644963ce7577c3e54aec3b26352, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d5b89644963ce7577c3e54aec3b26352,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d5b89644963ce7577c3e54aec3b26352 == cache_frame_d5b89644963ce7577c3e54aec3b26352 )
    {
        Py_DECREF( frame_d5b89644963ce7577c3e54aec3b26352 );
    }
    cache_frame_d5b89644963ce7577c3e54aec3b26352 = NULL;

    assertFrameObject( frame_d5b89644963ce7577c3e54aec3b26352 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_52_selected_npn_protocol );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_52_selected_npn_protocol );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_53_selected_alpn_protocol( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_0efd15d2dbf254a6a5ea212c2e808164;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0efd15d2dbf254a6a5ea212c2e808164 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0efd15d2dbf254a6a5ea212c2e808164, codeobj_0efd15d2dbf254a6a5ea212c2e808164, module_ssl, sizeof(void *) );
    frame_0efd15d2dbf254a6a5ea212c2e808164 = cache_frame_0efd15d2dbf254a6a5ea212c2e808164;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0efd15d2dbf254a6a5ea212c2e808164 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0efd15d2dbf254a6a5ea212c2e808164 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 738;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_HAS_ALPN );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 738;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 738;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 739;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_0efd15d2dbf254a6a5ea212c2e808164->m_frame.f_lineno = 739;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_selected_alpn_protocol );
            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 739;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0efd15d2dbf254a6a5ea212c2e808164 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0efd15d2dbf254a6a5ea212c2e808164 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0efd15d2dbf254a6a5ea212c2e808164 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0efd15d2dbf254a6a5ea212c2e808164, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0efd15d2dbf254a6a5ea212c2e808164->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0efd15d2dbf254a6a5ea212c2e808164, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0efd15d2dbf254a6a5ea212c2e808164,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0efd15d2dbf254a6a5ea212c2e808164 == cache_frame_0efd15d2dbf254a6a5ea212c2e808164 )
    {
        Py_DECREF( frame_0efd15d2dbf254a6a5ea212c2e808164 );
    }
    cache_frame_0efd15d2dbf254a6a5ea212c2e808164 = NULL;

    assertFrameObject( frame_0efd15d2dbf254a6a5ea212c2e808164 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_53_selected_alpn_protocol );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_53_selected_alpn_protocol );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_54_cipher( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_09f1bb5201b8ef073955738188ca32ac;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_09f1bb5201b8ef073955738188ca32ac = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_09f1bb5201b8ef073955738188ca32ac, codeobj_09f1bb5201b8ef073955738188ca32ac, module_ssl, sizeof(void *) );
    frame_09f1bb5201b8ef073955738188ca32ac = cache_frame_09f1bb5201b8ef073955738188ca32ac;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_09f1bb5201b8ef073955738188ca32ac );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_09f1bb5201b8ef073955738188ca32ac ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 744;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_09f1bb5201b8ef073955738188ca32ac->m_frame.f_lineno = 744;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_cipher );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 744;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_09f1bb5201b8ef073955738188ca32ac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_09f1bb5201b8ef073955738188ca32ac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_09f1bb5201b8ef073955738188ca32ac );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_09f1bb5201b8ef073955738188ca32ac, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_09f1bb5201b8ef073955738188ca32ac->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_09f1bb5201b8ef073955738188ca32ac, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_09f1bb5201b8ef073955738188ca32ac,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_09f1bb5201b8ef073955738188ca32ac == cache_frame_09f1bb5201b8ef073955738188ca32ac )
    {
        Py_DECREF( frame_09f1bb5201b8ef073955738188ca32ac );
    }
    cache_frame_09f1bb5201b8ef073955738188ca32ac = NULL;

    assertFrameObject( frame_09f1bb5201b8ef073955738188ca32ac );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_54_cipher );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_54_cipher );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_55_shared_ciphers( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_4c16b3b8e78753d108f56368b6107e65;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4c16b3b8e78753d108f56368b6107e65 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4c16b3b8e78753d108f56368b6107e65, codeobj_4c16b3b8e78753d108f56368b6107e65, module_ssl, sizeof(void *) );
    frame_4c16b3b8e78753d108f56368b6107e65 = cache_frame_4c16b3b8e78753d108f56368b6107e65;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4c16b3b8e78753d108f56368b6107e65 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4c16b3b8e78753d108f56368b6107e65 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 750;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_4c16b3b8e78753d108f56368b6107e65->m_frame.f_lineno = 750;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_shared_ciphers );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 750;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4c16b3b8e78753d108f56368b6107e65 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4c16b3b8e78753d108f56368b6107e65 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4c16b3b8e78753d108f56368b6107e65 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4c16b3b8e78753d108f56368b6107e65, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4c16b3b8e78753d108f56368b6107e65->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4c16b3b8e78753d108f56368b6107e65, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4c16b3b8e78753d108f56368b6107e65,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_4c16b3b8e78753d108f56368b6107e65 == cache_frame_4c16b3b8e78753d108f56368b6107e65 )
    {
        Py_DECREF( frame_4c16b3b8e78753d108f56368b6107e65 );
    }
    cache_frame_4c16b3b8e78753d108f56368b6107e65 = NULL;

    assertFrameObject( frame_4c16b3b8e78753d108f56368b6107e65 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_55_shared_ciphers );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_55_shared_ciphers );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_56_compression( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_c84cff19f5ca70203b24d6ffa781b6c6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c84cff19f5ca70203b24d6ffa781b6c6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c84cff19f5ca70203b24d6ffa781b6c6, codeobj_c84cff19f5ca70203b24d6ffa781b6c6, module_ssl, sizeof(void *) );
    frame_c84cff19f5ca70203b24d6ffa781b6c6 = cache_frame_c84cff19f5ca70203b24d6ffa781b6c6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c84cff19f5ca70203b24d6ffa781b6c6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c84cff19f5ca70203b24d6ffa781b6c6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 755;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_c84cff19f5ca70203b24d6ffa781b6c6->m_frame.f_lineno = 755;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_compression );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 755;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c84cff19f5ca70203b24d6ffa781b6c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c84cff19f5ca70203b24d6ffa781b6c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c84cff19f5ca70203b24d6ffa781b6c6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c84cff19f5ca70203b24d6ffa781b6c6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c84cff19f5ca70203b24d6ffa781b6c6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c84cff19f5ca70203b24d6ffa781b6c6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c84cff19f5ca70203b24d6ffa781b6c6,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c84cff19f5ca70203b24d6ffa781b6c6 == cache_frame_c84cff19f5ca70203b24d6ffa781b6c6 )
    {
        Py_DECREF( frame_c84cff19f5ca70203b24d6ffa781b6c6 );
    }
    cache_frame_c84cff19f5ca70203b24d6ffa781b6c6 = NULL;

    assertFrameObject( frame_c84cff19f5ca70203b24d6ffa781b6c6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_56_compression );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_56_compression );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_57_pending( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_3ecf3a2c062154f40f3b43857fadfa1b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3ecf3a2c062154f40f3b43857fadfa1b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3ecf3a2c062154f40f3b43857fadfa1b, codeobj_3ecf3a2c062154f40f3b43857fadfa1b, module_ssl, sizeof(void *) );
    frame_3ecf3a2c062154f40f3b43857fadfa1b = cache_frame_3ecf3a2c062154f40f3b43857fadfa1b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3ecf3a2c062154f40f3b43857fadfa1b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3ecf3a2c062154f40f3b43857fadfa1b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 759;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_3ecf3a2c062154f40f3b43857fadfa1b->m_frame.f_lineno = 759;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_pending );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 759;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ecf3a2c062154f40f3b43857fadfa1b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ecf3a2c062154f40f3b43857fadfa1b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ecf3a2c062154f40f3b43857fadfa1b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3ecf3a2c062154f40f3b43857fadfa1b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3ecf3a2c062154f40f3b43857fadfa1b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3ecf3a2c062154f40f3b43857fadfa1b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3ecf3a2c062154f40f3b43857fadfa1b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_3ecf3a2c062154f40f3b43857fadfa1b == cache_frame_3ecf3a2c062154f40f3b43857fadfa1b )
    {
        Py_DECREF( frame_3ecf3a2c062154f40f3b43857fadfa1b );
    }
    cache_frame_3ecf3a2c062154f40f3b43857fadfa1b = NULL;

    assertFrameObject( frame_3ecf3a2c062154f40f3b43857fadfa1b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_57_pending );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_57_pending );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_58_do_handshake( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_85a48a901c551db5360868c6ff2fcbe0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_85a48a901c551db5360868c6ff2fcbe0 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_85a48a901c551db5360868c6ff2fcbe0, codeobj_85a48a901c551db5360868c6ff2fcbe0, module_ssl, sizeof(void *) );
    frame_85a48a901c551db5360868c6ff2fcbe0 = cache_frame_85a48a901c551db5360868c6ff2fcbe0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_85a48a901c551db5360868c6ff2fcbe0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_85a48a901c551db5360868c6ff2fcbe0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 763;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_85a48a901c551db5360868c6ff2fcbe0->m_frame.f_lineno = 763;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_do_handshake );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 763;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_85a48a901c551db5360868c6ff2fcbe0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_85a48a901c551db5360868c6ff2fcbe0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_85a48a901c551db5360868c6ff2fcbe0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_85a48a901c551db5360868c6ff2fcbe0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_85a48a901c551db5360868c6ff2fcbe0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_85a48a901c551db5360868c6ff2fcbe0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_85a48a901c551db5360868c6ff2fcbe0 == cache_frame_85a48a901c551db5360868c6ff2fcbe0 )
    {
        Py_DECREF( frame_85a48a901c551db5360868c6ff2fcbe0 );
    }
    cache_frame_85a48a901c551db5360868c6ff2fcbe0 = NULL;

    assertFrameObject( frame_85a48a901c551db5360868c6ff2fcbe0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_58_do_handshake );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_58_do_handshake );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_59_unwrap( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_8299ff8d044f5af021c11f1525c08864;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8299ff8d044f5af021c11f1525c08864 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8299ff8d044f5af021c11f1525c08864, codeobj_8299ff8d044f5af021c11f1525c08864, module_ssl, sizeof(void *) );
    frame_8299ff8d044f5af021c11f1525c08864 = cache_frame_8299ff8d044f5af021c11f1525c08864;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8299ff8d044f5af021c11f1525c08864 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8299ff8d044f5af021c11f1525c08864 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 767;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_8299ff8d044f5af021c11f1525c08864->m_frame.f_lineno = 767;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_shutdown );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 767;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8299ff8d044f5af021c11f1525c08864 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8299ff8d044f5af021c11f1525c08864 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8299ff8d044f5af021c11f1525c08864 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8299ff8d044f5af021c11f1525c08864, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8299ff8d044f5af021c11f1525c08864->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8299ff8d044f5af021c11f1525c08864, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8299ff8d044f5af021c11f1525c08864,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8299ff8d044f5af021c11f1525c08864 == cache_frame_8299ff8d044f5af021c11f1525c08864 )
    {
        Py_DECREF( frame_8299ff8d044f5af021c11f1525c08864 );
    }
    cache_frame_8299ff8d044f5af021c11f1525c08864 = NULL;

    assertFrameObject( frame_8299ff8d044f5af021c11f1525c08864 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_59_unwrap );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_59_unwrap );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_60_get_channel_binding( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cb_type = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_df41c359df46e3b95ae46ee541469c12;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_df41c359df46e3b95ae46ee541469c12 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_df41c359df46e3b95ae46ee541469c12, codeobj_df41c359df46e3b95ae46ee541469c12, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_df41c359df46e3b95ae46ee541469c12 = cache_frame_df41c359df46e3b95ae46ee541469c12;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_df41c359df46e3b95ae46ee541469c12 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_df41c359df46e3b95ae46ee541469c12 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 773;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cb_type );
        tmp_args_element_name_1 = par_cb_type;
        frame_df41c359df46e3b95ae46ee541469c12->m_frame.f_lineno = 773;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_get_channel_binding, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 773;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df41c359df46e3b95ae46ee541469c12 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_df41c359df46e3b95ae46ee541469c12 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df41c359df46e3b95ae46ee541469c12 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_df41c359df46e3b95ae46ee541469c12, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_df41c359df46e3b95ae46ee541469c12->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_df41c359df46e3b95ae46ee541469c12, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_df41c359df46e3b95ae46ee541469c12,
        type_description_1,
        par_self,
        par_cb_type
    );


    // Release cached frame.
    if ( frame_df41c359df46e3b95ae46ee541469c12 == cache_frame_df41c359df46e3b95ae46ee541469c12 )
    {
        Py_DECREF( frame_df41c359df46e3b95ae46ee541469c12 );
    }
    cache_frame_df41c359df46e3b95ae46ee541469c12 = NULL;

    assertFrameObject( frame_df41c359df46e3b95ae46ee541469c12 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_60_get_channel_binding );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cb_type );
    Py_DECREF( par_cb_type );
    par_cb_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cb_type );
    Py_DECREF( par_cb_type );
    par_cb_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_60_get_channel_binding );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_61_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_074ad722ef8e6ac8cf69c8739de2b3f8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_074ad722ef8e6ac8cf69c8739de2b3f8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_074ad722ef8e6ac8cf69c8739de2b3f8, codeobj_074ad722ef8e6ac8cf69c8739de2b3f8, module_ssl, sizeof(void *) );
    frame_074ad722ef8e6ac8cf69c8739de2b3f8 = cache_frame_074ad722ef8e6ac8cf69c8739de2b3f8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_074ad722ef8e6ac8cf69c8739de2b3f8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_074ad722ef8e6ac8cf69c8739de2b3f8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 778;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_074ad722ef8e6ac8cf69c8739de2b3f8->m_frame.f_lineno = 778;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_version );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 778;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_074ad722ef8e6ac8cf69c8739de2b3f8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_074ad722ef8e6ac8cf69c8739de2b3f8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_074ad722ef8e6ac8cf69c8739de2b3f8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_074ad722ef8e6ac8cf69c8739de2b3f8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_074ad722ef8e6ac8cf69c8739de2b3f8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_074ad722ef8e6ac8cf69c8739de2b3f8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_074ad722ef8e6ac8cf69c8739de2b3f8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_074ad722ef8e6ac8cf69c8739de2b3f8 == cache_frame_074ad722ef8e6ac8cf69c8739de2b3f8 )
    {
        Py_DECREF( frame_074ad722ef8e6ac8cf69c8739de2b3f8 );
    }
    cache_frame_074ad722ef8e6ac8cf69c8739de2b3f8 = NULL;

    assertFrameObject( frame_074ad722ef8e6ac8cf69c8739de2b3f8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_61_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_61_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_62_verify_client_post_handshake( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_7fef2a19fae27d1b2e8f283d57279247;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7fef2a19fae27d1b2e8f283d57279247 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7fef2a19fae27d1b2e8f283d57279247, codeobj_7fef2a19fae27d1b2e8f283d57279247, module_ssl, sizeof(void *) );
    frame_7fef2a19fae27d1b2e8f283d57279247 = cache_frame_7fef2a19fae27d1b2e8f283d57279247;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7fef2a19fae27d1b2e8f283d57279247 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7fef2a19fae27d1b2e8f283d57279247 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 781;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_7fef2a19fae27d1b2e8f283d57279247->m_frame.f_lineno = 781;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_verify_client_post_handshake );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 781;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7fef2a19fae27d1b2e8f283d57279247 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7fef2a19fae27d1b2e8f283d57279247 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7fef2a19fae27d1b2e8f283d57279247 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7fef2a19fae27d1b2e8f283d57279247, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7fef2a19fae27d1b2e8f283d57279247->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7fef2a19fae27d1b2e8f283d57279247, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7fef2a19fae27d1b2e8f283d57279247,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_7fef2a19fae27d1b2e8f283d57279247 == cache_frame_7fef2a19fae27d1b2e8f283d57279247 )
    {
        Py_DECREF( frame_7fef2a19fae27d1b2e8f283d57279247 );
    }
    cache_frame_7fef2a19fae27d1b2e8f283d57279247 = NULL;

    assertFrameObject( frame_7fef2a19fae27d1b2e8f283d57279247 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_62_verify_client_post_handshake );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_62_verify_client_post_handshake );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_63___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_6a15f1fb4e124c5cd5441c67dd7b8e26;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6a15f1fb4e124c5cd5441c67dd7b8e26 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6a15f1fb4e124c5cd5441c67dd7b8e26, codeobj_6a15f1fb4e124c5cd5441c67dd7b8e26, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6a15f1fb4e124c5cd5441c67dd7b8e26 = cache_frame_6a15f1fb4e124c5cd5441c67dd7b8e26;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6a15f1fb4e124c5cd5441c67dd7b8e26 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6a15f1fb4e124c5cd5441c67dd7b8e26 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_string_concat_values_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_format_value_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_format_spec_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 791;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_format_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___name__ );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_format_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 791;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_format_spec_1 = const_str_empty;
        tmp_tuple_element_1 = BUILTIN_FORMAT( tmp_format_value_1, tmp_format_spec_1 );
        Py_DECREF( tmp_format_value_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 791;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_string_concat_values_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_string_concat_values_1, 0, tmp_tuple_element_1 );
        tmp_tuple_element_1 = const_str_digest_04a99d395c987ae1e95aaa52fcd9f5b1;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_string_concat_values_1, 1, tmp_tuple_element_1 );
        tmp_make_exception_arg_1 = PyUnicode_Join( const_str_empty, tmp_string_concat_values_1 );
        Py_DECREF( tmp_string_concat_values_1 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 791;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_6a15f1fb4e124c5cd5441c67dd7b8e26->m_frame.f_lineno = 790;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 790;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a15f1fb4e124c5cd5441c67dd7b8e26 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a15f1fb4e124c5cd5441c67dd7b8e26 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6a15f1fb4e124c5cd5441c67dd7b8e26, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6a15f1fb4e124c5cd5441c67dd7b8e26->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6a15f1fb4e124c5cd5441c67dd7b8e26, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6a15f1fb4e124c5cd5441c67dd7b8e26,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_6a15f1fb4e124c5cd5441c67dd7b8e26 == cache_frame_6a15f1fb4e124c5cd5441c67dd7b8e26 )
    {
        Py_DECREF( frame_6a15f1fb4e124c5cd5441c67dd7b8e26 );
    }
    cache_frame_6a15f1fb4e124c5cd5441c67dd7b8e26 = NULL;

    assertFrameObject( frame_6a15f1fb4e124c5cd5441c67dd7b8e26 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_63___init__ );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_63___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_ssl$$$function_64__create( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_sock = python_pars[ 1 ];
    PyObject *par_server_side = python_pars[ 2 ];
    PyObject *par_do_handshake_on_connect = python_pars[ 3 ];
    PyObject *par_suppress_ragged_eofs = python_pars[ 4 ];
    PyObject *par_server_hostname = python_pars[ 5 ];
    PyObject *par_context = python_pars[ 6 ];
    PyObject *par_session = python_pars[ 7 ];
    PyObject *var_kwargs = NULL;
    PyObject *var_self = NULL;
    PyObject *var_e = NULL;
    PyObject *var_connected = NULL;
    PyObject *var_timeout = NULL;
    nuitka_bool tmp_try_except_1__unhandled_indicator = NUITKA_BOOL_UNASSIGNED;
    struct Nuitka_FrameObject *frame_5d3f549a94129cada014514f247e56ae;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_preserved_type_2;
    PyObject *exception_preserved_value_2;
    PyTracebackObject *exception_preserved_tb_2;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    static struct Nuitka_FrameObject *cache_frame_5d3f549a94129cada014514f247e56ae = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5d3f549a94129cada014514f247e56ae, codeobj_5d3f549a94129cada014514f247e56ae, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5d3f549a94129cada014514f247e56ae = cache_frame_5d3f549a94129cada014514f247e56ae;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5d3f549a94129cada014514f247e56ae );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5d3f549a94129cada014514f247e56ae ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( par_sock );
        tmp_source_name_1 = par_sock;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_getsockopt );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 800;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SOL_SOCKET );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SOL_SOCKET );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SOL_SOCKET" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 800;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SO_TYPE );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SO_TYPE );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SO_TYPE" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 800;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_2 = tmp_mvar_value_2;
        frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 800;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 800;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SOCK_STREAM );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SOCK_STREAM );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SOCK_STREAM" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 800;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 800;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_6ca8402699116cba8121763dd25b997a;
            frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 801;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 801;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_server_side );
        tmp_truth_name_1 = CHECK_IF_TRUE( par_server_side );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 802;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            nuitka_bool tmp_condition_result_3;
            int tmp_truth_name_2;
            CHECK_OBJECT( par_server_hostname );
            tmp_truth_name_2 = CHECK_IF_TRUE( par_server_hostname );
            if ( tmp_truth_name_2 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 803;
                type_description_1 = "oooooooooooooN";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_0b3815e873a7a8f2437fdb42dbe60fbf;
                frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 804;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_2 };
                    tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_2 == NULL) );
                exception_type = tmp_raise_type_2;
                exception_lineno = 804;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooooooooN";
                goto frame_exception_exit_1;
            }
            branch_no_3:;
        }
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( par_session );
            tmp_compexpr_left_2 = par_session;
            tmp_compexpr_right_2 = Py_None;
            tmp_condition_result_4 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_3;
                PyObject *tmp_make_exception_arg_3;
                tmp_make_exception_arg_3 = const_str_digest_7024ed96f0952bfda665eb960a91de44;
                frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 807;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_3 };
                    tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_3 == NULL) );
                exception_type = tmp_raise_type_3;
                exception_lineno = 807;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooooooooN";
                goto frame_exception_exit_1;
            }
            branch_no_4:;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_3;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( par_context );
        tmp_source_name_2 = par_context;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_check_hostname );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 809;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_3 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_3 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 809;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_server_hostname );
        tmp_operand_name_1 = par_server_hostname;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 809;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_5 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_5 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_raise_type_4;
            PyObject *tmp_make_exception_arg_4;
            tmp_make_exception_arg_4 = const_str_digest_4f58dc80390e8e62e2885e34b814c3ae;
            frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 810;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_4 };
                tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_4 == NULL) );
            exception_type = tmp_raise_type_4;
            exception_lineno = 810;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        PyObject *tmp_called_instance_1;
        tmp_dict_key_1 = const_str_plain_family;
        CHECK_OBJECT( par_sock );
        tmp_source_name_3 = par_sock;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_family );
        if ( tmp_dict_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 813;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = _PyDict_NewPresized( 4 );
        tmp_res = PyDict_SetItem( tmp_assign_source_1, tmp_dict_key_1, tmp_dict_value_1 );
        Py_DECREF( tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_2 = const_str_plain_type;
        CHECK_OBJECT( par_sock );
        tmp_source_name_4 = par_sock;
        tmp_dict_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_type );
        if ( tmp_dict_value_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );

            exception_lineno = 813;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_1, tmp_dict_key_2, tmp_dict_value_2 );
        Py_DECREF( tmp_dict_value_2 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_3 = const_str_plain_proto;
        CHECK_OBJECT( par_sock );
        tmp_source_name_5 = par_sock;
        tmp_dict_value_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_proto );
        if ( tmp_dict_value_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );

            exception_lineno = 813;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_1, tmp_dict_key_3, tmp_dict_value_3 );
        Py_DECREF( tmp_dict_value_3 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_4 = const_str_plain_fileno;
        CHECK_OBJECT( par_sock );
        tmp_called_instance_1 = par_sock;
        frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 814;
        tmp_dict_value_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_fileno );
        if ( tmp_dict_value_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );

            exception_lineno = 814;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_1, tmp_dict_key_4, tmp_dict_value_4 );
        Py_DECREF( tmp_dict_value_4 );
        assert( !(tmp_res != 0) );
        assert( var_kwargs == NULL );
        var_kwargs = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_6;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_cls );
        tmp_source_name_6 = par_cls;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain___new__ );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 816;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cls );
        tmp_tuple_element_1 = par_cls;
        tmp_dircall_arg2_1 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( var_kwargs );
        tmp_dircall_arg3_1 = var_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_assign_source_2 = impl___internal__$$$function_12_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 816;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        assert( var_self == NULL );
        var_self = tmp_assign_source_2;
    }
    {
        PyObject *tmp_dircall_arg1_2;
        PyObject *tmp_source_name_7;
        PyObject *tmp_type_name_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_object_name_1;
        PyObject *tmp_dircall_arg2_2;
        PyObject *tmp_call_result_1;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLSocket );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLSocket );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLSocket" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 817;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = tmp_mvar_value_4;
        CHECK_OBJECT( var_self );
        tmp_object_name_1 = var_self;
        tmp_source_name_7 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_source_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 817;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_dircall_arg1_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain___init__ );
        Py_DECREF( tmp_source_name_7 );
        if ( tmp_dircall_arg1_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 817;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_kwargs );
        tmp_dircall_arg2_2 = var_kwargs;
        Py_INCREF( tmp_dircall_arg2_2 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_2, tmp_dircall_arg2_2};
            tmp_call_result_1 = impl___internal__$$$function_9_complex_call_helper_star_dict( dir_call_args );
        }
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 817;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_8;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_2;
        CHECK_OBJECT( var_self );
        tmp_source_name_8 = var_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_settimeout );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 818;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_sock );
        tmp_called_instance_2 = par_sock;
        frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 818;
        tmp_args_element_name_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_gettimeout );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 818;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 818;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 818;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_call_result_3;
        CHECK_OBJECT( par_sock );
        tmp_called_instance_3 = par_sock;
        frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 819;
        tmp_call_result_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_detach );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 819;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_context );
        tmp_assattr_name_1 = par_context;
        CHECK_OBJECT( var_self );
        tmp_assattr_target_1 = var_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__context, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 821;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_session );
        tmp_assattr_name_2 = par_session;
        CHECK_OBJECT( var_self );
        tmp_assattr_target_2 = var_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__session, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 822;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_False;
        CHECK_OBJECT( var_self );
        tmp_assattr_target_3 = var_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__closed, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 823;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        tmp_assattr_name_4 = Py_None;
        CHECK_OBJECT( var_self );
        tmp_assattr_target_4 = var_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__sslobj, tmp_assattr_name_4 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 824;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        CHECK_OBJECT( par_server_side );
        tmp_assattr_name_5 = par_server_side;
        CHECK_OBJECT( var_self );
        tmp_assattr_target_5 = var_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_server_side, tmp_assattr_name_5 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 825;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_6;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_assattr_target_6;
        CHECK_OBJECT( par_context );
        tmp_called_instance_4 = par_context;
        CHECK_OBJECT( par_server_hostname );
        tmp_args_element_name_4 = par_server_hostname;
        frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 826;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_assattr_name_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain__encode_hostname, call_args );
        }

        if ( tmp_assattr_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 826;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_self );
        tmp_assattr_target_6 = var_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain_server_hostname, tmp_assattr_name_6 );
        Py_DECREF( tmp_assattr_name_6 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 826;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_7;
        PyObject *tmp_assattr_target_7;
        CHECK_OBJECT( par_do_handshake_on_connect );
        tmp_assattr_name_7 = par_do_handshake_on_connect;
        CHECK_OBJECT( var_self );
        tmp_assattr_target_7 = var_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_do_handshake_on_connect, tmp_assattr_name_7 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 827;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_8;
        PyObject *tmp_assattr_target_8;
        CHECK_OBJECT( par_suppress_ragged_eofs );
        tmp_assattr_name_8 = par_suppress_ragged_eofs;
        CHECK_OBJECT( var_self );
        tmp_assattr_target_8 = var_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain_suppress_ragged_eofs, tmp_assattr_name_8 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 828;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_assign_source_3;
        tmp_assign_source_3 = NUITKA_BOOL_TRUE;
        tmp_try_except_1__unhandled_indicator = tmp_assign_source_3;
    }
    // Tried code:
    // Tried code:
    {
        PyObject *tmp_called_instance_5;
        PyObject *tmp_call_result_4;
        CHECK_OBJECT( var_self );
        tmp_called_instance_5 = var_self;
        frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 832;
        tmp_call_result_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_getpeername );
        if ( tmp_call_result_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 832;
            type_description_1 = "oooooooooooooN";
            goto try_except_handler_3;
        }
        Py_DECREF( tmp_call_result_4 );
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        nuitka_bool tmp_assign_source_4;
        tmp_assign_source_4 = NUITKA_BOOL_FALSE;
        tmp_try_except_1__unhandled_indicator = tmp_assign_source_4;
    }
    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_5d3f549a94129cada014514f247e56ae, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_5d3f549a94129cada014514f247e56ae, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_OSError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 833;
            type_description_1 = "oooooooooooooN";
            goto try_except_handler_4;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_assign_source_5;
            tmp_assign_source_5 = EXC_VALUE(PyThreadState_GET());
            assert( var_e == NULL );
            Py_INCREF( tmp_assign_source_5 );
            var_e = tmp_assign_source_5;
        }
        // Tried code:
        {
            nuitka_bool tmp_condition_result_7;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            PyObject *tmp_source_name_9;
            PyObject *tmp_source_name_10;
            PyObject *tmp_mvar_value_5;
            CHECK_OBJECT( var_e );
            tmp_source_name_9 = var_e;
            tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_errno );
            if ( tmp_compexpr_left_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 834;
                type_description_1 = "oooooooooooooN";
                goto try_except_handler_5;
            }
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_errno );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_errno );
            }

            if ( tmp_mvar_value_5 == NULL )
            {
                Py_DECREF( tmp_compexpr_left_4 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "errno" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 834;
                type_description_1 = "oooooooooooooN";
                goto try_except_handler_5;
            }

            tmp_source_name_10 = tmp_mvar_value_5;
            tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_ENOTCONN );
            if ( tmp_compexpr_right_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_4 );

                exception_lineno = 834;
                type_description_1 = "oooooooooooooN";
                goto try_except_handler_5;
            }
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            Py_DECREF( tmp_compexpr_left_4 );
            Py_DECREF( tmp_compexpr_right_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 834;
                type_description_1 = "oooooooooooooN";
                goto try_except_handler_5;
            }
            tmp_condition_result_7 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_7;
            }
            else
            {
                goto branch_no_7;
            }
            branch_yes_7:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 835;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_5d3f549a94129cada014514f247e56ae->m_frame) frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "oooooooooooooN";
            goto try_except_handler_5;
            branch_no_7:;
        }
        goto try_end_2;
        // Exception handler code:
        try_except_handler_5:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( var_e );
        var_e = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto try_except_handler_4;
        // End of try:
        try_end_2:;
        {
            PyObject *tmp_assign_source_6;
            tmp_assign_source_6 = Py_False;
            assert( var_connected == NULL );
            Py_INCREF( tmp_assign_source_6 );
            var_connected = tmp_assign_source_6;
        }
        Py_XDECREF( var_e );
        var_e = NULL;

        goto branch_end_6;
        branch_no_6:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 831;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_5d3f549a94129cada014514f247e56ae->m_frame) frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooooooooN";
        goto try_except_handler_4;
        branch_end_6:;
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_2;
    // End of try:
    try_end_3:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_64__create );
    return NULL;
    // End of try:
    try_end_1:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    {
        nuitka_bool tmp_condition_result_8;
        nuitka_bool tmp_compexpr_left_5;
        nuitka_bool tmp_compexpr_right_5;
        assert( tmp_try_except_1__unhandled_indicator != NUITKA_BOOL_UNASSIGNED);
        tmp_compexpr_left_5 = tmp_try_except_1__unhandled_indicator;
        tmp_compexpr_right_5 = NUITKA_BOOL_TRUE;
        tmp_condition_result_8 = ( tmp_compexpr_left_5 == tmp_compexpr_right_5 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_8;
        }
        else
        {
            goto branch_no_8;
        }
        branch_yes_8:;
        {
            PyObject *tmp_assign_source_7;
            tmp_assign_source_7 = Py_True;
            {
                PyObject *old = var_connected;
                var_connected = tmp_assign_source_7;
                Py_INCREF( var_connected );
                Py_XDECREF( old );
            }

        }
        branch_no_8:;
    }
    {
        PyObject *tmp_assattr_name_9;
        PyObject *tmp_assattr_target_9;
        if ( var_connected == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "connected" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 840;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }

        tmp_assattr_name_9 = var_connected;
        CHECK_OBJECT( var_self );
        tmp_assattr_target_9 = var_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain__connected, tmp_assattr_name_9 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 840;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_9;
        int tmp_truth_name_4;
        if ( var_connected == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "connected" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 841;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }

        tmp_truth_name_4 = CHECK_IF_TRUE( var_connected );
        if ( tmp_truth_name_4 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 841;
            type_description_1 = "oooooooooooooN";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_9 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_9;
        }
        else
        {
            goto branch_no_9;
        }
        branch_yes_9:;
        // Tried code:
        {
            PyObject *tmp_assattr_name_10;
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_11;
            PyObject *tmp_source_name_12;
            PyObject *tmp_args_name_1;
            PyObject *tmp_tuple_element_2;
            PyObject *tmp_source_name_13;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_5;
            PyObject *tmp_dict_value_5;
            PyObject *tmp_dict_key_6;
            PyObject *tmp_dict_value_6;
            PyObject *tmp_source_name_14;
            PyObject *tmp_assattr_target_10;
            CHECK_OBJECT( var_self );
            tmp_source_name_12 = var_self;
            tmp_source_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain__context );
            if ( tmp_source_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 844;
                type_description_1 = "oooooooooooooN";
                goto try_except_handler_6;
            }
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__wrap_socket );
            Py_DECREF( tmp_source_name_11 );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 844;
                type_description_1 = "oooooooooooooN";
                goto try_except_handler_6;
            }
            CHECK_OBJECT( var_self );
            tmp_tuple_element_2 = var_self;
            tmp_args_name_1 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_2 );
            CHECK_OBJECT( par_server_side );
            tmp_tuple_element_2 = par_server_side;
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_2 );
            CHECK_OBJECT( var_self );
            tmp_source_name_13 = var_self;
            tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_server_hostname );
            if ( tmp_tuple_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_args_name_1 );

                exception_lineno = 845;
                type_description_1 = "oooooooooooooN";
                goto try_except_handler_6;
            }
            PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_2 );
            tmp_dict_key_5 = const_str_plain_owner;
            CHECK_OBJECT( var_self );
            tmp_dict_value_5 = var_self;
            tmp_kw_name_1 = _PyDict_NewPresized( 2 );
            tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_5, tmp_dict_value_5 );
            assert( !(tmp_res != 0) );
            tmp_dict_key_6 = const_str_plain_session;
            CHECK_OBJECT( var_self );
            tmp_source_name_14 = var_self;
            tmp_dict_value_6 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain__session );
            if ( tmp_dict_value_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_args_name_1 );
                Py_DECREF( tmp_kw_name_1 );

                exception_lineno = 846;
                type_description_1 = "oooooooooooooN";
                goto try_except_handler_6;
            }
            tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_6, tmp_dict_value_6 );
            Py_DECREF( tmp_dict_value_6 );
            assert( !(tmp_res != 0) );
            frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 844;
            tmp_assattr_name_10 = CALL_FUNCTION( tmp_called_name_3, tmp_args_name_1, tmp_kw_name_1 );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_name_1 );
            Py_DECREF( tmp_kw_name_1 );
            if ( tmp_assattr_name_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 844;
                type_description_1 = "oooooooooooooN";
                goto try_except_handler_6;
            }
            CHECK_OBJECT( var_self );
            tmp_assattr_target_10 = var_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain__sslobj, tmp_assattr_name_10 );
            Py_DECREF( tmp_assattr_name_10 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 844;
                type_description_1 = "oooooooooooooN";
                goto try_except_handler_6;
            }
        }
        {
            nuitka_bool tmp_condition_result_10;
            int tmp_truth_name_5;
            CHECK_OBJECT( par_do_handshake_on_connect );
            tmp_truth_name_5 = CHECK_IF_TRUE( par_do_handshake_on_connect );
            if ( tmp_truth_name_5 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 848;
                type_description_1 = "oooooooooooooN";
                goto try_except_handler_6;
            }
            tmp_condition_result_10 = tmp_truth_name_5 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_10;
            }
            else
            {
                goto branch_no_10;
            }
            branch_yes_10:;
            {
                PyObject *tmp_assign_source_8;
                PyObject *tmp_called_instance_6;
                CHECK_OBJECT( var_self );
                tmp_called_instance_6 = var_self;
                frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 849;
                tmp_assign_source_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_gettimeout );
                if ( tmp_assign_source_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 849;
                    type_description_1 = "oooooooooooooN";
                    goto try_except_handler_6;
                }
                assert( var_timeout == NULL );
                var_timeout = tmp_assign_source_8;
            }
            {
                nuitka_bool tmp_condition_result_11;
                PyObject *tmp_compexpr_left_6;
                PyObject *tmp_compexpr_right_6;
                CHECK_OBJECT( var_timeout );
                tmp_compexpr_left_6 = var_timeout;
                tmp_compexpr_right_6 = const_float_0_0;
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 850;
                    type_description_1 = "oooooooooooooN";
                    goto try_except_handler_6;
                }
                tmp_condition_result_11 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_11;
                }
                else
                {
                    goto branch_no_11;
                }
                branch_yes_11:;
                {
                    PyObject *tmp_raise_type_5;
                    PyObject *tmp_make_exception_arg_5;
                    tmp_make_exception_arg_5 = const_str_digest_4d5300aa45c1f4e7d70a328a278e2af4;
                    frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 852;
                    {
                        PyObject *call_args[] = { tmp_make_exception_arg_5 };
                        tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                    }

                    assert( !(tmp_raise_type_5 == NULL) );
                    exception_type = tmp_raise_type_5;
                    exception_lineno = 852;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooooooooooooN";
                    goto try_except_handler_6;
                }
                branch_no_11:;
            }
            {
                PyObject *tmp_called_instance_7;
                PyObject *tmp_call_result_5;
                CHECK_OBJECT( var_self );
                tmp_called_instance_7 = var_self;
                frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 853;
                tmp_call_result_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_do_handshake );
                if ( tmp_call_result_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 853;
                    type_description_1 = "oooooooooooooN";
                    goto try_except_handler_6;
                }
                Py_DECREF( tmp_call_result_5 );
            }
            branch_no_10:;
        }
        goto try_end_5;
        // Exception handler code:
        try_except_handler_6:;
        exception_keeper_type_5 = exception_type;
        exception_keeper_value_5 = exception_value;
        exception_keeper_tb_5 = exception_tb;
        exception_keeper_lineno_5 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        exception_preserved_type_2 = EXC_TYPE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_type_2 );
        exception_preserved_value_2 = EXC_VALUE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_value_2 );
        exception_preserved_tb_2 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
        Py_XINCREF( exception_preserved_tb_2 );

        if ( exception_keeper_tb_5 == NULL )
        {
            exception_keeper_tb_5 = MAKE_TRACEBACK( frame_5d3f549a94129cada014514f247e56ae, exception_keeper_lineno_5 );
        }
        else if ( exception_keeper_lineno_5 != 0 )
        {
            exception_keeper_tb_5 = ADD_TRACEBACK( exception_keeper_tb_5, frame_5d3f549a94129cada014514f247e56ae, exception_keeper_lineno_5 );
        }

        NORMALIZE_EXCEPTION( &exception_keeper_type_5, &exception_keeper_value_5, &exception_keeper_tb_5 );
        PyException_SetTraceback( exception_keeper_value_5, (PyObject *)exception_keeper_tb_5 );
        PUBLISH_EXCEPTION( &exception_keeper_type_5, &exception_keeper_value_5, &exception_keeper_tb_5 );
        // Tried code:
        {
            nuitka_bool tmp_condition_result_12;
            PyObject *tmp_compexpr_left_7;
            PyObject *tmp_compexpr_right_7;
            tmp_compexpr_left_7 = EXC_TYPE(PyThreadState_GET());
            tmp_compexpr_right_7 = const_tuple_type_OSError_type_ValueError_tuple;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_7, tmp_compexpr_right_7 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 854;
                type_description_1 = "oooooooooooooN";
                goto try_except_handler_7;
            }
            tmp_condition_result_12 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_12 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_12;
            }
            else
            {
                goto branch_no_12;
            }
            branch_yes_12:;
            {
                PyObject *tmp_called_instance_8;
                PyObject *tmp_call_result_6;
                CHECK_OBJECT( var_self );
                tmp_called_instance_8 = var_self;
                frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = 855;
                tmp_call_result_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain_close );
                if ( tmp_call_result_6 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 855;
                    type_description_1 = "oooooooooooooN";
                    goto try_except_handler_7;
                }
                Py_DECREF( tmp_call_result_6 );
            }
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 856;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_5d3f549a94129cada014514f247e56ae->m_frame) frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "oooooooooooooN";
            goto try_except_handler_7;
            goto branch_end_12;
            branch_no_12:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 843;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_5d3f549a94129cada014514f247e56ae->m_frame) frame_5d3f549a94129cada014514f247e56ae->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "oooooooooooooN";
            goto try_except_handler_7;
            branch_end_12:;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl$$$function_64__create );
        return NULL;
        // Exception handler code:
        try_except_handler_7:;
        exception_keeper_type_6 = exception_type;
        exception_keeper_value_6 = exception_value;
        exception_keeper_tb_6 = exception_tb;
        exception_keeper_lineno_6 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Restore previous exception.
        SET_CURRENT_EXCEPTION( exception_preserved_type_2, exception_preserved_value_2, exception_preserved_tb_2 );
        // Re-raise.
        exception_type = exception_keeper_type_6;
        exception_value = exception_keeper_value_6;
        exception_tb = exception_keeper_tb_6;
        exception_lineno = exception_keeper_lineno_6;

        goto frame_exception_exit_1;
        // End of try:
        // End of try:
        try_end_5:;
        branch_no_9:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d3f549a94129cada014514f247e56ae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d3f549a94129cada014514f247e56ae );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5d3f549a94129cada014514f247e56ae, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5d3f549a94129cada014514f247e56ae->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5d3f549a94129cada014514f247e56ae, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5d3f549a94129cada014514f247e56ae,
        type_description_1,
        par_cls,
        par_sock,
        par_server_side,
        par_do_handshake_on_connect,
        par_suppress_ragged_eofs,
        par_server_hostname,
        par_context,
        par_session,
        var_kwargs,
        var_self,
        var_e,
        var_connected,
        var_timeout,
        NULL
    );


    // Release cached frame.
    if ( frame_5d3f549a94129cada014514f247e56ae == cache_frame_5d3f549a94129cada014514f247e56ae )
    {
        Py_DECREF( frame_5d3f549a94129cada014514f247e56ae );
    }
    cache_frame_5d3f549a94129cada014514f247e56ae = NULL;

    assertFrameObject( frame_5d3f549a94129cada014514f247e56ae );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_self );
    tmp_return_value = var_self;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_64__create );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_sock );
    Py_DECREF( par_sock );
    par_sock = NULL;

    CHECK_OBJECT( (PyObject *)par_server_side );
    Py_DECREF( par_server_side );
    par_server_side = NULL;

    CHECK_OBJECT( (PyObject *)par_do_handshake_on_connect );
    Py_DECREF( par_do_handshake_on_connect );
    par_do_handshake_on_connect = NULL;

    CHECK_OBJECT( (PyObject *)par_suppress_ragged_eofs );
    Py_DECREF( par_suppress_ragged_eofs );
    par_suppress_ragged_eofs = NULL;

    CHECK_OBJECT( (PyObject *)par_server_hostname );
    Py_DECREF( par_server_hostname );
    par_server_hostname = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    CHECK_OBJECT( (PyObject *)var_kwargs );
    Py_DECREF( var_kwargs );
    var_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)var_self );
    Py_DECREF( var_self );
    var_self = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_connected );
    var_connected = NULL;

    Py_XDECREF( var_timeout );
    var_timeout = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_sock );
    Py_DECREF( par_sock );
    par_sock = NULL;

    CHECK_OBJECT( (PyObject *)par_server_side );
    Py_DECREF( par_server_side );
    par_server_side = NULL;

    CHECK_OBJECT( (PyObject *)par_do_handshake_on_connect );
    Py_DECREF( par_do_handshake_on_connect );
    par_do_handshake_on_connect = NULL;

    CHECK_OBJECT( (PyObject *)par_suppress_ragged_eofs );
    Py_DECREF( par_suppress_ragged_eofs );
    par_suppress_ragged_eofs = NULL;

    CHECK_OBJECT( (PyObject *)par_server_hostname );
    Py_DECREF( par_server_hostname );
    par_server_hostname = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    Py_XDECREF( var_kwargs );
    var_kwargs = NULL;

    Py_XDECREF( var_self );
    var_self = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_connected );
    var_connected = NULL;

    Py_XDECREF( var_timeout );
    var_timeout = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_64__create );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_65_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6a50350fea64982993f4c32f68ed6a2a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6a50350fea64982993f4c32f68ed6a2a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6a50350fea64982993f4c32f68ed6a2a, codeobj_6a50350fea64982993f4c32f68ed6a2a, module_ssl, sizeof(void *) );
    frame_6a50350fea64982993f4c32f68ed6a2a = cache_frame_6a50350fea64982993f4c32f68ed6a2a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6a50350fea64982993f4c32f68ed6a2a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6a50350fea64982993f4c32f68ed6a2a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__context );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 861;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a50350fea64982993f4c32f68ed6a2a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a50350fea64982993f4c32f68ed6a2a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a50350fea64982993f4c32f68ed6a2a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6a50350fea64982993f4c32f68ed6a2a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6a50350fea64982993f4c32f68ed6a2a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6a50350fea64982993f4c32f68ed6a2a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6a50350fea64982993f4c32f68ed6a2a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6a50350fea64982993f4c32f68ed6a2a == cache_frame_6a50350fea64982993f4c32f68ed6a2a )
    {
        Py_DECREF( frame_6a50350fea64982993f4c32f68ed6a2a );
    }
    cache_frame_6a50350fea64982993f4c32f68ed6a2a = NULL;

    assertFrameObject( frame_6a50350fea64982993f4c32f68ed6a2a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_65_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_65_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_66_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_ctx = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_0abbe3d29d94097de2b4cca44b79ff1d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0abbe3d29d94097de2b4cca44b79ff1d = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0abbe3d29d94097de2b4cca44b79ff1d, codeobj_0abbe3d29d94097de2b4cca44b79ff1d, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_0abbe3d29d94097de2b4cca44b79ff1d = cache_frame_0abbe3d29d94097de2b4cca44b79ff1d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0abbe3d29d94097de2b4cca44b79ff1d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0abbe3d29d94097de2b4cca44b79ff1d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_ctx );
        tmp_assattr_name_1 = par_ctx;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__context, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 865;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_ctx );
        tmp_assattr_name_2 = par_ctx;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_assattr_target_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_assattr_target_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 866;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_context, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_target_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 866;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0abbe3d29d94097de2b4cca44b79ff1d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0abbe3d29d94097de2b4cca44b79ff1d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0abbe3d29d94097de2b4cca44b79ff1d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0abbe3d29d94097de2b4cca44b79ff1d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0abbe3d29d94097de2b4cca44b79ff1d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0abbe3d29d94097de2b4cca44b79ff1d,
        type_description_1,
        par_self,
        par_ctx
    );


    // Release cached frame.
    if ( frame_0abbe3d29d94097de2b4cca44b79ff1d == cache_frame_0abbe3d29d94097de2b4cca44b79ff1d )
    {
        Py_DECREF( frame_0abbe3d29d94097de2b4cca44b79ff1d );
    }
    cache_frame_0abbe3d29d94097de2b4cca44b79ff1d = NULL;

    assertFrameObject( frame_0abbe3d29d94097de2b4cca44b79ff1d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_66_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_ctx );
    Py_DECREF( par_ctx );
    par_ctx = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_ctx );
    Py_DECREF( par_ctx );
    par_ctx = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_66_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_67_session( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_f436d72429baf7d16ba6a700826ecce2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f436d72429baf7d16ba6a700826ecce2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f436d72429baf7d16ba6a700826ecce2, codeobj_f436d72429baf7d16ba6a700826ecce2, module_ssl, sizeof(void *) );
    frame_f436d72429baf7d16ba6a700826ecce2 = cache_frame_f436d72429baf7d16ba6a700826ecce2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f436d72429baf7d16ba6a700826ecce2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f436d72429baf7d16ba6a700826ecce2 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 871;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_source_name_2;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__sslobj );
            if ( tmp_source_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 872;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_session );
            Py_DECREF( tmp_source_name_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 872;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f436d72429baf7d16ba6a700826ecce2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f436d72429baf7d16ba6a700826ecce2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f436d72429baf7d16ba6a700826ecce2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f436d72429baf7d16ba6a700826ecce2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f436d72429baf7d16ba6a700826ecce2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f436d72429baf7d16ba6a700826ecce2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f436d72429baf7d16ba6a700826ecce2,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f436d72429baf7d16ba6a700826ecce2 == cache_frame_f436d72429baf7d16ba6a700826ecce2 )
    {
        Py_DECREF( frame_f436d72429baf7d16ba6a700826ecce2 );
    }
    cache_frame_f436d72429baf7d16ba6a700826ecce2 = NULL;

    assertFrameObject( frame_f436d72429baf7d16ba6a700826ecce2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_67_session );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_67_session );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_68_session( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_session = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_81b99666473d5e4c99b07c76650d6532;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_81b99666473d5e4c99b07c76650d6532 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_81b99666473d5e4c99b07c76650d6532, codeobj_81b99666473d5e4c99b07c76650d6532, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_81b99666473d5e4c99b07c76650d6532 = cache_frame_81b99666473d5e4c99b07c76650d6532;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_81b99666473d5e4c99b07c76650d6532 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_81b99666473d5e4c99b07c76650d6532 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_session );
        tmp_assattr_name_1 = par_session;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__session, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 876;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 877;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_session );
            tmp_assattr_name_2 = par_session;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_assattr_target_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_assattr_target_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 878;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_session, tmp_assattr_name_2 );
            Py_DECREF( tmp_assattr_target_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 878;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81b99666473d5e4c99b07c76650d6532 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81b99666473d5e4c99b07c76650d6532 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_81b99666473d5e4c99b07c76650d6532, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_81b99666473d5e4c99b07c76650d6532->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_81b99666473d5e4c99b07c76650d6532, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_81b99666473d5e4c99b07c76650d6532,
        type_description_1,
        par_self,
        par_session
    );


    // Release cached frame.
    if ( frame_81b99666473d5e4c99b07c76650d6532 == cache_frame_81b99666473d5e4c99b07c76650d6532 )
    {
        Py_DECREF( frame_81b99666473d5e4c99b07c76650d6532 );
    }
    cache_frame_81b99666473d5e4c99b07c76650d6532 = NULL;

    assertFrameObject( frame_81b99666473d5e4c99b07c76650d6532 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_68_session );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_68_session );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_69_session_reused( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_854fbf8c0d35e06c7abf19e23c21f425;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_854fbf8c0d35e06c7abf19e23c21f425 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_854fbf8c0d35e06c7abf19e23c21f425, codeobj_854fbf8c0d35e06c7abf19e23c21f425, module_ssl, sizeof(void *) );
    frame_854fbf8c0d35e06c7abf19e23c21f425 = cache_frame_854fbf8c0d35e06c7abf19e23c21f425;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_854fbf8c0d35e06c7abf19e23c21f425 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_854fbf8c0d35e06c7abf19e23c21f425 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 883;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_source_name_2;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__sslobj );
            if ( tmp_source_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 884;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_session_reused );
            Py_DECREF( tmp_source_name_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 884;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_854fbf8c0d35e06c7abf19e23c21f425 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_854fbf8c0d35e06c7abf19e23c21f425 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_854fbf8c0d35e06c7abf19e23c21f425 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_854fbf8c0d35e06c7abf19e23c21f425, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_854fbf8c0d35e06c7abf19e23c21f425->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_854fbf8c0d35e06c7abf19e23c21f425, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_854fbf8c0d35e06c7abf19e23c21f425,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_854fbf8c0d35e06c7abf19e23c21f425 == cache_frame_854fbf8c0d35e06c7abf19e23c21f425 )
    {
        Py_DECREF( frame_854fbf8c0d35e06c7abf19e23c21f425 );
    }
    cache_frame_854fbf8c0d35e06c7abf19e23c21f425 = NULL;

    assertFrameObject( frame_854fbf8c0d35e06c7abf19e23c21f425 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_69_session_reused );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_69_session_reused );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_70_dup( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_a9707a26dabb530d65fb63614a8bfaf3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a9707a26dabb530d65fb63614a8bfaf3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a9707a26dabb530d65fb63614a8bfaf3, codeobj_a9707a26dabb530d65fb63614a8bfaf3, module_ssl, sizeof(void *) );
    frame_a9707a26dabb530d65fb63614a8bfaf3 = cache_frame_a9707a26dabb530d65fb63614a8bfaf3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a9707a26dabb530d65fb63614a8bfaf3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a9707a26dabb530d65fb63614a8bfaf3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        tmp_left_name_1 = const_str_digest_a4e634bd5e8eac5aa83cadc1f04fa575;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 888;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___name__ );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 888;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 887;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_a9707a26dabb530d65fb63614a8bfaf3->m_frame.f_lineno = 887;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 887;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a9707a26dabb530d65fb63614a8bfaf3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a9707a26dabb530d65fb63614a8bfaf3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a9707a26dabb530d65fb63614a8bfaf3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a9707a26dabb530d65fb63614a8bfaf3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a9707a26dabb530d65fb63614a8bfaf3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a9707a26dabb530d65fb63614a8bfaf3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_a9707a26dabb530d65fb63614a8bfaf3 == cache_frame_a9707a26dabb530d65fb63614a8bfaf3 )
    {
        Py_DECREF( frame_a9707a26dabb530d65fb63614a8bfaf3 );
    }
    cache_frame_a9707a26dabb530d65fb63614a8bfaf3 = NULL;

    assertFrameObject( frame_a9707a26dabb530d65fb63614a8bfaf3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_70_dup );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_70_dup );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_ssl$$$function_71__checkClosed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_msg = python_pars[ 1 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_71__checkClosed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_msg );
    Py_DECREF( par_msg );
    par_msg = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_msg );
    Py_DECREF( par_msg );
    par_msg = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_71__checkClosed );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_72__check_connected( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_b5f510e6cb81eab7bc9dba35574f0396;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_b5f510e6cb81eab7bc9dba35574f0396 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b5f510e6cb81eab7bc9dba35574f0396, codeobj_b5f510e6cb81eab7bc9dba35574f0396, module_ssl, sizeof(void *) );
    frame_b5f510e6cb81eab7bc9dba35574f0396 = cache_frame_b5f510e6cb81eab7bc9dba35574f0396;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b5f510e6cb81eab7bc9dba35574f0396 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b5f510e6cb81eab7bc9dba35574f0396 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__connected );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 895;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 895;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            frame_b5f510e6cb81eab7bc9dba35574f0396->m_frame.f_lineno = 900;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getpeername );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 900;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b5f510e6cb81eab7bc9dba35574f0396 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b5f510e6cb81eab7bc9dba35574f0396 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b5f510e6cb81eab7bc9dba35574f0396, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b5f510e6cb81eab7bc9dba35574f0396->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b5f510e6cb81eab7bc9dba35574f0396, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b5f510e6cb81eab7bc9dba35574f0396,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b5f510e6cb81eab7bc9dba35574f0396 == cache_frame_b5f510e6cb81eab7bc9dba35574f0396 )
    {
        Py_DECREF( frame_b5f510e6cb81eab7bc9dba35574f0396 );
    }
    cache_frame_b5f510e6cb81eab7bc9dba35574f0396 = NULL;

    assertFrameObject( frame_b5f510e6cb81eab7bc9dba35574f0396 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_72__check_connected );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_72__check_connected );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_73_read( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_len = python_pars[ 1 ];
    PyObject *par_buffer = python_pars[ 2 ];
    PyObject *var_x = NULL;
    struct Nuitka_FrameObject *frame_bc55c6947047d12d73c6cf85fd31316d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    static struct Nuitka_FrameObject *cache_frame_bc55c6947047d12d73c6cf85fd31316d = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bc55c6947047d12d73c6cf85fd31316d, codeobj_bc55c6947047d12d73c6cf85fd31316d, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_bc55c6947047d12d73c6cf85fd31316d = cache_frame_bc55c6947047d12d73c6cf85fd31316d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bc55c6947047d12d73c6cf85fd31316d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bc55c6947047d12d73c6cf85fd31316d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_bc55c6947047d12d73c6cf85fd31316d->m_frame.f_lineno = 906;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 906;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 907;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_02add5f1196bf0982325724e556ddbe7;
            frame_bc55c6947047d12d73c6cf85fd31316d->m_frame.f_lineno = 908;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 908;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    // Tried code:
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_buffer );
        tmp_compexpr_left_2 = par_buffer;
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 911;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( par_len );
            tmp_args_element_name_1 = par_len;
            CHECK_OBJECT( par_buffer );
            tmp_args_element_name_2 = par_buffer;
            frame_bc55c6947047d12d73c6cf85fd31316d->m_frame.f_lineno = 911;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_read, call_args );
            }

            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 911;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__sslobj );
            if ( tmp_called_instance_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 913;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( par_len );
            tmp_args_element_name_3 = par_len;
            frame_bc55c6947047d12d73c6cf85fd31316d->m_frame.f_lineno = 913;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_read, call_args );
            }

            Py_DECREF( tmp_called_instance_3 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 913;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            goto frame_return_exit_1;
        }
        branch_end_2:;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_73_read );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_bc55c6947047d12d73c6cf85fd31316d, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_bc55c6947047d12d73c6cf85fd31316d, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_mvar_value_1;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLError );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLError );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLError" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 914;
            type_description_1 = "oooo";
            goto try_except_handler_3;
        }

        tmp_compexpr_right_3 = tmp_mvar_value_1;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 914;
            type_description_1 = "oooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_1;
            tmp_assign_source_1 = EXC_VALUE(PyThreadState_GET());
            assert( var_x == NULL );
            Py_INCREF( tmp_assign_source_1 );
            var_x = tmp_assign_source_1;
        }
        // Tried code:
        {
            nuitka_bool tmp_condition_result_4;
            int tmp_and_left_truth_1;
            nuitka_bool tmp_and_left_value_1;
            nuitka_bool tmp_and_right_value_1;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_source_name_4;
            PyObject *tmp_subscript_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_source_name_5;
            PyObject *tmp_attribute_value_1;
            int tmp_truth_name_1;
            CHECK_OBJECT( var_x );
            tmp_source_name_4 = var_x;
            tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_args );
            if ( tmp_subscribed_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 915;
                type_description_1 = "oooo";
                goto try_except_handler_4;
            }
            tmp_subscript_name_1 = const_int_0;
            tmp_compexpr_left_4 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
            Py_DECREF( tmp_subscribed_name_1 );
            if ( tmp_compexpr_left_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 915;
                type_description_1 = "oooo";
                goto try_except_handler_4;
            }
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSL_ERROR_EOF );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSL_ERROR_EOF );
            }

            if ( tmp_mvar_value_2 == NULL )
            {
                Py_DECREF( tmp_compexpr_left_4 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSL_ERROR_EOF" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 915;
                type_description_1 = "oooo";
                goto try_except_handler_4;
            }

            tmp_compexpr_right_4 = tmp_mvar_value_2;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            Py_DECREF( tmp_compexpr_left_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 915;
                type_description_1 = "oooo";
                goto try_except_handler_4;
            }
            tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_1 == 1 )
            {
                goto and_right_1;
            }
            else
            {
                goto and_left_1;
            }
            and_right_1:;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_suppress_ragged_eofs );
            if ( tmp_attribute_value_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 915;
                type_description_1 = "oooo";
                goto try_except_handler_4;
            }
            tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
            if ( tmp_truth_name_1 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_attribute_value_1 );

                exception_lineno = 915;
                type_description_1 = "oooo";
                goto try_except_handler_4;
            }
            tmp_and_right_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_attribute_value_1 );
            tmp_condition_result_4 = tmp_and_right_value_1;
            goto and_end_1;
            and_left_1:;
            tmp_condition_result_4 = tmp_and_left_value_1;
            and_end_1:;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                nuitka_bool tmp_condition_result_5;
                PyObject *tmp_compexpr_left_5;
                PyObject *tmp_compexpr_right_5;
                CHECK_OBJECT( par_buffer );
                tmp_compexpr_left_5 = par_buffer;
                tmp_compexpr_right_5 = Py_None;
                tmp_condition_result_5 = ( tmp_compexpr_left_5 != tmp_compexpr_right_5 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_5;
                }
                else
                {
                    goto branch_no_5;
                }
                branch_yes_5:;
                tmp_return_value = const_int_0;
                Py_INCREF( tmp_return_value );
                goto try_return_handler_4;
                goto branch_end_5;
                branch_no_5:;
                tmp_return_value = const_bytes_empty;
                Py_INCREF( tmp_return_value );
                goto try_return_handler_4;
                branch_end_5:;
            }
            goto branch_end_4;
            branch_no_4:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 921;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_bc55c6947047d12d73c6cf85fd31316d->m_frame) frame_bc55c6947047d12d73c6cf85fd31316d->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "oooo";
            goto try_except_handler_4;
            branch_end_4:;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl$$$function_73_read );
        return NULL;
        // Return handler code:
        try_return_handler_4:;
        Py_XDECREF( var_x );
        var_x = NULL;

        goto try_return_handler_3;
        // Exception handler code:
        try_except_handler_4:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( var_x );
        var_x = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto try_except_handler_3;
        // End of try:
        goto branch_end_3;
        branch_no_3:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 909;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_bc55c6947047d12d73c6cf85fd31316d->m_frame) frame_bc55c6947047d12d73c6cf85fd31316d->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooo";
        goto try_except_handler_3;
        branch_end_3:;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_73_read );
    return NULL;
    // Return handler code:
    try_return_handler_3:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bc55c6947047d12d73c6cf85fd31316d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_bc55c6947047d12d73c6cf85fd31316d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bc55c6947047d12d73c6cf85fd31316d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bc55c6947047d12d73c6cf85fd31316d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bc55c6947047d12d73c6cf85fd31316d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bc55c6947047d12d73c6cf85fd31316d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bc55c6947047d12d73c6cf85fd31316d,
        type_description_1,
        par_self,
        par_len,
        par_buffer,
        var_x
    );


    // Release cached frame.
    if ( frame_bc55c6947047d12d73c6cf85fd31316d == cache_frame_bc55c6947047d12d73c6cf85fd31316d )
    {
        Py_DECREF( frame_bc55c6947047d12d73c6cf85fd31316d );
    }
    cache_frame_bc55c6947047d12d73c6cf85fd31316d = NULL;

    assertFrameObject( frame_bc55c6947047d12d73c6cf85fd31316d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_73_read );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_len );
    Py_DECREF( par_len );
    par_len = NULL;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_len );
    Py_DECREF( par_len );
    par_len = NULL;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_73_read );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_74_write( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_data = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_2116eb980de7dd12514dc72c39fd3f4d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_2116eb980de7dd12514dc72c39fd3f4d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2116eb980de7dd12514dc72c39fd3f4d, codeobj_2116eb980de7dd12514dc72c39fd3f4d, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_2116eb980de7dd12514dc72c39fd3f4d = cache_frame_2116eb980de7dd12514dc72c39fd3f4d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2116eb980de7dd12514dc72c39fd3f4d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2116eb980de7dd12514dc72c39fd3f4d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_2116eb980de7dd12514dc72c39fd3f4d->m_frame.f_lineno = 927;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 927;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 928;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_66cbc636bc9077e66f69e97ca6e2f8dc;
            frame_2116eb980de7dd12514dc72c39fd3f4d->m_frame.f_lineno = 929;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 929;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
        if ( tmp_called_instance_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 930;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_data );
        tmp_args_element_name_1 = par_data;
        frame_2116eb980de7dd12514dc72c39fd3f4d->m_frame.f_lineno = 930;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_write, call_args );
        }

        Py_DECREF( tmp_called_instance_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 930;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2116eb980de7dd12514dc72c39fd3f4d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2116eb980de7dd12514dc72c39fd3f4d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2116eb980de7dd12514dc72c39fd3f4d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2116eb980de7dd12514dc72c39fd3f4d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2116eb980de7dd12514dc72c39fd3f4d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2116eb980de7dd12514dc72c39fd3f4d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2116eb980de7dd12514dc72c39fd3f4d,
        type_description_1,
        par_self,
        par_data
    );


    // Release cached frame.
    if ( frame_2116eb980de7dd12514dc72c39fd3f4d == cache_frame_2116eb980de7dd12514dc72c39fd3f4d )
    {
        Py_DECREF( frame_2116eb980de7dd12514dc72c39fd3f4d );
    }
    cache_frame_2116eb980de7dd12514dc72c39fd3f4d = NULL;

    assertFrameObject( frame_2116eb980de7dd12514dc72c39fd3f4d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_74_write );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_74_write );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_75_getpeercert( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_binary_form = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_40f8c9a48268243d506769f5f3c9f87c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_40f8c9a48268243d506769f5f3c9f87c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_40f8c9a48268243d506769f5f3c9f87c, codeobj_40f8c9a48268243d506769f5f3c9f87c, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_40f8c9a48268243d506769f5f3c9f87c = cache_frame_40f8c9a48268243d506769f5f3c9f87c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_40f8c9a48268243d506769f5f3c9f87c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_40f8c9a48268243d506769f5f3c9f87c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_40f8c9a48268243d506769f5f3c9f87c->m_frame.f_lineno = 938;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        frame_40f8c9a48268243d506769f5f3c9f87c->m_frame.f_lineno = 939;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain__check_connected );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_binary_form );
        tmp_args_element_name_1 = par_binary_form;
        frame_40f8c9a48268243d506769f5f3c9f87c->m_frame.f_lineno = 940;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_getpeercert, call_args );
        }

        Py_DECREF( tmp_called_instance_3 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40f8c9a48268243d506769f5f3c9f87c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_40f8c9a48268243d506769f5f3c9f87c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40f8c9a48268243d506769f5f3c9f87c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_40f8c9a48268243d506769f5f3c9f87c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_40f8c9a48268243d506769f5f3c9f87c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_40f8c9a48268243d506769f5f3c9f87c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_40f8c9a48268243d506769f5f3c9f87c,
        type_description_1,
        par_self,
        par_binary_form
    );


    // Release cached frame.
    if ( frame_40f8c9a48268243d506769f5f3c9f87c == cache_frame_40f8c9a48268243d506769f5f3c9f87c )
    {
        Py_DECREF( frame_40f8c9a48268243d506769f5f3c9f87c );
    }
    cache_frame_40f8c9a48268243d506769f5f3c9f87c = NULL;

    assertFrameObject( frame_40f8c9a48268243d506769f5f3c9f87c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_75_getpeercert );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_binary_form );
    Py_DECREF( par_binary_form );
    par_binary_form = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_binary_form );
    Py_DECREF( par_binary_form );
    par_binary_form = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_75_getpeercert );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_76_selected_npn_protocol( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_9946f25858fede3b1b6536c2d85f8023;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_9946f25858fede3b1b6536c2d85f8023 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9946f25858fede3b1b6536c2d85f8023, codeobj_9946f25858fede3b1b6536c2d85f8023, module_ssl, sizeof(void *) );
    frame_9946f25858fede3b1b6536c2d85f8023 = cache_frame_9946f25858fede3b1b6536c2d85f8023;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9946f25858fede3b1b6536c2d85f8023 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9946f25858fede3b1b6536c2d85f8023 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_9946f25858fede3b1b6536c2d85f8023->m_frame.f_lineno = 943;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 943;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 944;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_or_left_value_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 944;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_HAS_NPN );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 944;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 944;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_1 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__sslobj );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 947;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_9946f25858fede3b1b6536c2d85f8023->m_frame.f_lineno = 947;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_selected_npn_protocol );
            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 947;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9946f25858fede3b1b6536c2d85f8023 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9946f25858fede3b1b6536c2d85f8023 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9946f25858fede3b1b6536c2d85f8023 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9946f25858fede3b1b6536c2d85f8023, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9946f25858fede3b1b6536c2d85f8023->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9946f25858fede3b1b6536c2d85f8023, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9946f25858fede3b1b6536c2d85f8023,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_9946f25858fede3b1b6536c2d85f8023 == cache_frame_9946f25858fede3b1b6536c2d85f8023 )
    {
        Py_DECREF( frame_9946f25858fede3b1b6536c2d85f8023 );
    }
    cache_frame_9946f25858fede3b1b6536c2d85f8023 = NULL;

    assertFrameObject( frame_9946f25858fede3b1b6536c2d85f8023 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_76_selected_npn_protocol );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_76_selected_npn_protocol );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_77_selected_alpn_protocol( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d2bc38bd2c275ba26d06739a8be65121;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_d2bc38bd2c275ba26d06739a8be65121 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d2bc38bd2c275ba26d06739a8be65121, codeobj_d2bc38bd2c275ba26d06739a8be65121, module_ssl, sizeof(void *) );
    frame_d2bc38bd2c275ba26d06739a8be65121 = cache_frame_d2bc38bd2c275ba26d06739a8be65121;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d2bc38bd2c275ba26d06739a8be65121 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d2bc38bd2c275ba26d06739a8be65121 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_d2bc38bd2c275ba26d06739a8be65121->m_frame.f_lineno = 950;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 950;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 951;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_or_left_value_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 951;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_HAS_ALPN );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 951;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 951;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_1 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__sslobj );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 954;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_d2bc38bd2c275ba26d06739a8be65121->m_frame.f_lineno = 954;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_selected_alpn_protocol );
            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 954;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d2bc38bd2c275ba26d06739a8be65121 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d2bc38bd2c275ba26d06739a8be65121 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d2bc38bd2c275ba26d06739a8be65121 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d2bc38bd2c275ba26d06739a8be65121, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d2bc38bd2c275ba26d06739a8be65121->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d2bc38bd2c275ba26d06739a8be65121, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d2bc38bd2c275ba26d06739a8be65121,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d2bc38bd2c275ba26d06739a8be65121 == cache_frame_d2bc38bd2c275ba26d06739a8be65121 )
    {
        Py_DECREF( frame_d2bc38bd2c275ba26d06739a8be65121 );
    }
    cache_frame_d2bc38bd2c275ba26d06739a8be65121 = NULL;

    assertFrameObject( frame_d2bc38bd2c275ba26d06739a8be65121 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_77_selected_alpn_protocol );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_77_selected_alpn_protocol );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_78_cipher( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_8d5372b515e339fede7165b142e8a13c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_8d5372b515e339fede7165b142e8a13c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8d5372b515e339fede7165b142e8a13c, codeobj_8d5372b515e339fede7165b142e8a13c, module_ssl, sizeof(void *) );
    frame_8d5372b515e339fede7165b142e8a13c = cache_frame_8d5372b515e339fede7165b142e8a13c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8d5372b515e339fede7165b142e8a13c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8d5372b515e339fede7165b142e8a13c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_8d5372b515e339fede7165b142e8a13c->m_frame.f_lineno = 957;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 957;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 958;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 961;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_8d5372b515e339fede7165b142e8a13c->m_frame.f_lineno = 961;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_cipher );
            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 961;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8d5372b515e339fede7165b142e8a13c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8d5372b515e339fede7165b142e8a13c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8d5372b515e339fede7165b142e8a13c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8d5372b515e339fede7165b142e8a13c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8d5372b515e339fede7165b142e8a13c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8d5372b515e339fede7165b142e8a13c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8d5372b515e339fede7165b142e8a13c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8d5372b515e339fede7165b142e8a13c == cache_frame_8d5372b515e339fede7165b142e8a13c )
    {
        Py_DECREF( frame_8d5372b515e339fede7165b142e8a13c );
    }
    cache_frame_8d5372b515e339fede7165b142e8a13c = NULL;

    assertFrameObject( frame_8d5372b515e339fede7165b142e8a13c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_78_cipher );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_78_cipher );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_79_shared_ciphers( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6720aa3c1b1df68a0d363d84d0591c66;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_6720aa3c1b1df68a0d363d84d0591c66 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6720aa3c1b1df68a0d363d84d0591c66, codeobj_6720aa3c1b1df68a0d363d84d0591c66, module_ssl, sizeof(void *) );
    frame_6720aa3c1b1df68a0d363d84d0591c66 = cache_frame_6720aa3c1b1df68a0d363d84d0591c66;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6720aa3c1b1df68a0d363d84d0591c66 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6720aa3c1b1df68a0d363d84d0591c66 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_6720aa3c1b1df68a0d363d84d0591c66->m_frame.f_lineno = 964;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 964;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 965;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 968;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_6720aa3c1b1df68a0d363d84d0591c66->m_frame.f_lineno = 968;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_shared_ciphers );
            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 968;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6720aa3c1b1df68a0d363d84d0591c66 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6720aa3c1b1df68a0d363d84d0591c66 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6720aa3c1b1df68a0d363d84d0591c66 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6720aa3c1b1df68a0d363d84d0591c66, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6720aa3c1b1df68a0d363d84d0591c66->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6720aa3c1b1df68a0d363d84d0591c66, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6720aa3c1b1df68a0d363d84d0591c66,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6720aa3c1b1df68a0d363d84d0591c66 == cache_frame_6720aa3c1b1df68a0d363d84d0591c66 )
    {
        Py_DECREF( frame_6720aa3c1b1df68a0d363d84d0591c66 );
    }
    cache_frame_6720aa3c1b1df68a0d363d84d0591c66 = NULL;

    assertFrameObject( frame_6720aa3c1b1df68a0d363d84d0591c66 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_79_shared_ciphers );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_79_shared_ciphers );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_80_compression( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_c86b13db4689f046ff5f1afeb5710181;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c86b13db4689f046ff5f1afeb5710181 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c86b13db4689f046ff5f1afeb5710181, codeobj_c86b13db4689f046ff5f1afeb5710181, module_ssl, sizeof(void *) );
    frame_c86b13db4689f046ff5f1afeb5710181 = cache_frame_c86b13db4689f046ff5f1afeb5710181;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c86b13db4689f046ff5f1afeb5710181 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c86b13db4689f046ff5f1afeb5710181 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_c86b13db4689f046ff5f1afeb5710181->m_frame.f_lineno = 971;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 971;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 972;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 975;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_c86b13db4689f046ff5f1afeb5710181->m_frame.f_lineno = 975;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_compression );
            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 975;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c86b13db4689f046ff5f1afeb5710181 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c86b13db4689f046ff5f1afeb5710181 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c86b13db4689f046ff5f1afeb5710181 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c86b13db4689f046ff5f1afeb5710181, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c86b13db4689f046ff5f1afeb5710181->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c86b13db4689f046ff5f1afeb5710181, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c86b13db4689f046ff5f1afeb5710181,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c86b13db4689f046ff5f1afeb5710181 == cache_frame_c86b13db4689f046ff5f1afeb5710181 )
    {
        Py_DECREF( frame_c86b13db4689f046ff5f1afeb5710181 );
    }
    cache_frame_c86b13db4689f046ff5f1afeb5710181 = NULL;

    assertFrameObject( frame_c86b13db4689f046ff5f1afeb5710181 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_80_compression );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_80_compression );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_81_send( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_data = python_pars[ 1 ];
    PyObject *par_flags = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_04c7d04cc1994e94386698ea320f0a34;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_04c7d04cc1994e94386698ea320f0a34 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_04c7d04cc1994e94386698ea320f0a34, codeobj_04c7d04cc1994e94386698ea320f0a34, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_04c7d04cc1994e94386698ea320f0a34 = cache_frame_04c7d04cc1994e94386698ea320f0a34;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_04c7d04cc1994e94386698ea320f0a34 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_04c7d04cc1994e94386698ea320f0a34 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_04c7d04cc1994e94386698ea320f0a34->m_frame.f_lineno = 978;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 978;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 979;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( par_flags );
            tmp_compexpr_left_2 = par_flags;
            tmp_compexpr_right_2 = const_int_0;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 980;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_source_name_2;
                tmp_left_name_1 = const_str_digest_0b796367a64c49cc2aaf578dcf85fdf5;
                CHECK_OBJECT( par_self );
                tmp_source_name_2 = par_self;
                tmp_right_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
                if ( tmp_right_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 983;
                    type_description_1 = "oooc";
                    goto frame_exception_exit_1;
                }
                tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
                Py_DECREF( tmp_right_name_1 );
                if ( tmp_make_exception_arg_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 982;
                    type_description_1 = "oooc";
                    goto frame_exception_exit_1;
                }
                frame_04c7d04cc1994e94386698ea320f0a34->m_frame.f_lineno = 981;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                Py_DECREF( tmp_make_exception_arg_1 );
                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 981;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__sslobj );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 984;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_data );
            tmp_args_element_name_1 = par_data;
            frame_04c7d04cc1994e94386698ea320f0a34->m_frame.f_lineno = 984;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_write, call_args );
            }

            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 984;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_type_name_1;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            if ( PyCell_GET( self->m_closure[0] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 986;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
            CHECK_OBJECT( par_self );
            tmp_object_name_1 = par_self;
            tmp_called_instance_3 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
            if ( tmp_called_instance_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 986;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_data );
            tmp_args_element_name_2 = par_data;
            CHECK_OBJECT( par_flags );
            tmp_args_element_name_3 = par_flags;
            frame_04c7d04cc1994e94386698ea320f0a34->m_frame.f_lineno = 986;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_send, call_args );
            }

            Py_DECREF( tmp_called_instance_3 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 986;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_04c7d04cc1994e94386698ea320f0a34 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_04c7d04cc1994e94386698ea320f0a34 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_04c7d04cc1994e94386698ea320f0a34 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_04c7d04cc1994e94386698ea320f0a34, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_04c7d04cc1994e94386698ea320f0a34->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_04c7d04cc1994e94386698ea320f0a34, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_04c7d04cc1994e94386698ea320f0a34,
        type_description_1,
        par_self,
        par_data,
        par_flags,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_04c7d04cc1994e94386698ea320f0a34 == cache_frame_04c7d04cc1994e94386698ea320f0a34 )
    {
        Py_DECREF( frame_04c7d04cc1994e94386698ea320f0a34 );
    }
    cache_frame_04c7d04cc1994e94386698ea320f0a34 = NULL;

    assertFrameObject( frame_04c7d04cc1994e94386698ea320f0a34 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_81_send );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_81_send );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_82_sendto( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_data = python_pars[ 1 ];
    PyObject *par_flags_or_addr = python_pars[ 2 ];
    PyObject *par_addr = python_pars[ 3 ];
    struct Nuitka_FrameObject *frame_7d99f84954cc8e5a491c234fdf7ba84c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_7d99f84954cc8e5a491c234fdf7ba84c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7d99f84954cc8e5a491c234fdf7ba84c, codeobj_7d99f84954cc8e5a491c234fdf7ba84c, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7d99f84954cc8e5a491c234fdf7ba84c = cache_frame_7d99f84954cc8e5a491c234fdf7ba84c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7d99f84954cc8e5a491c234fdf7ba84c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7d99f84954cc8e5a491c234fdf7ba84c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_7d99f84954cc8e5a491c234fdf7ba84c->m_frame.f_lineno = 989;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 989;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 990;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_source_name_2;
            tmp_left_name_1 = const_str_digest_b80e22ff8ef58437a3cdcf9966f6ec5d;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_right_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 992;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 991;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            frame_7d99f84954cc8e5a491c234fdf7ba84c->m_frame.f_lineno = 991;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 991;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( par_addr );
            tmp_compexpr_left_2 = par_addr;
            tmp_compexpr_right_2 = Py_None;
            tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_type_name_1;
                PyObject *tmp_object_name_1;
                PyObject *tmp_args_element_name_1;
                PyObject *tmp_args_element_name_2;
                if ( PyCell_GET( self->m_closure[0] ) == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 994;
                    type_description_1 = "ooooc";
                    goto frame_exception_exit_1;
                }

                tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
                CHECK_OBJECT( par_self );
                tmp_object_name_1 = par_self;
                tmp_called_instance_2 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
                if ( tmp_called_instance_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 994;
                    type_description_1 = "ooooc";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_data );
                tmp_args_element_name_1 = par_data;
                CHECK_OBJECT( par_flags_or_addr );
                tmp_args_element_name_2 = par_flags_or_addr;
                frame_7d99f84954cc8e5a491c234fdf7ba84c->m_frame.f_lineno = 994;
                {
                    PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                    tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sendto, call_args );
                }

                Py_DECREF( tmp_called_instance_2 );
                if ( tmp_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 994;
                    type_description_1 = "ooooc";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_called_instance_3;
                PyObject *tmp_type_name_2;
                PyObject *tmp_object_name_2;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_args_element_name_5;
                if ( PyCell_GET( self->m_closure[0] ) == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 996;
                    type_description_1 = "ooooc";
                    goto frame_exception_exit_1;
                }

                tmp_type_name_2 = PyCell_GET( self->m_closure[0] );
                CHECK_OBJECT( par_self );
                tmp_object_name_2 = par_self;
                tmp_called_instance_3 = BUILTIN_SUPER( tmp_type_name_2, tmp_object_name_2 );
                if ( tmp_called_instance_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 996;
                    type_description_1 = "ooooc";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_data );
                tmp_args_element_name_3 = par_data;
                CHECK_OBJECT( par_flags_or_addr );
                tmp_args_element_name_4 = par_flags_or_addr;
                CHECK_OBJECT( par_addr );
                tmp_args_element_name_5 = par_addr;
                frame_7d99f84954cc8e5a491c234fdf7ba84c->m_frame.f_lineno = 996;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                    tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_3, const_str_plain_sendto, call_args );
                }

                Py_DECREF( tmp_called_instance_3 );
                if ( tmp_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 996;
                    type_description_1 = "ooooc";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7d99f84954cc8e5a491c234fdf7ba84c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7d99f84954cc8e5a491c234fdf7ba84c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7d99f84954cc8e5a491c234fdf7ba84c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7d99f84954cc8e5a491c234fdf7ba84c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7d99f84954cc8e5a491c234fdf7ba84c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7d99f84954cc8e5a491c234fdf7ba84c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7d99f84954cc8e5a491c234fdf7ba84c,
        type_description_1,
        par_self,
        par_data,
        par_flags_or_addr,
        par_addr,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_7d99f84954cc8e5a491c234fdf7ba84c == cache_frame_7d99f84954cc8e5a491c234fdf7ba84c )
    {
        Py_DECREF( frame_7d99f84954cc8e5a491c234fdf7ba84c );
    }
    cache_frame_7d99f84954cc8e5a491c234fdf7ba84c = NULL;

    assertFrameObject( frame_7d99f84954cc8e5a491c234fdf7ba84c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_82_sendto );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_flags_or_addr );
    Py_DECREF( par_flags_or_addr );
    par_flags_or_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_flags_or_addr );
    Py_DECREF( par_flags_or_addr );
    par_flags_or_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_82_sendto );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_83_sendmsg( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_d919d033f6f5ba6049cfa7306704c4e1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d919d033f6f5ba6049cfa7306704c4e1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d919d033f6f5ba6049cfa7306704c4e1, codeobj_d919d033f6f5ba6049cfa7306704c4e1, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d919d033f6f5ba6049cfa7306704c4e1 = cache_frame_d919d033f6f5ba6049cfa7306704c4e1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d919d033f6f5ba6049cfa7306704c4e1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d919d033f6f5ba6049cfa7306704c4e1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_1;
        tmp_left_name_1 = const_str_digest_32e7fb4c0950e94f71a622b4bef91a91;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_1 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1002;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1001;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_d919d033f6f5ba6049cfa7306704c4e1->m_frame.f_lineno = 1001;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 1001;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d919d033f6f5ba6049cfa7306704c4e1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d919d033f6f5ba6049cfa7306704c4e1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d919d033f6f5ba6049cfa7306704c4e1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d919d033f6f5ba6049cfa7306704c4e1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d919d033f6f5ba6049cfa7306704c4e1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d919d033f6f5ba6049cfa7306704c4e1,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_d919d033f6f5ba6049cfa7306704c4e1 == cache_frame_d919d033f6f5ba6049cfa7306704c4e1 )
    {
        Py_DECREF( frame_d919d033f6f5ba6049cfa7306704c4e1 );
    }
    cache_frame_d919d033f6f5ba6049cfa7306704c4e1 = NULL;

    assertFrameObject( frame_d919d033f6f5ba6049cfa7306704c4e1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_83_sendmsg );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_83_sendmsg );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_ssl$$$function_84_sendall( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_data = python_pars[ 1 ];
    PyObject *par_flags = python_pars[ 2 ];
    PyObject *var_count = NULL;
    PyObject *var_view = NULL;
    PyObject *var_byte_view = NULL;
    PyObject *var_amount = NULL;
    PyObject *var_v = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__exit = NULL;
    nuitka_bool tmp_with_1__indicator = NUITKA_BOOL_UNASSIGNED;
    PyObject *tmp_with_1__source = NULL;
    PyObject *tmp_with_2__enter = NULL;
    PyObject *tmp_with_2__exit = NULL;
    nuitka_bool tmp_with_2__indicator = NUITKA_BOOL_UNASSIGNED;
    PyObject *tmp_with_2__source = NULL;
    struct Nuitka_FrameObject *frame_6f2722bf3b4b9cc66de9b446db7a9e02;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_preserved_type_2;
    PyObject *exception_preserved_value_2;
    PyTracebackObject *exception_preserved_tb_2;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_6f2722bf3b4b9cc66de9b446db7a9e02 = NULL;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6f2722bf3b4b9cc66de9b446db7a9e02, codeobj_6f2722bf3b4b9cc66de9b446db7a9e02, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6f2722bf3b4b9cc66de9b446db7a9e02 = cache_frame_6f2722bf3b4b9cc66de9b446db7a9e02;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6f2722bf3b4b9cc66de9b446db7a9e02 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6f2722bf3b4b9cc66de9b446db7a9e02 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1005;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1005;
            type_description_1 = "ooooooooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1006;
            type_description_1 = "ooooooooc";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( par_flags );
            tmp_compexpr_left_2 = par_flags;
            tmp_compexpr_right_2 = const_int_0;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1007;
                type_description_1 = "ooooooooc";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_source_name_2;
                tmp_left_name_1 = const_str_digest_5792c6e630cc995ac06314e738846670;
                CHECK_OBJECT( par_self );
                tmp_source_name_2 = par_self;
                tmp_right_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
                if ( tmp_right_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1010;
                    type_description_1 = "ooooooooc";
                    goto frame_exception_exit_1;
                }
                tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
                Py_DECREF( tmp_right_name_1 );
                if ( tmp_make_exception_arg_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1009;
                    type_description_1 = "ooooooooc";
                    goto frame_exception_exit_1;
                }
                frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1008;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                Py_DECREF( tmp_make_exception_arg_1 );
                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 1008;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooooc";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        {
            PyObject *tmp_assign_source_1;
            tmp_assign_source_1 = const_int_0;
            assert( var_count == NULL );
            Py_INCREF( tmp_assign_source_1 );
            var_count = tmp_assign_source_1;
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_1;
            PyObject *tmp_args_element_name_1;
            tmp_called_name_1 = (PyObject *)&PyMemoryView_Type;
            CHECK_OBJECT( par_data );
            tmp_args_element_name_1 = par_data;
            frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1012;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1012;
                type_description_1 = "ooooooooc";
                goto try_except_handler_2;
            }
            assert( tmp_with_2__source == NULL );
            tmp_with_2__source = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( tmp_with_2__source );
            tmp_source_name_3 = tmp_with_2__source;
            tmp_called_name_2 = LOOKUP_SPECIAL( tmp_source_name_3, const_str_plain___enter__ );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1012;
                type_description_1 = "ooooooooc";
                goto try_except_handler_2;
            }
            frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1012;
            tmp_assign_source_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
            Py_DECREF( tmp_called_name_2 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1012;
                type_description_1 = "ooooooooc";
                goto try_except_handler_2;
            }
            assert( tmp_with_2__enter == NULL );
            tmp_with_2__enter = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_source_name_4;
            CHECK_OBJECT( tmp_with_2__source );
            tmp_source_name_4 = tmp_with_2__source;
            tmp_assign_source_4 = LOOKUP_SPECIAL( tmp_source_name_4, const_str_plain___exit__ );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1012;
                type_description_1 = "ooooooooc";
                goto try_except_handler_2;
            }
            assert( tmp_with_2__exit == NULL );
            tmp_with_2__exit = tmp_assign_source_4;
        }
        {
            nuitka_bool tmp_assign_source_5;
            tmp_assign_source_5 = NUITKA_BOOL_TRUE;
            tmp_with_2__indicator = tmp_assign_source_5;
        }
        {
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT( tmp_with_2__enter );
            tmp_assign_source_6 = tmp_with_2__enter;
            assert( var_view == NULL );
            Py_INCREF( tmp_assign_source_6 );
            var_view = tmp_assign_source_6;
        }
        // Tried code:
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_assign_source_7;
            PyObject *tmp_called_instance_2;
            CHECK_OBJECT( var_view );
            tmp_called_instance_2 = var_view;
            frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1012;
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_cast, &PyTuple_GET_ITEM( const_tuple_str_plain_B_tuple, 0 ) );

            if ( tmp_assign_source_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1012;
                type_description_1 = "ooooooooc";
                goto try_except_handler_5;
            }
            assert( tmp_with_1__source == NULL );
            tmp_with_1__source = tmp_assign_source_7;
        }
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_5;
            CHECK_OBJECT( tmp_with_1__source );
            tmp_source_name_5 = tmp_with_1__source;
            tmp_called_name_3 = LOOKUP_SPECIAL( tmp_source_name_5, const_str_plain___enter__ );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1012;
                type_description_1 = "ooooooooc";
                goto try_except_handler_5;
            }
            frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1012;
            tmp_assign_source_8 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
            Py_DECREF( tmp_called_name_3 );
            if ( tmp_assign_source_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1012;
                type_description_1 = "ooooooooc";
                goto try_except_handler_5;
            }
            assert( tmp_with_1__enter == NULL );
            tmp_with_1__enter = tmp_assign_source_8;
        }
        {
            PyObject *tmp_assign_source_9;
            PyObject *tmp_source_name_6;
            CHECK_OBJECT( tmp_with_1__source );
            tmp_source_name_6 = tmp_with_1__source;
            tmp_assign_source_9 = LOOKUP_SPECIAL( tmp_source_name_6, const_str_plain___exit__ );
            if ( tmp_assign_source_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1012;
                type_description_1 = "ooooooooc";
                goto try_except_handler_5;
            }
            assert( tmp_with_1__exit == NULL );
            tmp_with_1__exit = tmp_assign_source_9;
        }
        {
            nuitka_bool tmp_assign_source_10;
            tmp_assign_source_10 = NUITKA_BOOL_TRUE;
            tmp_with_1__indicator = tmp_assign_source_10;
        }
        {
            PyObject *tmp_assign_source_11;
            CHECK_OBJECT( tmp_with_1__enter );
            tmp_assign_source_11 = tmp_with_1__enter;
            assert( var_byte_view == NULL );
            Py_INCREF( tmp_assign_source_11 );
            var_byte_view = tmp_assign_source_11;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_assign_source_12;
            PyObject *tmp_len_arg_1;
            CHECK_OBJECT( var_byte_view );
            tmp_len_arg_1 = var_byte_view;
            tmp_assign_source_12 = BUILTIN_LEN( tmp_len_arg_1 );
            if ( tmp_assign_source_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1013;
                type_description_1 = "ooooooooc";
                goto try_except_handler_7;
            }
            assert( var_amount == NULL );
            var_amount = tmp_assign_source_12;
        }
        loop_start_1:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            CHECK_OBJECT( var_count );
            tmp_compexpr_left_3 = var_count;
            CHECK_OBJECT( var_amount );
            tmp_compexpr_right_3 = var_amount;
            tmp_operand_name_1 = RICH_COMPARE_LT_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            if ( tmp_operand_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1014;
                type_description_1 = "ooooooooc";
                goto try_except_handler_7;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            Py_DECREF( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1014;
                type_description_1 = "ooooooooc";
                goto try_except_handler_7;
            }
            tmp_condition_result_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            goto loop_end_1;
            branch_no_3:;
        }
        {
            PyObject *tmp_assign_source_13;
            PyObject *tmp_called_name_4;
            PyObject *tmp_source_name_7;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            PyObject *tmp_start_name_1;
            PyObject *tmp_stop_name_1;
            PyObject *tmp_step_name_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_7 = par_self;
            tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_send );
            if ( tmp_called_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1015;
                type_description_1 = "ooooooooc";
                goto try_except_handler_7;
            }
            CHECK_OBJECT( var_byte_view );
            tmp_subscribed_name_1 = var_byte_view;
            CHECK_OBJECT( var_count );
            tmp_start_name_1 = var_count;
            tmp_stop_name_1 = Py_None;
            tmp_step_name_1 = Py_None;
            tmp_subscript_name_1 = MAKE_SLICEOBJ3( tmp_start_name_1, tmp_stop_name_1, tmp_step_name_1 );
            assert( !(tmp_subscript_name_1 == NULL) );
            tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
            Py_DECREF( tmp_subscript_name_1 );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_4 );

                exception_lineno = 1015;
                type_description_1 = "ooooooooc";
                goto try_except_handler_7;
            }
            frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1015;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_assign_source_13 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
            }

            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_assign_source_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1015;
                type_description_1 = "ooooooooc";
                goto try_except_handler_7;
            }
            {
                PyObject *old = var_v;
                var_v = tmp_assign_source_13;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_14;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            CHECK_OBJECT( var_count );
            tmp_left_name_2 = var_count;
            CHECK_OBJECT( var_v );
            tmp_right_name_2 = var_v;
            tmp_result = BINARY_OPERATION_ADD_OBJECT_OBJECT_INPLACE( &tmp_left_name_2, tmp_right_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1016;
                type_description_1 = "ooooooooc";
                goto try_except_handler_7;
            }
            tmp_assign_source_14 = tmp_left_name_2;
            var_count = tmp_assign_source_14;

        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1014;
            type_description_1 = "ooooooooc";
            goto try_except_handler_7;
        }
        goto loop_start_1;
        loop_end_1:;
        goto try_end_1;
        // Exception handler code:
        try_except_handler_7:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_type_1 );
        exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_value_1 );
        exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
        Py_XINCREF( exception_preserved_tb_1 );

        if ( exception_keeper_tb_1 == NULL )
        {
            exception_keeper_tb_1 = MAKE_TRACEBACK( frame_6f2722bf3b4b9cc66de9b446db7a9e02, exception_keeper_lineno_1 );
        }
        else if ( exception_keeper_lineno_1 != 0 )
        {
            exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_6f2722bf3b4b9cc66de9b446db7a9e02, exception_keeper_lineno_1 );
        }

        NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
        PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        // Tried code:
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            tmp_compexpr_left_4 = EXC_TYPE(PyThreadState_GET());
            tmp_compexpr_right_4 = PyExc_BaseException;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1012;
                type_description_1 = "ooooooooc";
                goto try_except_handler_8;
            }
            tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                nuitka_bool tmp_assign_source_15;
                tmp_assign_source_15 = NUITKA_BOOL_FALSE;
                tmp_with_1__indicator = tmp_assign_source_15;
            }
            {
                nuitka_bool tmp_condition_result_5;
                PyObject *tmp_operand_name_2;
                PyObject *tmp_called_name_5;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_args_element_name_5;
                CHECK_OBJECT( tmp_with_1__exit );
                tmp_called_name_5 = tmp_with_1__exit;
                tmp_args_element_name_3 = EXC_TYPE(PyThreadState_GET());
                tmp_args_element_name_4 = EXC_VALUE(PyThreadState_GET());
                tmp_args_element_name_5 = EXC_TRACEBACK(PyThreadState_GET());
                frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1012;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                    tmp_operand_name_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
                }

                if ( tmp_operand_name_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1012;
                    type_description_1 = "ooooooooc";
                    goto try_except_handler_8;
                }
                tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
                Py_DECREF( tmp_operand_name_2 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1012;
                    type_description_1 = "ooooooooc";
                    goto try_except_handler_8;
                }
                tmp_condition_result_5 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_5;
                }
                else
                {
                    goto branch_no_5;
                }
                branch_yes_5:;
                tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                if (unlikely( tmp_result == false ))
                {
                    exception_lineno = 1012;
                }

                if (exception_tb && exception_tb->tb_frame == &frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame) frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = exception_tb->tb_lineno;
                type_description_1 = "ooooooooc";
                goto try_except_handler_8;
                branch_no_5:;
            }
            goto branch_end_4;
            branch_no_4:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 1012;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame) frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "ooooooooc";
            goto try_except_handler_8;
            branch_end_4:;
        }
        goto try_end_2;
        // Exception handler code:
        try_except_handler_8:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Restore previous exception.
        SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto try_except_handler_6;
        // End of try:
        try_end_2:;
        // Restore previous exception.
        SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
        goto try_end_1;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl$$$function_84_sendall );
        return NULL;
        // End of try:
        try_end_1:;
        goto try_end_3;
        // Exception handler code:
        try_except_handler_6:;
        exception_keeper_type_3 = exception_type;
        exception_keeper_value_3 = exception_value;
        exception_keeper_tb_3 = exception_tb;
        exception_keeper_lineno_3 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            nuitka_bool tmp_condition_result_6;
            nuitka_bool tmp_compexpr_left_5;
            nuitka_bool tmp_compexpr_right_5;
            assert( tmp_with_1__indicator != NUITKA_BOOL_UNASSIGNED);
            tmp_compexpr_left_5 = tmp_with_1__indicator;
            tmp_compexpr_right_5 = NUITKA_BOOL_TRUE;
            tmp_condition_result_6 = ( tmp_compexpr_left_5 == tmp_compexpr_right_5 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_6;
            }
            else
            {
                goto branch_no_6;
            }
            branch_yes_6:;
            {
                PyObject *tmp_called_name_6;
                PyObject *tmp_call_result_2;
                CHECK_OBJECT( tmp_with_1__exit );
                tmp_called_name_6 = tmp_with_1__exit;
                frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1012;
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

                if ( tmp_call_result_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    Py_DECREF( exception_keeper_type_3 );
                    Py_XDECREF( exception_keeper_value_3 );
                    Py_XDECREF( exception_keeper_tb_3 );

                    exception_lineno = 1012;
                    type_description_1 = "ooooooooc";
                    goto try_except_handler_5;
                }
                Py_DECREF( tmp_call_result_2 );
            }
            branch_no_6:;
        }
        // Re-raise.
        exception_type = exception_keeper_type_3;
        exception_value = exception_keeper_value_3;
        exception_tb = exception_keeper_tb_3;
        exception_lineno = exception_keeper_lineno_3;

        goto try_except_handler_5;
        // End of try:
        try_end_3:;
        {
            nuitka_bool tmp_condition_result_7;
            nuitka_bool tmp_compexpr_left_6;
            nuitka_bool tmp_compexpr_right_6;
            assert( tmp_with_1__indicator != NUITKA_BOOL_UNASSIGNED);
            tmp_compexpr_left_6 = tmp_with_1__indicator;
            tmp_compexpr_right_6 = NUITKA_BOOL_TRUE;
            tmp_condition_result_7 = ( tmp_compexpr_left_6 == tmp_compexpr_right_6 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_7;
            }
            else
            {
                goto branch_no_7;
            }
            branch_yes_7:;
            {
                PyObject *tmp_called_name_7;
                PyObject *tmp_call_result_3;
                CHECK_OBJECT( tmp_with_1__exit );
                tmp_called_name_7 = tmp_with_1__exit;
                frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1012;
                tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_7, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

                if ( tmp_call_result_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1012;
                    type_description_1 = "ooooooooc";
                    goto try_except_handler_5;
                }
                Py_DECREF( tmp_call_result_3 );
            }
            branch_no_7:;
        }
        goto try_end_4;
        // Exception handler code:
        try_except_handler_5:;
        exception_keeper_type_4 = exception_type;
        exception_keeper_value_4 = exception_value;
        exception_keeper_tb_4 = exception_tb;
        exception_keeper_lineno_4 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_with_1__source );
        tmp_with_1__source = NULL;

        Py_XDECREF( tmp_with_1__enter );
        tmp_with_1__enter = NULL;

        Py_XDECREF( tmp_with_1__exit );
        tmp_with_1__exit = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_4;
        exception_value = exception_keeper_value_4;
        exception_tb = exception_keeper_tb_4;
        exception_lineno = exception_keeper_lineno_4;

        goto try_except_handler_4;
        // End of try:
        try_end_4:;
        CHECK_OBJECT( (PyObject *)tmp_with_1__source );
        Py_DECREF( tmp_with_1__source );
        tmp_with_1__source = NULL;

        CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
        Py_DECREF( tmp_with_1__enter );
        tmp_with_1__enter = NULL;

        CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
        Py_DECREF( tmp_with_1__exit );
        tmp_with_1__exit = NULL;

        goto try_end_5;
        // Exception handler code:
        try_except_handler_4:;
        exception_keeper_type_5 = exception_type;
        exception_keeper_value_5 = exception_value;
        exception_keeper_tb_5 = exception_tb;
        exception_keeper_lineno_5 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        exception_preserved_type_2 = EXC_TYPE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_type_2 );
        exception_preserved_value_2 = EXC_VALUE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_value_2 );
        exception_preserved_tb_2 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
        Py_XINCREF( exception_preserved_tb_2 );

        if ( exception_keeper_tb_5 == NULL )
        {
            exception_keeper_tb_5 = MAKE_TRACEBACK( frame_6f2722bf3b4b9cc66de9b446db7a9e02, exception_keeper_lineno_5 );
        }
        else if ( exception_keeper_lineno_5 != 0 )
        {
            exception_keeper_tb_5 = ADD_TRACEBACK( exception_keeper_tb_5, frame_6f2722bf3b4b9cc66de9b446db7a9e02, exception_keeper_lineno_5 );
        }

        NORMALIZE_EXCEPTION( &exception_keeper_type_5, &exception_keeper_value_5, &exception_keeper_tb_5 );
        PyException_SetTraceback( exception_keeper_value_5, (PyObject *)exception_keeper_tb_5 );
        PUBLISH_EXCEPTION( &exception_keeper_type_5, &exception_keeper_value_5, &exception_keeper_tb_5 );
        // Tried code:
        {
            nuitka_bool tmp_condition_result_8;
            PyObject *tmp_compexpr_left_7;
            PyObject *tmp_compexpr_right_7;
            tmp_compexpr_left_7 = EXC_TYPE(PyThreadState_GET());
            tmp_compexpr_right_7 = PyExc_BaseException;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_7, tmp_compexpr_right_7 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1012;
                type_description_1 = "ooooooooc";
                goto try_except_handler_9;
            }
            tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_8;
            }
            else
            {
                goto branch_no_8;
            }
            branch_yes_8:;
            {
                nuitka_bool tmp_assign_source_16;
                tmp_assign_source_16 = NUITKA_BOOL_FALSE;
                tmp_with_2__indicator = tmp_assign_source_16;
            }
            {
                nuitka_bool tmp_condition_result_9;
                PyObject *tmp_operand_name_3;
                PyObject *tmp_called_name_8;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_args_element_name_8;
                CHECK_OBJECT( tmp_with_2__exit );
                tmp_called_name_8 = tmp_with_2__exit;
                tmp_args_element_name_6 = EXC_TYPE(PyThreadState_GET());
                tmp_args_element_name_7 = EXC_VALUE(PyThreadState_GET());
                tmp_args_element_name_8 = EXC_TRACEBACK(PyThreadState_GET());
                frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1012;
                {
                    PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
                    tmp_operand_name_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, call_args );
                }

                if ( tmp_operand_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1012;
                    type_description_1 = "ooooooooc";
                    goto try_except_handler_9;
                }
                tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
                Py_DECREF( tmp_operand_name_3 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1012;
                    type_description_1 = "ooooooooc";
                    goto try_except_handler_9;
                }
                tmp_condition_result_9 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_9;
                }
                else
                {
                    goto branch_no_9;
                }
                branch_yes_9:;
                tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                if (unlikely( tmp_result == false ))
                {
                    exception_lineno = 1012;
                }

                if (exception_tb && exception_tb->tb_frame == &frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame) frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = exception_tb->tb_lineno;
                type_description_1 = "ooooooooc";
                goto try_except_handler_9;
                branch_no_9:;
            }
            goto branch_end_8;
            branch_no_8:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 1012;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame) frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "ooooooooc";
            goto try_except_handler_9;
            branch_end_8:;
        }
        goto try_end_6;
        // Exception handler code:
        try_except_handler_9:;
        exception_keeper_type_6 = exception_type;
        exception_keeper_value_6 = exception_value;
        exception_keeper_tb_6 = exception_tb;
        exception_keeper_lineno_6 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Restore previous exception.
        SET_CURRENT_EXCEPTION( exception_preserved_type_2, exception_preserved_value_2, exception_preserved_tb_2 );
        // Re-raise.
        exception_type = exception_keeper_type_6;
        exception_value = exception_keeper_value_6;
        exception_tb = exception_keeper_tb_6;
        exception_lineno = exception_keeper_lineno_6;

        goto try_except_handler_3;
        // End of try:
        try_end_6:;
        // Restore previous exception.
        SET_CURRENT_EXCEPTION( exception_preserved_type_2, exception_preserved_value_2, exception_preserved_tb_2 );
        goto try_end_5;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl$$$function_84_sendall );
        return NULL;
        // End of try:
        try_end_5:;
        goto try_end_7;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_7 = exception_type;
        exception_keeper_value_7 = exception_value;
        exception_keeper_tb_7 = exception_tb;
        exception_keeper_lineno_7 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            nuitka_bool tmp_condition_result_10;
            nuitka_bool tmp_compexpr_left_8;
            nuitka_bool tmp_compexpr_right_8;
            assert( tmp_with_2__indicator != NUITKA_BOOL_UNASSIGNED);
            tmp_compexpr_left_8 = tmp_with_2__indicator;
            tmp_compexpr_right_8 = NUITKA_BOOL_TRUE;
            tmp_condition_result_10 = ( tmp_compexpr_left_8 == tmp_compexpr_right_8 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_10;
            }
            else
            {
                goto branch_no_10;
            }
            branch_yes_10:;
            {
                PyObject *tmp_called_name_9;
                PyObject *tmp_call_result_4;
                CHECK_OBJECT( tmp_with_2__exit );
                tmp_called_name_9 = tmp_with_2__exit;
                frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1012;
                tmp_call_result_4 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

                if ( tmp_call_result_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    Py_DECREF( exception_keeper_type_7 );
                    Py_XDECREF( exception_keeper_value_7 );
                    Py_XDECREF( exception_keeper_tb_7 );

                    exception_lineno = 1012;
                    type_description_1 = "ooooooooc";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_4 );
            }
            branch_no_10:;
        }
        // Re-raise.
        exception_type = exception_keeper_type_7;
        exception_value = exception_keeper_value_7;
        exception_tb = exception_keeper_tb_7;
        exception_lineno = exception_keeper_lineno_7;

        goto try_except_handler_2;
        // End of try:
        try_end_7:;
        {
            nuitka_bool tmp_condition_result_11;
            nuitka_bool tmp_compexpr_left_9;
            nuitka_bool tmp_compexpr_right_9;
            assert( tmp_with_2__indicator != NUITKA_BOOL_UNASSIGNED);
            tmp_compexpr_left_9 = tmp_with_2__indicator;
            tmp_compexpr_right_9 = NUITKA_BOOL_TRUE;
            tmp_condition_result_11 = ( tmp_compexpr_left_9 == tmp_compexpr_right_9 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_11;
            }
            else
            {
                goto branch_no_11;
            }
            branch_yes_11:;
            {
                PyObject *tmp_called_name_10;
                PyObject *tmp_call_result_5;
                CHECK_OBJECT( tmp_with_2__exit );
                tmp_called_name_10 = tmp_with_2__exit;
                frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1012;
                tmp_call_result_5 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_10, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

                if ( tmp_call_result_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1012;
                    type_description_1 = "ooooooooc";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_5 );
            }
            branch_no_11:;
        }
        goto try_end_8;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_8 = exception_type;
        exception_keeper_value_8 = exception_value;
        exception_keeper_tb_8 = exception_tb;
        exception_keeper_lineno_8 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_with_2__source );
        tmp_with_2__source = NULL;

        Py_XDECREF( tmp_with_2__enter );
        tmp_with_2__enter = NULL;

        Py_XDECREF( tmp_with_2__exit );
        tmp_with_2__exit = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_8;
        exception_value = exception_keeper_value_8;
        exception_tb = exception_keeper_tb_8;
        exception_lineno = exception_keeper_lineno_8;

        goto frame_exception_exit_1;
        // End of try:
        try_end_8:;
        CHECK_OBJECT( (PyObject *)tmp_with_2__source );
        Py_DECREF( tmp_with_2__source );
        tmp_with_2__source = NULL;

        CHECK_OBJECT( (PyObject *)tmp_with_2__enter );
        Py_DECREF( tmp_with_2__enter );
        tmp_with_2__enter = NULL;

        CHECK_OBJECT( (PyObject *)tmp_with_2__exit );
        Py_DECREF( tmp_with_2__exit );
        tmp_with_2__exit = NULL;

        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_type_name_1;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_args_element_name_10;
            if ( PyCell_GET( self->m_closure[0] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1018;
                type_description_1 = "ooooooooc";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
            CHECK_OBJECT( par_self );
            tmp_object_name_1 = par_self;
            tmp_called_instance_3 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
            if ( tmp_called_instance_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1018;
                type_description_1 = "ooooooooc";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_data );
            tmp_args_element_name_9 = par_data;
            CHECK_OBJECT( par_flags );
            tmp_args_element_name_10 = par_flags;
            frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame.f_lineno = 1018;
            {
                PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
                tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_sendall, call_args );
            }

            Py_DECREF( tmp_called_instance_3 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1018;
                type_description_1 = "ooooooooc";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f2722bf3b4b9cc66de9b446db7a9e02 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f2722bf3b4b9cc66de9b446db7a9e02 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f2722bf3b4b9cc66de9b446db7a9e02 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6f2722bf3b4b9cc66de9b446db7a9e02, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6f2722bf3b4b9cc66de9b446db7a9e02->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6f2722bf3b4b9cc66de9b446db7a9e02, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6f2722bf3b4b9cc66de9b446db7a9e02,
        type_description_1,
        par_self,
        par_data,
        par_flags,
        var_count,
        var_view,
        var_byte_view,
        var_amount,
        var_v,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_6f2722bf3b4b9cc66de9b446db7a9e02 == cache_frame_6f2722bf3b4b9cc66de9b446db7a9e02 )
    {
        Py_DECREF( frame_6f2722bf3b4b9cc66de9b446db7a9e02 );
    }
    cache_frame_6f2722bf3b4b9cc66de9b446db7a9e02 = NULL;

    assertFrameObject( frame_6f2722bf3b4b9cc66de9b446db7a9e02 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_84_sendall );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    Py_XDECREF( var_count );
    var_count = NULL;

    Py_XDECREF( var_view );
    var_view = NULL;

    Py_XDECREF( var_byte_view );
    var_byte_view = NULL;

    Py_XDECREF( var_amount );
    var_amount = NULL;

    Py_XDECREF( var_v );
    var_v = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    Py_XDECREF( var_count );
    var_count = NULL;

    Py_XDECREF( var_view );
    var_view = NULL;

    Py_XDECREF( var_byte_view );
    var_byte_view = NULL;

    Py_XDECREF( var_amount );
    var_amount = NULL;

    Py_XDECREF( var_v );
    var_v = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_84_sendall );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_85_sendfile( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_file = python_pars[ 1 ];
    PyObject *par_offset = python_pars[ 2 ];
    PyObject *par_count = python_pars[ 3 ];
    struct Nuitka_FrameObject *frame_b6715770c57c475edff269e2bfce93b7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_b6715770c57c475edff269e2bfce93b7 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b6715770c57c475edff269e2bfce93b7, codeobj_b6715770c57c475edff269e2bfce93b7, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b6715770c57c475edff269e2bfce93b7 = cache_frame_b6715770c57c475edff269e2bfce93b7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b6715770c57c475edff269e2bfce93b7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b6715770c57c475edff269e2bfce93b7 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1024;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( par_file );
            tmp_args_element_name_1 = par_file;
            CHECK_OBJECT( par_offset );
            tmp_args_element_name_2 = par_offset;
            CHECK_OBJECT( par_count );
            tmp_args_element_name_3 = par_count;
            frame_b6715770c57c475edff269e2bfce93b7->m_frame.f_lineno = 1025;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain__sendfile_use_send, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1025;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_type_name_1;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_args_element_name_6;
            if ( PyCell_GET( self->m_closure[0] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1028;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
            CHECK_OBJECT( par_self );
            tmp_object_name_1 = par_self;
            tmp_called_instance_2 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1028;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_file );
            tmp_args_element_name_4 = par_file;
            CHECK_OBJECT( par_offset );
            tmp_args_element_name_5 = par_offset;
            CHECK_OBJECT( par_count );
            tmp_args_element_name_6 = par_count;
            frame_b6715770c57c475edff269e2bfce93b7->m_frame.f_lineno = 1028;
            {
                PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
                tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_2, const_str_plain_sendfile, call_args );
            }

            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1028;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b6715770c57c475edff269e2bfce93b7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b6715770c57c475edff269e2bfce93b7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b6715770c57c475edff269e2bfce93b7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b6715770c57c475edff269e2bfce93b7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b6715770c57c475edff269e2bfce93b7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b6715770c57c475edff269e2bfce93b7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b6715770c57c475edff269e2bfce93b7,
        type_description_1,
        par_self,
        par_file,
        par_offset,
        par_count,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_b6715770c57c475edff269e2bfce93b7 == cache_frame_b6715770c57c475edff269e2bfce93b7 )
    {
        Py_DECREF( frame_b6715770c57c475edff269e2bfce93b7 );
    }
    cache_frame_b6715770c57c475edff269e2bfce93b7 = NULL;

    assertFrameObject( frame_b6715770c57c475edff269e2bfce93b7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_85_sendfile );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_file );
    Py_DECREF( par_file );
    par_file = NULL;

    CHECK_OBJECT( (PyObject *)par_offset );
    Py_DECREF( par_offset );
    par_offset = NULL;

    CHECK_OBJECT( (PyObject *)par_count );
    Py_DECREF( par_count );
    par_count = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_file );
    Py_DECREF( par_file );
    par_file = NULL;

    CHECK_OBJECT( (PyObject *)par_offset );
    Py_DECREF( par_offset );
    par_offset = NULL;

    CHECK_OBJECT( (PyObject *)par_count );
    Py_DECREF( par_count );
    par_count = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_85_sendfile );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_86_recv( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buflen = python_pars[ 1 ];
    PyObject *par_flags = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_3e272a599979dddb2106eeb0ca82341b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3e272a599979dddb2106eeb0ca82341b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3e272a599979dddb2106eeb0ca82341b, codeobj_3e272a599979dddb2106eeb0ca82341b, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3e272a599979dddb2106eeb0ca82341b = cache_frame_3e272a599979dddb2106eeb0ca82341b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3e272a599979dddb2106eeb0ca82341b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3e272a599979dddb2106eeb0ca82341b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_3e272a599979dddb2106eeb0ca82341b->m_frame.f_lineno = 1031;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1031;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1032;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( par_flags );
            tmp_compexpr_left_2 = par_flags;
            tmp_compexpr_right_2 = const_int_0;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1033;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_source_name_2;
                tmp_left_name_1 = const_str_digest_8c05d508622896570bf3da8f7e6eb9cb;
                CHECK_OBJECT( par_self );
                tmp_source_name_2 = par_self;
                tmp_right_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
                if ( tmp_right_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1036;
                    type_description_1 = "oooc";
                    goto frame_exception_exit_1;
                }
                tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
                Py_DECREF( tmp_right_name_1 );
                if ( tmp_make_exception_arg_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1035;
                    type_description_1 = "oooc";
                    goto frame_exception_exit_1;
                }
                frame_3e272a599979dddb2106eeb0ca82341b->m_frame.f_lineno = 1034;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                Py_DECREF( tmp_make_exception_arg_1 );
                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 1034;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT( par_buflen );
            tmp_args_element_name_1 = par_buflen;
            frame_3e272a599979dddb2106eeb0ca82341b->m_frame.f_lineno = 1037;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_read, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1037;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_type_name_1;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            if ( PyCell_GET( self->m_closure[0] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1039;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
            CHECK_OBJECT( par_self );
            tmp_object_name_1 = par_self;
            tmp_called_instance_3 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
            if ( tmp_called_instance_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1039;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_buflen );
            tmp_args_element_name_2 = par_buflen;
            CHECK_OBJECT( par_flags );
            tmp_args_element_name_3 = par_flags;
            frame_3e272a599979dddb2106eeb0ca82341b->m_frame.f_lineno = 1039;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_recv, call_args );
            }

            Py_DECREF( tmp_called_instance_3 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1039;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3e272a599979dddb2106eeb0ca82341b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3e272a599979dddb2106eeb0ca82341b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3e272a599979dddb2106eeb0ca82341b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3e272a599979dddb2106eeb0ca82341b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3e272a599979dddb2106eeb0ca82341b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3e272a599979dddb2106eeb0ca82341b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3e272a599979dddb2106eeb0ca82341b,
        type_description_1,
        par_self,
        par_buflen,
        par_flags,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_3e272a599979dddb2106eeb0ca82341b == cache_frame_3e272a599979dddb2106eeb0ca82341b )
    {
        Py_DECREF( frame_3e272a599979dddb2106eeb0ca82341b );
    }
    cache_frame_3e272a599979dddb2106eeb0ca82341b = NULL;

    assertFrameObject( frame_3e272a599979dddb2106eeb0ca82341b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_86_recv );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buflen );
    Py_DECREF( par_buflen );
    par_buflen = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buflen );
    Py_DECREF( par_buflen );
    par_buflen = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_86_recv );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_87_recv_into( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *par_nbytes = python_pars[ 2 ];
    PyObject *par_flags = python_pars[ 3 ];
    struct Nuitka_FrameObject *frame_54a01adef0ac9e521553dadf12222313;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_54a01adef0ac9e521553dadf12222313 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_54a01adef0ac9e521553dadf12222313, codeobj_54a01adef0ac9e521553dadf12222313, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_54a01adef0ac9e521553dadf12222313 = cache_frame_54a01adef0ac9e521553dadf12222313;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_54a01adef0ac9e521553dadf12222313 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_54a01adef0ac9e521553dadf12222313 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_54a01adef0ac9e521553dadf12222313->m_frame.f_lineno = 1042;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1042;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        int tmp_truth_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_buffer );
        tmp_truth_name_1 = CHECK_IF_TRUE( par_buffer );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1043;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_nbytes );
        tmp_compexpr_left_1 = par_nbytes;
        tmp_compexpr_right_1 = Py_None;
        tmp_and_right_value_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_len_arg_1;
            CHECK_OBJECT( par_buffer );
            tmp_len_arg_1 = par_buffer;
            tmp_assign_source_1 = BUILTIN_LEN( tmp_len_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1044;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_nbytes;
                assert( old != NULL );
                par_nbytes = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( par_nbytes );
            tmp_compexpr_left_2 = par_nbytes;
            tmp_compexpr_right_2 = Py_None;
            tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_2;
                tmp_assign_source_2 = const_int_pos_1024;
                {
                    PyObject *old = par_nbytes;
                    assert( old != NULL );
                    par_nbytes = tmp_assign_source_2;
                    Py_INCREF( par_nbytes );
                    Py_DECREF( old );
                }

            }
            branch_no_2:;
        }
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1047;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = Py_None;
        tmp_condition_result_3 = ( tmp_compexpr_left_3 != tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_3 );
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            CHECK_OBJECT( par_flags );
            tmp_compexpr_left_4 = par_flags;
            tmp_compexpr_right_4 = const_int_0;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1048;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_source_name_2;
                tmp_left_name_1 = const_str_digest_d1654dbcf9c06006c0b37bb1c5c65ca0;
                CHECK_OBJECT( par_self );
                tmp_source_name_2 = par_self;
                tmp_right_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
                if ( tmp_right_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1051;
                    type_description_1 = "ooooc";
                    goto frame_exception_exit_1;
                }
                tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
                Py_DECREF( tmp_right_name_1 );
                if ( tmp_make_exception_arg_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1050;
                    type_description_1 = "ooooc";
                    goto frame_exception_exit_1;
                }
                frame_54a01adef0ac9e521553dadf12222313->m_frame.f_lineno = 1049;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                Py_DECREF( tmp_make_exception_arg_1 );
                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 1049;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            branch_no_4:;
        }
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_read );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1052;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            if ( par_nbytes == NULL )
            {
                Py_DECREF( tmp_called_name_1 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "nbytes" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1052;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }

            tmp_args_element_name_1 = par_nbytes;
            CHECK_OBJECT( par_buffer );
            tmp_args_element_name_2 = par_buffer;
            frame_54a01adef0ac9e521553dadf12222313->m_frame.f_lineno = 1052;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1052;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_3;
        branch_no_3:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_type_name_1;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            if ( PyCell_GET( self->m_closure[0] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1054;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
            CHECK_OBJECT( par_self );
            tmp_object_name_1 = par_self;
            tmp_source_name_4 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
            if ( tmp_source_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1054;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_recv_into );
            Py_DECREF( tmp_source_name_4 );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1054;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_buffer );
            tmp_args_element_name_3 = par_buffer;
            if ( par_nbytes == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "nbytes" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1054;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }

            tmp_args_element_name_4 = par_nbytes;
            CHECK_OBJECT( par_flags );
            tmp_args_element_name_5 = par_flags;
            frame_54a01adef0ac9e521553dadf12222313->m_frame.f_lineno = 1054;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1054;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_3:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_54a01adef0ac9e521553dadf12222313 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_54a01adef0ac9e521553dadf12222313 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_54a01adef0ac9e521553dadf12222313 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_54a01adef0ac9e521553dadf12222313, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_54a01adef0ac9e521553dadf12222313->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_54a01adef0ac9e521553dadf12222313, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_54a01adef0ac9e521553dadf12222313,
        type_description_1,
        par_self,
        par_buffer,
        par_nbytes,
        par_flags,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_54a01adef0ac9e521553dadf12222313 == cache_frame_54a01adef0ac9e521553dadf12222313 )
    {
        Py_DECREF( frame_54a01adef0ac9e521553dadf12222313 );
    }
    cache_frame_54a01adef0ac9e521553dadf12222313 = NULL;

    assertFrameObject( frame_54a01adef0ac9e521553dadf12222313 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_87_recv_into );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( par_nbytes );
    par_nbytes = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( par_nbytes );
    par_nbytes = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_87_recv_into );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_88_recvfrom( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buflen = python_pars[ 1 ];
    PyObject *par_flags = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_d836e52222fa765674eb7fabb95e256a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_d836e52222fa765674eb7fabb95e256a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d836e52222fa765674eb7fabb95e256a, codeobj_d836e52222fa765674eb7fabb95e256a, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d836e52222fa765674eb7fabb95e256a = cache_frame_d836e52222fa765674eb7fabb95e256a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d836e52222fa765674eb7fabb95e256a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d836e52222fa765674eb7fabb95e256a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_d836e52222fa765674eb7fabb95e256a->m_frame.f_lineno = 1057;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1057;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1058;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_source_name_2;
            tmp_left_name_1 = const_str_digest_8b455849c74cb8521c58441c05e67f30;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_right_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1060;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1059;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            frame_d836e52222fa765674eb7fabb95e256a->m_frame.f_lineno = 1059;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1059;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_type_name_1;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            if ( PyCell_GET( self->m_closure[0] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1062;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
            CHECK_OBJECT( par_self );
            tmp_object_name_1 = par_self;
            tmp_called_instance_2 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1062;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_buflen );
            tmp_args_element_name_1 = par_buflen;
            CHECK_OBJECT( par_flags );
            tmp_args_element_name_2 = par_flags;
            frame_d836e52222fa765674eb7fabb95e256a->m_frame.f_lineno = 1062;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_recvfrom, call_args );
            }

            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1062;
                type_description_1 = "oooc";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d836e52222fa765674eb7fabb95e256a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d836e52222fa765674eb7fabb95e256a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d836e52222fa765674eb7fabb95e256a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d836e52222fa765674eb7fabb95e256a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d836e52222fa765674eb7fabb95e256a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d836e52222fa765674eb7fabb95e256a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d836e52222fa765674eb7fabb95e256a,
        type_description_1,
        par_self,
        par_buflen,
        par_flags,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_d836e52222fa765674eb7fabb95e256a == cache_frame_d836e52222fa765674eb7fabb95e256a )
    {
        Py_DECREF( frame_d836e52222fa765674eb7fabb95e256a );
    }
    cache_frame_d836e52222fa765674eb7fabb95e256a = NULL;

    assertFrameObject( frame_d836e52222fa765674eb7fabb95e256a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_88_recvfrom );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buflen );
    Py_DECREF( par_buflen );
    par_buflen = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buflen );
    Py_DECREF( par_buflen );
    par_buflen = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_88_recvfrom );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_89_recvfrom_into( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *par_nbytes = python_pars[ 2 ];
    PyObject *par_flags = python_pars[ 3 ];
    struct Nuitka_FrameObject *frame_102787f65a848b0f5ef93c552b2754a8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_102787f65a848b0f5ef93c552b2754a8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_102787f65a848b0f5ef93c552b2754a8, codeobj_102787f65a848b0f5ef93c552b2754a8, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_102787f65a848b0f5ef93c552b2754a8 = cache_frame_102787f65a848b0f5ef93c552b2754a8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_102787f65a848b0f5ef93c552b2754a8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_102787f65a848b0f5ef93c552b2754a8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_102787f65a848b0f5ef93c552b2754a8->m_frame.f_lineno = 1065;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1065;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1066;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_source_name_2;
            tmp_left_name_1 = const_str_digest_8ccc1038eb9505b2eb128b6c50cf7933;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_right_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1068;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1067;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            frame_102787f65a848b0f5ef93c552b2754a8->m_frame.f_lineno = 1067;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1067;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_type_name_1;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            if ( PyCell_GET( self->m_closure[0] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1070;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
            CHECK_OBJECT( par_self );
            tmp_object_name_1 = par_self;
            tmp_called_instance_2 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1070;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_buffer );
            tmp_args_element_name_1 = par_buffer;
            CHECK_OBJECT( par_nbytes );
            tmp_args_element_name_2 = par_nbytes;
            CHECK_OBJECT( par_flags );
            tmp_args_element_name_3 = par_flags;
            frame_102787f65a848b0f5ef93c552b2754a8->m_frame.f_lineno = 1070;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_2, const_str_plain_recvfrom_into, call_args );
            }

            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1070;
                type_description_1 = "ooooc";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_102787f65a848b0f5ef93c552b2754a8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_102787f65a848b0f5ef93c552b2754a8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_102787f65a848b0f5ef93c552b2754a8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_102787f65a848b0f5ef93c552b2754a8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_102787f65a848b0f5ef93c552b2754a8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_102787f65a848b0f5ef93c552b2754a8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_102787f65a848b0f5ef93c552b2754a8,
        type_description_1,
        par_self,
        par_buffer,
        par_nbytes,
        par_flags,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_102787f65a848b0f5ef93c552b2754a8 == cache_frame_102787f65a848b0f5ef93c552b2754a8 )
    {
        Py_DECREF( frame_102787f65a848b0f5ef93c552b2754a8 );
    }
    cache_frame_102787f65a848b0f5ef93c552b2754a8 = NULL;

    assertFrameObject( frame_102787f65a848b0f5ef93c552b2754a8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_89_recvfrom_into );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_nbytes );
    Py_DECREF( par_nbytes );
    par_nbytes = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_nbytes );
    Py_DECREF( par_nbytes );
    par_nbytes = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_89_recvfrom_into );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_90_recvmsg( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_6753233f97c67ba60fed48cd037a5da1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6753233f97c67ba60fed48cd037a5da1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6753233f97c67ba60fed48cd037a5da1, codeobj_6753233f97c67ba60fed48cd037a5da1, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6753233f97c67ba60fed48cd037a5da1 = cache_frame_6753233f97c67ba60fed48cd037a5da1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6753233f97c67ba60fed48cd037a5da1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6753233f97c67ba60fed48cd037a5da1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_1;
        tmp_left_name_1 = const_str_digest_8d25e8341eff71b65c9386d4018600c9;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_1 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1074;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1073;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_6753233f97c67ba60fed48cd037a5da1->m_frame.f_lineno = 1073;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 1073;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6753233f97c67ba60fed48cd037a5da1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6753233f97c67ba60fed48cd037a5da1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6753233f97c67ba60fed48cd037a5da1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6753233f97c67ba60fed48cd037a5da1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6753233f97c67ba60fed48cd037a5da1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6753233f97c67ba60fed48cd037a5da1,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_6753233f97c67ba60fed48cd037a5da1 == cache_frame_6753233f97c67ba60fed48cd037a5da1 )
    {
        Py_DECREF( frame_6753233f97c67ba60fed48cd037a5da1 );
    }
    cache_frame_6753233f97c67ba60fed48cd037a5da1 = NULL;

    assertFrameObject( frame_6753233f97c67ba60fed48cd037a5da1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_90_recvmsg );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_90_recvmsg );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_ssl$$$function_91_recvmsg_into( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_b9c49bf51fd490ce845154517abf5afe;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b9c49bf51fd490ce845154517abf5afe = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b9c49bf51fd490ce845154517abf5afe, codeobj_b9c49bf51fd490ce845154517abf5afe, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b9c49bf51fd490ce845154517abf5afe = cache_frame_b9c49bf51fd490ce845154517abf5afe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b9c49bf51fd490ce845154517abf5afe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b9c49bf51fd490ce845154517abf5afe ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_1;
        tmp_left_name_1 = const_str_digest_193178a81b56eec77a885bf7ab4dceb1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_1 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1078;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1077;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_b9c49bf51fd490ce845154517abf5afe->m_frame.f_lineno = 1077;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 1077;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b9c49bf51fd490ce845154517abf5afe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b9c49bf51fd490ce845154517abf5afe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b9c49bf51fd490ce845154517abf5afe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b9c49bf51fd490ce845154517abf5afe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b9c49bf51fd490ce845154517abf5afe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b9c49bf51fd490ce845154517abf5afe,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_b9c49bf51fd490ce845154517abf5afe == cache_frame_b9c49bf51fd490ce845154517abf5afe )
    {
        Py_DECREF( frame_b9c49bf51fd490ce845154517abf5afe );
    }
    cache_frame_b9c49bf51fd490ce845154517abf5afe = NULL;

    assertFrameObject( frame_b9c49bf51fd490ce845154517abf5afe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_91_recvmsg_into );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_91_recvmsg_into );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_ssl$$$function_92_pending( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a, codeobj_c9ee113a8b3a2d7e49dd2e5a09a16c0a, module_ssl, sizeof(void *) );
    frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a = cache_frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a->m_frame.f_lineno = 1081;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1081;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1082;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1083;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a->m_frame.f_lineno = 1083;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_pending );
            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1083;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_return_value = const_int_0;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a == cache_frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a )
    {
        Py_DECREF( frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a );
    }
    cache_frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a = NULL;

    assertFrameObject( frame_c9ee113a8b3a2d7e49dd2e5a09a16c0a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_92_pending );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_92_pending );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_93_shutdown( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_how = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_b581a977e97c824d653f0d91e1864d5a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b581a977e97c824d653f0d91e1864d5a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b581a977e97c824d653f0d91e1864d5a, codeobj_b581a977e97c824d653f0d91e1864d5a, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b581a977e97c824d653f0d91e1864d5a = cache_frame_b581a977e97c824d653f0d91e1864d5a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b581a977e97c824d653f0d91e1864d5a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b581a977e97c824d653f0d91e1864d5a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_b581a977e97c824d653f0d91e1864d5a->m_frame.f_lineno = 1088;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__checkClosed );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1088;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__sslobj, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1089;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_type_name_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1090;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_self );
        tmp_object_name_1 = par_self;
        tmp_called_instance_2 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_called_instance_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1090;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_how );
        tmp_args_element_name_1 = par_how;
        frame_b581a977e97c824d653f0d91e1864d5a->m_frame.f_lineno = 1090;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_shutdown, call_args );
        }

        Py_DECREF( tmp_called_instance_2 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1090;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b581a977e97c824d653f0d91e1864d5a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b581a977e97c824d653f0d91e1864d5a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b581a977e97c824d653f0d91e1864d5a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b581a977e97c824d653f0d91e1864d5a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b581a977e97c824d653f0d91e1864d5a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b581a977e97c824d653f0d91e1864d5a,
        type_description_1,
        par_self,
        par_how,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_b581a977e97c824d653f0d91e1864d5a == cache_frame_b581a977e97c824d653f0d91e1864d5a )
    {
        Py_DECREF( frame_b581a977e97c824d653f0d91e1864d5a );
    }
    cache_frame_b581a977e97c824d653f0d91e1864d5a = NULL;

    assertFrameObject( frame_b581a977e97c824d653f0d91e1864d5a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_93_shutdown );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_how );
    Py_DECREF( par_how );
    par_how = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_how );
    Py_DECREF( par_how );
    par_how = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_93_shutdown );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_94_unwrap( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_s = NULL;
    struct Nuitka_FrameObject *frame_f30c98b20585ea45248d54a7a131cbd6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f30c98b20585ea45248d54a7a131cbd6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f30c98b20585ea45248d54a7a131cbd6, codeobj_f30c98b20585ea45248d54a7a131cbd6, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_f30c98b20585ea45248d54a7a131cbd6 = cache_frame_f30c98b20585ea45248d54a7a131cbd6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f30c98b20585ea45248d54a7a131cbd6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f30c98b20585ea45248d54a7a131cbd6 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1093;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 1093;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1094;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_f30c98b20585ea45248d54a7a131cbd6->m_frame.f_lineno = 1094;
            tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_shutdown );
            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1094;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            assert( var_s == NULL );
            var_s = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            tmp_assattr_name_1 = Py_None;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__sslobj, tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1095;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
        }
        CHECK_OBJECT( var_s );
        tmp_return_value = var_s;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_unicode_arg_1;
            tmp_left_name_1 = const_str_digest_cb937a135d1407a4127cb28ad691044b;
            CHECK_OBJECT( par_self );
            tmp_unicode_arg_1 = par_self;
            tmp_right_name_1 = PyObject_Unicode( tmp_unicode_arg_1 );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1098;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_make_exception_arg_1 = BINARY_OPERATION_ADD_UNICODE_OBJECT( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1098;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_f30c98b20585ea45248d54a7a131cbd6->m_frame.f_lineno = 1098;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1098;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f30c98b20585ea45248d54a7a131cbd6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f30c98b20585ea45248d54a7a131cbd6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f30c98b20585ea45248d54a7a131cbd6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f30c98b20585ea45248d54a7a131cbd6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f30c98b20585ea45248d54a7a131cbd6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f30c98b20585ea45248d54a7a131cbd6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f30c98b20585ea45248d54a7a131cbd6,
        type_description_1,
        par_self,
        var_s
    );


    // Release cached frame.
    if ( frame_f30c98b20585ea45248d54a7a131cbd6 == cache_frame_f30c98b20585ea45248d54a7a131cbd6 )
    {
        Py_DECREF( frame_f30c98b20585ea45248d54a7a131cbd6 );
    }
    cache_frame_f30c98b20585ea45248d54a7a131cbd6 = NULL;

    assertFrameObject( frame_f30c98b20585ea45248d54a7a131cbd6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_94_unwrap );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_s );
    Py_DECREF( var_s );
    var_s = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_s );
    var_s = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_94_unwrap );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_95_verify_client_post_handshake( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_c308f005c60a48850ddc38c70cfc9e4a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c308f005c60a48850ddc38c70cfc9e4a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c308f005c60a48850ddc38c70cfc9e4a, codeobj_c308f005c60a48850ddc38c70cfc9e4a, module_ssl, sizeof(void *) );
    frame_c308f005c60a48850ddc38c70cfc9e4a = cache_frame_c308f005c60a48850ddc38c70cfc9e4a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c308f005c60a48850ddc38c70cfc9e4a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c308f005c60a48850ddc38c70cfc9e4a ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1101;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 1101;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1102;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_c308f005c60a48850ddc38c70cfc9e4a->m_frame.f_lineno = 1102;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_verify_client_post_handshake );
            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1102;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_unicode_arg_1;
            tmp_left_name_1 = const_str_digest_cb937a135d1407a4127cb28ad691044b;
            CHECK_OBJECT( par_self );
            tmp_unicode_arg_1 = par_self;
            tmp_right_name_1 = PyObject_Unicode( tmp_unicode_arg_1 );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1104;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_make_exception_arg_1 = BINARY_OPERATION_ADD_UNICODE_OBJECT( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1104;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_c308f005c60a48850ddc38c70cfc9e4a->m_frame.f_lineno = 1104;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1104;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c308f005c60a48850ddc38c70cfc9e4a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c308f005c60a48850ddc38c70cfc9e4a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c308f005c60a48850ddc38c70cfc9e4a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c308f005c60a48850ddc38c70cfc9e4a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c308f005c60a48850ddc38c70cfc9e4a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c308f005c60a48850ddc38c70cfc9e4a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c308f005c60a48850ddc38c70cfc9e4a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c308f005c60a48850ddc38c70cfc9e4a == cache_frame_c308f005c60a48850ddc38c70cfc9e4a )
    {
        Py_DECREF( frame_c308f005c60a48850ddc38c70cfc9e4a );
    }
    cache_frame_c308f005c60a48850ddc38c70cfc9e4a = NULL;

    assertFrameObject( frame_c308f005c60a48850ddc38c70cfc9e4a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_95_verify_client_post_handshake );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_95_verify_client_post_handshake );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_96__real_close( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_84c36608fe52cf263db57111bd71529a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_84c36608fe52cf263db57111bd71529a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_84c36608fe52cf263db57111bd71529a, codeobj_84c36608fe52cf263db57111bd71529a, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_84c36608fe52cf263db57111bd71529a = cache_frame_84c36608fe52cf263db57111bd71529a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_84c36608fe52cf263db57111bd71529a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_84c36608fe52cf263db57111bd71529a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__sslobj, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1107;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_call_result_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1108;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_self );
        tmp_object_name_1 = par_self;
        tmp_called_instance_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1108;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        frame_84c36608fe52cf263db57111bd71529a->m_frame.f_lineno = 1108;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__real_close );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1108;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84c36608fe52cf263db57111bd71529a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84c36608fe52cf263db57111bd71529a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_84c36608fe52cf263db57111bd71529a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_84c36608fe52cf263db57111bd71529a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_84c36608fe52cf263db57111bd71529a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_84c36608fe52cf263db57111bd71529a,
        type_description_1,
        par_self,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_84c36608fe52cf263db57111bd71529a == cache_frame_84c36608fe52cf263db57111bd71529a )
    {
        Py_DECREF( frame_84c36608fe52cf263db57111bd71529a );
    }
    cache_frame_84c36608fe52cf263db57111bd71529a = NULL;

    assertFrameObject( frame_84c36608fe52cf263db57111bd71529a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_96__real_close );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_96__real_close );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_97_do_handshake( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_block = python_pars[ 1 ];
    PyObject *var_timeout = NULL;
    struct Nuitka_FrameObject *frame_732e9b90c8c97c0d936101eda76a8170;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_732e9b90c8c97c0d936101eda76a8170 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_732e9b90c8c97c0d936101eda76a8170, codeobj_732e9b90c8c97c0d936101eda76a8170, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_732e9b90c8c97c0d936101eda76a8170 = cache_frame_732e9b90c8c97c0d936101eda76a8170;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_732e9b90c8c97c0d936101eda76a8170 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_732e9b90c8c97c0d936101eda76a8170 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_732e9b90c8c97c0d936101eda76a8170->m_frame.f_lineno = 1112;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__check_connected );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1112;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        frame_732e9b90c8c97c0d936101eda76a8170->m_frame.f_lineno = 1113;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_gettimeout );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1113;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_timeout == NULL );
        var_timeout = tmp_assign_source_1;
    }
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( var_timeout );
        tmp_compexpr_left_1 = var_timeout;
        tmp_compexpr_right_1 = const_float_0_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1115;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_block );
        tmp_truth_name_1 = CHECK_IF_TRUE( par_block );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1115;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        tmp_and_right_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_call_result_2;
            CHECK_OBJECT( par_self );
            tmp_called_instance_3 = par_self;
            frame_732e9b90c8c97c0d936101eda76a8170->m_frame.f_lineno = 1116;
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_settimeout, &PyTuple_GET_ITEM( const_tuple_none_tuple, 0 ) );

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1116;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_4 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_called_instance_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1117;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        frame_732e9b90c8c97c0d936101eda76a8170->m_frame.f_lineno = 1117;
        tmp_call_result_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_do_handshake );
        Py_DECREF( tmp_called_instance_4 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1117;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_732e9b90c8c97c0d936101eda76a8170, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_732e9b90c8c97c0d936101eda76a8170, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    // Tried code:
    {
        PyObject *tmp_called_instance_5;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_5 = par_self;
        CHECK_OBJECT( var_timeout );
        tmp_args_element_name_1 = var_timeout;
        frame_732e9b90c8c97c0d936101eda76a8170->m_frame.f_lineno = 1119;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_settimeout, call_args );
        }

        if ( tmp_call_result_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1119;
            type_description_1 = "ooo";
            goto try_except_handler_3;
        }
        Py_DECREF( tmp_call_result_4 );
    }
    tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (unlikely( tmp_result == false ))
    {
        exception_lineno = 1114;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_732e9b90c8c97c0d936101eda76a8170->m_frame) frame_732e9b90c8c97c0d936101eda76a8170->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "ooo";
    goto try_except_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_97_do_handshake );
    return NULL;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    // End of try:
    try_end_1:;
    {
        PyObject *tmp_called_instance_6;
        PyObject *tmp_call_result_5;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_6 = par_self;
        CHECK_OBJECT( var_timeout );
        tmp_args_element_name_2 = var_timeout;
        frame_732e9b90c8c97c0d936101eda76a8170->m_frame.f_lineno = 1119;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_settimeout, call_args );
        }

        if ( tmp_call_result_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1119;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_5 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_732e9b90c8c97c0d936101eda76a8170 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_732e9b90c8c97c0d936101eda76a8170 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_732e9b90c8c97c0d936101eda76a8170, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_732e9b90c8c97c0d936101eda76a8170->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_732e9b90c8c97c0d936101eda76a8170, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_732e9b90c8c97c0d936101eda76a8170,
        type_description_1,
        par_self,
        par_block,
        var_timeout
    );


    // Release cached frame.
    if ( frame_732e9b90c8c97c0d936101eda76a8170 == cache_frame_732e9b90c8c97c0d936101eda76a8170 )
    {
        Py_DECREF( frame_732e9b90c8c97c0d936101eda76a8170 );
    }
    cache_frame_732e9b90c8c97c0d936101eda76a8170 = NULL;

    assertFrameObject( frame_732e9b90c8c97c0d936101eda76a8170 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_97_do_handshake );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_block );
    Py_DECREF( par_block );
    par_block = NULL;

    CHECK_OBJECT( (PyObject *)var_timeout );
    Py_DECREF( var_timeout );
    var_timeout = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_block );
    Py_DECREF( par_block );
    par_block = NULL;

    Py_XDECREF( var_timeout );
    var_timeout = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_97_do_handshake );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_98__real_connect( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_addr = python_pars[ 1 ];
    PyObject *par_connect_ex = python_pars[ 2 ];
    PyObject *var_rc = NULL;
    struct Nuitka_FrameObject *frame_ce20ccea364a64a500bf53152ecbb3df;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_ce20ccea364a64a500bf53152ecbb3df = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ce20ccea364a64a500bf53152ecbb3df, codeobj_ce20ccea364a64a500bf53152ecbb3df, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ce20ccea364a64a500bf53152ecbb3df = cache_frame_ce20ccea364a64a500bf53152ecbb3df;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ce20ccea364a64a500bf53152ecbb3df );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ce20ccea364a64a500bf53152ecbb3df ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_server_side );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1122;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 1122;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_3248563d58214c71a4c9da2c5bedaa28;
            frame_ce20ccea364a64a500bf53152ecbb3df->m_frame.f_lineno = 1123;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1123;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_attribute_value_2;
        int tmp_truth_name_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_attribute_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__connected );
        if ( tmp_attribute_value_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1126;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_2 = CHECK_IF_TRUE( tmp_attribute_value_2 );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_2 );

            exception_lineno = 1126;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_2 );
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1126;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_or_right_value_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        tmp_condition_result_2 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_2 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_f3590796fc6a572064ab68e58c2e47b2;
            frame_ce20ccea364a64a500bf53152ecbb3df->m_frame.f_lineno = 1127;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 1127;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_6;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_source_name_7;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_source_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_context );
        if ( tmp_source_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1128;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__wrap_socket );
        Py_DECREF( tmp_source_name_4 );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1128;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_tuple_element_1 = par_self;
        tmp_args_name_1 = PyTuple_New( 3 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
        tmp_tuple_element_1 = Py_False;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_server_hostname );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );

            exception_lineno = 1129;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
        tmp_dict_key_1 = const_str_plain_owner;
        CHECK_OBJECT( par_self );
        tmp_dict_value_1 = par_self;
        tmp_kw_name_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_2 = const_str_plain_session;
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_dict_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__session );
        if ( tmp_dict_value_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );
            Py_DECREF( tmp_kw_name_1 );

            exception_lineno = 1130;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
        Py_DECREF( tmp_dict_value_2 );
        assert( !(tmp_res != 0) );
        frame_ce20ccea364a64a500bf53152ecbb3df->m_frame.f_lineno = 1128;
        tmp_assattr_name_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1128;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__sslobj, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1128;
            type_description_1 = "ooooc";
            goto frame_exception_exit_1;
        }
    }
    // Tried code:
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_truth_name_3;
        CHECK_OBJECT( par_connect_ex );
        tmp_truth_name_3 = CHECK_IF_TRUE( par_connect_ex );
        if ( tmp_truth_name_3 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1133;
            type_description_1 = "ooooc";
            goto try_except_handler_2;
        }
        tmp_condition_result_3 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_type_name_1;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_1;
            if ( PyCell_GET( self->m_closure[0] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1134;
                type_description_1 = "ooooc";
                goto try_except_handler_2;
            }

            tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
            CHECK_OBJECT( par_self );
            tmp_object_name_1 = par_self;
            tmp_called_instance_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1134;
                type_description_1 = "ooooc";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( par_addr );
            tmp_args_element_name_1 = par_addr;
            frame_ce20ccea364a64a500bf53152ecbb3df->m_frame.f_lineno = 1134;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_connect_ex, call_args );
            }

            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1134;
                type_description_1 = "ooooc";
                goto try_except_handler_2;
            }
            assert( var_rc == NULL );
            var_rc = tmp_assign_source_1;
        }
        goto branch_end_3;
        branch_no_3:;
        {
            PyObject *tmp_assign_source_2;
            tmp_assign_source_2 = Py_None;
            assert( var_rc == NULL );
            Py_INCREF( tmp_assign_source_2 );
            var_rc = tmp_assign_source_2;
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_type_name_2;
            PyObject *tmp_object_name_2;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            if ( PyCell_GET( self->m_closure[0] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1137;
                type_description_1 = "ooooc";
                goto try_except_handler_2;
            }

            tmp_type_name_2 = PyCell_GET( self->m_closure[0] );
            CHECK_OBJECT( par_self );
            tmp_object_name_2 = par_self;
            tmp_called_instance_2 = BUILTIN_SUPER( tmp_type_name_2, tmp_object_name_2 );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1137;
                type_description_1 = "ooooc";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( par_addr );
            tmp_args_element_name_2 = par_addr;
            frame_ce20ccea364a64a500bf53152ecbb3df->m_frame.f_lineno = 1137;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_connect, call_args );
            }

            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1137;
                type_description_1 = "ooooc";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_end_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( var_rc );
        tmp_operand_name_1 = var_rc;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1138;
            type_description_1 = "ooooc";
            goto try_except_handler_2;
        }
        tmp_condition_result_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            tmp_assattr_name_2 = Py_True;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_2 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__connected, tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1139;
                type_description_1 = "ooooc";
                goto try_except_handler_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_source_name_8;
            PyObject *tmp_attribute_value_3;
            int tmp_truth_name_4;
            CHECK_OBJECT( par_self );
            tmp_source_name_8 = par_self;
            tmp_attribute_value_3 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_do_handshake_on_connect );
            if ( tmp_attribute_value_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1140;
                type_description_1 = "ooooc";
                goto try_except_handler_2;
            }
            tmp_truth_name_4 = CHECK_IF_TRUE( tmp_attribute_value_3 );
            if ( tmp_truth_name_4 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_attribute_value_3 );

                exception_lineno = 1140;
                type_description_1 = "ooooc";
                goto try_except_handler_2;
            }
            tmp_condition_result_5 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_attribute_value_3 );
            if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_5;
            }
            else
            {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_called_instance_3;
                PyObject *tmp_call_result_2;
                CHECK_OBJECT( par_self );
                tmp_called_instance_3 = par_self;
                frame_ce20ccea364a64a500bf53152ecbb3df->m_frame.f_lineno = 1141;
                tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_do_handshake );
                if ( tmp_call_result_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1141;
                    type_description_1 = "ooooc";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_2 );
            }
            branch_no_5:;
        }
        branch_no_4:;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_ce20ccea364a64a500bf53152ecbb3df, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_ce20ccea364a64a500bf53152ecbb3df, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_2 = const_tuple_type_OSError_type_ValueError_tuple;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1143;
            type_description_1 = "ooooc";
            goto try_except_handler_3;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_assattr_name_3;
            PyObject *tmp_assattr_target_3;
            tmp_assattr_name_3 = Py_None;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_3 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__sslobj, tmp_assattr_name_3 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1144;
                type_description_1 = "ooooc";
                goto try_except_handler_3;
            }
        }
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 1145;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_ce20ccea364a64a500bf53152ecbb3df->m_frame) frame_ce20ccea364a64a500bf53152ecbb3df->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooooc";
        goto try_except_handler_3;
        goto branch_end_6;
        branch_no_6:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 1132;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_ce20ccea364a64a500bf53152ecbb3df->m_frame) frame_ce20ccea364a64a500bf53152ecbb3df->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooooc";
        goto try_except_handler_3;
        branch_end_6:;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_98__real_connect );
    return NULL;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce20ccea364a64a500bf53152ecbb3df );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce20ccea364a64a500bf53152ecbb3df );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ce20ccea364a64a500bf53152ecbb3df, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ce20ccea364a64a500bf53152ecbb3df->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ce20ccea364a64a500bf53152ecbb3df, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ce20ccea364a64a500bf53152ecbb3df,
        type_description_1,
        par_self,
        par_addr,
        par_connect_ex,
        var_rc,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_ce20ccea364a64a500bf53152ecbb3df == cache_frame_ce20ccea364a64a500bf53152ecbb3df )
    {
        Py_DECREF( frame_ce20ccea364a64a500bf53152ecbb3df );
    }
    cache_frame_ce20ccea364a64a500bf53152ecbb3df = NULL;

    assertFrameObject( frame_ce20ccea364a64a500bf53152ecbb3df );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_rc );
    tmp_return_value = var_rc;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_98__real_connect );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_connect_ex );
    Py_DECREF( par_connect_ex );
    par_connect_ex = NULL;

    CHECK_OBJECT( (PyObject *)var_rc );
    Py_DECREF( var_rc );
    var_rc = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_connect_ex );
    Py_DECREF( par_connect_ex );
    par_connect_ex = NULL;

    Py_XDECREF( var_rc );
    var_rc = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_98__real_connect );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_99_connect( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_addr = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_e55c77de5189f075a317b4725d964bc7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e55c77de5189f075a317b4725d964bc7 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e55c77de5189f075a317b4725d964bc7, codeobj_e55c77de5189f075a317b4725d964bc7, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_e55c77de5189f075a317b4725d964bc7 = cache_frame_e55c77de5189f075a317b4725d964bc7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e55c77de5189f075a317b4725d964bc7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e55c77de5189f075a317b4725d964bc7 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_addr );
        tmp_args_element_name_1 = par_addr;
        tmp_args_element_name_2 = Py_False;
        frame_e55c77de5189f075a317b4725d964bc7->m_frame.f_lineno = 1150;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain__real_connect, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1150;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e55c77de5189f075a317b4725d964bc7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e55c77de5189f075a317b4725d964bc7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e55c77de5189f075a317b4725d964bc7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e55c77de5189f075a317b4725d964bc7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e55c77de5189f075a317b4725d964bc7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e55c77de5189f075a317b4725d964bc7,
        type_description_1,
        par_self,
        par_addr
    );


    // Release cached frame.
    if ( frame_e55c77de5189f075a317b4725d964bc7 == cache_frame_e55c77de5189f075a317b4725d964bc7 )
    {
        Py_DECREF( frame_e55c77de5189f075a317b4725d964bc7 );
    }
    cache_frame_e55c77de5189f075a317b4725d964bc7 = NULL;

    assertFrameObject( frame_e55c77de5189f075a317b4725d964bc7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_99_connect );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_99_connect );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_100_connect_ex( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_addr = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_a86b95352fc9c8cca13ec96f3cf3e648;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a86b95352fc9c8cca13ec96f3cf3e648 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a86b95352fc9c8cca13ec96f3cf3e648, codeobj_a86b95352fc9c8cca13ec96f3cf3e648, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_a86b95352fc9c8cca13ec96f3cf3e648 = cache_frame_a86b95352fc9c8cca13ec96f3cf3e648;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a86b95352fc9c8cca13ec96f3cf3e648 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a86b95352fc9c8cca13ec96f3cf3e648 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_addr );
        tmp_args_element_name_1 = par_addr;
        tmp_args_element_name_2 = Py_True;
        frame_a86b95352fc9c8cca13ec96f3cf3e648->m_frame.f_lineno = 1155;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain__real_connect, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1155;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a86b95352fc9c8cca13ec96f3cf3e648 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a86b95352fc9c8cca13ec96f3cf3e648 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a86b95352fc9c8cca13ec96f3cf3e648 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a86b95352fc9c8cca13ec96f3cf3e648, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a86b95352fc9c8cca13ec96f3cf3e648->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a86b95352fc9c8cca13ec96f3cf3e648, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a86b95352fc9c8cca13ec96f3cf3e648,
        type_description_1,
        par_self,
        par_addr
    );


    // Release cached frame.
    if ( frame_a86b95352fc9c8cca13ec96f3cf3e648 == cache_frame_a86b95352fc9c8cca13ec96f3cf3e648 )
    {
        Py_DECREF( frame_a86b95352fc9c8cca13ec96f3cf3e648 );
    }
    cache_frame_a86b95352fc9c8cca13ec96f3cf3e648 = NULL;

    assertFrameObject( frame_a86b95352fc9c8cca13ec96f3cf3e648 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_100_connect_ex );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_100_connect_ex );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_101_accept( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_newsock = NULL;
    PyObject *var_addr = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_3ddc9f7565e4886cd4a659572d70f974;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_3ddc9f7565e4886cd4a659572d70f974 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3ddc9f7565e4886cd4a659572d70f974, codeobj_3ddc9f7565e4886cd4a659572d70f974, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3ddc9f7565e4886cd4a659572d70f974 = cache_frame_3ddc9f7565e4886cd4a659572d70f974;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3ddc9f7565e4886cd4a659572d70f974 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3ddc9f7565e4886cd4a659572d70f974 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_object_name_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "__class__" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1162;
            type_description_1 = "oooc";
            goto try_except_handler_2;
        }

        tmp_type_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_self );
        tmp_object_name_1 = par_self;
        tmp_called_instance_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1162;
            type_description_1 = "oooc";
            goto try_except_handler_2;
        }
        frame_3ddc9f7565e4886cd4a659572d70f974->m_frame.f_lineno = 1162;
        tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_accept );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1162;
            type_description_1 = "oooc";
            goto try_except_handler_2;
        }
        tmp_assign_source_1 = MAKE_UNPACK_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1162;
            type_description_1 = "oooc";
            goto try_except_handler_2;
        }
        assert( tmp_tuple_unpack_1__source_iter == NULL );
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_1;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_2 = UNPACK_NEXT( tmp_unpack_1, 0, 2 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooc";
            exception_lineno = 1162;
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__element_1 == NULL );
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_2, 1, 2 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooc";
            exception_lineno = 1162;
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__element_2 == NULL );
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_3;
    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "oooc";
                    exception_lineno = 1162;
                    goto try_except_handler_3;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "oooc";
            exception_lineno = 1162;
            goto try_except_handler_3;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_4 = tmp_tuple_unpack_1__element_1;
        assert( var_newsock == NULL );
        Py_INCREF( tmp_assign_source_4 );
        var_newsock = tmp_assign_source_4;
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_5 = tmp_tuple_unpack_1__element_2;
        assert( var_addr == NULL );
        Py_INCREF( tmp_assign_source_5 );
        var_addr = tmp_assign_source_5;
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_context );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1163;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_wrap_socket );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1163;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_newsock );
        tmp_tuple_element_1 = var_newsock;
        tmp_args_name_1 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
        tmp_dict_key_1 = const_str_plain_do_handshake_on_connect;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_do_handshake_on_connect );
        if ( tmp_dict_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );

            exception_lineno = 1164;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
        Py_DECREF( tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_2 = const_str_plain_suppress_ragged_eofs;
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_dict_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_suppress_ragged_eofs );
        if ( tmp_dict_value_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );
            Py_DECREF( tmp_kw_name_1 );

            exception_lineno = 1165;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
        Py_DECREF( tmp_dict_value_2 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_3 = const_str_plain_server_side;
        tmp_dict_value_3 = Py_True;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
        assert( !(tmp_res != 0) );
        frame_3ddc9f7565e4886cd4a659572d70f974->m_frame.f_lineno = 1163;
        tmp_assign_source_6 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1163;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_newsock;
            assert( old != NULL );
            var_newsock = tmp_assign_source_6;
            Py_DECREF( old );
        }

    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ddc9f7565e4886cd4a659572d70f974 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ddc9f7565e4886cd4a659572d70f974 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3ddc9f7565e4886cd4a659572d70f974, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3ddc9f7565e4886cd4a659572d70f974->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3ddc9f7565e4886cd4a659572d70f974, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3ddc9f7565e4886cd4a659572d70f974,
        type_description_1,
        par_self,
        var_newsock,
        var_addr,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_3ddc9f7565e4886cd4a659572d70f974 == cache_frame_3ddc9f7565e4886cd4a659572d70f974 )
    {
        Py_DECREF( frame_3ddc9f7565e4886cd4a659572d70f974 );
    }
    cache_frame_3ddc9f7565e4886cd4a659572d70f974 = NULL;

    assertFrameObject( frame_3ddc9f7565e4886cd4a659572d70f974 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    {
        PyObject *tmp_tuple_element_2;
        CHECK_OBJECT( var_newsock );
        tmp_tuple_element_2 = var_newsock;
        tmp_return_value = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_return_value, 0, tmp_tuple_element_2 );
        CHECK_OBJECT( var_addr );
        tmp_tuple_element_2 = var_addr;
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_return_value, 1, tmp_tuple_element_2 );
        goto try_return_handler_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_101_accept );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_newsock );
    Py_DECREF( var_newsock );
    var_newsock = NULL;

    CHECK_OBJECT( (PyObject *)var_addr );
    Py_DECREF( var_addr );
    var_addr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_newsock );
    var_newsock = NULL;

    Py_XDECREF( var_addr );
    var_addr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_101_accept );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_102_get_channel_binding( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cb_type = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_0adca387694c9d0d05e6dcf361654043;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_0adca387694c9d0d05e6dcf361654043 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0adca387694c9d0d05e6dcf361654043, codeobj_0adca387694c9d0d05e6dcf361654043, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_0adca387694c9d0d05e6dcf361654043 = cache_frame_0adca387694c9d0d05e6dcf361654043;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0adca387694c9d0d05e6dcf361654043 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0adca387694c9d0d05e6dcf361654043 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1174;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1175;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_cb_type );
            tmp_args_element_name_1 = par_cb_type;
            frame_0adca387694c9d0d05e6dcf361654043->m_frame.f_lineno = 1175;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_get_channel_binding, call_args );
            }

            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1175;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT( par_cb_type );
            tmp_compexpr_left_2 = par_cb_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CHANNEL_BINDING_TYPES );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CHANNEL_BINDING_TYPES );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CHANNEL_BINDING_TYPES" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1177;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_res = PySequence_Contains( tmp_compexpr_right_2, tmp_compexpr_left_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1177;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                tmp_called_instance_2 = const_str_digest_b0a77916798fd37c9cee67fc494763a2;
                CHECK_OBJECT( par_cb_type );
                tmp_args_element_name_2 = par_cb_type;
                frame_0adca387694c9d0d05e6dcf361654043->m_frame.f_lineno = 1179;
                {
                    PyObject *call_args[] = { tmp_args_element_name_2 };
                    tmp_make_exception_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_format, call_args );
                }

                if ( tmp_make_exception_arg_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1179;
                    type_description_1 = "oo";
                    goto frame_exception_exit_1;
                }
                frame_0adca387694c9d0d05e6dcf361654043->m_frame.f_lineno = 1178;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                Py_DECREF( tmp_make_exception_arg_1 );
                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 1178;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0adca387694c9d0d05e6dcf361654043 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0adca387694c9d0d05e6dcf361654043 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0adca387694c9d0d05e6dcf361654043 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0adca387694c9d0d05e6dcf361654043, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0adca387694c9d0d05e6dcf361654043->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0adca387694c9d0d05e6dcf361654043, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0adca387694c9d0d05e6dcf361654043,
        type_description_1,
        par_self,
        par_cb_type
    );


    // Release cached frame.
    if ( frame_0adca387694c9d0d05e6dcf361654043 == cache_frame_0adca387694c9d0d05e6dcf361654043 )
    {
        Py_DECREF( frame_0adca387694c9d0d05e6dcf361654043 );
    }
    cache_frame_0adca387694c9d0d05e6dcf361654043 = NULL;

    assertFrameObject( frame_0adca387694c9d0d05e6dcf361654043 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_102_get_channel_binding );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cb_type );
    Py_DECREF( par_cb_type );
    par_cb_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cb_type );
    Py_DECREF( par_cb_type );
    par_cb_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_102_get_channel_binding );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_103_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_431602757d87c0ffb4cfc07c16f40c0f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_431602757d87c0ffb4cfc07c16f40c0f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_431602757d87c0ffb4cfc07c16f40c0f, codeobj_431602757d87c0ffb4cfc07c16f40c0f, module_ssl, sizeof(void *) );
    frame_431602757d87c0ffb4cfc07c16f40c0f = cache_frame_431602757d87c0ffb4cfc07c16f40c0f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_431602757d87c0ffb4cfc07c16f40c0f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_431602757d87c0ffb4cfc07c16f40c0f ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__sslobj );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1188;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__sslobj );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1189;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_431602757d87c0ffb4cfc07c16f40c0f->m_frame.f_lineno = 1189;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_version );
            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1189;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_431602757d87c0ffb4cfc07c16f40c0f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_431602757d87c0ffb4cfc07c16f40c0f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_431602757d87c0ffb4cfc07c16f40c0f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_431602757d87c0ffb4cfc07c16f40c0f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_431602757d87c0ffb4cfc07c16f40c0f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_431602757d87c0ffb4cfc07c16f40c0f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_431602757d87c0ffb4cfc07c16f40c0f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_431602757d87c0ffb4cfc07c16f40c0f == cache_frame_431602757d87c0ffb4cfc07c16f40c0f )
    {
        Py_DECREF( frame_431602757d87c0ffb4cfc07c16f40c0f );
    }
    cache_frame_431602757d87c0ffb4cfc07c16f40c0f = NULL;

    assertFrameObject( frame_431602757d87c0ffb4cfc07c16f40c0f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_103_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_103_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_104_wrap_socket( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_sock = python_pars[ 0 ];
    PyObject *par_keyfile = python_pars[ 1 ];
    PyObject *par_certfile = python_pars[ 2 ];
    PyObject *par_server_side = python_pars[ 3 ];
    PyObject *par_cert_reqs = python_pars[ 4 ];
    PyObject *par_ssl_version = python_pars[ 5 ];
    PyObject *par_ca_certs = python_pars[ 6 ];
    PyObject *par_do_handshake_on_connect = python_pars[ 7 ];
    PyObject *par_suppress_ragged_eofs = python_pars[ 8 ];
    PyObject *par_ciphers = python_pars[ 9 ];
    PyObject *var_context = NULL;
    struct Nuitka_FrameObject *frame_e52a48e17e348b81afa21bb0833b5cee;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_e52a48e17e348b81afa21bb0833b5cee = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e52a48e17e348b81afa21bb0833b5cee, codeobj_e52a48e17e348b81afa21bb0833b5cee, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e52a48e17e348b81afa21bb0833b5cee = cache_frame_e52a48e17e348b81afa21bb0833b5cee;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e52a48e17e348b81afa21bb0833b5cee );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e52a48e17e348b81afa21bb0833b5cee ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        int tmp_truth_name_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( par_server_side );
        tmp_truth_name_1 = CHECK_IF_TRUE( par_server_side );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1206;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_certfile );
        tmp_operand_name_1 = par_certfile;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1206;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_a94b2028d7a56b84bcb25adb9dde5120;
            frame_e52a48e17e348b81afa21bb0833b5cee->m_frame.f_lineno = 1207;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1207;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        int tmp_truth_name_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( par_keyfile );
        tmp_truth_name_2 = CHECK_IF_TRUE( par_keyfile );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1209;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT( par_certfile );
        tmp_operand_name_2 = par_certfile;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1209;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_2 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_condition_result_2 = tmp_and_left_value_2;
        and_end_2:;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_d2f106a7c85896a5d2d135f72c5b78b7;
            frame_e52a48e17e348b81afa21bb0833b5cee->m_frame.f_lineno = 1210;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 1210;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1211;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ssl_version );
        tmp_args_element_name_1 = par_ssl_version;
        frame_e52a48e17e348b81afa21bb0833b5cee->m_frame.f_lineno = 1211;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1211;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_context == NULL );
        var_context = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_cert_reqs );
        tmp_assattr_name_1 = par_cert_reqs;
        CHECK_OBJECT( var_context );
        tmp_assattr_target_1 = var_context;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_verify_mode, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1212;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_truth_name_3;
        CHECK_OBJECT( par_ca_certs );
        tmp_truth_name_3 = CHECK_IF_TRUE( par_ca_certs );
        if ( tmp_truth_name_3 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1213;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT( var_context );
            tmp_called_instance_1 = var_context;
            CHECK_OBJECT( par_ca_certs );
            tmp_args_element_name_2 = par_ca_certs;
            frame_e52a48e17e348b81afa21bb0833b5cee->m_frame.f_lineno = 1214;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_load_verify_locations, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1214;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_truth_name_4;
        CHECK_OBJECT( par_certfile );
        tmp_truth_name_4 = CHECK_IF_TRUE( par_certfile );
        if ( tmp_truth_name_4 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1215;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            CHECK_OBJECT( var_context );
            tmp_called_instance_2 = var_context;
            CHECK_OBJECT( par_certfile );
            tmp_args_element_name_3 = par_certfile;
            CHECK_OBJECT( par_keyfile );
            tmp_args_element_name_4 = par_keyfile;
            frame_e52a48e17e348b81afa21bb0833b5cee->m_frame.f_lineno = 1216;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_load_cert_chain, call_args );
            }

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1216;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        int tmp_truth_name_5;
        CHECK_OBJECT( par_ciphers );
        tmp_truth_name_5 = CHECK_IF_TRUE( par_ciphers );
        if ( tmp_truth_name_5 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1217;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = tmp_truth_name_5 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_5;
            CHECK_OBJECT( var_context );
            tmp_called_instance_3 = var_context;
            CHECK_OBJECT( par_ciphers );
            tmp_args_element_name_5 = par_ciphers;
            frame_e52a48e17e348b81afa21bb0833b5cee->m_frame.f_lineno = 1218;
            {
                PyObject *call_args[] = { tmp_args_element_name_5 };
                tmp_call_result_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_set_ciphers, call_args );
            }

            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1218;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        CHECK_OBJECT( var_context );
        tmp_source_name_1 = var_context;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_wrap_socket );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1219;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_sock;
        CHECK_OBJECT( par_sock );
        tmp_dict_value_1 = par_sock;
        tmp_kw_name_1 = _PyDict_NewPresized( 4 );
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_2 = const_str_plain_server_side;
        CHECK_OBJECT( par_server_side );
        tmp_dict_value_2 = par_server_side;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_3 = const_str_plain_do_handshake_on_connect;
        CHECK_OBJECT( par_do_handshake_on_connect );
        tmp_dict_value_3 = par_do_handshake_on_connect;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_4 = const_str_plain_suppress_ragged_eofs;
        CHECK_OBJECT( par_suppress_ragged_eofs );
        tmp_dict_value_4 = par_suppress_ragged_eofs;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
        assert( !(tmp_res != 0) );
        frame_e52a48e17e348b81afa21bb0833b5cee->m_frame.f_lineno = 1219;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1219;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e52a48e17e348b81afa21bb0833b5cee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e52a48e17e348b81afa21bb0833b5cee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e52a48e17e348b81afa21bb0833b5cee );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e52a48e17e348b81afa21bb0833b5cee, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e52a48e17e348b81afa21bb0833b5cee->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e52a48e17e348b81afa21bb0833b5cee, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e52a48e17e348b81afa21bb0833b5cee,
        type_description_1,
        par_sock,
        par_keyfile,
        par_certfile,
        par_server_side,
        par_cert_reqs,
        par_ssl_version,
        par_ca_certs,
        par_do_handshake_on_connect,
        par_suppress_ragged_eofs,
        par_ciphers,
        var_context
    );


    // Release cached frame.
    if ( frame_e52a48e17e348b81afa21bb0833b5cee == cache_frame_e52a48e17e348b81afa21bb0833b5cee )
    {
        Py_DECREF( frame_e52a48e17e348b81afa21bb0833b5cee );
    }
    cache_frame_e52a48e17e348b81afa21bb0833b5cee = NULL;

    assertFrameObject( frame_e52a48e17e348b81afa21bb0833b5cee );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_104_wrap_socket );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_sock );
    Py_DECREF( par_sock );
    par_sock = NULL;

    CHECK_OBJECT( (PyObject *)par_keyfile );
    Py_DECREF( par_keyfile );
    par_keyfile = NULL;

    CHECK_OBJECT( (PyObject *)par_certfile );
    Py_DECREF( par_certfile );
    par_certfile = NULL;

    CHECK_OBJECT( (PyObject *)par_server_side );
    Py_DECREF( par_server_side );
    par_server_side = NULL;

    CHECK_OBJECT( (PyObject *)par_cert_reqs );
    Py_DECREF( par_cert_reqs );
    par_cert_reqs = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl_version );
    Py_DECREF( par_ssl_version );
    par_ssl_version = NULL;

    CHECK_OBJECT( (PyObject *)par_ca_certs );
    Py_DECREF( par_ca_certs );
    par_ca_certs = NULL;

    CHECK_OBJECT( (PyObject *)par_do_handshake_on_connect );
    Py_DECREF( par_do_handshake_on_connect );
    par_do_handshake_on_connect = NULL;

    CHECK_OBJECT( (PyObject *)par_suppress_ragged_eofs );
    Py_DECREF( par_suppress_ragged_eofs );
    par_suppress_ragged_eofs = NULL;

    CHECK_OBJECT( (PyObject *)par_ciphers );
    Py_DECREF( par_ciphers );
    par_ciphers = NULL;

    CHECK_OBJECT( (PyObject *)var_context );
    Py_DECREF( var_context );
    var_context = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_sock );
    Py_DECREF( par_sock );
    par_sock = NULL;

    CHECK_OBJECT( (PyObject *)par_keyfile );
    Py_DECREF( par_keyfile );
    par_keyfile = NULL;

    CHECK_OBJECT( (PyObject *)par_certfile );
    Py_DECREF( par_certfile );
    par_certfile = NULL;

    CHECK_OBJECT( (PyObject *)par_server_side );
    Py_DECREF( par_server_side );
    par_server_side = NULL;

    CHECK_OBJECT( (PyObject *)par_cert_reqs );
    Py_DECREF( par_cert_reqs );
    par_cert_reqs = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl_version );
    Py_DECREF( par_ssl_version );
    par_ssl_version = NULL;

    CHECK_OBJECT( (PyObject *)par_ca_certs );
    Py_DECREF( par_ca_certs );
    par_ca_certs = NULL;

    CHECK_OBJECT( (PyObject *)par_do_handshake_on_connect );
    Py_DECREF( par_do_handshake_on_connect );
    par_do_handshake_on_connect = NULL;

    CHECK_OBJECT( (PyObject *)par_suppress_ragged_eofs );
    Py_DECREF( par_suppress_ragged_eofs );
    par_suppress_ragged_eofs = NULL;

    CHECK_OBJECT( (PyObject *)par_ciphers );
    Py_DECREF( par_ciphers );
    par_ciphers = NULL;

    Py_XDECREF( var_context );
    var_context = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_104_wrap_socket );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_105_cert_time_to_seconds( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cert_time = python_pars[ 0 ];
    PyObject *var_strptime = NULL;
    PyObject *var_timegm = NULL;
    PyObject *var_month_number = NULL;
    PyObject *var_tt = NULL;
    struct Nuitka_FrameObject *frame_f0d4a14b639c208b031798e88d64dcf8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f0d4a14b639c208b031798e88d64dcf8 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        PyObject *tmp_level_name_1;
        tmp_name_name_1 = const_str_plain_time;
        tmp_globals_name_1 = (PyObject *)moduledict_ssl;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain_strptime_tuple;
        tmp_level_name_1 = const_int_0;
        tmp_import_name_from_1 = IMPORT_MODULE5( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1, tmp_level_name_1 );
        assert( !(tmp_import_name_from_1 == NULL) );
        tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_strptime );
        Py_DECREF( tmp_import_name_from_1 );
        assert( !(tmp_assign_source_1 == NULL) );
        assert( var_strptime == NULL );
        var_strptime = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f0d4a14b639c208b031798e88d64dcf8, codeobj_f0d4a14b639c208b031798e88d64dcf8, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f0d4a14b639c208b031798e88d64dcf8 = cache_frame_f0d4a14b639c208b031798e88d64dcf8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f0d4a14b639c208b031798e88d64dcf8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f0d4a14b639c208b031798e88d64dcf8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_import_name_from_2;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        PyObject *tmp_level_name_2;
        tmp_name_name_2 = const_str_plain_calendar;
        tmp_globals_name_2 = (PyObject *)moduledict_ssl;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = const_tuple_str_plain_timegm_tuple;
        tmp_level_name_2 = const_int_0;
        frame_f0d4a14b639c208b031798e88d64dcf8->m_frame.f_lineno = 1238;
        tmp_import_name_from_2 = IMPORT_MODULE5( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2, tmp_level_name_2 );
        if ( tmp_import_name_from_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1238;
            type_description_1 = "oooNNoo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_timegm );
        Py_DECREF( tmp_import_name_from_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1238;
            type_description_1 = "oooNNoo";
            goto frame_exception_exit_1;
        }
        assert( var_timegm == NULL );
        var_timegm = tmp_assign_source_2;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_right_name_1;
        tmp_source_name_1 = const_tuple_e3f1f861e20f2c66d91a00fa8f97a3a3_tuple;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_index );
        assert( !(tmp_called_name_1 == NULL) );
        CHECK_OBJECT( par_cert_time );
        tmp_subscribed_name_1 = par_cert_time;
        tmp_subscript_name_1 = const_slice_none_int_pos_3_none;
        tmp_called_instance_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1246;
            type_description_1 = "oooNNoo";
            goto try_except_handler_2;
        }
        frame_f0d4a14b639c208b031798e88d64dcf8->m_frame.f_lineno = 1246;
        tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_title );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1246;
            type_description_1 = "oooNNoo";
            goto try_except_handler_2;
        }
        frame_f0d4a14b639c208b031798e88d64dcf8->m_frame.f_lineno = 1246;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_left_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1246;
            type_description_1 = "oooNNoo";
            goto try_except_handler_2;
        }
        tmp_right_name_1 = const_int_pos_1;
        tmp_assign_source_3 = BINARY_OPERATION_ADD_OBJECT_LONG( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1246;
            type_description_1 = "oooNNoo";
            goto try_except_handler_2;
        }
        assert( var_month_number == NULL );
        var_month_number = tmp_assign_source_3;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_f0d4a14b639c208b031798e88d64dcf8, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_f0d4a14b639c208b031798e88d64dcf8, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_ValueError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1247;
            type_description_1 = "oooNNoo";
            goto try_except_handler_3;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            PyObject *tmp_tuple_element_1;
            tmp_left_name_2 = const_str_digest_a4d6f3a910ee9d9d33781f7776fa0650;
            CHECK_OBJECT( par_cert_time );
            tmp_tuple_element_1 = par_cert_time;
            tmp_right_name_2 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_1 );
            tmp_tuple_element_1 = const_str_digest_b414a1b63ea6dd23ea915006aafd2a8f;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_1 );
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
            Py_DECREF( tmp_right_name_2 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1248;
                type_description_1 = "oooNNoo";
                goto try_except_handler_3;
            }
            frame_f0d4a14b639c208b031798e88d64dcf8->m_frame.f_lineno = 1248;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1248;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooNNoo";
            goto try_except_handler_3;
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 1245;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_f0d4a14b639c208b031798e88d64dcf8->m_frame) frame_f0d4a14b639c208b031798e88d64dcf8->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooNNoo";
        goto try_except_handler_3;
        branch_end_1:;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_105_cert_time_to_seconds );
    return NULL;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    // End of try:
    try_end_1:;
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( var_strptime );
        tmp_called_name_2 = var_strptime;
        CHECK_OBJECT( par_cert_time );
        tmp_subscribed_name_2 = par_cert_time;
        tmp_subscript_name_2 = const_slice_int_pos_3_none_none;
        tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1252;
            type_description_1 = "oooNNoo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = const_str_digest_b414a1b63ea6dd23ea915006aafd2a8f;
        frame_f0d4a14b639c208b031798e88d64dcf8->m_frame.f_lineno = 1252;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1252;
            type_description_1 = "oooNNoo";
            goto frame_exception_exit_1;
        }
        assert( var_tt == NULL );
        var_tt = tmp_assign_source_4;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_left_name_3;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_right_name_3;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_subscript_name_4;
        CHECK_OBJECT( var_timegm );
        tmp_called_name_3 = var_timegm;
        CHECK_OBJECT( var_tt );
        tmp_subscribed_name_3 = var_tt;
        tmp_subscript_name_3 = const_int_0;
        tmp_tuple_element_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
        if ( tmp_tuple_element_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1255;
            type_description_1 = "oooNNoo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_3 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_left_name_3, 0, tmp_tuple_element_2 );
        CHECK_OBJECT( var_month_number );
        tmp_tuple_element_2 = var_month_number;
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_left_name_3, 1, tmp_tuple_element_2 );
        CHECK_OBJECT( var_tt );
        tmp_subscribed_name_4 = var_tt;
        tmp_subscript_name_4 = const_slice_int_pos_2_int_pos_6_none;
        tmp_right_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
        if ( tmp_right_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_3 );

            exception_lineno = 1255;
            type_description_1 = "oooNNoo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = BINARY_OPERATION_ADD_TUPLE_OBJECT( tmp_left_name_3, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_3 );
        Py_DECREF( tmp_right_name_3 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1255;
            type_description_1 = "oooNNoo";
            goto frame_exception_exit_1;
        }
        frame_f0d4a14b639c208b031798e88d64dcf8->m_frame.f_lineno = 1255;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1255;
            type_description_1 = "oooNNoo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f0d4a14b639c208b031798e88d64dcf8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f0d4a14b639c208b031798e88d64dcf8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f0d4a14b639c208b031798e88d64dcf8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f0d4a14b639c208b031798e88d64dcf8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f0d4a14b639c208b031798e88d64dcf8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f0d4a14b639c208b031798e88d64dcf8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f0d4a14b639c208b031798e88d64dcf8,
        type_description_1,
        par_cert_time,
        var_strptime,
        var_timegm,
        NULL,
        NULL,
        var_month_number,
        var_tt
    );


    // Release cached frame.
    if ( frame_f0d4a14b639c208b031798e88d64dcf8 == cache_frame_f0d4a14b639c208b031798e88d64dcf8 )
    {
        Py_DECREF( frame_f0d4a14b639c208b031798e88d64dcf8 );
    }
    cache_frame_f0d4a14b639c208b031798e88d64dcf8 = NULL;

    assertFrameObject( frame_f0d4a14b639c208b031798e88d64dcf8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_105_cert_time_to_seconds );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cert_time );
    Py_DECREF( par_cert_time );
    par_cert_time = NULL;

    CHECK_OBJECT( (PyObject *)var_strptime );
    Py_DECREF( var_strptime );
    var_strptime = NULL;

    CHECK_OBJECT( (PyObject *)var_timegm );
    Py_DECREF( var_timegm );
    var_timegm = NULL;

    CHECK_OBJECT( (PyObject *)var_month_number );
    Py_DECREF( var_month_number );
    var_month_number = NULL;

    CHECK_OBJECT( (PyObject *)var_tt );
    Py_DECREF( var_tt );
    var_tt = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_cert_time );
    Py_DECREF( par_cert_time );
    par_cert_time = NULL;

    CHECK_OBJECT( (PyObject *)var_strptime );
    Py_DECREF( var_strptime );
    var_strptime = NULL;

    Py_XDECREF( var_timegm );
    var_timegm = NULL;

    Py_XDECREF( var_month_number );
    var_month_number = NULL;

    Py_XDECREF( var_tt );
    var_tt = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_105_cert_time_to_seconds );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_106_DER_cert_to_PEM_cert( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_der_cert_bytes = python_pars[ 0 ];
    PyObject *var_f = NULL;
    PyObject *var_ss = NULL;
    PyObject *outline_0_var_i = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_f0ee1f5fb95d4844854b515739861369;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_9e2248c3806a82f029138496cc7533f5_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_9e2248c3806a82f029138496cc7533f5_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f0ee1f5fb95d4844854b515739861369 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f0ee1f5fb95d4844854b515739861369, codeobj_f0ee1f5fb95d4844854b515739861369, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f0ee1f5fb95d4844854b515739861369 = cache_frame_f0ee1f5fb95d4844854b515739861369;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f0ee1f5fb95d4844854b515739861369 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f0ee1f5fb95d4844854b515739861369 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_unicode_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_unicode_encoding_1;
        PyObject *tmp_unicode_errors_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_base64 );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_base64 );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "base64" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1264;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_der_cert_bytes );
        tmp_args_element_name_1 = par_der_cert_bytes;
        frame_f0ee1f5fb95d4844854b515739861369->m_frame.f_lineno = 1264;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_unicode_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_standard_b64encode, call_args );
        }

        if ( tmp_unicode_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1264;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_unicode_encoding_1 = const_str_plain_ASCII;
        tmp_unicode_errors_1 = const_str_plain_strict;
        tmp_assign_source_1 = TO_UNICODE3( tmp_unicode_arg_1, tmp_unicode_encoding_1, tmp_unicode_errors_1 );
        Py_DECREF( tmp_unicode_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1264;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_f == NULL );
        var_f = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_list_element_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PEM_HEADER );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PEM_HEADER );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PEM_HEADER" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1265;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_list_element_1 = tmp_mvar_value_2;
        tmp_assign_source_2 = PyList_New( 1 );
        Py_INCREF( tmp_list_element_1 );
        PyList_SET_ITEM( tmp_assign_source_2, 0, tmp_list_element_1 );
        assert( var_ss == NULL );
        var_ss = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( var_ss );
        tmp_left_name_1 = var_ss;
        // Tried code:
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_xrange_low_1;
            PyObject *tmp_xrange_high_1;
            PyObject *tmp_len_arg_1;
            PyObject *tmp_xrange_step_1;
            tmp_xrange_low_1 = const_int_0;
            CHECK_OBJECT( var_f );
            tmp_len_arg_1 = var_f;
            tmp_xrange_high_1 = BUILTIN_LEN( tmp_len_arg_1 );
            if ( tmp_xrange_high_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1266;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            tmp_xrange_step_1 = const_int_pos_64;
            tmp_iter_arg_1 = BUILTIN_XRANGE3( tmp_xrange_low_1, tmp_xrange_high_1, tmp_xrange_step_1 );
            Py_DECREF( tmp_xrange_high_1 );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1266;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1266;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            assert( tmp_listcomp_1__$0 == NULL );
            tmp_listcomp_1__$0 = tmp_assign_source_4;
        }
        {
            PyObject *tmp_assign_source_5;
            tmp_assign_source_5 = PyList_New( 0 );
            assert( tmp_listcomp_1__contraction == NULL );
            tmp_listcomp_1__contraction = tmp_assign_source_5;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_9e2248c3806a82f029138496cc7533f5_2, codeobj_9e2248c3806a82f029138496cc7533f5, module_ssl, sizeof(void *)+sizeof(void *) );
        frame_9e2248c3806a82f029138496cc7533f5_2 = cache_frame_9e2248c3806a82f029138496cc7533f5_2;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_9e2248c3806a82f029138496cc7533f5_2 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_9e2248c3806a82f029138496cc7533f5_2 ) == 2 ); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT( tmp_listcomp_1__$0 );
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_6 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_6 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_2 = "oo";
                    exception_lineno = 1266;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_6;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_7;
            CHECK_OBJECT( tmp_listcomp_1__iter_value_0 );
            tmp_assign_source_7 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_i;
                outline_0_var_i = tmp_assign_source_7;
                Py_INCREF( outline_0_var_i );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            PyObject *tmp_start_name_1;
            PyObject *tmp_stop_name_1;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            PyObject *tmp_step_name_1;
            CHECK_OBJECT( tmp_listcomp_1__contraction );
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT( var_f );
            tmp_subscribed_name_1 = var_f;
            CHECK_OBJECT( outline_0_var_i );
            tmp_start_name_1 = outline_0_var_i;
            CHECK_OBJECT( outline_0_var_i );
            tmp_left_name_2 = outline_0_var_i;
            tmp_right_name_2 = const_int_pos_64;
            tmp_stop_name_1 = BINARY_OPERATION_ADD_OBJECT_LONG( tmp_left_name_2, tmp_right_name_2 );
            if ( tmp_stop_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1266;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            tmp_step_name_1 = Py_None;
            tmp_subscript_name_1 = MAKE_SLICEOBJ3( tmp_start_name_1, tmp_stop_name_1, tmp_step_name_1 );
            Py_DECREF( tmp_stop_name_1 );
            assert( !(tmp_subscript_name_1 == NULL) );
            tmp_append_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
            Py_DECREF( tmp_subscript_name_1 );
            if ( tmp_append_value_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1266;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert( PyList_Check( tmp_append_list_1 ) );
            tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
            Py_DECREF( tmp_append_value_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1266;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1266;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT( tmp_listcomp_1__contraction );
        tmp_right_name_1 = tmp_listcomp_1__contraction;
        Py_INCREF( tmp_right_name_1 );
        goto try_return_handler_3;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl$$$function_106_DER_cert_to_PEM_cert );
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT( (PyObject *)tmp_listcomp_1__$0 );
        Py_DECREF( tmp_listcomp_1__$0 );
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_listcomp_1__contraction );
        Py_DECREF( tmp_listcomp_1__contraction );
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF( tmp_listcomp_1__iter_value_0 );
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_listcomp_1__$0 );
        Py_DECREF( tmp_listcomp_1__$0 );
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_listcomp_1__contraction );
        Py_DECREF( tmp_listcomp_1__contraction );
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF( tmp_listcomp_1__iter_value_0 );
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION( frame_9e2248c3806a82f029138496cc7533f5_2 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION( frame_9e2248c3806a82f029138496cc7533f5_2 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_9e2248c3806a82f029138496cc7533f5_2 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_9e2248c3806a82f029138496cc7533f5_2, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_9e2248c3806a82f029138496cc7533f5_2->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_9e2248c3806a82f029138496cc7533f5_2, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_9e2248c3806a82f029138496cc7533f5_2,
            type_description_2,
            outline_0_var_i,
            var_f
        );


        // Release cached frame.
        if ( frame_9e2248c3806a82f029138496cc7533f5_2 == cache_frame_9e2248c3806a82f029138496cc7533f5_2 )
        {
            Py_DECREF( frame_9e2248c3806a82f029138496cc7533f5_2 );
        }
        cache_frame_9e2248c3806a82f029138496cc7533f5_2 = NULL;

        assertFrameObject( frame_9e2248c3806a82f029138496cc7533f5_2 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl$$$function_106_DER_cert_to_PEM_cert );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF( outline_0_var_i );
        outline_0_var_i = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( outline_0_var_i );
        outline_0_var_i = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ssl$$$function_106_DER_cert_to_PEM_cert );
        return NULL;
        outline_exception_1:;
        exception_lineno = 1266;
        goto frame_exception_exit_1;
        outline_result_1:;
        tmp_result = BINARY_OPERATION_ADD_LIST_OBJECT_INPLACE( &tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1266;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = tmp_left_name_1;
        var_ss = tmp_assign_source_3;

    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_right_name_3;
        CHECK_OBJECT( var_ss );
        tmp_source_name_1 = var_ss;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1267;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PEM_FOOTER );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PEM_FOOTER );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PEM_FOOTER" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1267;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_left_name_3 = tmp_mvar_value_3;
        tmp_right_name_3 = const_str_newline;
        tmp_args_element_name_2 = BINARY_OPERATION_ADD_OBJECT_UNICODE( tmp_left_name_3, tmp_right_name_3 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1267;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_f0ee1f5fb95d4844854b515739861369->m_frame.f_lineno = 1267;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1267;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_3;
        tmp_called_instance_2 = const_str_newline;
        CHECK_OBJECT( var_ss );
        tmp_args_element_name_3 = var_ss;
        frame_f0ee1f5fb95d4844854b515739861369->m_frame.f_lineno = 1268;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_join, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1268;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f0ee1f5fb95d4844854b515739861369 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f0ee1f5fb95d4844854b515739861369 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f0ee1f5fb95d4844854b515739861369 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f0ee1f5fb95d4844854b515739861369, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f0ee1f5fb95d4844854b515739861369->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f0ee1f5fb95d4844854b515739861369, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f0ee1f5fb95d4844854b515739861369,
        type_description_1,
        par_der_cert_bytes,
        var_f,
        var_ss
    );


    // Release cached frame.
    if ( frame_f0ee1f5fb95d4844854b515739861369 == cache_frame_f0ee1f5fb95d4844854b515739861369 )
    {
        Py_DECREF( frame_f0ee1f5fb95d4844854b515739861369 );
    }
    cache_frame_f0ee1f5fb95d4844854b515739861369 = NULL;

    assertFrameObject( frame_f0ee1f5fb95d4844854b515739861369 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_106_DER_cert_to_PEM_cert );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_der_cert_bytes );
    Py_DECREF( par_der_cert_bytes );
    par_der_cert_bytes = NULL;

    CHECK_OBJECT( (PyObject *)var_f );
    Py_DECREF( var_f );
    var_f = NULL;

    CHECK_OBJECT( (PyObject *)var_ss );
    Py_DECREF( var_ss );
    var_ss = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_der_cert_bytes );
    Py_DECREF( par_der_cert_bytes );
    par_der_cert_bytes = NULL;

    Py_XDECREF( var_f );
    var_f = NULL;

    Py_XDECREF( var_ss );
    var_ss = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_106_DER_cert_to_PEM_cert );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_107_PEM_cert_to_DER_cert( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_pem_cert_string = python_pars[ 0 ];
    PyObject *var_d = NULL;
    struct Nuitka_FrameObject *frame_d8e122175713d41c07a5a5cfce696240;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_d8e122175713d41c07a5a5cfce696240 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d8e122175713d41c07a5a5cfce696240, codeobj_d8e122175713d41c07a5a5cfce696240, module_ssl, sizeof(void *)+sizeof(void *) );
    frame_d8e122175713d41c07a5a5cfce696240 = cache_frame_d8e122175713d41c07a5a5cfce696240;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d8e122175713d41c07a5a5cfce696240 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d8e122175713d41c07a5a5cfce696240 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_pem_cert_string );
        tmp_source_name_1 = par_pem_cert_string;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_startswith );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1274;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PEM_HEADER );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PEM_HEADER );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PEM_HEADER" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1274;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_1;
        frame_d8e122175713d41c07a5a5cfce696240->m_frame.f_lineno = 1274;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_operand_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1274;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1274;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_mvar_value_2;
            tmp_left_name_1 = const_str_digest_eb88db45ef5928fe9d291865fa2c3133;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PEM_HEADER );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PEM_HEADER );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PEM_HEADER" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1276;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_right_name_1 = tmp_mvar_value_2;
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1275;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_d8e122175713d41c07a5a5cfce696240->m_frame.f_lineno = 1275;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1275;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( par_pem_cert_string );
        tmp_called_instance_1 = par_pem_cert_string;
        frame_d8e122175713d41c07a5a5cfce696240->m_frame.f_lineno = 1277;
        tmp_source_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_strip );
        if ( tmp_source_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1277;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_endswith );
        Py_DECREF( tmp_source_name_2 );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1277;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PEM_FOOTER );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PEM_FOOTER );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PEM_FOOTER" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1277;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_2 = tmp_mvar_value_3;
        frame_d8e122175713d41c07a5a5cfce696240->m_frame.f_lineno = 1277;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_operand_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        if ( tmp_operand_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1277;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        Py_DECREF( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1277;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            PyObject *tmp_mvar_value_4;
            tmp_left_name_2 = const_str_digest_50b5c2eaada4a849fea984fb96dc55f1;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PEM_FOOTER );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PEM_FOOTER );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PEM_FOOTER" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1279;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_right_name_2 = tmp_mvar_value_4;
            tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
            if ( tmp_make_exception_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1278;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_d8e122175713d41c07a5a5cfce696240->m_frame.f_lineno = 1278;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_2 );
            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 1278;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_start_name_1;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_stop_name_1;
        PyObject *tmp_operand_name_3;
        PyObject *tmp_len_arg_2;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_step_name_1;
        CHECK_OBJECT( par_pem_cert_string );
        tmp_called_instance_2 = par_pem_cert_string;
        frame_d8e122175713d41c07a5a5cfce696240->m_frame.f_lineno = 1280;
        tmp_subscribed_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_strip );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1280;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PEM_HEADER );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PEM_HEADER );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_subscribed_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PEM_HEADER" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1280;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_len_arg_1 = tmp_mvar_value_5;
        tmp_start_name_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_start_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_subscribed_name_1 );

            exception_lineno = 1280;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PEM_FOOTER );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PEM_FOOTER );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_subscribed_name_1 );
            Py_DECREF( tmp_start_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PEM_FOOTER" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1280;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_len_arg_2 = tmp_mvar_value_6;
        tmp_operand_name_3 = BUILTIN_LEN( tmp_len_arg_2 );
        if ( tmp_operand_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_subscribed_name_1 );
            Py_DECREF( tmp_start_name_1 );

            exception_lineno = 1280;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_stop_name_1 = UNARY_OPERATION( PyNumber_Negative, tmp_operand_name_3 );
        Py_DECREF( tmp_operand_name_3 );
        if ( tmp_stop_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_subscribed_name_1 );
            Py_DECREF( tmp_start_name_1 );

            exception_lineno = 1280;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_step_name_1 = Py_None;
        tmp_subscript_name_1 = MAKE_SLICEOBJ3( tmp_start_name_1, tmp_stop_name_1, tmp_step_name_1 );
        Py_DECREF( tmp_start_name_1 );
        Py_DECREF( tmp_stop_name_1 );
        assert( !(tmp_subscript_name_1 == NULL) );
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        Py_DECREF( tmp_subscript_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1280;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_d == NULL );
        var_d = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_3;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_base64 );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_base64 );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "base64" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1281;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_7;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_decodebytes );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1281;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_d );
        tmp_called_instance_3 = var_d;
        frame_d8e122175713d41c07a5a5cfce696240->m_frame.f_lineno = 1281;
        tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ASCII_str_plain_strict_tuple, 0 ) );

        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1281;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_d8e122175713d41c07a5a5cfce696240->m_frame.f_lineno = 1281;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1281;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d8e122175713d41c07a5a5cfce696240 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d8e122175713d41c07a5a5cfce696240 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d8e122175713d41c07a5a5cfce696240 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d8e122175713d41c07a5a5cfce696240, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d8e122175713d41c07a5a5cfce696240->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d8e122175713d41c07a5a5cfce696240, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d8e122175713d41c07a5a5cfce696240,
        type_description_1,
        par_pem_cert_string,
        var_d
    );


    // Release cached frame.
    if ( frame_d8e122175713d41c07a5a5cfce696240 == cache_frame_d8e122175713d41c07a5a5cfce696240 )
    {
        Py_DECREF( frame_d8e122175713d41c07a5a5cfce696240 );
    }
    cache_frame_d8e122175713d41c07a5a5cfce696240 = NULL;

    assertFrameObject( frame_d8e122175713d41c07a5a5cfce696240 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_107_PEM_cert_to_DER_cert );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pem_cert_string );
    Py_DECREF( par_pem_cert_string );
    par_pem_cert_string = NULL;

    CHECK_OBJECT( (PyObject *)var_d );
    Py_DECREF( var_d );
    var_d = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pem_cert_string );
    Py_DECREF( par_pem_cert_string );
    par_pem_cert_string = NULL;

    Py_XDECREF( var_d );
    var_d = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_107_PEM_cert_to_DER_cert );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_108_get_server_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_addr = python_pars[ 0 ];
    PyObject *par_ssl_version = python_pars[ 1 ];
    PyObject *par_ca_certs = python_pars[ 2 ];
    PyObject *var_host = NULL;
    PyObject *var_port = NULL;
    PyObject *var_cert_reqs = NULL;
    PyObject *var_context = NULL;
    PyObject *var_sock = NULL;
    PyObject *var_sslsock = NULL;
    PyObject *var_dercert = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__exit = NULL;
    nuitka_bool tmp_with_1__indicator = NUITKA_BOOL_UNASSIGNED;
    PyObject *tmp_with_1__source = NULL;
    PyObject *tmp_with_2__enter = NULL;
    PyObject *tmp_with_2__exit = NULL;
    nuitka_bool tmp_with_2__indicator = NUITKA_BOOL_UNASSIGNED;
    PyObject *tmp_with_2__source = NULL;
    struct Nuitka_FrameObject *frame_49a3d9e5040ae940801c3d349086f58b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    int tmp_res;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    bool tmp_result;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_preserved_type_2;
    PyObject *exception_preserved_value_2;
    PyTracebackObject *exception_preserved_tb_2;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_49a3d9e5040ae940801c3d349086f58b = NULL;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_49a3d9e5040ae940801c3d349086f58b, codeobj_49a3d9e5040ae940801c3d349086f58b, module_ssl, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_49a3d9e5040ae940801c3d349086f58b = cache_frame_49a3d9e5040ae940801c3d349086f58b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_49a3d9e5040ae940801c3d349086f58b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_49a3d9e5040ae940801c3d349086f58b ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_addr );
        tmp_iter_arg_1 = par_addr;
        tmp_assign_source_1 = MAKE_UNPACK_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1289;
            type_description_1 = "oooooooooo";
            goto try_except_handler_2;
        }
        assert( tmp_tuple_unpack_1__source_iter == NULL );
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_1;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_2 = UNPACK_NEXT( tmp_unpack_1, 0, 2 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooooooo";
            exception_lineno = 1289;
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__element_1 == NULL );
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_2, 1, 2 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooooooo";
            exception_lineno = 1289;
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__element_2 == NULL );
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_3;
    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "oooooooooo";
                    exception_lineno = 1289;
                    goto try_except_handler_3;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "oooooooooo";
            exception_lineno = 1289;
            goto try_except_handler_3;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_4 = tmp_tuple_unpack_1__element_1;
        assert( var_host == NULL );
        Py_INCREF( tmp_assign_source_4 );
        var_host = tmp_assign_source_4;
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_5 = tmp_tuple_unpack_1__element_2;
        assert( var_port == NULL );
        Py_INCREF( tmp_assign_source_5 );
        var_port = tmp_assign_source_5;
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_ca_certs );
        tmp_compexpr_left_1 = par_ca_certs;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_mvar_value_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CERT_REQUIRED );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CERT_REQUIRED );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CERT_REQUIRED" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1291;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_assign_source_6 = tmp_mvar_value_1;
            assert( var_cert_reqs == NULL );
            Py_INCREF( tmp_assign_source_6 );
            var_cert_reqs = tmp_assign_source_6;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_7;
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CERT_NONE );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CERT_NONE );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CERT_NONE" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 1293;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_assign_source_7 = tmp_mvar_value_2;
            assert( var_cert_reqs == NULL );
            Py_INCREF( tmp_assign_source_7 );
            var_cert_reqs = tmp_assign_source_7;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__create_stdlib_context );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__create_stdlib_context );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_create_stdlib_context" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1294;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_3;
        CHECK_OBJECT( par_ssl_version );
        tmp_tuple_element_1 = par_ssl_version;
        tmp_args_name_1 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
        tmp_dict_key_1 = const_str_plain_cert_reqs;
        CHECK_OBJECT( var_cert_reqs );
        tmp_dict_value_1 = var_cert_reqs;
        tmp_kw_name_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_2 = const_str_plain_cafile;
        CHECK_OBJECT( par_ca_certs );
        tmp_dict_value_2 = par_ca_certs;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
        assert( !(tmp_res != 0) );
        frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1294;
        tmp_assign_source_8 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1294;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_context == NULL );
        var_context = tmp_assign_source_8;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_create_connection );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_create_connection );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "create_connection" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1297;
            type_description_1 = "oooooooooo";
            goto try_except_handler_4;
        }

        tmp_called_name_2 = tmp_mvar_value_4;
        CHECK_OBJECT( par_addr );
        tmp_args_element_name_1 = par_addr;
        frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1297;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1297;
            type_description_1 = "oooooooooo";
            goto try_except_handler_4;
        }
        assert( tmp_with_2__source == NULL );
        tmp_with_2__source = tmp_assign_source_9;
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( tmp_with_2__source );
        tmp_source_name_1 = tmp_with_2__source;
        tmp_called_name_3 = LOOKUP_SPECIAL( tmp_source_name_1, const_str_plain___enter__ );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1297;
            type_description_1 = "oooooooooo";
            goto try_except_handler_4;
        }
        frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1297;
        tmp_assign_source_10 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
        Py_DECREF( tmp_called_name_3 );
        if ( tmp_assign_source_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1297;
            type_description_1 = "oooooooooo";
            goto try_except_handler_4;
        }
        assert( tmp_with_2__enter == NULL );
        tmp_with_2__enter = tmp_assign_source_10;
    }
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( tmp_with_2__source );
        tmp_source_name_2 = tmp_with_2__source;
        tmp_assign_source_11 = LOOKUP_SPECIAL( tmp_source_name_2, const_str_plain___exit__ );
        if ( tmp_assign_source_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1297;
            type_description_1 = "oooooooooo";
            goto try_except_handler_4;
        }
        assert( tmp_with_2__exit == NULL );
        tmp_with_2__exit = tmp_assign_source_11;
    }
    {
        nuitka_bool tmp_assign_source_12;
        tmp_assign_source_12 = NUITKA_BOOL_TRUE;
        tmp_with_2__indicator = tmp_assign_source_12;
    }
    {
        PyObject *tmp_assign_source_13;
        CHECK_OBJECT( tmp_with_2__enter );
        tmp_assign_source_13 = tmp_with_2__enter;
        assert( var_sock == NULL );
        Py_INCREF( tmp_assign_source_13 );
        var_sock = tmp_assign_source_13;
    }
    // Tried code:
    // Tried code:
    // Tried code:
    {
        PyObject *tmp_assign_source_14;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( var_context );
        tmp_called_instance_1 = var_context;
        CHECK_OBJECT( var_sock );
        tmp_args_element_name_2 = var_sock;
        frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1298;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_14 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_wrap_socket, call_args );
        }

        if ( tmp_assign_source_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1298;
            type_description_1 = "oooooooooo";
            goto try_except_handler_7;
        }
        assert( tmp_with_1__source == NULL );
        tmp_with_1__source = tmp_assign_source_14;
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( tmp_with_1__source );
        tmp_source_name_3 = tmp_with_1__source;
        tmp_called_name_4 = LOOKUP_SPECIAL( tmp_source_name_3, const_str_plain___enter__ );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1298;
            type_description_1 = "oooooooooo";
            goto try_except_handler_7;
        }
        frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1298;
        tmp_assign_source_15 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
        Py_DECREF( tmp_called_name_4 );
        if ( tmp_assign_source_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1298;
            type_description_1 = "oooooooooo";
            goto try_except_handler_7;
        }
        assert( tmp_with_1__enter == NULL );
        tmp_with_1__enter = tmp_assign_source_15;
    }
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( tmp_with_1__source );
        tmp_source_name_4 = tmp_with_1__source;
        tmp_assign_source_16 = LOOKUP_SPECIAL( tmp_source_name_4, const_str_plain___exit__ );
        if ( tmp_assign_source_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1298;
            type_description_1 = "oooooooooo";
            goto try_except_handler_7;
        }
        assert( tmp_with_1__exit == NULL );
        tmp_with_1__exit = tmp_assign_source_16;
    }
    {
        nuitka_bool tmp_assign_source_17;
        tmp_assign_source_17 = NUITKA_BOOL_TRUE;
        tmp_with_1__indicator = tmp_assign_source_17;
    }
    {
        PyObject *tmp_assign_source_18;
        CHECK_OBJECT( tmp_with_1__enter );
        tmp_assign_source_18 = tmp_with_1__enter;
        assert( var_sslsock == NULL );
        Py_INCREF( tmp_assign_source_18 );
        var_sslsock = tmp_assign_source_18;
    }
    // Tried code:
    // Tried code:
    {
        PyObject *tmp_assign_source_19;
        PyObject *tmp_called_instance_2;
        CHECK_OBJECT( var_sslsock );
        tmp_called_instance_2 = var_sslsock;
        frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1299;
        tmp_assign_source_19 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_getpeercert, &PyTuple_GET_ITEM( const_tuple_true_tuple, 0 ) );

        if ( tmp_assign_source_19 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1299;
            type_description_1 = "oooooooooo";
            goto try_except_handler_9;
        }
        assert( var_dercert == NULL );
        var_dercert = tmp_assign_source_19;
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_9:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_3 == NULL )
    {
        exception_keeper_tb_3 = MAKE_TRACEBACK( frame_49a3d9e5040ae940801c3d349086f58b, exception_keeper_lineno_3 );
    }
    else if ( exception_keeper_lineno_3 != 0 )
    {
        exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_49a3d9e5040ae940801c3d349086f58b, exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    PyException_SetTraceback( exception_keeper_value_3, (PyObject *)exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_2 = PyExc_BaseException;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1298;
            type_description_1 = "oooooooooo";
            goto try_except_handler_10;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            nuitka_bool tmp_assign_source_20;
            tmp_assign_source_20 = NUITKA_BOOL_FALSE;
            tmp_with_1__indicator = tmp_assign_source_20;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_called_name_5;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            CHECK_OBJECT( tmp_with_1__exit );
            tmp_called_name_5 = tmp_with_1__exit;
            tmp_args_element_name_3 = EXC_TYPE(PyThreadState_GET());
            tmp_args_element_name_4 = EXC_VALUE(PyThreadState_GET());
            tmp_args_element_name_5 = EXC_TRACEBACK(PyThreadState_GET());
            frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1298;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_operand_name_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
            }

            if ( tmp_operand_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1298;
                type_description_1 = "oooooooooo";
                goto try_except_handler_10;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            Py_DECREF( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1298;
                type_description_1 = "oooooooooo";
                goto try_except_handler_10;
            }
            tmp_condition_result_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 1298;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_49a3d9e5040ae940801c3d349086f58b->m_frame) frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "oooooooooo";
            goto try_except_handler_10;
            branch_no_3:;
        }
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 1298;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_49a3d9e5040ae940801c3d349086f58b->m_frame) frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooooo";
        goto try_except_handler_10;
        branch_end_2:;
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_10:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto try_except_handler_8;
    // End of try:
    try_end_4:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    goto try_end_3;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_108_get_server_certificate );
    return NULL;
    // End of try:
    try_end_3:;
    goto try_end_5;
    // Exception handler code:
    try_except_handler_8:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        nuitka_bool tmp_condition_result_4;
        nuitka_bool tmp_compexpr_left_3;
        nuitka_bool tmp_compexpr_right_3;
        assert( tmp_with_1__indicator != NUITKA_BOOL_UNASSIGNED);
        tmp_compexpr_left_3 = tmp_with_1__indicator;
        tmp_compexpr_right_3 = NUITKA_BOOL_TRUE;
        tmp_condition_result_4 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_6;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT( tmp_with_1__exit );
            tmp_called_name_6 = tmp_with_1__exit;
            frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1298;
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                Py_DECREF( exception_keeper_type_5 );
                Py_XDECREF( exception_keeper_value_5 );
                Py_XDECREF( exception_keeper_tb_5 );

                exception_lineno = 1298;
                type_description_1 = "oooooooooo";
                goto try_except_handler_7;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_4:;
    }
    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto try_except_handler_7;
    // End of try:
    try_end_5:;
    {
        nuitka_bool tmp_condition_result_5;
        nuitka_bool tmp_compexpr_left_4;
        nuitka_bool tmp_compexpr_right_4;
        assert( tmp_with_1__indicator != NUITKA_BOOL_UNASSIGNED);
        tmp_compexpr_left_4 = tmp_with_1__indicator;
        tmp_compexpr_right_4 = NUITKA_BOOL_TRUE;
        tmp_condition_result_5 = ( tmp_compexpr_left_4 == tmp_compexpr_right_4 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_called_name_7;
            PyObject *tmp_call_result_2;
            CHECK_OBJECT( tmp_with_1__exit );
            tmp_called_name_7 = tmp_with_1__exit;
            frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1298;
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_7, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1298;
                type_description_1 = "oooooooooo";
                goto try_except_handler_7;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_5:;
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto try_except_handler_6;
    // End of try:
    try_end_6:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    goto try_end_7;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_2 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_2 );
    exception_preserved_value_2 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_2 );
    exception_preserved_tb_2 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_2 );

    if ( exception_keeper_tb_7 == NULL )
    {
        exception_keeper_tb_7 = MAKE_TRACEBACK( frame_49a3d9e5040ae940801c3d349086f58b, exception_keeper_lineno_7 );
    }
    else if ( exception_keeper_lineno_7 != 0 )
    {
        exception_keeper_tb_7 = ADD_TRACEBACK( exception_keeper_tb_7, frame_49a3d9e5040ae940801c3d349086f58b, exception_keeper_lineno_7 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_7, &exception_keeper_value_7, &exception_keeper_tb_7 );
    PyException_SetTraceback( exception_keeper_value_7, (PyObject *)exception_keeper_tb_7 );
    PUBLISH_EXCEPTION( &exception_keeper_type_7, &exception_keeper_value_7, &exception_keeper_tb_7 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        tmp_compexpr_left_5 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_5 = PyExc_BaseException;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_5, tmp_compexpr_right_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1297;
            type_description_1 = "oooooooooo";
            goto try_except_handler_11;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            nuitka_bool tmp_assign_source_21;
            tmp_assign_source_21 = NUITKA_BOOL_FALSE;
            tmp_with_2__indicator = tmp_assign_source_21;
        }
        {
            nuitka_bool tmp_condition_result_7;
            PyObject *tmp_operand_name_2;
            PyObject *tmp_called_name_8;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_args_element_name_8;
            CHECK_OBJECT( tmp_with_2__exit );
            tmp_called_name_8 = tmp_with_2__exit;
            tmp_args_element_name_6 = EXC_TYPE(PyThreadState_GET());
            tmp_args_element_name_7 = EXC_VALUE(PyThreadState_GET());
            tmp_args_element_name_8 = EXC_TRACEBACK(PyThreadState_GET());
            frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1297;
            {
                PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
                tmp_operand_name_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, call_args );
            }

            if ( tmp_operand_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1297;
                type_description_1 = "oooooooooo";
                goto try_except_handler_11;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
            Py_DECREF( tmp_operand_name_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1297;
                type_description_1 = "oooooooooo";
                goto try_except_handler_11;
            }
            tmp_condition_result_7 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_7;
            }
            else
            {
                goto branch_no_7;
            }
            branch_yes_7:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 1297;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_49a3d9e5040ae940801c3d349086f58b->m_frame) frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "oooooooooo";
            goto try_except_handler_11;
            branch_no_7:;
        }
        goto branch_end_6;
        branch_no_6:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 1297;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_49a3d9e5040ae940801c3d349086f58b->m_frame) frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooooo";
        goto try_except_handler_11;
        branch_end_6:;
    }
    goto try_end_8;
    // Exception handler code:
    try_except_handler_11:;
    exception_keeper_type_8 = exception_type;
    exception_keeper_value_8 = exception_value;
    exception_keeper_tb_8 = exception_tb;
    exception_keeper_lineno_8 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_2, exception_preserved_value_2, exception_preserved_tb_2 );
    // Re-raise.
    exception_type = exception_keeper_type_8;
    exception_value = exception_keeper_value_8;
    exception_tb = exception_keeper_tb_8;
    exception_lineno = exception_keeper_lineno_8;

    goto try_except_handler_5;
    // End of try:
    try_end_8:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_2, exception_preserved_value_2, exception_preserved_tb_2 );
    goto try_end_7;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_108_get_server_certificate );
    return NULL;
    // End of try:
    try_end_7:;
    goto try_end_9;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        nuitka_bool tmp_condition_result_8;
        nuitka_bool tmp_compexpr_left_6;
        nuitka_bool tmp_compexpr_right_6;
        assert( tmp_with_2__indicator != NUITKA_BOOL_UNASSIGNED);
        tmp_compexpr_left_6 = tmp_with_2__indicator;
        tmp_compexpr_right_6 = NUITKA_BOOL_TRUE;
        tmp_condition_result_8 = ( tmp_compexpr_left_6 == tmp_compexpr_right_6 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_8;
        }
        else
        {
            goto branch_no_8;
        }
        branch_yes_8:;
        {
            PyObject *tmp_called_name_9;
            PyObject *tmp_call_result_3;
            CHECK_OBJECT( tmp_with_2__exit );
            tmp_called_name_9 = tmp_with_2__exit;
            frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1297;
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                Py_DECREF( exception_keeper_type_9 );
                Py_XDECREF( exception_keeper_value_9 );
                Py_XDECREF( exception_keeper_tb_9 );

                exception_lineno = 1297;
                type_description_1 = "oooooooooo";
                goto try_except_handler_4;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        branch_no_8:;
    }
    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto try_except_handler_4;
    // End of try:
    try_end_9:;
    {
        nuitka_bool tmp_condition_result_9;
        nuitka_bool tmp_compexpr_left_7;
        nuitka_bool tmp_compexpr_right_7;
        assert( tmp_with_2__indicator != NUITKA_BOOL_UNASSIGNED);
        tmp_compexpr_left_7 = tmp_with_2__indicator;
        tmp_compexpr_right_7 = NUITKA_BOOL_TRUE;
        tmp_condition_result_9 = ( tmp_compexpr_left_7 == tmp_compexpr_right_7 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_9;
        }
        else
        {
            goto branch_no_9;
        }
        branch_yes_9:;
        {
            PyObject *tmp_called_name_10;
            PyObject *tmp_call_result_4;
            CHECK_OBJECT( tmp_with_2__exit );
            tmp_called_name_10 = tmp_with_2__exit;
            frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1297;
            tmp_call_result_4 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_10, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

            if ( tmp_call_result_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1297;
                type_description_1 = "oooooooooo";
                goto try_except_handler_4;
            }
            Py_DECREF( tmp_call_result_4 );
        }
        branch_no_9:;
    }
    goto try_end_10;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_10 = exception_type;
    exception_keeper_value_10 = exception_value;
    exception_keeper_tb_10 = exception_tb;
    exception_keeper_lineno_10 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_with_2__source );
    tmp_with_2__source = NULL;

    Py_XDECREF( tmp_with_2__enter );
    tmp_with_2__enter = NULL;

    Py_XDECREF( tmp_with_2__exit );
    tmp_with_2__exit = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_10;
    exception_value = exception_keeper_value_10;
    exception_tb = exception_keeper_tb_10;
    exception_lineno = exception_keeper_lineno_10;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    CHECK_OBJECT( (PyObject *)tmp_with_2__source );
    Py_DECREF( tmp_with_2__source );
    tmp_with_2__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_2__enter );
    Py_DECREF( tmp_with_2__enter );
    tmp_with_2__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_2__exit );
    Py_DECREF( tmp_with_2__exit );
    tmp_with_2__exit = NULL;

    {
        PyObject *tmp_called_name_11;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_DER_cert_to_PEM_cert );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DER_cert_to_PEM_cert );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "DER_cert_to_PEM_cert" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1300;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_11 = tmp_mvar_value_5;
        if ( var_dercert == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "dercert" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1300;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_9 = var_dercert;
        frame_49a3d9e5040ae940801c3d349086f58b->m_frame.f_lineno = 1300;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1300;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_49a3d9e5040ae940801c3d349086f58b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_49a3d9e5040ae940801c3d349086f58b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_49a3d9e5040ae940801c3d349086f58b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_49a3d9e5040ae940801c3d349086f58b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_49a3d9e5040ae940801c3d349086f58b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_49a3d9e5040ae940801c3d349086f58b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_49a3d9e5040ae940801c3d349086f58b,
        type_description_1,
        par_addr,
        par_ssl_version,
        par_ca_certs,
        var_host,
        var_port,
        var_cert_reqs,
        var_context,
        var_sock,
        var_sslsock,
        var_dercert
    );


    // Release cached frame.
    if ( frame_49a3d9e5040ae940801c3d349086f58b == cache_frame_49a3d9e5040ae940801c3d349086f58b )
    {
        Py_DECREF( frame_49a3d9e5040ae940801c3d349086f58b );
    }
    cache_frame_49a3d9e5040ae940801c3d349086f58b = NULL;

    assertFrameObject( frame_49a3d9e5040ae940801c3d349086f58b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_108_get_server_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl_version );
    Py_DECREF( par_ssl_version );
    par_ssl_version = NULL;

    CHECK_OBJECT( (PyObject *)par_ca_certs );
    Py_DECREF( par_ca_certs );
    par_ca_certs = NULL;

    CHECK_OBJECT( (PyObject *)var_host );
    Py_DECREF( var_host );
    var_host = NULL;

    CHECK_OBJECT( (PyObject *)var_port );
    Py_DECREF( var_port );
    var_port = NULL;

    CHECK_OBJECT( (PyObject *)var_cert_reqs );
    Py_DECREF( var_cert_reqs );
    var_cert_reqs = NULL;

    CHECK_OBJECT( (PyObject *)var_context );
    Py_DECREF( var_context );
    var_context = NULL;

    CHECK_OBJECT( (PyObject *)var_sock );
    Py_DECREF( var_sock );
    var_sock = NULL;

    Py_XDECREF( var_sslsock );
    var_sslsock = NULL;

    Py_XDECREF( var_dercert );
    var_dercert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl_version );
    Py_DECREF( par_ssl_version );
    par_ssl_version = NULL;

    CHECK_OBJECT( (PyObject *)par_ca_certs );
    Py_DECREF( par_ca_certs );
    par_ca_certs = NULL;

    Py_XDECREF( var_host );
    var_host = NULL;

    Py_XDECREF( var_port );
    var_port = NULL;

    Py_XDECREF( var_cert_reqs );
    var_cert_reqs = NULL;

    Py_XDECREF( var_context );
    var_context = NULL;

    Py_XDECREF( var_sock );
    var_sock = NULL;

    Py_XDECREF( var_sslsock );
    var_sslsock = NULL;

    Py_XDECREF( var_dercert );
    var_dercert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_11;
    exception_value = exception_keeper_value_11;
    exception_tb = exception_keeper_tb_11;
    exception_lineno = exception_keeper_lineno_11;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_108_get_server_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_ssl$$$function_109_get_protocol_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_protocol_code = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_0fefcbe6be1b7672f9495fe2d2c2b520;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0fefcbe6be1b7672f9495fe2d2c2b520 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0fefcbe6be1b7672f9495fe2d2c2b520, codeobj_0fefcbe6be1b7672f9495fe2d2c2b520, module_ssl, sizeof(void *) );
    frame_0fefcbe6be1b7672f9495fe2d2c2b520 = cache_frame_0fefcbe6be1b7672f9495fe2d2c2b520;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0fefcbe6be1b7672f9495fe2d2c2b520 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0fefcbe6be1b7672f9495fe2d2c2b520 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__PROTOCOL_NAMES );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PROTOCOL_NAMES );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_PROTOCOL_NAMES" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1303;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_protocol_code );
        tmp_args_element_name_1 = par_protocol_code;
        tmp_args_element_name_2 = const_str_angle_unknown;
        frame_0fefcbe6be1b7672f9495fe2d2c2b520->m_frame.f_lineno = 1303;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_get, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1303;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0fefcbe6be1b7672f9495fe2d2c2b520 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0fefcbe6be1b7672f9495fe2d2c2b520 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0fefcbe6be1b7672f9495fe2d2c2b520 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0fefcbe6be1b7672f9495fe2d2c2b520, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0fefcbe6be1b7672f9495fe2d2c2b520->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0fefcbe6be1b7672f9495fe2d2c2b520, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0fefcbe6be1b7672f9495fe2d2c2b520,
        type_description_1,
        par_protocol_code
    );


    // Release cached frame.
    if ( frame_0fefcbe6be1b7672f9495fe2d2c2b520 == cache_frame_0fefcbe6be1b7672f9495fe2d2c2b520 )
    {
        Py_DECREF( frame_0fefcbe6be1b7672f9495fe2d2c2b520 );
    }
    cache_frame_0fefcbe6be1b7672f9495fe2d2c2b520 = NULL;

    assertFrameObject( frame_0fefcbe6be1b7672f9495fe2d2c2b520 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl$$$function_109_get_protocol_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_protocol_code );
    Py_DECREF( par_protocol_code );
    par_protocol_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_protocol_code );
    Py_DECREF( par_protocol_code );
    par_protocol_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( ssl$$$function_109_get_protocol_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_100_connect_ex(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_100_connect_ex,
        const_str_plain_connect_ex,
#if PYTHON_VERSION >= 300
        const_str_digest_4cf3e4c966a8b447aeec91c80c53ce91,
#endif
        codeobj_a86b95352fc9c8cca13ec96f3cf3e648,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_ec2adfb37273b3eee2296f564999ae55,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_101_accept(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_101_accept,
        const_str_plain_accept,
#if PYTHON_VERSION >= 300
        const_str_digest_13a57eb57bd6e3598d5407c5d5c65a2c,
#endif
        codeobj_3ddc9f7565e4886cd4a659572d70f974,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_4abc699b5da7389d367032b57dc69eb3,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_102_get_channel_binding( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_102_get_channel_binding,
        const_str_plain_get_channel_binding,
#if PYTHON_VERSION >= 300
        const_str_digest_e1cb74300b7a6f137d7d5aaa4117b8b1,
#endif
        codeobj_0adca387694c9d0d05e6dcf361654043,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_0f3e3cca38e905dbbeef437e4cc1b13f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_103_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_103_version,
        const_str_plain_version,
#if PYTHON_VERSION >= 300
        const_str_digest_c0263368b21f5075dd51002a02eed279,
#endif
        codeobj_431602757d87c0ffb4cfc07c16f40c0f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_2021457612f445845421aa4f7c76fecb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_104_wrap_socket( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_104_wrap_socket,
        const_str_plain_wrap_socket,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e52a48e17e348b81afa21bb0833b5cee,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_105_cert_time_to_seconds(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_105_cert_time_to_seconds,
        const_str_plain_cert_time_to_seconds,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f0d4a14b639c208b031798e88d64dcf8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_80ae286fde266c9ce3eea805317b53e8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_106_DER_cert_to_PEM_cert(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_106_DER_cert_to_PEM_cert,
        const_str_plain_DER_cert_to_PEM_cert,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f0ee1f5fb95d4844854b515739861369,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_8646af1ebee17c0c9f3fc9ba01d5d9b4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_107_PEM_cert_to_DER_cert(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_107_PEM_cert_to_DER_cert,
        const_str_plain_PEM_cert_to_DER_cert,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d8e122175713d41c07a5a5cfce696240,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_f21776754563ee820956e9eca7440392,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_108_get_server_certificate( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_108_get_server_certificate,
        const_str_plain_get_server_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_49a3d9e5040ae940801c3d349086f58b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_435b76333d08b4e4e629143b740aa218,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_109_get_protocol_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_109_get_protocol_name,
        const_str_plain_get_protocol_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0fefcbe6be1b7672f9495fe2d2c2b520,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_10_match_hostname(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_10_match_hostname,
        const_str_plain_match_hostname,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b22e2653cdc93fd04980c249351d9dc3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_d301f91992faa4f4f10ac91822e37e3a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_11_get_default_verify_paths(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_11_get_default_verify_paths,
        const_str_plain_get_default_verify_paths,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f4b142c4d615bce9c4fa208111063de1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_57a4d671eaa11e961fe988b76b7923cd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_12___new__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_12___new__,
        const_str_plain___new__,
#if PYTHON_VERSION >= 300
        const_str_digest_9efba2909c944f0cd3b20389eca3a9de,
#endif
        codeobj_387d510b0de4869ce257c4fd150c3e1d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_13_fromnid(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_13_fromnid,
        const_str_plain_fromnid,
#if PYTHON_VERSION >= 300
        const_str_digest_3093a3b7e6ad2e3ac70240f1b5e28199,
#endif
        codeobj_6a9f24714f01965dd94fca0f0e8d2494,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_d88b1a2ff0cfef8fd6528c6cef0c98c5,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_14_fromname(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_14_fromname,
        const_str_plain_fromname,
#if PYTHON_VERSION >= 300
        const_str_digest_11ed960077872fa0d08c8c433b669058,
#endif
        codeobj_d56e86ad148a7f35b220cc951f739bf5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_cb9fea72893243c85d3f8a7fa5745fd1,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_15___new__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_15___new__,
        const_str_plain___new__,
#if PYTHON_VERSION >= 300
        const_str_digest_c5de37dcc49253fe34f7e237641f0f0d,
#endif
        codeobj_c25b78dcc70e44b70350d3078f666eb1,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_16__encode_hostname(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_16__encode_hostname,
        const_str_plain__encode_hostname,
#if PYTHON_VERSION >= 300
        const_str_digest_b57613816b83a6d5e901aa481a5f48e3,
#endif
        codeobj_5ff02ef703e17041cf7c28f0f9774842,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_17_wrap_socket( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_17_wrap_socket,
        const_str_plain_wrap_socket,
#if PYTHON_VERSION >= 300
        const_str_digest_90dcfb0c5b2e395585c44f2c6f8db8bf,
#endif
        codeobj_5e4ce0716b248a14e09f49928b12effa,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_18_wrap_bio( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_18_wrap_bio,
        const_str_plain_wrap_bio,
#if PYTHON_VERSION >= 300
        const_str_digest_00d07f74b29f8afb5fd73d7e9c08e6c3,
#endif
        codeobj_5f141f0f9a51bec2ef519041ccab0132,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_19_set_npn_protocols(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_19_set_npn_protocols,
        const_str_plain_set_npn_protocols,
#if PYTHON_VERSION >= 300
        const_str_digest_d348e50cee6b156ae47b722599f9ef5e,
#endif
        codeobj_c315ec050432736c21843c7f8970ed99,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_1_lambda(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8b2169752a1cafe1c590b905bc1817cf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_20_set_servername_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_20_set_servername_callback,
        const_str_plain_set_servername_callback,
#if PYTHON_VERSION >= 300
        const_str_digest_4271da0b33163508c03517c8a66c3ca2,
#endif
        codeobj_6362b4ab8ff4a74ff389af21e2831505,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_20_set_servername_callback$$$function_1_shim_cb(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_20_set_servername_callback$$$function_1_shim_cb,
        const_str_plain_shim_cb,
#if PYTHON_VERSION >= 300
        const_str_digest_8571c784ae144b6aa943c631c479aeb3,
#endif
        codeobj_c9128c1053ef6f473a6bfd7f36ba0b37,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_21_set_alpn_protocols(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_21_set_alpn_protocols,
        const_str_plain_set_alpn_protocols,
#if PYTHON_VERSION >= 300
        const_str_digest_8b4af18647c3b6e36880d4732ff55e63,
#endif
        codeobj_e33384d5e86c4c6b681e06b935a1eccd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_22__load_windows_store_certs(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_22__load_windows_store_certs,
        const_str_plain__load_windows_store_certs,
#if PYTHON_VERSION >= 300
        const_str_digest_951e41b571762ac2eab94889431d0c17,
#endif
        codeobj_c3c87c308de5f0caba95e34d2a75cff3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_23_load_default_certs( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_23_load_default_certs,
        const_str_plain_load_default_certs,
#if PYTHON_VERSION >= 300
        const_str_digest_f7f5e69e32188905b76a51140481c41c,
#endif
        codeobj_bd31b2b0b29be68fb348a8509700aacb,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_24_minimum_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_24_minimum_version,
        const_str_plain_minimum_version,
#if PYTHON_VERSION >= 300
        const_str_digest_4fb5691c9145cd18b6bc6017c9a5b8c6,
#endif
        codeobj_c741f20b5460a44d8f7d1a1ec0524090,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_25_minimum_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_25_minimum_version,
        const_str_plain_minimum_version,
#if PYTHON_VERSION >= 300
        const_str_digest_4fb5691c9145cd18b6bc6017c9a5b8c6,
#endif
        codeobj_9c140cba594376b13de36d0b9d2cf41b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_26_maximum_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_26_maximum_version,
        const_str_plain_maximum_version,
#if PYTHON_VERSION >= 300
        const_str_digest_fdb327d09a1abb4e12c500a6d5b181cc,
#endif
        codeobj_1fa2afa1f2001c76009fa3bd74739a02,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_27_maximum_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_27_maximum_version,
        const_str_plain_maximum_version,
#if PYTHON_VERSION >= 300
        const_str_digest_fdb327d09a1abb4e12c500a6d5b181cc,
#endif
        codeobj_dd245307a21868517b26333004071afc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_28_options(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_28_options,
        const_str_plain_options,
#if PYTHON_VERSION >= 300
        const_str_digest_4807acc2340e0a598c0f10463503adbb,
#endif
        codeobj_e577eeee712faf011eac0a90d5a335cd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_29_options(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_29_options,
        const_str_plain_options,
#if PYTHON_VERSION >= 300
        const_str_digest_4807acc2340e0a598c0f10463503adbb,
#endif
        codeobj_d0ddd3c583ea0f70fd2c3f13c292f8d8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_2_lambda(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_2_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d8ef087d29dce5b7809ac49cd68adf25,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_30_hostname_checks_common_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_30_hostname_checks_common_name,
        const_str_plain_hostname_checks_common_name,
#if PYTHON_VERSION >= 300
        const_str_digest_2444bca47c3e4bf63ad35ca166c38217,
#endif
        codeobj_86ffcc5f322eb9e45b49c1aab256e2b5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_31_hostname_checks_common_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_31_hostname_checks_common_name,
        const_str_plain_hostname_checks_common_name,
#if PYTHON_VERSION >= 300
        const_str_digest_2444bca47c3e4bf63ad35ca166c38217,
#endif
        codeobj_8005450d1390ccb1db96bde8f18ccbc5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_32_hostname_checks_common_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_32_hostname_checks_common_name,
        const_str_plain_hostname_checks_common_name,
#if PYTHON_VERSION >= 300
        const_str_digest_2444bca47c3e4bf63ad35ca166c38217,
#endif
        codeobj_9eb5b4d9d73d171312d06b89742db6dc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_33_protocol(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_33_protocol,
        const_str_plain_protocol,
#if PYTHON_VERSION >= 300
        const_str_digest_fa76902b0955d1f1a4101fca59e6c5f4,
#endif
        codeobj_e90beb192a2d45b154b787dd334a641a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_34_verify_flags(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_34_verify_flags,
        const_str_plain_verify_flags,
#if PYTHON_VERSION >= 300
        const_str_digest_fe4ba6fdabf4a04ac73d126c6842f5da,
#endif
        codeobj_6eddcfd3501f9e6e8ff360a6e9e07ace,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_35_verify_flags(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_35_verify_flags,
        const_str_plain_verify_flags,
#if PYTHON_VERSION >= 300
        const_str_digest_fe4ba6fdabf4a04ac73d126c6842f5da,
#endif
        codeobj_a798b36ecbdc4799a3ed88ea793f49cf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_36_verify_mode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_36_verify_mode,
        const_str_plain_verify_mode,
#if PYTHON_VERSION >= 300
        const_str_digest_0f22ebe362b5851039539f32087f48b3,
#endif
        codeobj_cd07790829b56e8f6715d0e2df0d1b17,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_37_verify_mode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_37_verify_mode,
        const_str_plain_verify_mode,
#if PYTHON_VERSION >= 300
        const_str_digest_0f22ebe362b5851039539f32087f48b3,
#endif
        codeobj_58499782b4566c6282fbc531bfb08ebf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_38_create_default_context( PyObject *defaults, PyObject *kw_defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_38_create_default_context,
        const_str_plain_create_default_context,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_964b4ff49a75adfde8eac32fd1579b15,
        defaults,
#if PYTHON_VERSION >= 300
        kw_defaults,
        NULL,
#endif
        module_ssl,
        const_str_digest_014d24052ac75a4b7ea7a7f030f06442,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_39__create_unverified_context( PyObject *defaults, PyObject *kw_defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_39__create_unverified_context,
        const_str_plain__create_unverified_context,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e4273329f84da578e5b0c2c0ef1fb7e3,
        defaults,
#if PYTHON_VERSION >= 300
        kw_defaults,
        NULL,
#endif
        module_ssl,
        const_str_digest_a90f1c250f0693c766ae942c46747dfd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_3_lambda(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_3_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4ea3aebfeea4b0fb696d8e3f751bb569,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_40___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_40___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_29e692b3bed0448c0fbf90eb672dc2f9,
#endif
        codeobj_8a26c3fb8c2d5b0dc5ca8006ca18f426,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_41__create( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_41__create,
        const_str_plain__create,
#if PYTHON_VERSION >= 300
        const_str_digest_369cd8552536fc20754a282ea727c715,
#endif
        codeobj_78af8d33dbb832741c0ebdb2e3d0021a,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_42_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_42_context,
        const_str_plain_context,
#if PYTHON_VERSION >= 300
        const_str_digest_c1de6fe860a671d1e1fb4f389bb9c11f,
#endif
        codeobj_155bafd0723162e3e798ef484b14cd90,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_baf3113a8ef52750e55aaa38049d03e1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_43_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_43_context,
        const_str_plain_context,
#if PYTHON_VERSION >= 300
        const_str_digest_c1de6fe860a671d1e1fb4f389bb9c11f,
#endif
        codeobj_b025c5ada52dfc27ae3723ad4341ada3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_44_session(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_44_session,
        const_str_plain_session,
#if PYTHON_VERSION >= 300
        const_str_digest_0cf93d32ee4dc8845c885030fe30aef6,
#endif
        codeobj_150a7fc04f06617735354ee03a3a1379,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_aa8ad6ac7f5bb3b9bf58d630a5df3b73,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_45_session(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_45_session,
        const_str_plain_session,
#if PYTHON_VERSION >= 300
        const_str_digest_0cf93d32ee4dc8845c885030fe30aef6,
#endif
        codeobj_0cab748c09d01cef1fc04469feb036ab,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_46_session_reused(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_46_session_reused,
        const_str_plain_session_reused,
#if PYTHON_VERSION >= 300
        const_str_digest_f3568165cd86b32f3e6c65bf9c020450,
#endif
        codeobj_3d426fcde832f96f9fefe61110c3597f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_0e5d7991443807262ff75d28a8d3aab1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_47_server_side(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_47_server_side,
        const_str_plain_server_side,
#if PYTHON_VERSION >= 300
        const_str_digest_5b11666b6324b89e4fc385fb93a3c5a5,
#endif
        codeobj_af887c87284bed61555d654364a46bbc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_9d03fd1f2eedc7fbd45f8a10e06e8ab5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_48_server_hostname(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_48_server_hostname,
        const_str_plain_server_hostname,
#if PYTHON_VERSION >= 300
        const_str_digest_7860efcfc68c94064108f332b0e7ea2b,
#endif
        codeobj_148ded5e31bfc43993a6f070cc228356,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_af3afbb4c11be74ecd4b8a361dc5a331,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_49_read( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_49_read,
        const_str_plain_read,
#if PYTHON_VERSION >= 300
        const_str_digest_49f919db6f48720fb21b9178605834a0,
#endif
        codeobj_83f840bc627e14b2df37f66978eee02e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_7a9028390fde6cbc9e4e83008c224f13,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_4_lambda(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_4_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_57ad0ee0b24514877328827449ed6d3d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_50_write(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_50_write,
        const_str_plain_write,
#if PYTHON_VERSION >= 300
        const_str_digest_9ad09f827f7176b447bf061c19122ff5,
#endif
        codeobj_4bc9b1ac077eede44b66bfacb2b34b9c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_d168cf6508757f44c350431e0146bcff,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_51_getpeercert( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_51_getpeercert,
        const_str_plain_getpeercert,
#if PYTHON_VERSION >= 300
        const_str_digest_dddcbf0d2d0cc36b841a5401bf4b26d0,
#endif
        codeobj_0afdd5e99178c32be659fdceadf23330,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_f76ed44c3c7f75a52e9e990d67888b38,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_52_selected_npn_protocol(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_52_selected_npn_protocol,
        const_str_plain_selected_npn_protocol,
#if PYTHON_VERSION >= 300
        const_str_digest_456481dfc3cfeda5b8ffadc3f499a1a7,
#endif
        codeobj_d5b89644963ce7577c3e54aec3b26352,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_086013992ea1d11747aa99e000896ea7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_53_selected_alpn_protocol(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_53_selected_alpn_protocol,
        const_str_plain_selected_alpn_protocol,
#if PYTHON_VERSION >= 300
        const_str_digest_51317cfcec4946ff79f4fa2f128efe4d,
#endif
        codeobj_0efd15d2dbf254a6a5ea212c2e808164,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_59e9ef293dda2862f98a224ced32fcd6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_54_cipher(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_54_cipher,
        const_str_plain_cipher,
#if PYTHON_VERSION >= 300
        const_str_digest_02a360a134c6bbb34ce8a608f7da370d,
#endif
        codeobj_09f1bb5201b8ef073955738188ca32ac,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_4741f80d59d6685d72d119c884a60415,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_55_shared_ciphers(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_55_shared_ciphers,
        const_str_plain_shared_ciphers,
#if PYTHON_VERSION >= 300
        const_str_digest_bd00534ecca984542679be9e93bb7f91,
#endif
        codeobj_4c16b3b8e78753d108f56368b6107e65,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_c450fc9edb672e51af4935d607b84f7d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_56_compression(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_56_compression,
        const_str_plain_compression,
#if PYTHON_VERSION >= 300
        const_str_digest_7d6cdae49b3a41339758fb29bb72d243,
#endif
        codeobj_c84cff19f5ca70203b24d6ffa781b6c6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_264d5c6db8f5a84d0fe413b3a21dca69,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_57_pending(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_57_pending,
        const_str_plain_pending,
#if PYTHON_VERSION >= 300
        const_str_digest_a3d78346cd2f65fd6e9e17d7199e08b2,
#endif
        codeobj_3ecf3a2c062154f40f3b43857fadfa1b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_0658b8b82bf1e6709c574f4d2869db22,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_58_do_handshake(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_58_do_handshake,
        const_str_plain_do_handshake,
#if PYTHON_VERSION >= 300
        const_str_digest_a30bfbfaff6053905e0182626560596e,
#endif
        codeobj_85a48a901c551db5360868c6ff2fcbe0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_7612dba174ee645b8f9d8c3109227a4c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_59_unwrap(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_59_unwrap,
        const_str_plain_unwrap,
#if PYTHON_VERSION >= 300
        const_str_digest_6bb5243f02b53df7c631337cce5d1e63,
#endif
        codeobj_8299ff8d044f5af021c11f1525c08864,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_7acec48d7f5243b63c0fc27885a59467,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_5_lambda(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_5_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3fd973b4394bbb87224fe4972ac062b2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_60_get_channel_binding( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_60_get_channel_binding,
        const_str_plain_get_channel_binding,
#if PYTHON_VERSION >= 300
        const_str_digest_8c034cf983cd380cdbc5f3747143f35a,
#endif
        codeobj_df41c359df46e3b95ae46ee541469c12,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_04681951689da94a8b8ef39f2d829632,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_61_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_61_version,
        const_str_plain_version,
#if PYTHON_VERSION >= 300
        const_str_digest_f80b04da9426dc3c6eb61b2e2c8cefdc,
#endif
        codeobj_074ad722ef8e6ac8cf69c8739de2b3f8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_3b82cb8ef6775b0d84aaa035b45db24a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_62_verify_client_post_handshake(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_62_verify_client_post_handshake,
        const_str_plain_verify_client_post_handshake,
#if PYTHON_VERSION >= 300
        const_str_digest_f3ad832901b185e93d30c52a67b18042,
#endif
        codeobj_7fef2a19fae27d1b2e8f283d57279247,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_63___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_63___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_e4e3c476682898be85f27f17e066582d,
#endif
        codeobj_6a15f1fb4e124c5cd5441c67dd7b8e26,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_64__create( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_64__create,
        const_str_plain__create,
#if PYTHON_VERSION >= 300
        const_str_digest_0fb7a77c6d8e8842d00fc65591c86f2b,
#endif
        codeobj_5d3f549a94129cada014514f247e56ae,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_65_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_65_context,
        const_str_plain_context,
#if PYTHON_VERSION >= 300
        const_str_digest_ce00e64da7d82f6241d1726b2fac3925,
#endif
        codeobj_6a50350fea64982993f4c32f68ed6a2a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_66_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_66_context,
        const_str_plain_context,
#if PYTHON_VERSION >= 300
        const_str_digest_ce00e64da7d82f6241d1726b2fac3925,
#endif
        codeobj_0abbe3d29d94097de2b4cca44b79ff1d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_67_session(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_67_session,
        const_str_plain_session,
#if PYTHON_VERSION >= 300
        const_str_digest_dd8dbc1762dbe3e65f1ad22cbe807685,
#endif
        codeobj_f436d72429baf7d16ba6a700826ecce2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_aa8ad6ac7f5bb3b9bf58d630a5df3b73,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_68_session(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_68_session,
        const_str_plain_session,
#if PYTHON_VERSION >= 300
        const_str_digest_dd8dbc1762dbe3e65f1ad22cbe807685,
#endif
        codeobj_81b99666473d5e4c99b07c76650d6532,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_69_session_reused(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_69_session_reused,
        const_str_plain_session_reused,
#if PYTHON_VERSION >= 300
        const_str_digest_2b5d4e1e8c4b95888f9c32cd5e107a2a,
#endif
        codeobj_854fbf8c0d35e06c7abf19e23c21f425,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_0e5d7991443807262ff75d28a8d3aab1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_6_lambda(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_6_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e78ac027ae2374cae8fee268e861e6b6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_70_dup(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_70_dup,
        const_str_plain_dup,
#if PYTHON_VERSION >= 300
        const_str_digest_fcd4e210c82bde6da13a3f919066e7a3,
#endif
        codeobj_a9707a26dabb530d65fb63614a8bfaf3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_71__checkClosed( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_71__checkClosed,
        const_str_plain__checkClosed,
#if PYTHON_VERSION >= 300
        const_str_digest_31df743f2ce3fe988549bc25f2c8482c,
#endif
        codeobj_9f169d4682c81eb3da6d59c1ded46e8f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_72__check_connected(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_72__check_connected,
        const_str_plain__check_connected,
#if PYTHON_VERSION >= 300
        const_str_digest_c126f313dbab329c6eb48d2d248e63ab,
#endif
        codeobj_b5f510e6cb81eab7bc9dba35574f0396,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_73_read( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_73_read,
        const_str_plain_read,
#if PYTHON_VERSION >= 300
        const_str_digest_3a1a2ed1355dcbc368d7b0eae97a5e62,
#endif
        codeobj_bc55c6947047d12d73c6cf85fd31316d,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_407044a0a44e7edcc517eceddb07768e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_74_write(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_74_write,
        const_str_plain_write,
#if PYTHON_VERSION >= 300
        const_str_digest_c9db670f24eb7241cf3b613e4b11a252,
#endif
        codeobj_2116eb980de7dd12514dc72c39fd3f4d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_e00eea51626e2d416545145e0341879e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_75_getpeercert( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_75_getpeercert,
        const_str_plain_getpeercert,
#if PYTHON_VERSION >= 300
        const_str_digest_c7fd72035abc3711f49929c6db8a5d90,
#endif
        codeobj_40f8c9a48268243d506769f5f3c9f87c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_f6dd8c5e9e919cb24a1de58b3da498d7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_76_selected_npn_protocol(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_76_selected_npn_protocol,
        const_str_plain_selected_npn_protocol,
#if PYTHON_VERSION >= 300
        const_str_digest_5e9c5dde7d44f504eb1a9ddf508d33f1,
#endif
        codeobj_9946f25858fede3b1b6536c2d85f8023,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_77_selected_alpn_protocol(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_77_selected_alpn_protocol,
        const_str_plain_selected_alpn_protocol,
#if PYTHON_VERSION >= 300
        const_str_digest_2f5b04e7ff781fc829fd1336b1bac5d6,
#endif
        codeobj_d2bc38bd2c275ba26d06739a8be65121,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_78_cipher(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_78_cipher,
        const_str_plain_cipher,
#if PYTHON_VERSION >= 300
        const_str_digest_225bcc70c32be5d588e199b061dc20c4,
#endif
        codeobj_8d5372b515e339fede7165b142e8a13c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_79_shared_ciphers(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_79_shared_ciphers,
        const_str_plain_shared_ciphers,
#if PYTHON_VERSION >= 300
        const_str_digest_4fc88bc781b6216d197d14984f6b65eb,
#endif
        codeobj_6720aa3c1b1df68a0d363d84d0591c66,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_7__dnsname_match(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_7__dnsname_match,
        const_str_plain__dnsname_match,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a5072bf1a063c9f1c49782fa3c262d40,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_b1639321a9474ecb1b885a74076648f9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_80_compression(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_80_compression,
        const_str_plain_compression,
#if PYTHON_VERSION >= 300
        const_str_digest_a81fde8cd3c79156638379a671de86c9,
#endif
        codeobj_c86b13db4689f046ff5f1afeb5710181,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_81_send( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_81_send,
        const_str_plain_send,
#if PYTHON_VERSION >= 300
        const_str_digest_3e31e526fa6bfed4b24004be62ec2a41,
#endif
        codeobj_04c7d04cc1994e94386698ea320f0a34,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_82_sendto( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_82_sendto,
        const_str_plain_sendto,
#if PYTHON_VERSION >= 300
        const_str_digest_753f93511d826caab3f92515b0253a28,
#endif
        codeobj_7d99f84954cc8e5a491c234fdf7ba84c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_83_sendmsg(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_83_sendmsg,
        const_str_plain_sendmsg,
#if PYTHON_VERSION >= 300
        const_str_digest_46ab2be535dad9a4eb021b9ed0399647,
#endif
        codeobj_d919d033f6f5ba6049cfa7306704c4e1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_84_sendall( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_84_sendall,
        const_str_plain_sendall,
#if PYTHON_VERSION >= 300
        const_str_digest_e76c9d31e090b0229a44427e90c726c0,
#endif
        codeobj_6f2722bf3b4b9cc66de9b446db7a9e02,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_85_sendfile( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_85_sendfile,
        const_str_plain_sendfile,
#if PYTHON_VERSION >= 300
        const_str_digest_826765c7ea5b1e2da81cc031af37a88e,
#endif
        codeobj_b6715770c57c475edff269e2bfce93b7,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_32a9d7692d4036821acb38d0089e4f7d,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_86_recv( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_86_recv,
        const_str_plain_recv,
#if PYTHON_VERSION >= 300
        const_str_digest_222811c1d4bf55fcbb49085a180f5432,
#endif
        codeobj_3e272a599979dddb2106eeb0ca82341b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_87_recv_into( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_87_recv_into,
        const_str_plain_recv_into,
#if PYTHON_VERSION >= 300
        const_str_digest_a9f301e988a5655ce88c2b95e37f72a0,
#endif
        codeobj_54a01adef0ac9e521553dadf12222313,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_88_recvfrom( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_88_recvfrom,
        const_str_plain_recvfrom,
#if PYTHON_VERSION >= 300
        const_str_digest_8929e5696096b1b3a769926d596fd01d,
#endif
        codeobj_d836e52222fa765674eb7fabb95e256a,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_89_recvfrom_into( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_89_recvfrom_into,
        const_str_plain_recvfrom_into,
#if PYTHON_VERSION >= 300
        const_str_digest_b2d667c37f49b62a93484716e8b4da43,
#endif
        codeobj_102787f65a848b0f5ef93c552b2754a8,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_8__inet_paton(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_8__inet_paton,
        const_str_plain__inet_paton,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d8eebab0541bfa74aca42926ef69ef86,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_0eae601715bd5c30805ac496fbcd9992,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_90_recvmsg(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_90_recvmsg,
        const_str_plain_recvmsg,
#if PYTHON_VERSION >= 300
        const_str_digest_f27b9bf56c746e209815ef274ec83cd3,
#endif
        codeobj_6753233f97c67ba60fed48cd037a5da1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_91_recvmsg_into(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_91_recvmsg_into,
        const_str_plain_recvmsg_into,
#if PYTHON_VERSION >= 300
        const_str_digest_1deb9ad8da903aa02d0662894e4e5d19,
#endif
        codeobj_b9c49bf51fd490ce845154517abf5afe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_92_pending(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_92_pending,
        const_str_plain_pending,
#if PYTHON_VERSION >= 300
        const_str_digest_f042bcd35862fbe10a0a40d4f034fbdc,
#endif
        codeobj_c9ee113a8b3a2d7e49dd2e5a09a16c0a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_93_shutdown(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_93_shutdown,
        const_str_plain_shutdown,
#if PYTHON_VERSION >= 300
        const_str_digest_678b55cb9e2bbf2e94eb06e9ceb20edc,
#endif
        codeobj_b581a977e97c824d653f0d91e1864d5a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_94_unwrap(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_94_unwrap,
        const_str_plain_unwrap,
#if PYTHON_VERSION >= 300
        const_str_digest_0e477d4fd7854861d3a3e53f3c18df7a,
#endif
        codeobj_f30c98b20585ea45248d54a7a131cbd6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_95_verify_client_post_handshake(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_95_verify_client_post_handshake,
        const_str_plain_verify_client_post_handshake,
#if PYTHON_VERSION >= 300
        const_str_digest_970482a40f2631f2b534044dbb186357,
#endif
        codeobj_c308f005c60a48850ddc38c70cfc9e4a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_96__real_close(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_96__real_close,
        const_str_plain__real_close,
#if PYTHON_VERSION >= 300
        const_str_digest_578daa481dfc5d6804fc66ea53284c53,
#endif
        codeobj_84c36608fe52cf263db57111bd71529a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_97_do_handshake( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_97_do_handshake,
        const_str_plain_do_handshake,
#if PYTHON_VERSION >= 300
        const_str_digest_223a8a47fa4e201be7d43aff732dd6e1,
#endif
        codeobj_732e9b90c8c97c0d936101eda76a8170,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_9350c794d641bf1e05d2d5f369964cf4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_98__real_connect(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_98__real_connect,
        const_str_plain__real_connect,
#if PYTHON_VERSION >= 300
        const_str_digest_149ca022cd253208621db7e23b6370d3,
#endif
        codeobj_ce20ccea364a64a500bf53152ecbb3df,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_99_connect(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_99_connect,
        const_str_plain_connect,
#if PYTHON_VERSION >= 300
        const_str_digest_8f0f33542a5d07b827a3c15795f1bcd3,
#endif
        codeobj_e55c77de5189f075a317b4725d964bc7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_ec2adfb37273b3eee2296f564999ae55,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_ssl$$$function_9__ipaddress_match(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_ssl$$$function_9__ipaddress_match,
        const_str_plain__ipaddress_match,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_27463743bde98a64c19721f228ebca83,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_ssl,
        const_str_digest_cee8a0917b60d1bd22f94d241f22b50b,
        0
    );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_ssl =
{
    PyModuleDef_HEAD_INIT,
    "ssl",
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___compiled__;

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

extern PyTypeObject Nuitka_Loader_Type;

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( ssl )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_ssl );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("ssl: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("ssl: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("ssl: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initssl" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_ssl = Py_InitModule4(
        "ssl",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_ssl = PyModule_Create( &mdef_ssl );
#endif

    moduledict_ssl = MODULE_DICT( module_ssl );

    // Set __compiled__ to what it we know.
    UPDATE_STRING_DICT1(
        moduledict_ssl,
        (Nuitka_StringObject *)const_str_plain___compiled__,
        Nuitka_dunder_compiled_value
    );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_ssl,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_ssl,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_ssl,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_ssl );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PyImport_GetModuleDict(), const_str_plain_ssl, module_ssl );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type );
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___name__ ),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF( module_spec_class );

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT( spec_value );

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE( spec_value, const_str_plain_submodule_search_locations, PyList_New(0) );
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE( spec_value, const_str_plain__initializing, Py_True );

        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );
    }
#endif
#endif

    // Temp variables if any
    PyObject *outline_0_var_name = NULL;
    PyObject *outline_0_var_value = NULL;
    PyObject *outline_1_var___class__ = NULL;
    struct Nuitka_CellObject *outline_2_var___class__ = PyCell_EMPTY();
    PyObject *outline_3_var___class__ = NULL;
    struct Nuitka_CellObject *outline_4_var___class__ = PyCell_EMPTY();
    PyObject *outline_5_var___class__ = NULL;
    struct Nuitka_CellObject *outline_6_var___class__ = PyCell_EMPTY();
    PyObject *tmp_assign_unpack_1__assign_source = NULL;
    PyObject *tmp_class_creation_1__bases = NULL;
    PyObject *tmp_class_creation_1__bases_orig = NULL;
    PyObject *tmp_class_creation_1__class_decl_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_1__prepared = NULL;
    PyObject *tmp_class_creation_2__bases = NULL;
    PyObject *tmp_class_creation_2__bases_orig = NULL;
    PyObject *tmp_class_creation_2__class_decl_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_2__prepared = NULL;
    PyObject *tmp_class_creation_3__bases = NULL;
    PyObject *tmp_class_creation_3__bases_orig = NULL;
    PyObject *tmp_class_creation_3__class_decl_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_3__prepared = NULL;
    PyObject *tmp_class_creation_4__bases = NULL;
    PyObject *tmp_class_creation_4__bases_orig = NULL;
    PyObject *tmp_class_creation_4__class_decl_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_4__prepared = NULL;
    PyObject *tmp_class_creation_5__class_decl_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_5__prepared = NULL;
    PyObject *tmp_class_creation_6__bases = NULL;
    PyObject *tmp_class_creation_6__bases_orig = NULL;
    PyObject *tmp_class_creation_6__class_decl_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_6__prepared = NULL;
    PyObject *tmp_dictcontraction$tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_dictcontraction$tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_dictcontraction$tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_dictcontraction_1__$0 = NULL;
    PyObject *tmp_dictcontraction_1__contraction = NULL;
    PyObject *tmp_dictcontraction_1__iter_value_0 = NULL;
    PyObject *tmp_import_from_10__module = NULL;
    PyObject *tmp_import_from_11__module = NULL;
    PyObject *tmp_import_from_1__module = NULL;
    PyObject *tmp_import_from_2__module = NULL;
    PyObject *tmp_import_from_3__module = NULL;
    PyObject *tmp_import_from_4__module = NULL;
    PyObject *tmp_import_from_5__module = NULL;
    PyObject *tmp_import_from_6__module = NULL;
    PyObject *tmp_import_from_7__module = NULL;
    PyObject *tmp_import_from_8__module = NULL;
    PyObject *tmp_import_from_9__module = NULL;
    struct Nuitka_FrameObject *frame_5fd67fa0e731842652c5161aa118e079;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    int tmp_res;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    struct Nuitka_FrameObject *frame_4e4f09e7416371c39d6e683dfaa31b44_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *tmp_dictset_value;
    PyObject *tmp_dictset_dict;
    PyObject *tmp_dictset_key;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    static struct Nuitka_FrameObject *cache_frame_4e4f09e7416371c39d6e683dfaa31b44_2 = NULL;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *tmp_dictdel_dict;
    PyObject *tmp_dictdel_key;
    PyObject *locals_ssl_158 = NULL;
    struct Nuitka_FrameObject *frame_5ecbd54808c422e093f59660e1c05923_3;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    static struct Nuitka_FrameObject *cache_frame_5ecbd54808c422e093f59660e1c05923_3 = NULL;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *locals_ssl_351 = NULL;
    struct Nuitka_FrameObject *frame_032aecff3336d18805e71dad2af1bc06_4;
    NUITKA_MAY_BE_UNUSED char const *type_description_4 = NULL;
    static struct Nuitka_FrameObject *cache_frame_032aecff3336d18805e71dad2af1bc06_4 = NULL;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *locals_ssl_372 = NULL;
    struct Nuitka_FrameObject *frame_cbc8eb4c7a80f833eeff58accc81965e_5;
    NUITKA_MAY_BE_UNUSED char const *type_description_5 = NULL;
    static struct Nuitka_FrameObject *cache_frame_cbc8eb4c7a80f833eeff58accc81965e_5 = NULL;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *locals_ssl_379 = NULL;
    struct Nuitka_FrameObject *frame_2f3dc3967a43757d07b0bed3cdf75e71_6;
    NUITKA_MAY_BE_UNUSED char const *type_description_6 = NULL;
    static struct Nuitka_FrameObject *cache_frame_2f3dc3967a43757d07b0bed3cdf75e71_6 = NULL;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;
    PyObject *locals_ssl_631 = NULL;
    struct Nuitka_FrameObject *frame_ca8bc35da6fc8bd12302bc56dc472f30_7;
    NUITKA_MAY_BE_UNUSED char const *type_description_7 = NULL;
    static struct Nuitka_FrameObject *cache_frame_ca8bc35da6fc8bd12302bc56dc472f30_7 = NULL;
    PyObject *exception_keeper_type_31;
    PyObject *exception_keeper_value_31;
    PyTracebackObject *exception_keeper_tb_31;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_31;
    PyObject *exception_keeper_type_32;
    PyObject *exception_keeper_value_32;
    PyTracebackObject *exception_keeper_tb_32;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_32;
    PyObject *exception_keeper_type_33;
    PyObject *exception_keeper_value_33;
    PyTracebackObject *exception_keeper_tb_33;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_33;
    PyObject *locals_ssl_784 = NULL;
    struct Nuitka_FrameObject *frame_283e017a64c5286699e9bc9396685a36_8;
    NUITKA_MAY_BE_UNUSED char const *type_description_8 = NULL;
    static struct Nuitka_FrameObject *cache_frame_283e017a64c5286699e9bc9396685a36_8 = NULL;
    PyObject *exception_keeper_type_34;
    PyObject *exception_keeper_value_34;
    PyTracebackObject *exception_keeper_tb_34;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_34;
    PyObject *exception_keeper_type_35;
    PyObject *exception_keeper_value_35;
    PyTracebackObject *exception_keeper_tb_35;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_35;
    PyObject *exception_keeper_type_36;
    PyObject *exception_keeper_value_36;
    PyTracebackObject *exception_keeper_tb_36;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_36;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = const_str_digest_ef46d7df3260d10040c06b56d31e4b9b;
        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = module_filename_obj;
        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    }
    // Frame without reuse.
    frame_5fd67fa0e731842652c5161aa118e079 = MAKE_MODULE_FRAME( codeobj_5fd67fa0e731842652c5161aa118e079, module_ssl );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_5fd67fa0e731842652c5161aa118e079 );
    assert( Py_REFCNT( frame_5fd67fa0e731842652c5161aa118e079 ) == 2 );

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        PyObject *tmp_mvar_value_1;
        tmp_assattr_name_1 = module_filename_obj;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___spec__ );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___spec__ );
        }

        CHECK_OBJECT( tmp_mvar_value_1 );
        tmp_assattr_target_1 = tmp_mvar_value_1;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_origin, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1;

            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        PyObject *tmp_mvar_value_2;
        tmp_assattr_name_2 = Py_True;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___spec__ );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___spec__ );
        }

        CHECK_OBJECT( tmp_mvar_value_2 );
        tmp_assattr_target_2 = tmp_mvar_value_2;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_has_location, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1;

            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = Py_None;
        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___cached__, tmp_assign_source_3 );
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        PyObject *tmp_level_name_1;
        tmp_name_name_1 = const_str_plain_sys;
        tmp_globals_name_1 = (PyObject *)moduledict_ssl;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = Py_None;
        tmp_level_name_1 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 93;
        tmp_assign_source_4 = IMPORT_MODULE5( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1, tmp_level_name_1 );
        assert( !(tmp_assign_source_4 == NULL) );
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_sys, tmp_assign_source_4 );
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        PyObject *tmp_level_name_2;
        tmp_name_name_2 = const_str_plain_os;
        tmp_globals_name_2 = (PyObject *)moduledict_ssl;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = Py_None;
        tmp_level_name_2 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 94;
        tmp_assign_source_5 = IMPORT_MODULE5( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2, tmp_level_name_2 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 94;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_os, tmp_assign_source_5 );
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_3;
        PyObject *tmp_globals_name_3;
        PyObject *tmp_locals_name_3;
        PyObject *tmp_fromlist_name_3;
        PyObject *tmp_level_name_3;
        tmp_name_name_3 = const_str_plain_collections;
        tmp_globals_name_3 = (PyObject *)moduledict_ssl;
        tmp_locals_name_3 = Py_None;
        tmp_fromlist_name_3 = const_tuple_str_plain_namedtuple_tuple;
        tmp_level_name_3 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 95;
        tmp_import_name_from_1 = IMPORT_MODULE5( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3, tmp_level_name_3 );
        if ( tmp_import_name_from_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 95;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_6 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_namedtuple );
        Py_DECREF( tmp_import_name_from_1 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 95;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_namedtuple, tmp_assign_source_6 );
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_name_name_4;
        PyObject *tmp_globals_name_4;
        PyObject *tmp_locals_name_4;
        PyObject *tmp_fromlist_name_4;
        PyObject *tmp_level_name_4;
        tmp_name_name_4 = const_str_plain_enum;
        tmp_globals_name_4 = (PyObject *)moduledict_ssl;
        tmp_locals_name_4 = Py_None;
        tmp_fromlist_name_4 = const_tuple_str_plain_Enum_str_plain_IntEnum_str_plain_IntFlag_tuple;
        tmp_level_name_4 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 96;
        tmp_assign_source_7 = IMPORT_MODULE5( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4, tmp_level_name_4 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 96;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_1__module == NULL );
        tmp_import_from_1__module = tmp_assign_source_7;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_import_name_from_2;
        CHECK_OBJECT( tmp_import_from_1__module );
        tmp_import_name_from_2 = tmp_import_from_1__module;
        tmp_assign_source_8 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_Enum );
        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 96;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__Enum, tmp_assign_source_8 );
    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_import_name_from_3;
        CHECK_OBJECT( tmp_import_from_1__module );
        tmp_import_name_from_3 = tmp_import_from_1__module;
        tmp_assign_source_9 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_IntEnum );
        if ( tmp_assign_source_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 96;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__IntEnum, tmp_assign_source_9 );
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_import_name_from_4;
        CHECK_OBJECT( tmp_import_from_1__module );
        tmp_import_name_from_4 = tmp_import_from_1__module;
        tmp_assign_source_10 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain_IntFlag );
        if ( tmp_assign_source_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 96;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__IntFlag, tmp_assign_source_10 );
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_name_name_5;
        PyObject *tmp_globals_name_5;
        PyObject *tmp_locals_name_5;
        PyObject *tmp_fromlist_name_5;
        PyObject *tmp_level_name_5;
        tmp_name_name_5 = const_str_plain__ssl;
        tmp_globals_name_5 = (PyObject *)moduledict_ssl;
        tmp_locals_name_5 = Py_None;
        tmp_fromlist_name_5 = Py_None;
        tmp_level_name_5 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 98;
        tmp_assign_source_11 = IMPORT_MODULE5( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5, tmp_level_name_5 );
        if ( tmp_assign_source_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl, tmp_assign_source_11 );
    }
    {
        PyObject *tmp_assign_source_12;
        PyObject *tmp_name_name_6;
        PyObject *tmp_globals_name_6;
        PyObject *tmp_locals_name_6;
        PyObject *tmp_fromlist_name_6;
        PyObject *tmp_level_name_6;
        tmp_name_name_6 = const_str_plain__ssl;
        tmp_globals_name_6 = (PyObject *)moduledict_ssl;
        tmp_locals_name_6 = Py_None;
        tmp_fromlist_name_6 = const_tuple_fa0db5e4cde953f91817f4436d4446fe_tuple;
        tmp_level_name_6 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 100;
        tmp_assign_source_12 = IMPORT_MODULE5( tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6, tmp_level_name_6 );
        if ( tmp_assign_source_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 100;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_2__module == NULL );
        tmp_import_from_2__module = tmp_assign_source_12;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_import_name_from_5;
        CHECK_OBJECT( tmp_import_from_2__module );
        tmp_import_name_from_5 = tmp_import_from_2__module;
        tmp_assign_source_13 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain_OPENSSL_VERSION_NUMBER );
        if ( tmp_assign_source_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 100;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_OPENSSL_VERSION_NUMBER, tmp_assign_source_13 );
    }
    {
        PyObject *tmp_assign_source_14;
        PyObject *tmp_import_name_from_6;
        CHECK_OBJECT( tmp_import_from_2__module );
        tmp_import_name_from_6 = tmp_import_from_2__module;
        tmp_assign_source_14 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain_OPENSSL_VERSION_INFO );
        if ( tmp_assign_source_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 100;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_OPENSSL_VERSION_INFO, tmp_assign_source_14 );
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_import_name_from_7;
        CHECK_OBJECT( tmp_import_from_2__module );
        tmp_import_name_from_7 = tmp_import_from_2__module;
        tmp_assign_source_15 = IMPORT_NAME( tmp_import_name_from_7, const_str_plain_OPENSSL_VERSION );
        if ( tmp_assign_source_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 100;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_OPENSSL_VERSION, tmp_assign_source_15 );
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_name_name_7;
        PyObject *tmp_globals_name_7;
        PyObject *tmp_locals_name_7;
        PyObject *tmp_fromlist_name_7;
        PyObject *tmp_level_name_7;
        tmp_name_name_7 = const_str_plain__ssl;
        tmp_globals_name_7 = (PyObject *)moduledict_ssl;
        tmp_locals_name_7 = Py_None;
        tmp_fromlist_name_7 = const_tuple_fd5b2cb4c7284fdcd887df9c923ef28a_tuple;
        tmp_level_name_7 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 101;
        tmp_assign_source_16 = IMPORT_MODULE5( tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7, tmp_level_name_7 );
        if ( tmp_assign_source_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 101;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_3__module == NULL );
        tmp_import_from_3__module = tmp_assign_source_16;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_17;
        PyObject *tmp_import_name_from_8;
        CHECK_OBJECT( tmp_import_from_3__module );
        tmp_import_name_from_8 = tmp_import_from_3__module;
        tmp_assign_source_17 = IMPORT_NAME( tmp_import_name_from_8, const_str_plain__SSLContext );
        if ( tmp_assign_source_17 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 101;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__SSLContext, tmp_assign_source_17 );
    }
    {
        PyObject *tmp_assign_source_18;
        PyObject *tmp_import_name_from_9;
        CHECK_OBJECT( tmp_import_from_3__module );
        tmp_import_name_from_9 = tmp_import_from_3__module;
        tmp_assign_source_18 = IMPORT_NAME( tmp_import_name_from_9, const_str_plain_MemoryBIO );
        if ( tmp_assign_source_18 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 101;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_MemoryBIO, tmp_assign_source_18 );
    }
    {
        PyObject *tmp_assign_source_19;
        PyObject *tmp_import_name_from_10;
        CHECK_OBJECT( tmp_import_from_3__module );
        tmp_import_name_from_10 = tmp_import_from_3__module;
        tmp_assign_source_19 = IMPORT_NAME( tmp_import_name_from_10, const_str_plain_SSLSession );
        if ( tmp_assign_source_19 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 101;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLSession, tmp_assign_source_19 );
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    {
        PyObject *tmp_assign_source_20;
        PyObject *tmp_name_name_8;
        PyObject *tmp_globals_name_8;
        PyObject *tmp_locals_name_8;
        PyObject *tmp_fromlist_name_8;
        PyObject *tmp_level_name_8;
        tmp_name_name_8 = const_str_plain__ssl;
        tmp_globals_name_8 = (PyObject *)moduledict_ssl;
        tmp_locals_name_8 = Py_None;
        tmp_fromlist_name_8 = const_tuple_294dabb5a2c5ba151197a7c7ec901527_tuple;
        tmp_level_name_8 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 102;
        tmp_assign_source_20 = IMPORT_MODULE5( tmp_name_name_8, tmp_globals_name_8, tmp_locals_name_8, tmp_fromlist_name_8, tmp_level_name_8 );
        if ( tmp_assign_source_20 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 102;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_4__module == NULL );
        tmp_import_from_4__module = tmp_assign_source_20;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_21;
        PyObject *tmp_import_name_from_11;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_11 = tmp_import_from_4__module;
        tmp_assign_source_21 = IMPORT_NAME( tmp_import_name_from_11, const_str_plain_SSLError );
        if ( tmp_assign_source_21 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 102;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLError, tmp_assign_source_21 );
    }
    {
        PyObject *tmp_assign_source_22;
        PyObject *tmp_import_name_from_12;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_12 = tmp_import_from_4__module;
        tmp_assign_source_22 = IMPORT_NAME( tmp_import_name_from_12, const_str_plain_SSLZeroReturnError );
        if ( tmp_assign_source_22 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 102;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLZeroReturnError, tmp_assign_source_22 );
    }
    {
        PyObject *tmp_assign_source_23;
        PyObject *tmp_import_name_from_13;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_13 = tmp_import_from_4__module;
        tmp_assign_source_23 = IMPORT_NAME( tmp_import_name_from_13, const_str_plain_SSLWantReadError );
        if ( tmp_assign_source_23 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 102;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLWantReadError, tmp_assign_source_23 );
    }
    {
        PyObject *tmp_assign_source_24;
        PyObject *tmp_import_name_from_14;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_14 = tmp_import_from_4__module;
        tmp_assign_source_24 = IMPORT_NAME( tmp_import_name_from_14, const_str_plain_SSLWantWriteError );
        if ( tmp_assign_source_24 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 102;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLWantWriteError, tmp_assign_source_24 );
    }
    {
        PyObject *tmp_assign_source_25;
        PyObject *tmp_import_name_from_15;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_15 = tmp_import_from_4__module;
        tmp_assign_source_25 = IMPORT_NAME( tmp_import_name_from_15, const_str_plain_SSLSyscallError );
        if ( tmp_assign_source_25 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 102;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLSyscallError, tmp_assign_source_25 );
    }
    {
        PyObject *tmp_assign_source_26;
        PyObject *tmp_import_name_from_16;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_16 = tmp_import_from_4__module;
        tmp_assign_source_26 = IMPORT_NAME( tmp_import_name_from_16, const_str_plain_SSLEOFError );
        if ( tmp_assign_source_26 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 102;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLEOFError, tmp_assign_source_26 );
    }
    {
        PyObject *tmp_assign_source_27;
        PyObject *tmp_import_name_from_17;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_17 = tmp_import_from_4__module;
        tmp_assign_source_27 = IMPORT_NAME( tmp_import_name_from_17, const_str_plain_SSLCertVerificationError );
        if ( tmp_assign_source_27 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 102;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLCertVerificationError, tmp_assign_source_27 );
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_4__module );
    Py_DECREF( tmp_import_from_4__module );
    tmp_import_from_4__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_4__module );
    Py_DECREF( tmp_import_from_4__module );
    tmp_import_from_4__module = NULL;

    {
        PyObject *tmp_assign_source_28;
        PyObject *tmp_name_name_9;
        PyObject *tmp_globals_name_9;
        PyObject *tmp_locals_name_9;
        PyObject *tmp_fromlist_name_9;
        PyObject *tmp_level_name_9;
        tmp_name_name_9 = const_str_plain__ssl;
        tmp_globals_name_9 = (PyObject *)moduledict_ssl;
        tmp_locals_name_9 = Py_None;
        tmp_fromlist_name_9 = const_tuple_str_plain_txt2obj_str_plain_nid2obj_tuple;
        tmp_level_name_9 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 106;
        tmp_assign_source_28 = IMPORT_MODULE5( tmp_name_name_9, tmp_globals_name_9, tmp_locals_name_9, tmp_fromlist_name_9, tmp_level_name_9 );
        if ( tmp_assign_source_28 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 106;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_5__module == NULL );
        tmp_import_from_5__module = tmp_assign_source_28;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_29;
        PyObject *tmp_import_name_from_18;
        CHECK_OBJECT( tmp_import_from_5__module );
        tmp_import_name_from_18 = tmp_import_from_5__module;
        tmp_assign_source_29 = IMPORT_NAME( tmp_import_name_from_18, const_str_plain_txt2obj );
        if ( tmp_assign_source_29 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 106;

            goto try_except_handler_5;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__txt2obj, tmp_assign_source_29 );
    }
    {
        PyObject *tmp_assign_source_30;
        PyObject *tmp_import_name_from_19;
        CHECK_OBJECT( tmp_import_from_5__module );
        tmp_import_name_from_19 = tmp_import_from_5__module;
        tmp_assign_source_30 = IMPORT_NAME( tmp_import_name_from_19, const_str_plain_nid2obj );
        if ( tmp_assign_source_30 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 106;

            goto try_except_handler_5;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__nid2obj, tmp_assign_source_30 );
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_5__module );
    Py_DECREF( tmp_import_from_5__module );
    tmp_import_from_5__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_5__module );
    Py_DECREF( tmp_import_from_5__module );
    tmp_import_from_5__module = NULL;

    {
        PyObject *tmp_assign_source_31;
        PyObject *tmp_name_name_10;
        PyObject *tmp_globals_name_10;
        PyObject *tmp_locals_name_10;
        PyObject *tmp_fromlist_name_10;
        PyObject *tmp_level_name_10;
        tmp_name_name_10 = const_str_plain__ssl;
        tmp_globals_name_10 = (PyObject *)moduledict_ssl;
        tmp_locals_name_10 = Py_None;
        tmp_fromlist_name_10 = const_tuple_6211085d7c55211a934ca9ed6de6668a_tuple;
        tmp_level_name_10 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 107;
        tmp_assign_source_31 = IMPORT_MODULE5( tmp_name_name_10, tmp_globals_name_10, tmp_locals_name_10, tmp_fromlist_name_10, tmp_level_name_10 );
        if ( tmp_assign_source_31 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 107;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_6__module == NULL );
        tmp_import_from_6__module = tmp_assign_source_31;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_32;
        PyObject *tmp_import_name_from_20;
        CHECK_OBJECT( tmp_import_from_6__module );
        tmp_import_name_from_20 = tmp_import_from_6__module;
        tmp_assign_source_32 = IMPORT_NAME( tmp_import_name_from_20, const_str_plain_RAND_status );
        if ( tmp_assign_source_32 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 107;

            goto try_except_handler_6;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_RAND_status, tmp_assign_source_32 );
    }
    {
        PyObject *tmp_assign_source_33;
        PyObject *tmp_import_name_from_21;
        CHECK_OBJECT( tmp_import_from_6__module );
        tmp_import_name_from_21 = tmp_import_from_6__module;
        tmp_assign_source_33 = IMPORT_NAME( tmp_import_name_from_21, const_str_plain_RAND_add );
        if ( tmp_assign_source_33 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 107;

            goto try_except_handler_6;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_RAND_add, tmp_assign_source_33 );
    }
    {
        PyObject *tmp_assign_source_34;
        PyObject *tmp_import_name_from_22;
        CHECK_OBJECT( tmp_import_from_6__module );
        tmp_import_name_from_22 = tmp_import_from_6__module;
        tmp_assign_source_34 = IMPORT_NAME( tmp_import_name_from_22, const_str_plain_RAND_bytes );
        if ( tmp_assign_source_34 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 107;

            goto try_except_handler_6;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_RAND_bytes, tmp_assign_source_34 );
    }
    {
        PyObject *tmp_assign_source_35;
        PyObject *tmp_import_name_from_23;
        CHECK_OBJECT( tmp_import_from_6__module );
        tmp_import_name_from_23 = tmp_import_from_6__module;
        tmp_assign_source_35 = IMPORT_NAME( tmp_import_name_from_23, const_str_plain_RAND_pseudo_bytes );
        if ( tmp_assign_source_35 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 107;

            goto try_except_handler_6;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_RAND_pseudo_bytes, tmp_assign_source_35 );
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_6__module );
    Py_DECREF( tmp_import_from_6__module );
    tmp_import_from_6__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_6__module );
    Py_DECREF( tmp_import_from_6__module );
    tmp_import_from_6__module = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_36;
        PyObject *tmp_import_name_from_24;
        PyObject *tmp_name_name_11;
        PyObject *tmp_globals_name_11;
        PyObject *tmp_locals_name_11;
        PyObject *tmp_fromlist_name_11;
        PyObject *tmp_level_name_11;
        tmp_name_name_11 = const_str_plain__ssl;
        tmp_globals_name_11 = (PyObject *)moduledict_ssl;
        tmp_locals_name_11 = Py_None;
        tmp_fromlist_name_11 = const_tuple_str_plain_RAND_egd_tuple;
        tmp_level_name_11 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 109;
        tmp_import_name_from_24 = IMPORT_MODULE5( tmp_name_name_11, tmp_globals_name_11, tmp_locals_name_11, tmp_fromlist_name_11, tmp_level_name_11 );
        if ( tmp_import_name_from_24 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 109;

            goto try_except_handler_7;
        }
        tmp_assign_source_36 = IMPORT_NAME( tmp_import_name_from_24, const_str_plain_RAND_egd );
        Py_DECREF( tmp_import_name_from_24 );
        if ( tmp_assign_source_36 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 109;

            goto try_except_handler_7;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_RAND_egd, tmp_assign_source_36 );
    }
    goto try_end_7;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_7 == NULL )
    {
        exception_keeper_tb_7 = MAKE_TRACEBACK( frame_5fd67fa0e731842652c5161aa118e079, exception_keeper_lineno_7 );
    }
    else if ( exception_keeper_lineno_7 != 0 )
    {
        exception_keeper_tb_7 = ADD_TRACEBACK( exception_keeper_tb_7, frame_5fd67fa0e731842652c5161aa118e079, exception_keeper_lineno_7 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_7, &exception_keeper_value_7, &exception_keeper_tb_7 );
    PyException_SetTraceback( exception_keeper_value_7, (PyObject *)exception_keeper_tb_7 );
    PUBLISH_EXCEPTION( &exception_keeper_type_7, &exception_keeper_value_7, &exception_keeper_tb_7 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_ImportError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 110;

            goto try_except_handler_8;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 110;

            goto try_except_handler_8;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 108;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_5fd67fa0e731842652c5161aa118e079->m_frame) frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = exception_tb->tb_lineno;

        goto try_except_handler_8;
        branch_no_1:;
    }
    goto try_end_8;
    // Exception handler code:
    try_except_handler_8:;
    exception_keeper_type_8 = exception_type;
    exception_keeper_value_8 = exception_value;
    exception_keeper_tb_8 = exception_tb;
    exception_keeper_lineno_8 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_8;
    exception_value = exception_keeper_value_8;
    exception_tb = exception_keeper_tb_8;
    exception_lineno = exception_keeper_lineno_8;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    goto try_end_7;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( ssl );
    return MOD_RETURN_VALUE( NULL );
    // End of try:
    try_end_7:;
    {
        PyObject *tmp_assign_source_37;
        PyObject *tmp_name_name_12;
        PyObject *tmp_globals_name_12;
        PyObject *tmp_locals_name_12;
        PyObject *tmp_fromlist_name_12;
        PyObject *tmp_level_name_12;
        tmp_name_name_12 = const_str_plain__ssl;
        tmp_globals_name_12 = (PyObject *)moduledict_ssl;
        tmp_locals_name_12 = Py_None;
        tmp_fromlist_name_12 = const_tuple_a840e2093a227646419041bdd371a27b_tuple;
        tmp_level_name_12 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 115;
        tmp_assign_source_37 = IMPORT_MODULE5( tmp_name_name_12, tmp_globals_name_12, tmp_locals_name_12, tmp_fromlist_name_12, tmp_level_name_12 );
        if ( tmp_assign_source_37 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 115;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_7__module == NULL );
        tmp_import_from_7__module = tmp_assign_source_37;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_38;
        PyObject *tmp_import_name_from_25;
        CHECK_OBJECT( tmp_import_from_7__module );
        tmp_import_name_from_25 = tmp_import_from_7__module;
        tmp_assign_source_38 = IMPORT_NAME( tmp_import_name_from_25, const_str_plain_HAS_SNI );
        if ( tmp_assign_source_38 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 115;

            goto try_except_handler_9;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_HAS_SNI, tmp_assign_source_38 );
    }
    {
        PyObject *tmp_assign_source_39;
        PyObject *tmp_import_name_from_26;
        CHECK_OBJECT( tmp_import_from_7__module );
        tmp_import_name_from_26 = tmp_import_from_7__module;
        tmp_assign_source_39 = IMPORT_NAME( tmp_import_name_from_26, const_str_plain_HAS_ECDH );
        if ( tmp_assign_source_39 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 115;

            goto try_except_handler_9;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_HAS_ECDH, tmp_assign_source_39 );
    }
    {
        PyObject *tmp_assign_source_40;
        PyObject *tmp_import_name_from_27;
        CHECK_OBJECT( tmp_import_from_7__module );
        tmp_import_name_from_27 = tmp_import_from_7__module;
        tmp_assign_source_40 = IMPORT_NAME( tmp_import_name_from_27, const_str_plain_HAS_NPN );
        if ( tmp_assign_source_40 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 115;

            goto try_except_handler_9;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_HAS_NPN, tmp_assign_source_40 );
    }
    {
        PyObject *tmp_assign_source_41;
        PyObject *tmp_import_name_from_28;
        CHECK_OBJECT( tmp_import_from_7__module );
        tmp_import_name_from_28 = tmp_import_from_7__module;
        tmp_assign_source_41 = IMPORT_NAME( tmp_import_name_from_28, const_str_plain_HAS_ALPN );
        if ( tmp_assign_source_41 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 115;

            goto try_except_handler_9;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_HAS_ALPN, tmp_assign_source_41 );
    }
    {
        PyObject *tmp_assign_source_42;
        PyObject *tmp_import_name_from_29;
        CHECK_OBJECT( tmp_import_from_7__module );
        tmp_import_name_from_29 = tmp_import_from_7__module;
        tmp_assign_source_42 = IMPORT_NAME( tmp_import_name_from_29, const_str_plain_HAS_SSLv2 );
        if ( tmp_assign_source_42 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 115;

            goto try_except_handler_9;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_HAS_SSLv2, tmp_assign_source_42 );
    }
    {
        PyObject *tmp_assign_source_43;
        PyObject *tmp_import_name_from_30;
        CHECK_OBJECT( tmp_import_from_7__module );
        tmp_import_name_from_30 = tmp_import_from_7__module;
        tmp_assign_source_43 = IMPORT_NAME( tmp_import_name_from_30, const_str_plain_HAS_SSLv3 );
        if ( tmp_assign_source_43 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 115;

            goto try_except_handler_9;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_HAS_SSLv3, tmp_assign_source_43 );
    }
    {
        PyObject *tmp_assign_source_44;
        PyObject *tmp_import_name_from_31;
        CHECK_OBJECT( tmp_import_from_7__module );
        tmp_import_name_from_31 = tmp_import_from_7__module;
        tmp_assign_source_44 = IMPORT_NAME( tmp_import_name_from_31, const_str_plain_HAS_TLSv1 );
        if ( tmp_assign_source_44 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 115;

            goto try_except_handler_9;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_HAS_TLSv1, tmp_assign_source_44 );
    }
    {
        PyObject *tmp_assign_source_45;
        PyObject *tmp_import_name_from_32;
        CHECK_OBJECT( tmp_import_from_7__module );
        tmp_import_name_from_32 = tmp_import_from_7__module;
        tmp_assign_source_45 = IMPORT_NAME( tmp_import_name_from_32, const_str_plain_HAS_TLSv1_1 );
        if ( tmp_assign_source_45 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 115;

            goto try_except_handler_9;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_HAS_TLSv1_1, tmp_assign_source_45 );
    }
    {
        PyObject *tmp_assign_source_46;
        PyObject *tmp_import_name_from_33;
        CHECK_OBJECT( tmp_import_from_7__module );
        tmp_import_name_from_33 = tmp_import_from_7__module;
        tmp_assign_source_46 = IMPORT_NAME( tmp_import_name_from_33, const_str_plain_HAS_TLSv1_2 );
        if ( tmp_assign_source_46 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 115;

            goto try_except_handler_9;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_HAS_TLSv1_2, tmp_assign_source_46 );
    }
    {
        PyObject *tmp_assign_source_47;
        PyObject *tmp_import_name_from_34;
        CHECK_OBJECT( tmp_import_from_7__module );
        tmp_import_name_from_34 = tmp_import_from_7__module;
        tmp_assign_source_47 = IMPORT_NAME( tmp_import_name_from_34, const_str_plain_HAS_TLSv1_3 );
        if ( tmp_assign_source_47 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 115;

            goto try_except_handler_9;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_HAS_TLSv1_3, tmp_assign_source_47 );
    }
    goto try_end_9;
    // Exception handler code:
    try_except_handler_9:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_7__module );
    Py_DECREF( tmp_import_from_7__module );
    tmp_import_from_7__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_7__module );
    Py_DECREF( tmp_import_from_7__module );
    tmp_import_from_7__module = NULL;

    {
        PyObject *tmp_assign_source_48;
        PyObject *tmp_name_name_13;
        PyObject *tmp_globals_name_13;
        PyObject *tmp_locals_name_13;
        PyObject *tmp_fromlist_name_13;
        PyObject *tmp_level_name_13;
        tmp_name_name_13 = const_str_plain__ssl;
        tmp_globals_name_13 = (PyObject *)moduledict_ssl;
        tmp_locals_name_13 = Py_None;
        tmp_fromlist_name_13 = const_tuple_str_plain__DEFAULT_CIPHERS_str_plain__OPENSSL_API_VERSION_tuple;
        tmp_level_name_13 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 119;
        tmp_assign_source_48 = IMPORT_MODULE5( tmp_name_name_13, tmp_globals_name_13, tmp_locals_name_13, tmp_fromlist_name_13, tmp_level_name_13 );
        if ( tmp_assign_source_48 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 119;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_8__module == NULL );
        tmp_import_from_8__module = tmp_assign_source_48;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_49;
        PyObject *tmp_import_name_from_35;
        CHECK_OBJECT( tmp_import_from_8__module );
        tmp_import_name_from_35 = tmp_import_from_8__module;
        tmp_assign_source_49 = IMPORT_NAME( tmp_import_name_from_35, const_str_plain__DEFAULT_CIPHERS );
        if ( tmp_assign_source_49 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 119;

            goto try_except_handler_10;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__DEFAULT_CIPHERS, tmp_assign_source_49 );
    }
    {
        PyObject *tmp_assign_source_50;
        PyObject *tmp_import_name_from_36;
        CHECK_OBJECT( tmp_import_from_8__module );
        tmp_import_name_from_36 = tmp_import_from_8__module;
        tmp_assign_source_50 = IMPORT_NAME( tmp_import_name_from_36, const_str_plain__OPENSSL_API_VERSION );
        if ( tmp_assign_source_50 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 119;

            goto try_except_handler_10;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__OPENSSL_API_VERSION, tmp_assign_source_50 );
    }
    goto try_end_10;
    // Exception handler code:
    try_except_handler_10:;
    exception_keeper_type_10 = exception_type;
    exception_keeper_value_10 = exception_value;
    exception_keeper_tb_10 = exception_tb;
    exception_keeper_lineno_10 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_8__module );
    Py_DECREF( tmp_import_from_8__module );
    tmp_import_from_8__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_10;
    exception_value = exception_keeper_value_10;
    exception_tb = exception_keeper_tb_10;
    exception_lineno = exception_keeper_lineno_10;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_8__module );
    Py_DECREF( tmp_import_from_8__module );
    tmp_import_from_8__module = NULL;

    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__IntEnum );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IntEnum );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_IntEnum" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 122;

            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__convert );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 122;

            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = const_str_plain__SSLMethod;
        tmp_args_name_1 = PyTuple_New( 3 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
        tmp_tuple_element_1 = const_str_plain_ssl;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
        tmp_tuple_element_1 = MAKE_FUNCTION_ssl$$$function_1_lambda(  );



        PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
        tmp_dict_key_1 = const_str_plain_source;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 125;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_1 = tmp_mvar_value_4;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 122;
        tmp_call_result_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 122;

            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_name_2;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_kw_name_2;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__IntFlag );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IntFlag );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_IntFlag" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 127;

            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_5;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__convert );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 127;

            goto frame_exception_exit_1;
        }
        tmp_tuple_element_2 = const_str_plain_Options;
        tmp_args_name_2 = PyTuple_New( 3 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_args_name_2, 0, tmp_tuple_element_2 );
        tmp_tuple_element_2 = const_str_plain_ssl;
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_args_name_2, 1, tmp_tuple_element_2 );
        tmp_tuple_element_2 = MAKE_FUNCTION_ssl$$$function_2_lambda(  );



        PyTuple_SET_ITEM( tmp_args_name_2, 2, tmp_tuple_element_2 );
        tmp_dict_key_2 = const_str_plain_source;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 130;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_2 = tmp_mvar_value_6;
        tmp_kw_name_2 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_2, tmp_dict_value_2 );
        assert( !(tmp_res != 0) );
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 127;
        tmp_call_result_2 = CALL_FUNCTION( tmp_called_name_2, tmp_args_name_2, tmp_kw_name_2 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 127;

            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_name_3;
        PyObject *tmp_tuple_element_3;
        PyObject *tmp_kw_name_3;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_mvar_value_8;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__IntEnum );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IntEnum );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_IntEnum" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 132;

            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_7;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__convert );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 132;

            goto frame_exception_exit_1;
        }
        tmp_tuple_element_3 = const_str_plain_AlertDescription;
        tmp_args_name_3 = PyTuple_New( 3 );
        Py_INCREF( tmp_tuple_element_3 );
        PyTuple_SET_ITEM( tmp_args_name_3, 0, tmp_tuple_element_3 );
        tmp_tuple_element_3 = const_str_plain_ssl;
        Py_INCREF( tmp_tuple_element_3 );
        PyTuple_SET_ITEM( tmp_args_name_3, 1, tmp_tuple_element_3 );
        tmp_tuple_element_3 = MAKE_FUNCTION_ssl$$$function_3_lambda(  );



        PyTuple_SET_ITEM( tmp_args_name_3, 2, tmp_tuple_element_3 );
        tmp_dict_key_3 = const_str_plain_source;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_8 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 135;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_3 = tmp_mvar_value_8;
        tmp_kw_name_3 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_3, tmp_dict_value_3 );
        assert( !(tmp_res != 0) );
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 132;
        tmp_call_result_3 = CALL_FUNCTION( tmp_called_name_3, tmp_args_name_3, tmp_kw_name_3 );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_name_3 );
        Py_DECREF( tmp_kw_name_3 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 132;

            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_name_4;
        PyObject *tmp_tuple_element_4;
        PyObject *tmp_kw_name_4;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__IntEnum );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IntEnum );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_IntEnum" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 137;

            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_9;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__convert );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 137;

            goto frame_exception_exit_1;
        }
        tmp_tuple_element_4 = const_str_plain_SSLErrorNumber;
        tmp_args_name_4 = PyTuple_New( 3 );
        Py_INCREF( tmp_tuple_element_4 );
        PyTuple_SET_ITEM( tmp_args_name_4, 0, tmp_tuple_element_4 );
        tmp_tuple_element_4 = const_str_plain_ssl;
        Py_INCREF( tmp_tuple_element_4 );
        PyTuple_SET_ITEM( tmp_args_name_4, 1, tmp_tuple_element_4 );
        tmp_tuple_element_4 = MAKE_FUNCTION_ssl$$$function_4_lambda(  );



        PyTuple_SET_ITEM( tmp_args_name_4, 2, tmp_tuple_element_4 );
        tmp_dict_key_4 = const_str_plain_source;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_10 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 140;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_4 = tmp_mvar_value_10;
        tmp_kw_name_4 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_kw_name_4, tmp_dict_key_4, tmp_dict_value_4 );
        assert( !(tmp_res != 0) );
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 137;
        tmp_call_result_4 = CALL_FUNCTION( tmp_called_name_4, tmp_args_name_4, tmp_kw_name_4 );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_name_4 );
        Py_DECREF( tmp_kw_name_4 );
        if ( tmp_call_result_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 137;

            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_4 );
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_call_result_5;
        PyObject *tmp_args_name_5;
        PyObject *tmp_tuple_element_5;
        PyObject *tmp_kw_name_5;
        PyObject *tmp_dict_key_5;
        PyObject *tmp_dict_value_5;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__IntFlag );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IntFlag );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_IntFlag" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 142;

            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_11;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__convert );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 142;

            goto frame_exception_exit_1;
        }
        tmp_tuple_element_5 = const_str_plain_VerifyFlags;
        tmp_args_name_5 = PyTuple_New( 3 );
        Py_INCREF( tmp_tuple_element_5 );
        PyTuple_SET_ITEM( tmp_args_name_5, 0, tmp_tuple_element_5 );
        tmp_tuple_element_5 = const_str_plain_ssl;
        Py_INCREF( tmp_tuple_element_5 );
        PyTuple_SET_ITEM( tmp_args_name_5, 1, tmp_tuple_element_5 );
        tmp_tuple_element_5 = MAKE_FUNCTION_ssl$$$function_5_lambda(  );



        PyTuple_SET_ITEM( tmp_args_name_5, 2, tmp_tuple_element_5 );
        tmp_dict_key_5 = const_str_plain_source;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_12 == NULL )
        {
            Py_DECREF( tmp_called_name_5 );
            Py_DECREF( tmp_args_name_5 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 145;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_5 = tmp_mvar_value_12;
        tmp_kw_name_5 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_kw_name_5, tmp_dict_key_5, tmp_dict_value_5 );
        assert( !(tmp_res != 0) );
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 142;
        tmp_call_result_5 = CALL_FUNCTION( tmp_called_name_5, tmp_args_name_5, tmp_kw_name_5 );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_name_5 );
        Py_DECREF( tmp_kw_name_5 );
        if ( tmp_call_result_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 142;

            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_5 );
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_call_result_6;
        PyObject *tmp_args_name_6;
        PyObject *tmp_tuple_element_6;
        PyObject *tmp_kw_name_6;
        PyObject *tmp_dict_key_6;
        PyObject *tmp_dict_value_6;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__IntEnum );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IntEnum );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_IntEnum" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 147;

            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_13;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__convert );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 147;

            goto frame_exception_exit_1;
        }
        tmp_tuple_element_6 = const_str_plain_VerifyMode;
        tmp_args_name_6 = PyTuple_New( 3 );
        Py_INCREF( tmp_tuple_element_6 );
        PyTuple_SET_ITEM( tmp_args_name_6, 0, tmp_tuple_element_6 );
        tmp_tuple_element_6 = const_str_plain_ssl;
        Py_INCREF( tmp_tuple_element_6 );
        PyTuple_SET_ITEM( tmp_args_name_6, 1, tmp_tuple_element_6 );
        tmp_tuple_element_6 = MAKE_FUNCTION_ssl$$$function_6_lambda(  );



        PyTuple_SET_ITEM( tmp_args_name_6, 2, tmp_tuple_element_6 );
        tmp_dict_key_6 = const_str_plain_source;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_14 == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            Py_DECREF( tmp_args_name_6 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 150;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_6 = tmp_mvar_value_14;
        tmp_kw_name_6 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_kw_name_6, tmp_dict_key_6, tmp_dict_value_6 );
        assert( !(tmp_res != 0) );
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 147;
        tmp_call_result_6 = CALL_FUNCTION( tmp_called_name_6, tmp_args_name_6, tmp_kw_name_6 );
        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_name_6 );
        Py_DECREF( tmp_kw_name_6 );
        if ( tmp_call_result_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 147;

            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_6 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_51;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_15;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__SSLMethod );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__SSLMethod );
        }

        if ( tmp_mvar_value_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_SSLMethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 152;

            goto try_except_handler_11;
        }

        tmp_source_name_7 = tmp_mvar_value_15;
        tmp_assign_source_51 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_PROTOCOL_TLS );
        if ( tmp_assign_source_51 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 152;

            goto try_except_handler_11;
        }
        assert( tmp_assign_unpack_1__assign_source == NULL );
        tmp_assign_unpack_1__assign_source = tmp_assign_source_51;
    }
    {
        PyObject *tmp_assign_source_52;
        CHECK_OBJECT( tmp_assign_unpack_1__assign_source );
        tmp_assign_source_52 = tmp_assign_unpack_1__assign_source;
        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PROTOCOL_SSLv23, tmp_assign_source_52 );
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        PyObject *tmp_mvar_value_16;
        CHECK_OBJECT( tmp_assign_unpack_1__assign_source );
        tmp_assattr_name_3 = tmp_assign_unpack_1__assign_source;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__SSLMethod );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__SSLMethod );
        }

        if ( tmp_mvar_value_16 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_SSLMethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 152;

            goto try_except_handler_11;
        }

        tmp_assattr_target_3 = tmp_mvar_value_16;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_PROTOCOL_SSLv23, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 152;

            goto try_except_handler_11;
        }
    }
    goto try_end_11;
    // Exception handler code:
    try_except_handler_11:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_assign_unpack_1__assign_source );
    tmp_assign_unpack_1__assign_source = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_11;
    exception_value = exception_keeper_value_11;
    exception_tb = exception_keeper_tb_11;
    exception_lineno = exception_keeper_lineno_11;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    CHECK_OBJECT( (PyObject *)tmp_assign_unpack_1__assign_source );
    Py_DECREF( tmp_assign_unpack_1__assign_source );
    tmp_assign_unpack_1__assign_source = NULL;

    {
        PyObject *tmp_assign_source_53;
        // Tried code:
        {
            PyObject *tmp_assign_source_54;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_8;
            PyObject *tmp_mvar_value_17;
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__SSLMethod );

            if (unlikely( tmp_mvar_value_17 == NULL ))
            {
                tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__SSLMethod );
            }

            if ( tmp_mvar_value_17 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_SSLMethod" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 153;

                goto try_except_handler_12;
            }

            tmp_source_name_8 = tmp_mvar_value_17;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___members__ );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 153;

                goto try_except_handler_12;
            }
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 153;
            tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_items );
            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 153;

                goto try_except_handler_12;
            }
            tmp_assign_source_54 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_54 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 153;

                goto try_except_handler_12;
            }
            assert( tmp_dictcontraction_1__$0 == NULL );
            tmp_dictcontraction_1__$0 = tmp_assign_source_54;
        }
        {
            PyObject *tmp_assign_source_55;
            tmp_assign_source_55 = PyDict_New();
            assert( tmp_dictcontraction_1__contraction == NULL );
            tmp_dictcontraction_1__contraction = tmp_assign_source_55;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_4e4f09e7416371c39d6e683dfaa31b44_2, codeobj_4e4f09e7416371c39d6e683dfaa31b44, module_ssl, sizeof(void *)+sizeof(void *) );
        frame_4e4f09e7416371c39d6e683dfaa31b44_2 = cache_frame_4e4f09e7416371c39d6e683dfaa31b44_2;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_4e4f09e7416371c39d6e683dfaa31b44_2 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_4e4f09e7416371c39d6e683dfaa31b44_2 ) == 2 ); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_56;
            CHECK_OBJECT( tmp_dictcontraction_1__$0 );
            tmp_next_source_1 = tmp_dictcontraction_1__$0;
            tmp_assign_source_56 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_56 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_2 = "oo";
                    exception_lineno = 153;
                    goto try_except_handler_13;
                }
            }

            {
                PyObject *old = tmp_dictcontraction_1__iter_value_0;
                tmp_dictcontraction_1__iter_value_0 = tmp_assign_source_56;
                Py_XDECREF( old );
            }

        }
        // Tried code:
        {
            PyObject *tmp_assign_source_57;
            PyObject *tmp_iter_arg_2;
            CHECK_OBJECT( tmp_dictcontraction_1__iter_value_0 );
            tmp_iter_arg_2 = tmp_dictcontraction_1__iter_value_0;
            tmp_assign_source_57 = MAKE_UNPACK_ITERATOR( tmp_iter_arg_2 );
            if ( tmp_assign_source_57 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 153;
                type_description_2 = "oo";
                goto try_except_handler_14;
            }
            {
                PyObject *old = tmp_dictcontraction$tuple_unpack_1__source_iter;
                tmp_dictcontraction$tuple_unpack_1__source_iter = tmp_assign_source_57;
                Py_XDECREF( old );
            }

        }
        // Tried code:
        {
            PyObject *tmp_assign_source_58;
            PyObject *tmp_unpack_1;
            CHECK_OBJECT( tmp_dictcontraction$tuple_unpack_1__source_iter );
            tmp_unpack_1 = tmp_dictcontraction$tuple_unpack_1__source_iter;
            tmp_assign_source_58 = UNPACK_NEXT( tmp_unpack_1, 0, 2 );
            if ( tmp_assign_source_58 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_2 = "oo";
                exception_lineno = 153;
                goto try_except_handler_15;
            }
            {
                PyObject *old = tmp_dictcontraction$tuple_unpack_1__element_1;
                tmp_dictcontraction$tuple_unpack_1__element_1 = tmp_assign_source_58;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_59;
            PyObject *tmp_unpack_2;
            CHECK_OBJECT( tmp_dictcontraction$tuple_unpack_1__source_iter );
            tmp_unpack_2 = tmp_dictcontraction$tuple_unpack_1__source_iter;
            tmp_assign_source_59 = UNPACK_NEXT( tmp_unpack_2, 1, 2 );
            if ( tmp_assign_source_59 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_2 = "oo";
                exception_lineno = 153;
                goto try_except_handler_15;
            }
            {
                PyObject *old = tmp_dictcontraction$tuple_unpack_1__element_2;
                tmp_dictcontraction$tuple_unpack_1__element_2 = tmp_assign_source_59;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_iterator_name_1;
            CHECK_OBJECT( tmp_dictcontraction$tuple_unpack_1__source_iter );
            tmp_iterator_name_1 = tmp_dictcontraction$tuple_unpack_1__source_iter;
            // Check if iterator has left-over elements.
            CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

            tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

            if (likely( tmp_iterator_attempt == NULL ))
            {
                PyObject *error = GET_ERROR_OCCURRED();

                if ( error != NULL )
                {
                    if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                    {
                        CLEAR_ERROR_OCCURRED();
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                        type_description_2 = "oo";
                        exception_lineno = 153;
                        goto try_except_handler_15;
                    }
                }
            }
            else
            {
                Py_DECREF( tmp_iterator_attempt );

                // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_2 = "oo";
                exception_lineno = 153;
                goto try_except_handler_15;
            }
        }
        goto try_end_12;
        // Exception handler code:
        try_except_handler_15:;
        exception_keeper_type_12 = exception_type;
        exception_keeper_value_12 = exception_value;
        exception_keeper_tb_12 = exception_tb;
        exception_keeper_lineno_12 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_dictcontraction$tuple_unpack_1__source_iter );
        Py_DECREF( tmp_dictcontraction$tuple_unpack_1__source_iter );
        tmp_dictcontraction$tuple_unpack_1__source_iter = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_12;
        exception_value = exception_keeper_value_12;
        exception_tb = exception_keeper_tb_12;
        exception_lineno = exception_keeper_lineno_12;

        goto try_except_handler_14;
        // End of try:
        try_end_12:;
        goto try_end_13;
        // Exception handler code:
        try_except_handler_14:;
        exception_keeper_type_13 = exception_type;
        exception_keeper_value_13 = exception_value;
        exception_keeper_tb_13 = exception_tb;
        exception_keeper_lineno_13 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_dictcontraction$tuple_unpack_1__element_1 );
        tmp_dictcontraction$tuple_unpack_1__element_1 = NULL;

        Py_XDECREF( tmp_dictcontraction$tuple_unpack_1__element_2 );
        tmp_dictcontraction$tuple_unpack_1__element_2 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_13;
        exception_value = exception_keeper_value_13;
        exception_tb = exception_keeper_tb_13;
        exception_lineno = exception_keeper_lineno_13;

        goto try_except_handler_13;
        // End of try:
        try_end_13:;
        CHECK_OBJECT( (PyObject *)tmp_dictcontraction$tuple_unpack_1__source_iter );
        Py_DECREF( tmp_dictcontraction$tuple_unpack_1__source_iter );
        tmp_dictcontraction$tuple_unpack_1__source_iter = NULL;

        {
            PyObject *tmp_assign_source_60;
            CHECK_OBJECT( tmp_dictcontraction$tuple_unpack_1__element_1 );
            tmp_assign_source_60 = tmp_dictcontraction$tuple_unpack_1__element_1;
            {
                PyObject *old = outline_0_var_name;
                outline_0_var_name = tmp_assign_source_60;
                Py_INCREF( outline_0_var_name );
                Py_XDECREF( old );
            }

        }
        Py_XDECREF( tmp_dictcontraction$tuple_unpack_1__element_1 );
        tmp_dictcontraction$tuple_unpack_1__element_1 = NULL;

        {
            PyObject *tmp_assign_source_61;
            CHECK_OBJECT( tmp_dictcontraction$tuple_unpack_1__element_2 );
            tmp_assign_source_61 = tmp_dictcontraction$tuple_unpack_1__element_2;
            {
                PyObject *old = outline_0_var_value;
                outline_0_var_value = tmp_assign_source_61;
                Py_INCREF( outline_0_var_value );
                Py_XDECREF( old );
            }

        }
        Py_XDECREF( tmp_dictcontraction$tuple_unpack_1__element_2 );
        tmp_dictcontraction$tuple_unpack_1__element_2 = NULL;

        CHECK_OBJECT( outline_0_var_name );
        tmp_dictset_value = outline_0_var_name;
        CHECK_OBJECT( tmp_dictcontraction_1__contraction );
        tmp_dictset_dict = tmp_dictcontraction_1__contraction;
        CHECK_OBJECT( outline_0_var_value );
        tmp_dictset_key = outline_0_var_value;
        tmp_res = PyDict_SetItem( tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 153;
            type_description_2 = "oo";
            goto try_except_handler_13;
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 153;
            type_description_2 = "oo";
            goto try_except_handler_13;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT( tmp_dictcontraction_1__contraction );
        tmp_assign_source_53 = tmp_dictcontraction_1__contraction;
        Py_INCREF( tmp_assign_source_53 );
        goto try_return_handler_13;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_13:;
        CHECK_OBJECT( (PyObject *)tmp_dictcontraction_1__$0 );
        Py_DECREF( tmp_dictcontraction_1__$0 );
        tmp_dictcontraction_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_dictcontraction_1__contraction );
        Py_DECREF( tmp_dictcontraction_1__contraction );
        tmp_dictcontraction_1__contraction = NULL;

        Py_XDECREF( tmp_dictcontraction_1__iter_value_0 );
        tmp_dictcontraction_1__iter_value_0 = NULL;

        goto frame_return_exit_1;
        // Exception handler code:
        try_except_handler_13:;
        exception_keeper_type_14 = exception_type;
        exception_keeper_value_14 = exception_value;
        exception_keeper_tb_14 = exception_tb;
        exception_keeper_lineno_14 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_dictcontraction_1__$0 );
        Py_DECREF( tmp_dictcontraction_1__$0 );
        tmp_dictcontraction_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_dictcontraction_1__contraction );
        Py_DECREF( tmp_dictcontraction_1__contraction );
        tmp_dictcontraction_1__contraction = NULL;

        Py_XDECREF( tmp_dictcontraction_1__iter_value_0 );
        tmp_dictcontraction_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_14;
        exception_value = exception_keeper_value_14;
        exception_tb = exception_keeper_tb_14;
        exception_lineno = exception_keeper_lineno_14;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION( frame_4e4f09e7416371c39d6e683dfaa31b44_2 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_1:;
#if 0
        RESTORE_FRAME_EXCEPTION( frame_4e4f09e7416371c39d6e683dfaa31b44_2 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_12;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_4e4f09e7416371c39d6e683dfaa31b44_2 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_4e4f09e7416371c39d6e683dfaa31b44_2, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_4e4f09e7416371c39d6e683dfaa31b44_2->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_4e4f09e7416371c39d6e683dfaa31b44_2, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_4e4f09e7416371c39d6e683dfaa31b44_2,
            type_description_2,
            outline_0_var_name,
            outline_0_var_value
        );


        // Release cached frame.
        if ( frame_4e4f09e7416371c39d6e683dfaa31b44_2 == cache_frame_4e4f09e7416371c39d6e683dfaa31b44_2 )
        {
            Py_DECREF( frame_4e4f09e7416371c39d6e683dfaa31b44_2 );
        }
        cache_frame_4e4f09e7416371c39d6e683dfaa31b44_2 = NULL;

        assertFrameObject( frame_4e4f09e7416371c39d6e683dfaa31b44_2 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;

        goto try_except_handler_12;
        skip_nested_handling_1:;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_12:;
        Py_XDECREF( outline_0_var_name );
        outline_0_var_name = NULL;

        Py_XDECREF( outline_0_var_value );
        outline_0_var_value = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_12:;
        exception_keeper_type_15 = exception_type;
        exception_keeper_value_15 = exception_value;
        exception_keeper_tb_15 = exception_tb;
        exception_keeper_lineno_15 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( outline_0_var_name );
        outline_0_var_name = NULL;

        Py_XDECREF( outline_0_var_value );
        outline_0_var_value = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_15;
        exception_value = exception_keeper_value_15;
        exception_tb = exception_keeper_tb_15;
        exception_lineno = exception_keeper_lineno_15;

        goto outline_exception_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_1:;
        exception_lineno = 153;
        goto frame_exception_exit_1;
        outline_result_1:;
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__PROTOCOL_NAMES, tmp_assign_source_53 );
    }
    {
        PyObject *tmp_assign_source_62;
        PyObject *tmp_getattr_target_1;
        PyObject *tmp_mvar_value_18;
        PyObject *tmp_getattr_attr_1;
        PyObject *tmp_getattr_default_1;
        tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__SSLMethod );

        if (unlikely( tmp_mvar_value_18 == NULL ))
        {
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__SSLMethod );
        }

        if ( tmp_mvar_value_18 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_SSLMethod" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 155;

            goto frame_exception_exit_1;
        }

        tmp_getattr_target_1 = tmp_mvar_value_18;
        tmp_getattr_attr_1 = const_str_plain_PROTOCOL_SSLv2;
        tmp_getattr_default_1 = Py_None;
        tmp_assign_source_62 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1 );
        if ( tmp_assign_source_62 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 155;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__SSLv2_IF_EXISTS, tmp_assign_source_62 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_63;
        PyObject *tmp_tuple_element_7;
        PyObject *tmp_mvar_value_19;
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__IntEnum );

        if (unlikely( tmp_mvar_value_19 == NULL ))
        {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__IntEnum );
        }

        if ( tmp_mvar_value_19 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_IntEnum" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 158;

            goto try_except_handler_16;
        }

        tmp_tuple_element_7 = tmp_mvar_value_19;
        tmp_assign_source_63 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_7 );
        PyTuple_SET_ITEM( tmp_assign_source_63, 0, tmp_tuple_element_7 );
        assert( tmp_class_creation_1__bases_orig == NULL );
        tmp_class_creation_1__bases_orig = tmp_assign_source_63;
    }
    {
        PyObject *tmp_assign_source_64;
        PyObject *tmp_dircall_arg1_1;
        CHECK_OBJECT( tmp_class_creation_1__bases_orig );
        tmp_dircall_arg1_1 = tmp_class_creation_1__bases_orig;
        Py_INCREF( tmp_dircall_arg1_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1};
            tmp_assign_source_64 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_64 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;

            goto try_except_handler_16;
        }
        assert( tmp_class_creation_1__bases == NULL );
        tmp_class_creation_1__bases = tmp_assign_source_64;
    }
    {
        PyObject *tmp_assign_source_65;
        tmp_assign_source_65 = PyDict_New();
        assert( tmp_class_creation_1__class_decl_dict == NULL );
        tmp_class_creation_1__class_decl_dict = tmp_assign_source_65;
    }
    {
        PyObject *tmp_assign_source_66;
        PyObject *tmp_metaclass_name_1;
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_key_name_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        nuitka_bool tmp_condition_result_3;
        int tmp_truth_name_1;
        PyObject *tmp_type_arg_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_bases_name_1;
        tmp_key_name_1 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_1__class_decl_dict );
        tmp_dict_name_1 = tmp_class_creation_1__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_1, tmp_key_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;

            goto try_except_handler_16;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_1;
        }
        else
        {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT( tmp_class_creation_1__class_decl_dict );
        tmp_dict_name_2 = tmp_class_creation_1__class_decl_dict;
        tmp_key_name_2 = const_str_plain_metaclass;
        tmp_metaclass_name_1 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
        if ( tmp_metaclass_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;

            goto try_except_handler_16;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        CHECK_OBJECT( tmp_class_creation_1__bases );
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_class_creation_1__bases );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;

            goto try_except_handler_16;
        }
        tmp_condition_result_3 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_2;
        }
        else
        {
            goto condexpr_false_2;
        }
        condexpr_true_2:;
        CHECK_OBJECT( tmp_class_creation_1__bases );
        tmp_subscribed_name_1 = tmp_class_creation_1__bases;
        tmp_subscript_name_1 = const_int_0;
        tmp_type_arg_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_type_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;

            goto try_except_handler_16;
        }
        tmp_metaclass_name_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
        Py_DECREF( tmp_type_arg_1 );
        if ( tmp_metaclass_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;

            goto try_except_handler_16;
        }
        goto condexpr_end_2;
        condexpr_false_2:;
        tmp_metaclass_name_1 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_1 );
        condexpr_end_2:;
        condexpr_end_1:;
        CHECK_OBJECT( tmp_class_creation_1__bases );
        tmp_bases_name_1 = tmp_class_creation_1__bases;
        tmp_assign_source_66 = SELECT_METACLASS( tmp_metaclass_name_1, tmp_bases_name_1 );
        Py_DECREF( tmp_metaclass_name_1 );
        if ( tmp_assign_source_66 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;

            goto try_except_handler_16;
        }
        assert( tmp_class_creation_1__metaclass == NULL );
        tmp_class_creation_1__metaclass = tmp_assign_source_66;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_key_name_3;
        PyObject *tmp_dict_name_3;
        tmp_key_name_3 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_1__class_decl_dict );
        tmp_dict_name_3 = tmp_class_creation_1__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_3, tmp_key_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;

            goto try_except_handler_16;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        CHECK_OBJECT( tmp_class_creation_1__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_1__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;

            goto try_except_handler_16;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_source_name_9;
        CHECK_OBJECT( tmp_class_creation_1__metaclass );
        tmp_source_name_9 = tmp_class_creation_1__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_9, const_str_plain___prepare__ );
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_67;
            PyObject *tmp_called_name_7;
            PyObject *tmp_source_name_10;
            PyObject *tmp_args_name_7;
            PyObject *tmp_tuple_element_8;
            PyObject *tmp_kw_name_7;
            CHECK_OBJECT( tmp_class_creation_1__metaclass );
            tmp_source_name_10 = tmp_class_creation_1__metaclass;
            tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain___prepare__ );
            if ( tmp_called_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 158;

                goto try_except_handler_16;
            }
            tmp_tuple_element_8 = const_str_plain_TLSVersion;
            tmp_args_name_7 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_8 );
            PyTuple_SET_ITEM( tmp_args_name_7, 0, tmp_tuple_element_8 );
            CHECK_OBJECT( tmp_class_creation_1__bases );
            tmp_tuple_element_8 = tmp_class_creation_1__bases;
            Py_INCREF( tmp_tuple_element_8 );
            PyTuple_SET_ITEM( tmp_args_name_7, 1, tmp_tuple_element_8 );
            CHECK_OBJECT( tmp_class_creation_1__class_decl_dict );
            tmp_kw_name_7 = tmp_class_creation_1__class_decl_dict;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 158;
            tmp_assign_source_67 = CALL_FUNCTION( tmp_called_name_7, tmp_args_name_7, tmp_kw_name_7 );
            Py_DECREF( tmp_called_name_7 );
            Py_DECREF( tmp_args_name_7 );
            if ( tmp_assign_source_67 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 158;

                goto try_except_handler_16;
            }
            assert( tmp_class_creation_1__prepared == NULL );
            tmp_class_creation_1__prepared = tmp_assign_source_67;
        }
        {
            nuitka_bool tmp_condition_result_6;
            PyObject *tmp_operand_name_2;
            PyObject *tmp_source_name_11;
            CHECK_OBJECT( tmp_class_creation_1__prepared );
            tmp_source_name_11 = tmp_class_creation_1__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_11, const_str_plain___getitem__ );
            tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 158;

                goto try_except_handler_16;
            }
            tmp_condition_result_6 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_raise_value_1;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_tuple_element_9;
                PyObject *tmp_getattr_target_2;
                PyObject *tmp_getattr_attr_2;
                PyObject *tmp_getattr_default_2;
                PyObject *tmp_source_name_12;
                PyObject *tmp_type_arg_2;
                tmp_raise_type_1 = PyExc_TypeError;
                tmp_left_name_1 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_1__metaclass );
                tmp_getattr_target_2 = tmp_class_creation_1__metaclass;
                tmp_getattr_attr_2 = const_str_plain___name__;
                tmp_getattr_default_2 = const_str_angle_metaclass;
                tmp_tuple_element_9 = BUILTIN_GETATTR( tmp_getattr_target_2, tmp_getattr_attr_2, tmp_getattr_default_2 );
                if ( tmp_tuple_element_9 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 158;

                    goto try_except_handler_16;
                }
                tmp_right_name_1 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_9 );
                CHECK_OBJECT( tmp_class_creation_1__prepared );
                tmp_type_arg_2 = tmp_class_creation_1__prepared;
                tmp_source_name_12 = BUILTIN_TYPE1( tmp_type_arg_2 );
                assert( !(tmp_source_name_12 == NULL) );
                tmp_tuple_element_9 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_12 );
                if ( tmp_tuple_element_9 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_1 );

                    exception_lineno = 158;

                    goto try_except_handler_16;
                }
                PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_9 );
                tmp_raise_value_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
                Py_DECREF( tmp_right_name_1 );
                if ( tmp_raise_value_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 158;

                    goto try_except_handler_16;
                }
                exception_type = tmp_raise_type_1;
                Py_INCREF( tmp_raise_type_1 );
                exception_value = tmp_raise_value_1;
                exception_lineno = 158;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_16;
            }
            branch_no_4:;
        }
        goto branch_end_3;
        branch_no_3:;
        {
            PyObject *tmp_assign_source_68;
            tmp_assign_source_68 = PyDict_New();
            assert( tmp_class_creation_1__prepared == NULL );
            tmp_class_creation_1__prepared = tmp_assign_source_68;
        }
        branch_end_3:;
    }
    {
        PyObject *tmp_assign_source_69;
        {
            PyObject *tmp_set_locals_1;
            CHECK_OBJECT( tmp_class_creation_1__prepared );
            tmp_set_locals_1 = tmp_class_creation_1__prepared;
            locals_ssl_158 = tmp_set_locals_1;
            Py_INCREF( tmp_set_locals_1 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_ssl;
        tmp_res = PyObject_SetItem( locals_ssl_158, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;

            goto try_except_handler_18;
        }
        tmp_dictset_value = const_str_plain_TLSVersion;
        tmp_res = PyObject_SetItem( locals_ssl_158, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;

            goto try_except_handler_18;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_5ecbd54808c422e093f59660e1c05923_3, codeobj_5ecbd54808c422e093f59660e1c05923, module_ssl, sizeof(void *) );
        frame_5ecbd54808c422e093f59660e1c05923_3 = cache_frame_5ecbd54808c422e093f59660e1c05923_3;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_5ecbd54808c422e093f59660e1c05923_3 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_5ecbd54808c422e093f59660e1c05923_3 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_13;
            PyObject *tmp_mvar_value_20;
            tmp_source_name_13 = PyObject_GetItem( locals_ssl_158, const_str_plain__ssl );

            if ( tmp_source_name_13 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

                if (unlikely( tmp_mvar_value_20 == NULL ))
                {
                    tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
                }

                if ( tmp_mvar_value_20 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 159;
                    type_description_2 = "o";
                    goto frame_exception_exit_3;
                }

                tmp_source_name_13 = tmp_mvar_value_20;
                Py_INCREF( tmp_source_name_13 );
                }
            }

            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_PROTO_MINIMUM_SUPPORTED );
            Py_DECREF( tmp_source_name_13 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 159;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_res = PyObject_SetItem( locals_ssl_158, const_str_plain_MINIMUM_SUPPORTED, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 159;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_source_name_14;
            PyObject *tmp_mvar_value_21;
            tmp_source_name_14 = PyObject_GetItem( locals_ssl_158, const_str_plain__ssl );

            if ( tmp_source_name_14 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_21 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

                if (unlikely( tmp_mvar_value_21 == NULL ))
                {
                    tmp_mvar_value_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
                }

                if ( tmp_mvar_value_21 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 160;
                    type_description_2 = "o";
                    goto frame_exception_exit_3;
                }

                tmp_source_name_14 = tmp_mvar_value_21;
                Py_INCREF( tmp_source_name_14 );
                }
            }

            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_PROTO_SSLv3 );
            Py_DECREF( tmp_source_name_14 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 160;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_res = PyObject_SetItem( locals_ssl_158, const_str_plain_SSLv3, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 160;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_source_name_15;
            PyObject *tmp_mvar_value_22;
            tmp_source_name_15 = PyObject_GetItem( locals_ssl_158, const_str_plain__ssl );

            if ( tmp_source_name_15 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_22 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

                if (unlikely( tmp_mvar_value_22 == NULL ))
                {
                    tmp_mvar_value_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
                }

                if ( tmp_mvar_value_22 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 161;
                    type_description_2 = "o";
                    goto frame_exception_exit_3;
                }

                tmp_source_name_15 = tmp_mvar_value_22;
                Py_INCREF( tmp_source_name_15 );
                }
            }

            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_PROTO_TLSv1 );
            Py_DECREF( tmp_source_name_15 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 161;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_res = PyObject_SetItem( locals_ssl_158, const_str_plain_TLSv1, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 161;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_source_name_16;
            PyObject *tmp_mvar_value_23;
            tmp_source_name_16 = PyObject_GetItem( locals_ssl_158, const_str_plain__ssl );

            if ( tmp_source_name_16 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_23 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

                if (unlikely( tmp_mvar_value_23 == NULL ))
                {
                    tmp_mvar_value_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
                }

                if ( tmp_mvar_value_23 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 162;
                    type_description_2 = "o";
                    goto frame_exception_exit_3;
                }

                tmp_source_name_16 = tmp_mvar_value_23;
                Py_INCREF( tmp_source_name_16 );
                }
            }

            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_PROTO_TLSv1_1 );
            Py_DECREF( tmp_source_name_16 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 162;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_res = PyObject_SetItem( locals_ssl_158, const_str_plain_TLSv1_1, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 162;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_source_name_17;
            PyObject *tmp_mvar_value_24;
            tmp_source_name_17 = PyObject_GetItem( locals_ssl_158, const_str_plain__ssl );

            if ( tmp_source_name_17 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_24 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

                if (unlikely( tmp_mvar_value_24 == NULL ))
                {
                    tmp_mvar_value_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
                }

                if ( tmp_mvar_value_24 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 163;
                    type_description_2 = "o";
                    goto frame_exception_exit_3;
                }

                tmp_source_name_17 = tmp_mvar_value_24;
                Py_INCREF( tmp_source_name_17 );
                }
            }

            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_PROTO_TLSv1_2 );
            Py_DECREF( tmp_source_name_17 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 163;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_res = PyObject_SetItem( locals_ssl_158, const_str_plain_TLSv1_2, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 163;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_source_name_18;
            PyObject *tmp_mvar_value_25;
            tmp_source_name_18 = PyObject_GetItem( locals_ssl_158, const_str_plain__ssl );

            if ( tmp_source_name_18 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_25 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

                if (unlikely( tmp_mvar_value_25 == NULL ))
                {
                    tmp_mvar_value_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
                }

                if ( tmp_mvar_value_25 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 164;
                    type_description_2 = "o";
                    goto frame_exception_exit_3;
                }

                tmp_source_name_18 = tmp_mvar_value_25;
                Py_INCREF( tmp_source_name_18 );
                }
            }

            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_PROTO_TLSv1_3 );
            Py_DECREF( tmp_source_name_18 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 164;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_res = PyObject_SetItem( locals_ssl_158, const_str_plain_TLSv1_3, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 164;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_source_name_19;
            PyObject *tmp_mvar_value_26;
            tmp_source_name_19 = PyObject_GetItem( locals_ssl_158, const_str_plain__ssl );

            if ( tmp_source_name_19 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_26 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

                if (unlikely( tmp_mvar_value_26 == NULL ))
                {
                    tmp_mvar_value_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
                }

                if ( tmp_mvar_value_26 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 165;
                    type_description_2 = "o";
                    goto frame_exception_exit_3;
                }

                tmp_source_name_19 = tmp_mvar_value_26;
                Py_INCREF( tmp_source_name_19 );
                }
            }

            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_PROTO_MAXIMUM_SUPPORTED );
            Py_DECREF( tmp_source_name_19 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 165;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_res = PyObject_SetItem( locals_ssl_158, const_str_plain_MAXIMUM_SUPPORTED, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 165;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_5ecbd54808c422e093f59660e1c05923_3 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_2;

        frame_exception_exit_3:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_5ecbd54808c422e093f59660e1c05923_3 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_5ecbd54808c422e093f59660e1c05923_3, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_5ecbd54808c422e093f59660e1c05923_3->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_5ecbd54808c422e093f59660e1c05923_3, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_5ecbd54808c422e093f59660e1c05923_3,
            type_description_2,
            outline_1_var___class__
        );


        // Release cached frame.
        if ( frame_5ecbd54808c422e093f59660e1c05923_3 == cache_frame_5ecbd54808c422e093f59660e1c05923_3 )
        {
            Py_DECREF( frame_5ecbd54808c422e093f59660e1c05923_3 );
        }
        cache_frame_5ecbd54808c422e093f59660e1c05923_3 = NULL;

        assertFrameObject( frame_5ecbd54808c422e093f59660e1c05923_3 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_2;

        frame_no_exception_2:;
        goto skip_nested_handling_2;
        nested_frame_exit_2:;

        goto try_except_handler_18;
        skip_nested_handling_2:;
        {
            nuitka_bool tmp_condition_result_7;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( tmp_class_creation_1__bases );
            tmp_compexpr_left_2 = tmp_class_creation_1__bases;
            CHECK_OBJECT( tmp_class_creation_1__bases_orig );
            tmp_compexpr_right_2 = tmp_class_creation_1__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 158;

                goto try_except_handler_18;
            }
            tmp_condition_result_7 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_5;
            }
            else
            {
                goto branch_no_5;
            }
            branch_yes_5:;
            CHECK_OBJECT( tmp_class_creation_1__bases_orig );
            tmp_dictset_value = tmp_class_creation_1__bases_orig;
            tmp_res = PyObject_SetItem( locals_ssl_158, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 158;

                goto try_except_handler_18;
            }
            branch_no_5:;
        }
        {
            PyObject *tmp_assign_source_70;
            PyObject *tmp_called_name_8;
            PyObject *tmp_args_name_8;
            PyObject *tmp_tuple_element_10;
            PyObject *tmp_kw_name_8;
            CHECK_OBJECT( tmp_class_creation_1__metaclass );
            tmp_called_name_8 = tmp_class_creation_1__metaclass;
            tmp_tuple_element_10 = const_str_plain_TLSVersion;
            tmp_args_name_8 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_10 );
            PyTuple_SET_ITEM( tmp_args_name_8, 0, tmp_tuple_element_10 );
            CHECK_OBJECT( tmp_class_creation_1__bases );
            tmp_tuple_element_10 = tmp_class_creation_1__bases;
            Py_INCREF( tmp_tuple_element_10 );
            PyTuple_SET_ITEM( tmp_args_name_8, 1, tmp_tuple_element_10 );
            tmp_tuple_element_10 = locals_ssl_158;
            Py_INCREF( tmp_tuple_element_10 );
            PyTuple_SET_ITEM( tmp_args_name_8, 2, tmp_tuple_element_10 );
            CHECK_OBJECT( tmp_class_creation_1__class_decl_dict );
            tmp_kw_name_8 = tmp_class_creation_1__class_decl_dict;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 158;
            tmp_assign_source_70 = CALL_FUNCTION( tmp_called_name_8, tmp_args_name_8, tmp_kw_name_8 );
            Py_DECREF( tmp_args_name_8 );
            if ( tmp_assign_source_70 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 158;

                goto try_except_handler_18;
            }
            assert( outline_1_var___class__ == NULL );
            outline_1_var___class__ = tmp_assign_source_70;
        }
        CHECK_OBJECT( outline_1_var___class__ );
        tmp_assign_source_69 = outline_1_var___class__;
        Py_INCREF( tmp_assign_source_69 );
        goto try_return_handler_18;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_18:;
        Py_DECREF( locals_ssl_158 );
        locals_ssl_158 = NULL;
        goto try_return_handler_17;
        // Exception handler code:
        try_except_handler_18:;
        exception_keeper_type_16 = exception_type;
        exception_keeper_value_16 = exception_value;
        exception_keeper_tb_16 = exception_tb;
        exception_keeper_lineno_16 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ssl_158 );
        locals_ssl_158 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_16;
        exception_value = exception_keeper_value_16;
        exception_tb = exception_keeper_tb_16;
        exception_lineno = exception_keeper_lineno_16;

        goto try_except_handler_17;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_17:;
        CHECK_OBJECT( (PyObject *)outline_1_var___class__ );
        Py_DECREF( outline_1_var___class__ );
        outline_1_var___class__ = NULL;

        goto outline_result_2;
        // Exception handler code:
        try_except_handler_17:;
        exception_keeper_type_17 = exception_type;
        exception_keeper_value_17 = exception_value;
        exception_keeper_tb_17 = exception_tb;
        exception_keeper_lineno_17 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_17;
        exception_value = exception_keeper_value_17;
        exception_tb = exception_keeper_tb_17;
        exception_lineno = exception_keeper_lineno_17;

        goto outline_exception_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_2:;
        exception_lineno = 158;
        goto try_except_handler_16;
        outline_result_2:;
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_TLSVersion, tmp_assign_source_69 );
    }
    goto try_end_14;
    // Exception handler code:
    try_except_handler_16:;
    exception_keeper_type_18 = exception_type;
    exception_keeper_value_18 = exception_value;
    exception_keeper_tb_18 = exception_tb;
    exception_keeper_lineno_18 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_1__bases_orig );
    tmp_class_creation_1__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    Py_XDECREF( tmp_class_creation_1__class_decl_dict );
    tmp_class_creation_1__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_1__prepared );
    tmp_class_creation_1__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_18;
    exception_value = exception_keeper_value_18;
    exception_tb = exception_keeper_tb_18;
    exception_lineno = exception_keeper_lineno_18;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases_orig );
    Py_DECREF( tmp_class_creation_1__bases_orig );
    tmp_class_creation_1__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_decl_dict );
    Py_DECREF( tmp_class_creation_1__class_decl_dict );
    tmp_class_creation_1__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__prepared );
    Py_DECREF( tmp_class_creation_1__prepared );
    tmp_class_creation_1__prepared = NULL;

    {
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_20;
        PyObject *tmp_mvar_value_27;
        tmp_mvar_value_27 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_sys );

        if (unlikely( tmp_mvar_value_27 == NULL ))
        {
            tmp_mvar_value_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
        }

        if ( tmp_mvar_value_27 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 168;

            goto frame_exception_exit_1;
        }

        tmp_source_name_20 = tmp_mvar_value_27;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_platform );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 168;

            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = const_str_plain_win32;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT_NORECURSE( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 168;

            goto frame_exception_exit_1;
        }
        tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_assign_source_71;
            PyObject *tmp_name_name_14;
            PyObject *tmp_globals_name_14;
            PyObject *tmp_locals_name_14;
            PyObject *tmp_fromlist_name_14;
            PyObject *tmp_level_name_14;
            tmp_name_name_14 = const_str_plain__ssl;
            tmp_globals_name_14 = (PyObject *)moduledict_ssl;
            tmp_locals_name_14 = Py_None;
            tmp_fromlist_name_14 = const_tuple_str_plain_enum_certificates_str_plain_enum_crls_tuple;
            tmp_level_name_14 = const_int_0;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 169;
            tmp_assign_source_71 = IMPORT_MODULE5( tmp_name_name_14, tmp_globals_name_14, tmp_locals_name_14, tmp_fromlist_name_14, tmp_level_name_14 );
            if ( tmp_assign_source_71 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 169;

                goto frame_exception_exit_1;
            }
            assert( tmp_import_from_9__module == NULL );
            tmp_import_from_9__module = tmp_assign_source_71;
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_72;
            PyObject *tmp_import_name_from_37;
            CHECK_OBJECT( tmp_import_from_9__module );
            tmp_import_name_from_37 = tmp_import_from_9__module;
            tmp_assign_source_72 = IMPORT_NAME( tmp_import_name_from_37, const_str_plain_enum_certificates );
            if ( tmp_assign_source_72 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 169;

                goto try_except_handler_19;
            }
            UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_enum_certificates, tmp_assign_source_72 );
        }
        {
            PyObject *tmp_assign_source_73;
            PyObject *tmp_import_name_from_38;
            CHECK_OBJECT( tmp_import_from_9__module );
            tmp_import_name_from_38 = tmp_import_from_9__module;
            tmp_assign_source_73 = IMPORT_NAME( tmp_import_name_from_38, const_str_plain_enum_crls );
            if ( tmp_assign_source_73 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 169;

                goto try_except_handler_19;
            }
            UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_enum_crls, tmp_assign_source_73 );
        }
        goto try_end_15;
        // Exception handler code:
        try_except_handler_19:;
        exception_keeper_type_19 = exception_type;
        exception_keeper_value_19 = exception_value;
        exception_keeper_tb_19 = exception_tb;
        exception_keeper_lineno_19 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_import_from_9__module );
        Py_DECREF( tmp_import_from_9__module );
        tmp_import_from_9__module = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_19;
        exception_value = exception_keeper_value_19;
        exception_tb = exception_keeper_tb_19;
        exception_lineno = exception_keeper_lineno_19;

        goto frame_exception_exit_1;
        // End of try:
        try_end_15:;
        CHECK_OBJECT( (PyObject *)tmp_import_from_9__module );
        Py_DECREF( tmp_import_from_9__module );
        tmp_import_from_9__module = NULL;

        branch_no_6:;
    }
    {
        PyObject *tmp_assign_source_74;
        PyObject *tmp_name_name_15;
        PyObject *tmp_globals_name_15;
        PyObject *tmp_locals_name_15;
        PyObject *tmp_fromlist_name_15;
        PyObject *tmp_level_name_15;
        tmp_name_name_15 = const_str_plain_socket;
        tmp_globals_name_15 = (PyObject *)moduledict_ssl;
        tmp_locals_name_15 = Py_None;
        tmp_fromlist_name_15 = const_tuple_fc7bac9f346b6c5e0ab564aacc7d281d_tuple;
        tmp_level_name_15 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 171;
        tmp_assign_source_74 = IMPORT_MODULE5( tmp_name_name_15, tmp_globals_name_15, tmp_locals_name_15, tmp_fromlist_name_15, tmp_level_name_15 );
        if ( tmp_assign_source_74 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 171;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_10__module == NULL );
        tmp_import_from_10__module = tmp_assign_source_74;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_75;
        PyObject *tmp_import_name_from_39;
        CHECK_OBJECT( tmp_import_from_10__module );
        tmp_import_name_from_39 = tmp_import_from_10__module;
        tmp_assign_source_75 = IMPORT_NAME( tmp_import_name_from_39, const_str_plain_socket );
        if ( tmp_assign_source_75 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 171;

            goto try_except_handler_20;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_socket, tmp_assign_source_75 );
    }
    {
        PyObject *tmp_assign_source_76;
        PyObject *tmp_import_name_from_40;
        CHECK_OBJECT( tmp_import_from_10__module );
        tmp_import_name_from_40 = tmp_import_from_10__module;
        tmp_assign_source_76 = IMPORT_NAME( tmp_import_name_from_40, const_str_plain_AF_INET );
        if ( tmp_assign_source_76 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 171;

            goto try_except_handler_20;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_AF_INET, tmp_assign_source_76 );
    }
    {
        PyObject *tmp_assign_source_77;
        PyObject *tmp_import_name_from_41;
        CHECK_OBJECT( tmp_import_from_10__module );
        tmp_import_name_from_41 = tmp_import_from_10__module;
        tmp_assign_source_77 = IMPORT_NAME( tmp_import_name_from_41, const_str_plain_SOCK_STREAM );
        if ( tmp_assign_source_77 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 171;

            goto try_except_handler_20;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SOCK_STREAM, tmp_assign_source_77 );
    }
    {
        PyObject *tmp_assign_source_78;
        PyObject *tmp_import_name_from_42;
        CHECK_OBJECT( tmp_import_from_10__module );
        tmp_import_name_from_42 = tmp_import_from_10__module;
        tmp_assign_source_78 = IMPORT_NAME( tmp_import_name_from_42, const_str_plain_create_connection );
        if ( tmp_assign_source_78 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 171;

            goto try_except_handler_20;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_create_connection, tmp_assign_source_78 );
    }
    goto try_end_16;
    // Exception handler code:
    try_except_handler_20:;
    exception_keeper_type_20 = exception_type;
    exception_keeper_value_20 = exception_value;
    exception_keeper_tb_20 = exception_tb;
    exception_keeper_lineno_20 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_10__module );
    Py_DECREF( tmp_import_from_10__module );
    tmp_import_from_10__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_20;
    exception_value = exception_keeper_value_20;
    exception_tb = exception_keeper_tb_20;
    exception_lineno = exception_keeper_lineno_20;

    goto frame_exception_exit_1;
    // End of try:
    try_end_16:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_10__module );
    Py_DECREF( tmp_import_from_10__module );
    tmp_import_from_10__module = NULL;

    {
        PyObject *tmp_assign_source_79;
        PyObject *tmp_name_name_16;
        PyObject *tmp_globals_name_16;
        PyObject *tmp_locals_name_16;
        PyObject *tmp_fromlist_name_16;
        PyObject *tmp_level_name_16;
        tmp_name_name_16 = const_str_plain_socket;
        tmp_globals_name_16 = (PyObject *)moduledict_ssl;
        tmp_locals_name_16 = Py_None;
        tmp_fromlist_name_16 = const_tuple_str_plain_SOL_SOCKET_str_plain_SO_TYPE_tuple;
        tmp_level_name_16 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 172;
        tmp_assign_source_79 = IMPORT_MODULE5( tmp_name_name_16, tmp_globals_name_16, tmp_locals_name_16, tmp_fromlist_name_16, tmp_level_name_16 );
        if ( tmp_assign_source_79 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 172;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_11__module == NULL );
        tmp_import_from_11__module = tmp_assign_source_79;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_80;
        PyObject *tmp_import_name_from_43;
        CHECK_OBJECT( tmp_import_from_11__module );
        tmp_import_name_from_43 = tmp_import_from_11__module;
        tmp_assign_source_80 = IMPORT_NAME( tmp_import_name_from_43, const_str_plain_SOL_SOCKET );
        if ( tmp_assign_source_80 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 172;

            goto try_except_handler_21;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SOL_SOCKET, tmp_assign_source_80 );
    }
    {
        PyObject *tmp_assign_source_81;
        PyObject *tmp_import_name_from_44;
        CHECK_OBJECT( tmp_import_from_11__module );
        tmp_import_name_from_44 = tmp_import_from_11__module;
        tmp_assign_source_81 = IMPORT_NAME( tmp_import_name_from_44, const_str_plain_SO_TYPE );
        if ( tmp_assign_source_81 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 172;

            goto try_except_handler_21;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SO_TYPE, tmp_assign_source_81 );
    }
    goto try_end_17;
    // Exception handler code:
    try_except_handler_21:;
    exception_keeper_type_21 = exception_type;
    exception_keeper_value_21 = exception_value;
    exception_keeper_tb_21 = exception_tb;
    exception_keeper_lineno_21 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_11__module );
    Py_DECREF( tmp_import_from_11__module );
    tmp_import_from_11__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_21;
    exception_value = exception_keeper_value_21;
    exception_tb = exception_keeper_tb_21;
    exception_lineno = exception_keeper_lineno_21;

    goto frame_exception_exit_1;
    // End of try:
    try_end_17:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_11__module );
    Py_DECREF( tmp_import_from_11__module );
    tmp_import_from_11__module = NULL;

    {
        PyObject *tmp_assign_source_82;
        PyObject *tmp_name_name_17;
        PyObject *tmp_globals_name_17;
        PyObject *tmp_locals_name_17;
        PyObject *tmp_fromlist_name_17;
        PyObject *tmp_level_name_17;
        tmp_name_name_17 = const_str_plain_socket;
        tmp_globals_name_17 = (PyObject *)moduledict_ssl;
        tmp_locals_name_17 = Py_None;
        tmp_fromlist_name_17 = Py_None;
        tmp_level_name_17 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 173;
        tmp_assign_source_82 = IMPORT_MODULE5( tmp_name_name_17, tmp_globals_name_17, tmp_locals_name_17, tmp_fromlist_name_17, tmp_level_name_17 );
        if ( tmp_assign_source_82 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 173;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__socket, tmp_assign_source_82 );
    }
    {
        PyObject *tmp_assign_source_83;
        PyObject *tmp_name_name_18;
        PyObject *tmp_globals_name_18;
        PyObject *tmp_locals_name_18;
        PyObject *tmp_fromlist_name_18;
        PyObject *tmp_level_name_18;
        tmp_name_name_18 = const_str_plain_base64;
        tmp_globals_name_18 = (PyObject *)moduledict_ssl;
        tmp_locals_name_18 = Py_None;
        tmp_fromlist_name_18 = Py_None;
        tmp_level_name_18 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 174;
        tmp_assign_source_83 = IMPORT_MODULE5( tmp_name_name_18, tmp_globals_name_18, tmp_locals_name_18, tmp_fromlist_name_18, tmp_level_name_18 );
        if ( tmp_assign_source_83 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 174;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_base64, tmp_assign_source_83 );
    }
    {
        PyObject *tmp_assign_source_84;
        PyObject *tmp_name_name_19;
        PyObject *tmp_globals_name_19;
        PyObject *tmp_locals_name_19;
        PyObject *tmp_fromlist_name_19;
        PyObject *tmp_level_name_19;
        tmp_name_name_19 = const_str_plain_errno;
        tmp_globals_name_19 = (PyObject *)moduledict_ssl;
        tmp_locals_name_19 = Py_None;
        tmp_fromlist_name_19 = Py_None;
        tmp_level_name_19 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 175;
        tmp_assign_source_84 = IMPORT_MODULE5( tmp_name_name_19, tmp_globals_name_19, tmp_locals_name_19, tmp_fromlist_name_19, tmp_level_name_19 );
        assert( !(tmp_assign_source_84 == NULL) );
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_errno, tmp_assign_source_84 );
    }
    {
        PyObject *tmp_assign_source_85;
        PyObject *tmp_name_name_20;
        PyObject *tmp_globals_name_20;
        PyObject *tmp_locals_name_20;
        PyObject *tmp_fromlist_name_20;
        PyObject *tmp_level_name_20;
        tmp_name_name_20 = const_str_plain_warnings;
        tmp_globals_name_20 = (PyObject *)moduledict_ssl;
        tmp_locals_name_20 = Py_None;
        tmp_fromlist_name_20 = Py_None;
        tmp_level_name_20 = const_int_0;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 176;
        tmp_assign_source_85 = IMPORT_MODULE5( tmp_name_name_20, tmp_globals_name_20, tmp_locals_name_20, tmp_fromlist_name_20, tmp_level_name_20 );
        if ( tmp_assign_source_85 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 176;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_warnings, tmp_assign_source_85 );
    }
    {
        PyObject *tmp_assign_source_86;
        tmp_assign_source_86 = PyExc_OSError;
        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_socket_error, tmp_assign_source_86 );
    }
    {
        PyObject *tmp_assign_source_87;
        tmp_assign_source_87 = LIST_COPY( const_list_str_digest_554140970ff737b96d003bcbb3246411_list );
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CHANNEL_BINDING_TYPES, tmp_assign_source_87 );
    }
    {
        PyObject *tmp_assign_source_88;
        PyObject *tmp_source_name_21;
        PyObject *tmp_mvar_value_28;
        PyObject *tmp_attribute_name_1;
        tmp_mvar_value_28 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

        if (unlikely( tmp_mvar_value_28 == NULL ))
        {
            tmp_mvar_value_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
        }

        if ( tmp_mvar_value_28 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 183;

            goto frame_exception_exit_1;
        }

        tmp_source_name_21 = tmp_mvar_value_28;
        tmp_attribute_name_1 = const_str_plain_HOSTFLAG_NEVER_CHECK_SUBJECT;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_21, tmp_attribute_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 183;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_88 = ( tmp_res != 0 ) ? Py_True : Py_False;
        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_HAS_NEVER_CHECK_COMMON_NAME, tmp_assign_source_88 );
    }
    {
        PyObject *tmp_assign_source_89;
        PyObject *tmp_mvar_value_29;
        tmp_mvar_value_29 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__DEFAULT_CIPHERS );

        if (unlikely( tmp_mvar_value_29 == NULL ))
        {
            tmp_mvar_value_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__DEFAULT_CIPHERS );
        }

        if ( tmp_mvar_value_29 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_DEFAULT_CIPHERS" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 186;

            goto frame_exception_exit_1;
        }

        tmp_assign_source_89 = tmp_mvar_value_29;
        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__RESTRICTED_SERVER_CIPHERS, tmp_assign_source_89 );
    }
    {
        PyObject *tmp_assign_source_90;
        PyObject *tmp_mvar_value_30;
        tmp_mvar_value_30 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLCertVerificationError );

        if (unlikely( tmp_mvar_value_30 == NULL ))
        {
            tmp_mvar_value_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLCertVerificationError );
        }

        if ( tmp_mvar_value_30 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLCertVerificationError" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 188;

            goto frame_exception_exit_1;
        }

        tmp_assign_source_90 = tmp_mvar_value_30;
        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CertificateError, tmp_assign_source_90 );
    }
    {
        PyObject *tmp_assign_source_91;
        tmp_assign_source_91 = MAKE_FUNCTION_ssl$$$function_7__dnsname_match(  );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__dnsname_match, tmp_assign_source_91 );
    }
    {
        PyObject *tmp_assign_source_92;
        tmp_assign_source_92 = MAKE_FUNCTION_ssl$$$function_8__inet_paton(  );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__inet_paton, tmp_assign_source_92 );
    }
    {
        PyObject *tmp_assign_source_93;
        tmp_assign_source_93 = MAKE_FUNCTION_ssl$$$function_9__ipaddress_match(  );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ipaddress_match, tmp_assign_source_93 );
    }
    {
        PyObject *tmp_assign_source_94;
        tmp_assign_source_94 = MAKE_FUNCTION_ssl$$$function_10_match_hostname(  );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_match_hostname, tmp_assign_source_94 );
    }
    {
        PyObject *tmp_assign_source_95;
        PyObject *tmp_called_name_9;
        PyObject *tmp_mvar_value_31;
        tmp_mvar_value_31 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_namedtuple );

        if (unlikely( tmp_mvar_value_31 == NULL ))
        {
            tmp_mvar_value_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_namedtuple );
        }

        if ( tmp_mvar_value_31 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "namedtuple" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 333;

            goto frame_exception_exit_1;
        }

        tmp_called_name_9 = tmp_mvar_value_31;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 333;
        tmp_assign_source_95 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_9, &PyTuple_GET_ITEM( const_tuple_9007a0386d0b02e640600397a1fbac86_tuple, 0 ) );

        if ( tmp_assign_source_95 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 333;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_DefaultVerifyPaths, tmp_assign_source_95 );
    }
    {
        PyObject *tmp_assign_source_96;
        tmp_assign_source_96 = MAKE_FUNCTION_ssl$$$function_11_get_default_verify_paths(  );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_get_default_verify_paths, tmp_assign_source_96 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_97;
        PyObject *tmp_tuple_element_11;
        PyObject *tmp_called_name_10;
        PyObject *tmp_mvar_value_32;
        tmp_mvar_value_32 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_namedtuple );

        if (unlikely( tmp_mvar_value_32 == NULL ))
        {
            tmp_mvar_value_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_namedtuple );
        }

        if ( tmp_mvar_value_32 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "namedtuple" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 351;

            goto try_except_handler_22;
        }

        tmp_called_name_10 = tmp_mvar_value_32;
        frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 351;
        tmp_tuple_element_11 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_10, &PyTuple_GET_ITEM( const_tuple_39aff8525553a45d78a58dd13ef2a06a_tuple, 0 ) );

        if ( tmp_tuple_element_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_22;
        }
        tmp_assign_source_97 = PyTuple_New( 1 );
        PyTuple_SET_ITEM( tmp_assign_source_97, 0, tmp_tuple_element_11 );
        assert( tmp_class_creation_2__bases_orig == NULL );
        tmp_class_creation_2__bases_orig = tmp_assign_source_97;
    }
    {
        PyObject *tmp_assign_source_98;
        PyObject *tmp_dircall_arg1_2;
        CHECK_OBJECT( tmp_class_creation_2__bases_orig );
        tmp_dircall_arg1_2 = tmp_class_creation_2__bases_orig;
        Py_INCREF( tmp_dircall_arg1_2 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_2};
            tmp_assign_source_98 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_98 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_22;
        }
        assert( tmp_class_creation_2__bases == NULL );
        tmp_class_creation_2__bases = tmp_assign_source_98;
    }
    {
        PyObject *tmp_assign_source_99;
        tmp_assign_source_99 = PyDict_New();
        assert( tmp_class_creation_2__class_decl_dict == NULL );
        tmp_class_creation_2__class_decl_dict = tmp_assign_source_99;
    }
    {
        PyObject *tmp_assign_source_100;
        PyObject *tmp_metaclass_name_2;
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_key_name_4;
        PyObject *tmp_dict_name_4;
        PyObject *tmp_dict_name_5;
        PyObject *tmp_key_name_5;
        nuitka_bool tmp_condition_result_10;
        int tmp_truth_name_2;
        PyObject *tmp_type_arg_3;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_bases_name_2;
        tmp_key_name_4 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_2__class_decl_dict );
        tmp_dict_name_4 = tmp_class_creation_2__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_4, tmp_key_name_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_22;
        }
        tmp_condition_result_9 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_3;
        }
        else
        {
            goto condexpr_false_3;
        }
        condexpr_true_3:;
        CHECK_OBJECT( tmp_class_creation_2__class_decl_dict );
        tmp_dict_name_5 = tmp_class_creation_2__class_decl_dict;
        tmp_key_name_5 = const_str_plain_metaclass;
        tmp_metaclass_name_2 = DICT_GET_ITEM( tmp_dict_name_5, tmp_key_name_5 );
        if ( tmp_metaclass_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_22;
        }
        goto condexpr_end_3;
        condexpr_false_3:;
        CHECK_OBJECT( tmp_class_creation_2__bases );
        tmp_truth_name_2 = CHECK_IF_TRUE( tmp_class_creation_2__bases );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_22;
        }
        tmp_condition_result_10 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_4;
        }
        else
        {
            goto condexpr_false_4;
        }
        condexpr_true_4:;
        CHECK_OBJECT( tmp_class_creation_2__bases );
        tmp_subscribed_name_2 = tmp_class_creation_2__bases;
        tmp_subscript_name_2 = const_int_0;
        tmp_type_arg_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
        if ( tmp_type_arg_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_22;
        }
        tmp_metaclass_name_2 = BUILTIN_TYPE1( tmp_type_arg_3 );
        Py_DECREF( tmp_type_arg_3 );
        if ( tmp_metaclass_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_22;
        }
        goto condexpr_end_4;
        condexpr_false_4:;
        tmp_metaclass_name_2 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_2 );
        condexpr_end_4:;
        condexpr_end_3:;
        CHECK_OBJECT( tmp_class_creation_2__bases );
        tmp_bases_name_2 = tmp_class_creation_2__bases;
        tmp_assign_source_100 = SELECT_METACLASS( tmp_metaclass_name_2, tmp_bases_name_2 );
        Py_DECREF( tmp_metaclass_name_2 );
        if ( tmp_assign_source_100 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_22;
        }
        assert( tmp_class_creation_2__metaclass == NULL );
        tmp_class_creation_2__metaclass = tmp_assign_source_100;
    }
    {
        nuitka_bool tmp_condition_result_11;
        PyObject *tmp_key_name_6;
        PyObject *tmp_dict_name_6;
        tmp_key_name_6 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_2__class_decl_dict );
        tmp_dict_name_6 = tmp_class_creation_2__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_6, tmp_key_name_6 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_22;
        }
        tmp_condition_result_11 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        CHECK_OBJECT( tmp_class_creation_2__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_2__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_22;
        }
        branch_no_7:;
    }
    {
        nuitka_bool tmp_condition_result_12;
        PyObject *tmp_source_name_22;
        CHECK_OBJECT( tmp_class_creation_2__metaclass );
        tmp_source_name_22 = tmp_class_creation_2__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_22, const_str_plain___prepare__ );
        tmp_condition_result_12 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_12 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_8;
        }
        else
        {
            goto branch_no_8;
        }
        branch_yes_8:;
        {
            PyObject *tmp_assign_source_101;
            PyObject *tmp_called_name_11;
            PyObject *tmp_source_name_23;
            PyObject *tmp_args_name_9;
            PyObject *tmp_tuple_element_12;
            PyObject *tmp_kw_name_9;
            CHECK_OBJECT( tmp_class_creation_2__metaclass );
            tmp_source_name_23 = tmp_class_creation_2__metaclass;
            tmp_called_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain___prepare__ );
            if ( tmp_called_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 351;

                goto try_except_handler_22;
            }
            tmp_tuple_element_12 = const_str_plain__ASN1Object;
            tmp_args_name_9 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_12 );
            PyTuple_SET_ITEM( tmp_args_name_9, 0, tmp_tuple_element_12 );
            CHECK_OBJECT( tmp_class_creation_2__bases );
            tmp_tuple_element_12 = tmp_class_creation_2__bases;
            Py_INCREF( tmp_tuple_element_12 );
            PyTuple_SET_ITEM( tmp_args_name_9, 1, tmp_tuple_element_12 );
            CHECK_OBJECT( tmp_class_creation_2__class_decl_dict );
            tmp_kw_name_9 = tmp_class_creation_2__class_decl_dict;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 351;
            tmp_assign_source_101 = CALL_FUNCTION( tmp_called_name_11, tmp_args_name_9, tmp_kw_name_9 );
            Py_DECREF( tmp_called_name_11 );
            Py_DECREF( tmp_args_name_9 );
            if ( tmp_assign_source_101 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 351;

                goto try_except_handler_22;
            }
            assert( tmp_class_creation_2__prepared == NULL );
            tmp_class_creation_2__prepared = tmp_assign_source_101;
        }
        {
            nuitka_bool tmp_condition_result_13;
            PyObject *tmp_operand_name_3;
            PyObject *tmp_source_name_24;
            CHECK_OBJECT( tmp_class_creation_2__prepared );
            tmp_source_name_24 = tmp_class_creation_2__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_24, const_str_plain___getitem__ );
            tmp_operand_name_3 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 351;

                goto try_except_handler_22;
            }
            tmp_condition_result_13 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_13 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_9;
            }
            else
            {
                goto branch_no_9;
            }
            branch_yes_9:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_raise_value_2;
                PyObject *tmp_left_name_2;
                PyObject *tmp_right_name_2;
                PyObject *tmp_tuple_element_13;
                PyObject *tmp_getattr_target_3;
                PyObject *tmp_getattr_attr_3;
                PyObject *tmp_getattr_default_3;
                PyObject *tmp_source_name_25;
                PyObject *tmp_type_arg_4;
                tmp_raise_type_2 = PyExc_TypeError;
                tmp_left_name_2 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_2__metaclass );
                tmp_getattr_target_3 = tmp_class_creation_2__metaclass;
                tmp_getattr_attr_3 = const_str_plain___name__;
                tmp_getattr_default_3 = const_str_angle_metaclass;
                tmp_tuple_element_13 = BUILTIN_GETATTR( tmp_getattr_target_3, tmp_getattr_attr_3, tmp_getattr_default_3 );
                if ( tmp_tuple_element_13 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 351;

                    goto try_except_handler_22;
                }
                tmp_right_name_2 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_13 );
                CHECK_OBJECT( tmp_class_creation_2__prepared );
                tmp_type_arg_4 = tmp_class_creation_2__prepared;
                tmp_source_name_25 = BUILTIN_TYPE1( tmp_type_arg_4 );
                assert( !(tmp_source_name_25 == NULL) );
                tmp_tuple_element_13 = LOOKUP_ATTRIBUTE( tmp_source_name_25, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_25 );
                if ( tmp_tuple_element_13 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_2 );

                    exception_lineno = 351;

                    goto try_except_handler_22;
                }
                PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_13 );
                tmp_raise_value_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
                Py_DECREF( tmp_right_name_2 );
                if ( tmp_raise_value_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 351;

                    goto try_except_handler_22;
                }
                exception_type = tmp_raise_type_2;
                Py_INCREF( tmp_raise_type_2 );
                exception_value = tmp_raise_value_2;
                exception_lineno = 351;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_22;
            }
            branch_no_9:;
        }
        goto branch_end_8;
        branch_no_8:;
        {
            PyObject *tmp_assign_source_102;
            tmp_assign_source_102 = PyDict_New();
            assert( tmp_class_creation_2__prepared == NULL );
            tmp_class_creation_2__prepared = tmp_assign_source_102;
        }
        branch_end_8:;
    }
    {
        PyObject *tmp_assign_source_103;
        {
            PyObject *tmp_set_locals_2;
            CHECK_OBJECT( tmp_class_creation_2__prepared );
            tmp_set_locals_2 = tmp_class_creation_2__prepared;
            locals_ssl_351 = tmp_set_locals_2;
            Py_INCREF( tmp_set_locals_2 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_ssl;
        tmp_res = PyObject_SetItem( locals_ssl_351, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_24;
        }
        tmp_dictset_value = const_str_digest_180e88c045483f282cc9d36d7ae789f2;
        tmp_res = PyObject_SetItem( locals_ssl_351, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_24;
        }
        tmp_dictset_value = const_str_plain__ASN1Object;
        tmp_res = PyObject_SetItem( locals_ssl_351, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;

            goto try_except_handler_24;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_032aecff3336d18805e71dad2af1bc06_4, codeobj_032aecff3336d18805e71dad2af1bc06, module_ssl, sizeof(void *) );
        frame_032aecff3336d18805e71dad2af1bc06_4 = cache_frame_032aecff3336d18805e71dad2af1bc06_4;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_032aecff3336d18805e71dad2af1bc06_4 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_032aecff3336d18805e71dad2af1bc06_4 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = const_tuple_empty;
        tmp_res = PyObject_SetItem( locals_ssl_351, const_str_plain___slots__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 354;
            type_description_2 = "c";
            goto frame_exception_exit_4;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_12___new__(  );

        ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_2_var___class__;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


        tmp_res = PyObject_SetItem( locals_ssl_351, const_str_plain___new__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 356;
            type_description_2 = "c";
            goto frame_exception_exit_4;
        }
        {
            nuitka_bool tmp_condition_result_14;
            PyObject *tmp_called_name_12;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_classmethod_arg_1;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_351, const_str_plain_classmethod );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 359;
                type_description_2 = "c";
                goto frame_exception_exit_4;
            }
            tmp_condition_result_14 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_14 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_5;
            }
            else
            {
                goto condexpr_false_5;
            }
            condexpr_true_5:;
            tmp_called_name_12 = PyObject_GetItem( locals_ssl_351, const_str_plain_classmethod );

            if ( tmp_called_name_12 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "classmethod" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 359;
                type_description_2 = "c";
                goto frame_exception_exit_4;
            }

            if ( tmp_called_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 359;
                type_description_2 = "c";
                goto frame_exception_exit_4;
            }
            tmp_args_element_name_1 = MAKE_FUNCTION_ssl$$$function_13_fromnid(  );

            ((struct Nuitka_FunctionObject *)tmp_args_element_name_1)->m_closure[0] = outline_2_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_1)->m_closure[0] );


            frame_032aecff3336d18805e71dad2af1bc06_4->m_frame.f_lineno = 359;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, call_args );
            }

            Py_DECREF( tmp_called_name_12 );
            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 359;
                type_description_2 = "c";
                goto frame_exception_exit_4;
            }
            goto condexpr_end_5;
            condexpr_false_5:;
            tmp_classmethod_arg_1 = MAKE_FUNCTION_ssl$$$function_13_fromnid(  );

            ((struct Nuitka_FunctionObject *)tmp_classmethod_arg_1)->m_closure[0] = outline_2_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_classmethod_arg_1)->m_closure[0] );


            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_1 );
            Py_DECREF( tmp_classmethod_arg_1 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 359;
                type_description_2 = "c";
                goto frame_exception_exit_4;
            }
            condexpr_end_5:;
            tmp_res = PyObject_SetItem( locals_ssl_351, const_str_plain_fromnid, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 359;
                type_description_2 = "c";
                goto frame_exception_exit_4;
            }
        }
        {
            nuitka_bool tmp_condition_result_15;
            PyObject *tmp_called_name_13;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_classmethod_arg_2;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_351, const_str_plain_classmethod );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 365;
                type_description_2 = "c";
                goto frame_exception_exit_4;
            }
            tmp_condition_result_15 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_15 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_6;
            }
            else
            {
                goto condexpr_false_6;
            }
            condexpr_true_6:;
            tmp_called_name_13 = PyObject_GetItem( locals_ssl_351, const_str_plain_classmethod );

            if ( tmp_called_name_13 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "classmethod" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 365;
                type_description_2 = "c";
                goto frame_exception_exit_4;
            }

            if ( tmp_called_name_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 365;
                type_description_2 = "c";
                goto frame_exception_exit_4;
            }
            tmp_args_element_name_2 = MAKE_FUNCTION_ssl$$$function_14_fromname(  );

            ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = outline_2_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] );


            frame_032aecff3336d18805e71dad2af1bc06_4->m_frame.f_lineno = 365;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
            }

            Py_DECREF( tmp_called_name_13 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 365;
                type_description_2 = "c";
                goto frame_exception_exit_4;
            }
            goto condexpr_end_6;
            condexpr_false_6:;
            tmp_classmethod_arg_2 = MAKE_FUNCTION_ssl$$$function_14_fromname(  );

            ((struct Nuitka_FunctionObject *)tmp_classmethod_arg_2)->m_closure[0] = outline_2_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_classmethod_arg_2)->m_closure[0] );


            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_2 );
            Py_DECREF( tmp_classmethod_arg_2 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 365;
                type_description_2 = "c";
                goto frame_exception_exit_4;
            }
            condexpr_end_6:;
            tmp_res = PyObject_SetItem( locals_ssl_351, const_str_plain_fromname, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 365;
                type_description_2 = "c";
                goto frame_exception_exit_4;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_032aecff3336d18805e71dad2af1bc06_4 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_3;

        frame_exception_exit_4:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_032aecff3336d18805e71dad2af1bc06_4 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_032aecff3336d18805e71dad2af1bc06_4, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_032aecff3336d18805e71dad2af1bc06_4->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_032aecff3336d18805e71dad2af1bc06_4, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_032aecff3336d18805e71dad2af1bc06_4,
            type_description_2,
            outline_2_var___class__
        );


        // Release cached frame.
        if ( frame_032aecff3336d18805e71dad2af1bc06_4 == cache_frame_032aecff3336d18805e71dad2af1bc06_4 )
        {
            Py_DECREF( frame_032aecff3336d18805e71dad2af1bc06_4 );
        }
        cache_frame_032aecff3336d18805e71dad2af1bc06_4 = NULL;

        assertFrameObject( frame_032aecff3336d18805e71dad2af1bc06_4 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_3;

        frame_no_exception_3:;
        goto skip_nested_handling_3;
        nested_frame_exit_3:;

        goto try_except_handler_24;
        skip_nested_handling_3:;
        {
            nuitka_bool tmp_condition_result_16;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            CHECK_OBJECT( tmp_class_creation_2__bases );
            tmp_compexpr_left_4 = tmp_class_creation_2__bases;
            CHECK_OBJECT( tmp_class_creation_2__bases_orig );
            tmp_compexpr_right_4 = tmp_class_creation_2__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 351;

                goto try_except_handler_24;
            }
            tmp_condition_result_16 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_16 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_10;
            }
            else
            {
                goto branch_no_10;
            }
            branch_yes_10:;
            CHECK_OBJECT( tmp_class_creation_2__bases_orig );
            tmp_dictset_value = tmp_class_creation_2__bases_orig;
            tmp_res = PyObject_SetItem( locals_ssl_351, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 351;

                goto try_except_handler_24;
            }
            branch_no_10:;
        }
        {
            PyObject *tmp_assign_source_104;
            PyObject *tmp_called_name_14;
            PyObject *tmp_args_name_10;
            PyObject *tmp_tuple_element_14;
            PyObject *tmp_kw_name_10;
            CHECK_OBJECT( tmp_class_creation_2__metaclass );
            tmp_called_name_14 = tmp_class_creation_2__metaclass;
            tmp_tuple_element_14 = const_str_plain__ASN1Object;
            tmp_args_name_10 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_14 );
            PyTuple_SET_ITEM( tmp_args_name_10, 0, tmp_tuple_element_14 );
            CHECK_OBJECT( tmp_class_creation_2__bases );
            tmp_tuple_element_14 = tmp_class_creation_2__bases;
            Py_INCREF( tmp_tuple_element_14 );
            PyTuple_SET_ITEM( tmp_args_name_10, 1, tmp_tuple_element_14 );
            tmp_tuple_element_14 = locals_ssl_351;
            Py_INCREF( tmp_tuple_element_14 );
            PyTuple_SET_ITEM( tmp_args_name_10, 2, tmp_tuple_element_14 );
            CHECK_OBJECT( tmp_class_creation_2__class_decl_dict );
            tmp_kw_name_10 = tmp_class_creation_2__class_decl_dict;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 351;
            tmp_assign_source_104 = CALL_FUNCTION( tmp_called_name_14, tmp_args_name_10, tmp_kw_name_10 );
            Py_DECREF( tmp_args_name_10 );
            if ( tmp_assign_source_104 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 351;

                goto try_except_handler_24;
            }
            {
                PyObject *old = PyCell_GET( outline_2_var___class__ );
                PyCell_SET( outline_2_var___class__, tmp_assign_source_104 );
                Py_XDECREF( old );
            }

        }
        CHECK_OBJECT( PyCell_GET( outline_2_var___class__ ) );
        tmp_assign_source_103 = PyCell_GET( outline_2_var___class__ );
        Py_INCREF( tmp_assign_source_103 );
        goto try_return_handler_24;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_24:;
        Py_DECREF( locals_ssl_351 );
        locals_ssl_351 = NULL;
        goto try_return_handler_23;
        // Exception handler code:
        try_except_handler_24:;
        exception_keeper_type_22 = exception_type;
        exception_keeper_value_22 = exception_value;
        exception_keeper_tb_22 = exception_tb;
        exception_keeper_lineno_22 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ssl_351 );
        locals_ssl_351 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_22;
        exception_value = exception_keeper_value_22;
        exception_tb = exception_keeper_tb_22;
        exception_lineno = exception_keeper_lineno_22;

        goto try_except_handler_23;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_23:;
        CHECK_OBJECT( (PyObject *)outline_2_var___class__ );
        Py_DECREF( outline_2_var___class__ );
        outline_2_var___class__ = NULL;

        goto outline_result_3;
        // Exception handler code:
        try_except_handler_23:;
        exception_keeper_type_23 = exception_type;
        exception_keeper_value_23 = exception_value;
        exception_keeper_tb_23 = exception_tb;
        exception_keeper_lineno_23 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)outline_2_var___class__ );
        Py_DECREF( outline_2_var___class__ );
        outline_2_var___class__ = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_23;
        exception_value = exception_keeper_value_23;
        exception_tb = exception_keeper_tb_23;
        exception_lineno = exception_keeper_lineno_23;

        goto outline_exception_3;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_3:;
        exception_lineno = 351;
        goto try_except_handler_22;
        outline_result_3:;
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ASN1Object, tmp_assign_source_103 );
    }
    goto try_end_18;
    // Exception handler code:
    try_except_handler_22:;
    exception_keeper_type_24 = exception_type;
    exception_keeper_value_24 = exception_value;
    exception_keeper_tb_24 = exception_tb;
    exception_keeper_lineno_24 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_2__bases_orig );
    tmp_class_creation_2__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_2__bases );
    tmp_class_creation_2__bases = NULL;

    Py_XDECREF( tmp_class_creation_2__class_decl_dict );
    tmp_class_creation_2__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_2__prepared );
    tmp_class_creation_2__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_24;
    exception_value = exception_keeper_value_24;
    exception_tb = exception_keeper_tb_24;
    exception_lineno = exception_keeper_lineno_24;

    goto frame_exception_exit_1;
    // End of try:
    try_end_18:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__bases_orig );
    Py_DECREF( tmp_class_creation_2__bases_orig );
    tmp_class_creation_2__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__bases );
    Py_DECREF( tmp_class_creation_2__bases );
    tmp_class_creation_2__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_decl_dict );
    Py_DECREF( tmp_class_creation_2__class_decl_dict );
    tmp_class_creation_2__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__prepared );
    Py_DECREF( tmp_class_creation_2__prepared );
    tmp_class_creation_2__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_105;
        PyObject *tmp_tuple_element_15;
        PyObject *tmp_mvar_value_33;
        PyObject *tmp_mvar_value_34;
        tmp_mvar_value_33 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ASN1Object );

        if (unlikely( tmp_mvar_value_33 == NULL ))
        {
            tmp_mvar_value_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ASN1Object );
        }

        if ( tmp_mvar_value_33 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ASN1Object" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 372;

            goto try_except_handler_25;
        }

        tmp_tuple_element_15 = tmp_mvar_value_33;
        tmp_assign_source_105 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_15 );
        PyTuple_SET_ITEM( tmp_assign_source_105, 0, tmp_tuple_element_15 );
        tmp_mvar_value_34 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__Enum );

        if (unlikely( tmp_mvar_value_34 == NULL ))
        {
            tmp_mvar_value_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Enum );
        }

        if ( tmp_mvar_value_34 == NULL )
        {
            Py_DECREF( tmp_assign_source_105 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Enum" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 372;

            goto try_except_handler_25;
        }

        tmp_tuple_element_15 = tmp_mvar_value_34;
        Py_INCREF( tmp_tuple_element_15 );
        PyTuple_SET_ITEM( tmp_assign_source_105, 1, tmp_tuple_element_15 );
        assert( tmp_class_creation_3__bases_orig == NULL );
        tmp_class_creation_3__bases_orig = tmp_assign_source_105;
    }
    {
        PyObject *tmp_assign_source_106;
        PyObject *tmp_dircall_arg1_3;
        CHECK_OBJECT( tmp_class_creation_3__bases_orig );
        tmp_dircall_arg1_3 = tmp_class_creation_3__bases_orig;
        Py_INCREF( tmp_dircall_arg1_3 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_3};
            tmp_assign_source_106 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_106 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 372;

            goto try_except_handler_25;
        }
        assert( tmp_class_creation_3__bases == NULL );
        tmp_class_creation_3__bases = tmp_assign_source_106;
    }
    {
        PyObject *tmp_assign_source_107;
        tmp_assign_source_107 = PyDict_New();
        assert( tmp_class_creation_3__class_decl_dict == NULL );
        tmp_class_creation_3__class_decl_dict = tmp_assign_source_107;
    }
    {
        PyObject *tmp_assign_source_108;
        PyObject *tmp_metaclass_name_3;
        nuitka_bool tmp_condition_result_17;
        PyObject *tmp_key_name_7;
        PyObject *tmp_dict_name_7;
        PyObject *tmp_dict_name_8;
        PyObject *tmp_key_name_8;
        nuitka_bool tmp_condition_result_18;
        int tmp_truth_name_3;
        PyObject *tmp_type_arg_5;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_bases_name_3;
        tmp_key_name_7 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_3__class_decl_dict );
        tmp_dict_name_7 = tmp_class_creation_3__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_7, tmp_key_name_7 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 372;

            goto try_except_handler_25;
        }
        tmp_condition_result_17 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_17 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_7;
        }
        else
        {
            goto condexpr_false_7;
        }
        condexpr_true_7:;
        CHECK_OBJECT( tmp_class_creation_3__class_decl_dict );
        tmp_dict_name_8 = tmp_class_creation_3__class_decl_dict;
        tmp_key_name_8 = const_str_plain_metaclass;
        tmp_metaclass_name_3 = DICT_GET_ITEM( tmp_dict_name_8, tmp_key_name_8 );
        if ( tmp_metaclass_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 372;

            goto try_except_handler_25;
        }
        goto condexpr_end_7;
        condexpr_false_7:;
        CHECK_OBJECT( tmp_class_creation_3__bases );
        tmp_truth_name_3 = CHECK_IF_TRUE( tmp_class_creation_3__bases );
        if ( tmp_truth_name_3 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 372;

            goto try_except_handler_25;
        }
        tmp_condition_result_18 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_18 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_8;
        }
        else
        {
            goto condexpr_false_8;
        }
        condexpr_true_8:;
        CHECK_OBJECT( tmp_class_creation_3__bases );
        tmp_subscribed_name_3 = tmp_class_creation_3__bases;
        tmp_subscript_name_3 = const_int_0;
        tmp_type_arg_5 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
        if ( tmp_type_arg_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 372;

            goto try_except_handler_25;
        }
        tmp_metaclass_name_3 = BUILTIN_TYPE1( tmp_type_arg_5 );
        Py_DECREF( tmp_type_arg_5 );
        if ( tmp_metaclass_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 372;

            goto try_except_handler_25;
        }
        goto condexpr_end_8;
        condexpr_false_8:;
        tmp_metaclass_name_3 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_3 );
        condexpr_end_8:;
        condexpr_end_7:;
        CHECK_OBJECT( tmp_class_creation_3__bases );
        tmp_bases_name_3 = tmp_class_creation_3__bases;
        tmp_assign_source_108 = SELECT_METACLASS( tmp_metaclass_name_3, tmp_bases_name_3 );
        Py_DECREF( tmp_metaclass_name_3 );
        if ( tmp_assign_source_108 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 372;

            goto try_except_handler_25;
        }
        assert( tmp_class_creation_3__metaclass == NULL );
        tmp_class_creation_3__metaclass = tmp_assign_source_108;
    }
    {
        nuitka_bool tmp_condition_result_19;
        PyObject *tmp_key_name_9;
        PyObject *tmp_dict_name_9;
        tmp_key_name_9 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_3__class_decl_dict );
        tmp_dict_name_9 = tmp_class_creation_3__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_9, tmp_key_name_9 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 372;

            goto try_except_handler_25;
        }
        tmp_condition_result_19 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_19 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_11;
        }
        else
        {
            goto branch_no_11;
        }
        branch_yes_11:;
        CHECK_OBJECT( tmp_class_creation_3__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_3__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 372;

            goto try_except_handler_25;
        }
        branch_no_11:;
    }
    {
        nuitka_bool tmp_condition_result_20;
        PyObject *tmp_source_name_26;
        CHECK_OBJECT( tmp_class_creation_3__metaclass );
        tmp_source_name_26 = tmp_class_creation_3__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_26, const_str_plain___prepare__ );
        tmp_condition_result_20 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_20 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_12;
        }
        else
        {
            goto branch_no_12;
        }
        branch_yes_12:;
        {
            PyObject *tmp_assign_source_109;
            PyObject *tmp_called_name_15;
            PyObject *tmp_source_name_27;
            PyObject *tmp_args_name_11;
            PyObject *tmp_tuple_element_16;
            PyObject *tmp_kw_name_11;
            CHECK_OBJECT( tmp_class_creation_3__metaclass );
            tmp_source_name_27 = tmp_class_creation_3__metaclass;
            tmp_called_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_27, const_str_plain___prepare__ );
            if ( tmp_called_name_15 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 372;

                goto try_except_handler_25;
            }
            tmp_tuple_element_16 = const_str_plain_Purpose;
            tmp_args_name_11 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_16 );
            PyTuple_SET_ITEM( tmp_args_name_11, 0, tmp_tuple_element_16 );
            CHECK_OBJECT( tmp_class_creation_3__bases );
            tmp_tuple_element_16 = tmp_class_creation_3__bases;
            Py_INCREF( tmp_tuple_element_16 );
            PyTuple_SET_ITEM( tmp_args_name_11, 1, tmp_tuple_element_16 );
            CHECK_OBJECT( tmp_class_creation_3__class_decl_dict );
            tmp_kw_name_11 = tmp_class_creation_3__class_decl_dict;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 372;
            tmp_assign_source_109 = CALL_FUNCTION( tmp_called_name_15, tmp_args_name_11, tmp_kw_name_11 );
            Py_DECREF( tmp_called_name_15 );
            Py_DECREF( tmp_args_name_11 );
            if ( tmp_assign_source_109 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 372;

                goto try_except_handler_25;
            }
            assert( tmp_class_creation_3__prepared == NULL );
            tmp_class_creation_3__prepared = tmp_assign_source_109;
        }
        {
            nuitka_bool tmp_condition_result_21;
            PyObject *tmp_operand_name_4;
            PyObject *tmp_source_name_28;
            CHECK_OBJECT( tmp_class_creation_3__prepared );
            tmp_source_name_28 = tmp_class_creation_3__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_28, const_str_plain___getitem__ );
            tmp_operand_name_4 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 372;

                goto try_except_handler_25;
            }
            tmp_condition_result_21 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_21 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_13;
            }
            else
            {
                goto branch_no_13;
            }
            branch_yes_13:;
            {
                PyObject *tmp_raise_type_3;
                PyObject *tmp_raise_value_3;
                PyObject *tmp_left_name_3;
                PyObject *tmp_right_name_3;
                PyObject *tmp_tuple_element_17;
                PyObject *tmp_getattr_target_4;
                PyObject *tmp_getattr_attr_4;
                PyObject *tmp_getattr_default_4;
                PyObject *tmp_source_name_29;
                PyObject *tmp_type_arg_6;
                tmp_raise_type_3 = PyExc_TypeError;
                tmp_left_name_3 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_3__metaclass );
                tmp_getattr_target_4 = tmp_class_creation_3__metaclass;
                tmp_getattr_attr_4 = const_str_plain___name__;
                tmp_getattr_default_4 = const_str_angle_metaclass;
                tmp_tuple_element_17 = BUILTIN_GETATTR( tmp_getattr_target_4, tmp_getattr_attr_4, tmp_getattr_default_4 );
                if ( tmp_tuple_element_17 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 372;

                    goto try_except_handler_25;
                }
                tmp_right_name_3 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_3, 0, tmp_tuple_element_17 );
                CHECK_OBJECT( tmp_class_creation_3__prepared );
                tmp_type_arg_6 = tmp_class_creation_3__prepared;
                tmp_source_name_29 = BUILTIN_TYPE1( tmp_type_arg_6 );
                assert( !(tmp_source_name_29 == NULL) );
                tmp_tuple_element_17 = LOOKUP_ATTRIBUTE( tmp_source_name_29, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_29 );
                if ( tmp_tuple_element_17 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_3 );

                    exception_lineno = 372;

                    goto try_except_handler_25;
                }
                PyTuple_SET_ITEM( tmp_right_name_3, 1, tmp_tuple_element_17 );
                tmp_raise_value_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
                Py_DECREF( tmp_right_name_3 );
                if ( tmp_raise_value_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 372;

                    goto try_except_handler_25;
                }
                exception_type = tmp_raise_type_3;
                Py_INCREF( tmp_raise_type_3 );
                exception_value = tmp_raise_value_3;
                exception_lineno = 372;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_25;
            }
            branch_no_13:;
        }
        goto branch_end_12;
        branch_no_12:;
        {
            PyObject *tmp_assign_source_110;
            tmp_assign_source_110 = PyDict_New();
            assert( tmp_class_creation_3__prepared == NULL );
            tmp_class_creation_3__prepared = tmp_assign_source_110;
        }
        branch_end_12:;
    }
    {
        PyObject *tmp_assign_source_111;
        {
            PyObject *tmp_set_locals_3;
            CHECK_OBJECT( tmp_class_creation_3__prepared );
            tmp_set_locals_3 = tmp_class_creation_3__prepared;
            locals_ssl_372 = tmp_set_locals_3;
            Py_INCREF( tmp_set_locals_3 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_ssl;
        tmp_res = PyObject_SetItem( locals_ssl_372, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 372;

            goto try_except_handler_27;
        }
        tmp_dictset_value = const_str_digest_37015d915e90c3fed8a792f94c4aad8d;
        tmp_res = PyObject_SetItem( locals_ssl_372, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 372;

            goto try_except_handler_27;
        }
        tmp_dictset_value = const_str_plain_Purpose;
        tmp_res = PyObject_SetItem( locals_ssl_372, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 372;

            goto try_except_handler_27;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_cbc8eb4c7a80f833eeff58accc81965e_5, codeobj_cbc8eb4c7a80f833eeff58accc81965e, module_ssl, sizeof(void *) );
        frame_cbc8eb4c7a80f833eeff58accc81965e_5 = cache_frame_cbc8eb4c7a80f833eeff58accc81965e_5;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_cbc8eb4c7a80f833eeff58accc81965e_5 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_cbc8eb4c7a80f833eeff58accc81965e_5 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = const_str_digest_0376a15beee26a285b06cab589a6a7cd;
        tmp_res = PyObject_SetItem( locals_ssl_372, const_str_plain_SERVER_AUTH, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 375;
            type_description_2 = "o";
            goto frame_exception_exit_5;
        }
        tmp_dictset_value = const_str_digest_87cdc7b3da2a01efa67fc002f5f9e93d;
        tmp_res = PyObject_SetItem( locals_ssl_372, const_str_plain_CLIENT_AUTH, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 376;
            type_description_2 = "o";
            goto frame_exception_exit_5;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_cbc8eb4c7a80f833eeff58accc81965e_5 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_4;

        frame_exception_exit_5:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_cbc8eb4c7a80f833eeff58accc81965e_5 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_cbc8eb4c7a80f833eeff58accc81965e_5, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_cbc8eb4c7a80f833eeff58accc81965e_5->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_cbc8eb4c7a80f833eeff58accc81965e_5, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_cbc8eb4c7a80f833eeff58accc81965e_5,
            type_description_2,
            outline_3_var___class__
        );


        // Release cached frame.
        if ( frame_cbc8eb4c7a80f833eeff58accc81965e_5 == cache_frame_cbc8eb4c7a80f833eeff58accc81965e_5 )
        {
            Py_DECREF( frame_cbc8eb4c7a80f833eeff58accc81965e_5 );
        }
        cache_frame_cbc8eb4c7a80f833eeff58accc81965e_5 = NULL;

        assertFrameObject( frame_cbc8eb4c7a80f833eeff58accc81965e_5 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_4;

        frame_no_exception_4:;
        goto skip_nested_handling_4;
        nested_frame_exit_4:;

        goto try_except_handler_27;
        skip_nested_handling_4:;
        {
            nuitka_bool tmp_condition_result_22;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            CHECK_OBJECT( tmp_class_creation_3__bases );
            tmp_compexpr_left_5 = tmp_class_creation_3__bases;
            CHECK_OBJECT( tmp_class_creation_3__bases_orig );
            tmp_compexpr_right_5 = tmp_class_creation_3__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 372;

                goto try_except_handler_27;
            }
            tmp_condition_result_22 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_22 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_14;
            }
            else
            {
                goto branch_no_14;
            }
            branch_yes_14:;
            CHECK_OBJECT( tmp_class_creation_3__bases_orig );
            tmp_dictset_value = tmp_class_creation_3__bases_orig;
            tmp_res = PyObject_SetItem( locals_ssl_372, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 372;

                goto try_except_handler_27;
            }
            branch_no_14:;
        }
        {
            PyObject *tmp_assign_source_112;
            PyObject *tmp_called_name_16;
            PyObject *tmp_args_name_12;
            PyObject *tmp_tuple_element_18;
            PyObject *tmp_kw_name_12;
            CHECK_OBJECT( tmp_class_creation_3__metaclass );
            tmp_called_name_16 = tmp_class_creation_3__metaclass;
            tmp_tuple_element_18 = const_str_plain_Purpose;
            tmp_args_name_12 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_18 );
            PyTuple_SET_ITEM( tmp_args_name_12, 0, tmp_tuple_element_18 );
            CHECK_OBJECT( tmp_class_creation_3__bases );
            tmp_tuple_element_18 = tmp_class_creation_3__bases;
            Py_INCREF( tmp_tuple_element_18 );
            PyTuple_SET_ITEM( tmp_args_name_12, 1, tmp_tuple_element_18 );
            tmp_tuple_element_18 = locals_ssl_372;
            Py_INCREF( tmp_tuple_element_18 );
            PyTuple_SET_ITEM( tmp_args_name_12, 2, tmp_tuple_element_18 );
            CHECK_OBJECT( tmp_class_creation_3__class_decl_dict );
            tmp_kw_name_12 = tmp_class_creation_3__class_decl_dict;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 372;
            tmp_assign_source_112 = CALL_FUNCTION( tmp_called_name_16, tmp_args_name_12, tmp_kw_name_12 );
            Py_DECREF( tmp_args_name_12 );
            if ( tmp_assign_source_112 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 372;

                goto try_except_handler_27;
            }
            assert( outline_3_var___class__ == NULL );
            outline_3_var___class__ = tmp_assign_source_112;
        }
        CHECK_OBJECT( outline_3_var___class__ );
        tmp_assign_source_111 = outline_3_var___class__;
        Py_INCREF( tmp_assign_source_111 );
        goto try_return_handler_27;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_27:;
        Py_DECREF( locals_ssl_372 );
        locals_ssl_372 = NULL;
        goto try_return_handler_26;
        // Exception handler code:
        try_except_handler_27:;
        exception_keeper_type_25 = exception_type;
        exception_keeper_value_25 = exception_value;
        exception_keeper_tb_25 = exception_tb;
        exception_keeper_lineno_25 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ssl_372 );
        locals_ssl_372 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_25;
        exception_value = exception_keeper_value_25;
        exception_tb = exception_keeper_tb_25;
        exception_lineno = exception_keeper_lineno_25;

        goto try_except_handler_26;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_26:;
        CHECK_OBJECT( (PyObject *)outline_3_var___class__ );
        Py_DECREF( outline_3_var___class__ );
        outline_3_var___class__ = NULL;

        goto outline_result_4;
        // Exception handler code:
        try_except_handler_26:;
        exception_keeper_type_26 = exception_type;
        exception_keeper_value_26 = exception_value;
        exception_keeper_tb_26 = exception_tb;
        exception_keeper_lineno_26 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_26;
        exception_value = exception_keeper_value_26;
        exception_tb = exception_keeper_tb_26;
        exception_lineno = exception_keeper_lineno_26;

        goto outline_exception_4;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_4:;
        exception_lineno = 372;
        goto try_except_handler_25;
        outline_result_4:;
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_Purpose, tmp_assign_source_111 );
    }
    goto try_end_19;
    // Exception handler code:
    try_except_handler_25:;
    exception_keeper_type_27 = exception_type;
    exception_keeper_value_27 = exception_value;
    exception_keeper_tb_27 = exception_tb;
    exception_keeper_lineno_27 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_3__bases_orig );
    tmp_class_creation_3__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_3__bases );
    tmp_class_creation_3__bases = NULL;

    Py_XDECREF( tmp_class_creation_3__class_decl_dict );
    tmp_class_creation_3__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_3__prepared );
    tmp_class_creation_3__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_27;
    exception_value = exception_keeper_value_27;
    exception_tb = exception_keeper_tb_27;
    exception_lineno = exception_keeper_lineno_27;

    goto frame_exception_exit_1;
    // End of try:
    try_end_19:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__bases_orig );
    Py_DECREF( tmp_class_creation_3__bases_orig );
    tmp_class_creation_3__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__bases );
    Py_DECREF( tmp_class_creation_3__bases );
    tmp_class_creation_3__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_decl_dict );
    Py_DECREF( tmp_class_creation_3__class_decl_dict );
    tmp_class_creation_3__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__metaclass );
    Py_DECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__prepared );
    Py_DECREF( tmp_class_creation_3__prepared );
    tmp_class_creation_3__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_113;
        PyObject *tmp_tuple_element_19;
        PyObject *tmp_mvar_value_35;
        tmp_mvar_value_35 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__SSLContext );

        if (unlikely( tmp_mvar_value_35 == NULL ))
        {
            tmp_mvar_value_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__SSLContext );
        }

        if ( tmp_mvar_value_35 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 379;

            goto try_except_handler_28;
        }

        tmp_tuple_element_19 = tmp_mvar_value_35;
        tmp_assign_source_113 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_19 );
        PyTuple_SET_ITEM( tmp_assign_source_113, 0, tmp_tuple_element_19 );
        assert( tmp_class_creation_4__bases_orig == NULL );
        tmp_class_creation_4__bases_orig = tmp_assign_source_113;
    }
    {
        PyObject *tmp_assign_source_114;
        PyObject *tmp_dircall_arg1_4;
        CHECK_OBJECT( tmp_class_creation_4__bases_orig );
        tmp_dircall_arg1_4 = tmp_class_creation_4__bases_orig;
        Py_INCREF( tmp_dircall_arg1_4 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_4};
            tmp_assign_source_114 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_114 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 379;

            goto try_except_handler_28;
        }
        assert( tmp_class_creation_4__bases == NULL );
        tmp_class_creation_4__bases = tmp_assign_source_114;
    }
    {
        PyObject *tmp_assign_source_115;
        tmp_assign_source_115 = PyDict_New();
        assert( tmp_class_creation_4__class_decl_dict == NULL );
        tmp_class_creation_4__class_decl_dict = tmp_assign_source_115;
    }
    {
        PyObject *tmp_assign_source_116;
        PyObject *tmp_metaclass_name_4;
        nuitka_bool tmp_condition_result_23;
        PyObject *tmp_key_name_10;
        PyObject *tmp_dict_name_10;
        PyObject *tmp_dict_name_11;
        PyObject *tmp_key_name_11;
        nuitka_bool tmp_condition_result_24;
        int tmp_truth_name_4;
        PyObject *tmp_type_arg_7;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_subscript_name_4;
        PyObject *tmp_bases_name_4;
        tmp_key_name_10 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_4__class_decl_dict );
        tmp_dict_name_10 = tmp_class_creation_4__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_10, tmp_key_name_10 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 379;

            goto try_except_handler_28;
        }
        tmp_condition_result_23 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_23 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_9;
        }
        else
        {
            goto condexpr_false_9;
        }
        condexpr_true_9:;
        CHECK_OBJECT( tmp_class_creation_4__class_decl_dict );
        tmp_dict_name_11 = tmp_class_creation_4__class_decl_dict;
        tmp_key_name_11 = const_str_plain_metaclass;
        tmp_metaclass_name_4 = DICT_GET_ITEM( tmp_dict_name_11, tmp_key_name_11 );
        if ( tmp_metaclass_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 379;

            goto try_except_handler_28;
        }
        goto condexpr_end_9;
        condexpr_false_9:;
        CHECK_OBJECT( tmp_class_creation_4__bases );
        tmp_truth_name_4 = CHECK_IF_TRUE( tmp_class_creation_4__bases );
        if ( tmp_truth_name_4 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 379;

            goto try_except_handler_28;
        }
        tmp_condition_result_24 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_24 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_10;
        }
        else
        {
            goto condexpr_false_10;
        }
        condexpr_true_10:;
        CHECK_OBJECT( tmp_class_creation_4__bases );
        tmp_subscribed_name_4 = tmp_class_creation_4__bases;
        tmp_subscript_name_4 = const_int_0;
        tmp_type_arg_7 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 0 );
        if ( tmp_type_arg_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 379;

            goto try_except_handler_28;
        }
        tmp_metaclass_name_4 = BUILTIN_TYPE1( tmp_type_arg_7 );
        Py_DECREF( tmp_type_arg_7 );
        if ( tmp_metaclass_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 379;

            goto try_except_handler_28;
        }
        goto condexpr_end_10;
        condexpr_false_10:;
        tmp_metaclass_name_4 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_4 );
        condexpr_end_10:;
        condexpr_end_9:;
        CHECK_OBJECT( tmp_class_creation_4__bases );
        tmp_bases_name_4 = tmp_class_creation_4__bases;
        tmp_assign_source_116 = SELECT_METACLASS( tmp_metaclass_name_4, tmp_bases_name_4 );
        Py_DECREF( tmp_metaclass_name_4 );
        if ( tmp_assign_source_116 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 379;

            goto try_except_handler_28;
        }
        assert( tmp_class_creation_4__metaclass == NULL );
        tmp_class_creation_4__metaclass = tmp_assign_source_116;
    }
    {
        nuitka_bool tmp_condition_result_25;
        PyObject *tmp_key_name_12;
        PyObject *tmp_dict_name_12;
        tmp_key_name_12 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_4__class_decl_dict );
        tmp_dict_name_12 = tmp_class_creation_4__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_12, tmp_key_name_12 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 379;

            goto try_except_handler_28;
        }
        tmp_condition_result_25 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_25 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_15;
        }
        else
        {
            goto branch_no_15;
        }
        branch_yes_15:;
        CHECK_OBJECT( tmp_class_creation_4__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_4__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 379;

            goto try_except_handler_28;
        }
        branch_no_15:;
    }
    {
        nuitka_bool tmp_condition_result_26;
        PyObject *tmp_source_name_30;
        CHECK_OBJECT( tmp_class_creation_4__metaclass );
        tmp_source_name_30 = tmp_class_creation_4__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_30, const_str_plain___prepare__ );
        tmp_condition_result_26 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_26 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_16;
        }
        else
        {
            goto branch_no_16;
        }
        branch_yes_16:;
        {
            PyObject *tmp_assign_source_117;
            PyObject *tmp_called_name_17;
            PyObject *tmp_source_name_31;
            PyObject *tmp_args_name_13;
            PyObject *tmp_tuple_element_20;
            PyObject *tmp_kw_name_13;
            CHECK_OBJECT( tmp_class_creation_4__metaclass );
            tmp_source_name_31 = tmp_class_creation_4__metaclass;
            tmp_called_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_31, const_str_plain___prepare__ );
            if ( tmp_called_name_17 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 379;

                goto try_except_handler_28;
            }
            tmp_tuple_element_20 = const_str_plain_SSLContext;
            tmp_args_name_13 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_20 );
            PyTuple_SET_ITEM( tmp_args_name_13, 0, tmp_tuple_element_20 );
            CHECK_OBJECT( tmp_class_creation_4__bases );
            tmp_tuple_element_20 = tmp_class_creation_4__bases;
            Py_INCREF( tmp_tuple_element_20 );
            PyTuple_SET_ITEM( tmp_args_name_13, 1, tmp_tuple_element_20 );
            CHECK_OBJECT( tmp_class_creation_4__class_decl_dict );
            tmp_kw_name_13 = tmp_class_creation_4__class_decl_dict;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 379;
            tmp_assign_source_117 = CALL_FUNCTION( tmp_called_name_17, tmp_args_name_13, tmp_kw_name_13 );
            Py_DECREF( tmp_called_name_17 );
            Py_DECREF( tmp_args_name_13 );
            if ( tmp_assign_source_117 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 379;

                goto try_except_handler_28;
            }
            assert( tmp_class_creation_4__prepared == NULL );
            tmp_class_creation_4__prepared = tmp_assign_source_117;
        }
        {
            nuitka_bool tmp_condition_result_27;
            PyObject *tmp_operand_name_5;
            PyObject *tmp_source_name_32;
            CHECK_OBJECT( tmp_class_creation_4__prepared );
            tmp_source_name_32 = tmp_class_creation_4__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_32, const_str_plain___getitem__ );
            tmp_operand_name_5 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 379;

                goto try_except_handler_28;
            }
            tmp_condition_result_27 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_27 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_17;
            }
            else
            {
                goto branch_no_17;
            }
            branch_yes_17:;
            {
                PyObject *tmp_raise_type_4;
                PyObject *tmp_raise_value_4;
                PyObject *tmp_left_name_4;
                PyObject *tmp_right_name_4;
                PyObject *tmp_tuple_element_21;
                PyObject *tmp_getattr_target_5;
                PyObject *tmp_getattr_attr_5;
                PyObject *tmp_getattr_default_5;
                PyObject *tmp_source_name_33;
                PyObject *tmp_type_arg_8;
                tmp_raise_type_4 = PyExc_TypeError;
                tmp_left_name_4 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_4__metaclass );
                tmp_getattr_target_5 = tmp_class_creation_4__metaclass;
                tmp_getattr_attr_5 = const_str_plain___name__;
                tmp_getattr_default_5 = const_str_angle_metaclass;
                tmp_tuple_element_21 = BUILTIN_GETATTR( tmp_getattr_target_5, tmp_getattr_attr_5, tmp_getattr_default_5 );
                if ( tmp_tuple_element_21 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 379;

                    goto try_except_handler_28;
                }
                tmp_right_name_4 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_4, 0, tmp_tuple_element_21 );
                CHECK_OBJECT( tmp_class_creation_4__prepared );
                tmp_type_arg_8 = tmp_class_creation_4__prepared;
                tmp_source_name_33 = BUILTIN_TYPE1( tmp_type_arg_8 );
                assert( !(tmp_source_name_33 == NULL) );
                tmp_tuple_element_21 = LOOKUP_ATTRIBUTE( tmp_source_name_33, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_33 );
                if ( tmp_tuple_element_21 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_4 );

                    exception_lineno = 379;

                    goto try_except_handler_28;
                }
                PyTuple_SET_ITEM( tmp_right_name_4, 1, tmp_tuple_element_21 );
                tmp_raise_value_4 = BINARY_OPERATION_REMAINDER( tmp_left_name_4, tmp_right_name_4 );
                Py_DECREF( tmp_right_name_4 );
                if ( tmp_raise_value_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 379;

                    goto try_except_handler_28;
                }
                exception_type = tmp_raise_type_4;
                Py_INCREF( tmp_raise_type_4 );
                exception_value = tmp_raise_value_4;
                exception_lineno = 379;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_28;
            }
            branch_no_17:;
        }
        goto branch_end_16;
        branch_no_16:;
        {
            PyObject *tmp_assign_source_118;
            tmp_assign_source_118 = PyDict_New();
            assert( tmp_class_creation_4__prepared == NULL );
            tmp_class_creation_4__prepared = tmp_assign_source_118;
        }
        branch_end_16:;
    }
    {
        PyObject *tmp_assign_source_119;
        {
            PyObject *tmp_set_locals_4;
            CHECK_OBJECT( tmp_class_creation_4__prepared );
            tmp_set_locals_4 = tmp_class_creation_4__prepared;
            locals_ssl_379 = tmp_set_locals_4;
            Py_INCREF( tmp_set_locals_4 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_ssl;
        tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 379;

            goto try_except_handler_30;
        }
        tmp_dictset_value = const_str_digest_21bb40eac1bbe9900e4b65be65bdbc0d;
        tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 379;

            goto try_except_handler_30;
        }
        tmp_dictset_value = const_str_plain_SSLContext;
        tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 379;

            goto try_except_handler_30;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_2f3dc3967a43757d07b0bed3cdf75e71_6, codeobj_2f3dc3967a43757d07b0bed3cdf75e71, module_ssl, sizeof(void *) );
        frame_2f3dc3967a43757d07b0bed3cdf75e71_6 = cache_frame_2f3dc3967a43757d07b0bed3cdf75e71_6;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_2f3dc3967a43757d07b0bed3cdf75e71_6 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_2f3dc3967a43757d07b0bed3cdf75e71_6 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = const_tuple_str_plain_CA_str_plain_ROOT_tuple;
        tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain__windows_cert_stores, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 382;
            type_description_2 = "c";
            goto frame_exception_exit_6;
        }
        tmp_dictset_value = Py_None;
        tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_sslsocket_class, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 384;
            type_description_2 = "c";
            goto frame_exception_exit_6;
        }
        tmp_dictset_value = Py_None;
        tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_sslobject_class, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 385;
            type_description_2 = "c";
            goto frame_exception_exit_6;
        }
        {
            PyObject *tmp_defaults_1;
            PyObject *tmp_tuple_element_22;
            PyObject *tmp_mvar_value_36;
            tmp_tuple_element_22 = PyObject_GetItem( locals_ssl_379, const_str_plain_PROTOCOL_TLS );

            if ( tmp_tuple_element_22 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_36 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PROTOCOL_TLS );

                if (unlikely( tmp_mvar_value_36 == NULL ))
                {
                    tmp_mvar_value_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PROTOCOL_TLS );
                }

                if ( tmp_mvar_value_36 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PROTOCOL_TLS" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 387;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                tmp_tuple_element_22 = tmp_mvar_value_36;
                Py_INCREF( tmp_tuple_element_22 );
                }
            }

            tmp_defaults_1 = PyTuple_New( 1 );
            PyTuple_SET_ITEM( tmp_defaults_1, 0, tmp_tuple_element_22 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_15___new__( tmp_defaults_1 );



            tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain___new__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 387;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_16__encode_hostname(  );



        tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain__encode_hostname, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 391;
            type_description_2 = "c";
            goto frame_exception_exit_6;
        }
        {
            PyObject *tmp_defaults_2;
            tmp_defaults_2 = const_tuple_false_true_true_none_none_tuple;
            Py_INCREF( tmp_defaults_2 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_17_wrap_socket( tmp_defaults_2 );



            tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_wrap_socket, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 399;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_defaults_3;
            tmp_defaults_3 = const_tuple_false_none_none_tuple;
            Py_INCREF( tmp_defaults_3 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_18_wrap_bio( tmp_defaults_3 );



            tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_wrap_bio, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 415;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_19_set_npn_protocols(  );



        tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_set_npn_protocols, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 425;
            type_description_2 = "c";
            goto frame_exception_exit_6;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_20_set_servername_callback(  );



        tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_set_servername_callback, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 436;
            type_description_2 = "c";
            goto frame_exception_exit_6;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_21_set_alpn_protocols(  );



        tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_set_alpn_protocols, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 449;
            type_description_2 = "c";
            goto frame_exception_exit_6;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_22__load_windows_store_certs(  );



        tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain__load_windows_store_certs, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 460;
            type_description_2 = "c";
            goto frame_exception_exit_6;
        }
        {
            PyObject *tmp_defaults_4;
            PyObject *tmp_tuple_element_23;
            PyObject *tmp_source_name_34;
            PyObject *tmp_mvar_value_37;
            tmp_source_name_34 = PyObject_GetItem( locals_ssl_379, const_str_plain_Purpose );

            if ( tmp_source_name_34 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_37 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_Purpose );

                if (unlikely( tmp_mvar_value_37 == NULL ))
                {
                    tmp_mvar_value_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Purpose );
                }

                if ( tmp_mvar_value_37 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Purpose" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 474;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                tmp_source_name_34 = tmp_mvar_value_37;
                Py_INCREF( tmp_source_name_34 );
                }
            }

            tmp_tuple_element_23 = LOOKUP_ATTRIBUTE( tmp_source_name_34, const_str_plain_SERVER_AUTH );
            Py_DECREF( tmp_source_name_34 );
            if ( tmp_tuple_element_23 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 474;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_defaults_4 = PyTuple_New( 1 );
            PyTuple_SET_ITEM( tmp_defaults_4, 0, tmp_tuple_element_23 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_23_load_default_certs( tmp_defaults_4 );



            tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_load_default_certs, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 474;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
        }
        {
            nuitka_bool tmp_condition_result_28;
            nuitka_bool tmp_condition_result_29;
            PyObject *tmp_called_name_18;
            PyObject *tmp_call_result_7;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_mvar_value_38;
            PyObject *tmp_args_element_name_4;
            int tmp_truth_name_5;
            PyObject *tmp_source_name_35;
            PyObject *tmp_mvar_value_39;
            PyObject *tmp_attribute_name_2;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_379, const_str_plain_hasattr );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 482;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_condition_result_29 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_29 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_11;
            }
            else
            {
                goto condexpr_false_11;
            }
            condexpr_true_11:;
            tmp_called_name_18 = PyObject_GetItem( locals_ssl_379, const_str_plain_hasattr );

            if ( tmp_called_name_18 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "hasattr" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 482;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }

            if ( tmp_called_name_18 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 482;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_args_element_name_3 = PyObject_GetItem( locals_ssl_379, const_str_plain__SSLContext );

            if ( tmp_args_element_name_3 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_38 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__SSLContext );

                if (unlikely( tmp_mvar_value_38 == NULL ))
                {
                    tmp_mvar_value_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__SSLContext );
                }

                if ( tmp_mvar_value_38 == NULL )
                {
                    Py_DECREF( tmp_called_name_18 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_SSLContext" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 482;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                tmp_args_element_name_3 = tmp_mvar_value_38;
                Py_INCREF( tmp_args_element_name_3 );
                }
            }

            tmp_args_element_name_4 = const_str_plain_minimum_version;
            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 482;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                tmp_call_result_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_18, call_args );
            }

            Py_DECREF( tmp_called_name_18 );
            Py_DECREF( tmp_args_element_name_3 );
            if ( tmp_call_result_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 482;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_truth_name_5 = CHECK_IF_TRUE( tmp_call_result_7 );
            if ( tmp_truth_name_5 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_call_result_7 );

                exception_lineno = 482;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_condition_result_28 = tmp_truth_name_5 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_call_result_7 );
            goto condexpr_end_11;
            condexpr_false_11:;
            tmp_source_name_35 = PyObject_GetItem( locals_ssl_379, const_str_plain__SSLContext );

            if ( tmp_source_name_35 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_39 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__SSLContext );

                if (unlikely( tmp_mvar_value_39 == NULL ))
                {
                    tmp_mvar_value_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__SSLContext );
                }

                if ( tmp_mvar_value_39 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_SSLContext" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 482;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                tmp_source_name_35 = tmp_mvar_value_39;
                Py_INCREF( tmp_source_name_35 );
                }
            }

            tmp_attribute_name_2 = const_str_plain_minimum_version;
            tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_35, tmp_attribute_name_2 );
            Py_DECREF( tmp_source_name_35 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 482;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_condition_result_28 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            condexpr_end_11:;
            if ( tmp_condition_result_28 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_18;
            }
            else
            {
                goto branch_no_18;
            }
            branch_yes_18:;
            {
                nuitka_bool tmp_condition_result_30;
                PyObject *tmp_called_name_19;
                PyObject *tmp_args_element_name_5;
                PyObject *tmp_called_name_20;
                PyObject *tmp_args_element_name_6;
                tmp_res = MAPPING_HAS_ITEM( locals_ssl_379, const_str_plain_property );

                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 483;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_condition_result_30 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_30 == NUITKA_BOOL_TRUE )
                {
                    goto condexpr_true_12;
                }
                else
                {
                    goto condexpr_false_12;
                }
                condexpr_true_12:;
                tmp_called_name_19 = PyObject_GetItem( locals_ssl_379, const_str_plain_property );

                if ( tmp_called_name_19 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 483;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                if ( tmp_called_name_19 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 483;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_args_element_name_5 = MAKE_FUNCTION_ssl$$$function_24_minimum_version(  );

                ((struct Nuitka_FunctionObject *)tmp_args_element_name_5)->m_closure[0] = outline_4_var___class__;
                Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_5)->m_closure[0] );


                frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 483;
                {
                    PyObject *call_args[] = { tmp_args_element_name_5 };
                    tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_19, call_args );
                }

                Py_DECREF( tmp_called_name_19 );
                Py_DECREF( tmp_args_element_name_5 );
                if ( tmp_dictset_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 483;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                goto condexpr_end_12;
                condexpr_false_12:;
                tmp_called_name_20 = (PyObject *)&PyProperty_Type;
                tmp_args_element_name_6 = MAKE_FUNCTION_ssl$$$function_24_minimum_version(  );

                ((struct Nuitka_FunctionObject *)tmp_args_element_name_6)->m_closure[0] = outline_4_var___class__;
                Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_6)->m_closure[0] );


                frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 483;
                {
                    PyObject *call_args[] = { tmp_args_element_name_6 };
                    tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_20, call_args );
                }

                Py_DECREF( tmp_args_element_name_6 );
                if ( tmp_dictset_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 483;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                condexpr_end_12:;
                tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_minimum_version, tmp_dictset_value );
                Py_DECREF( tmp_dictset_value );
                if ( tmp_res != 0 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 483;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
            }
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_7;
                tmp_called_instance_2 = PyObject_GetItem( locals_ssl_379, const_str_plain_minimum_version );

                if ( tmp_called_instance_2 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "minimum_version" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 487;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                if ( tmp_called_instance_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 487;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_args_element_name_7 = MAKE_FUNCTION_ssl$$$function_25_minimum_version(  );



                frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 487;
                {
                    PyObject *call_args[] = { tmp_args_element_name_7 };
                    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_setter, call_args );
                }

                Py_DECREF( tmp_called_instance_2 );
                Py_DECREF( tmp_args_element_name_7 );
                if ( tmp_dictset_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 487;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_minimum_version, tmp_dictset_value );
                Py_DECREF( tmp_dictset_value );
                if ( tmp_res != 0 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 487;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
            }
            {
                nuitka_bool tmp_condition_result_31;
                PyObject *tmp_called_name_21;
                PyObject *tmp_args_element_name_8;
                PyObject *tmp_called_name_22;
                PyObject *tmp_args_element_name_9;
                tmp_res = MAPPING_HAS_ITEM( locals_ssl_379, const_str_plain_property );

                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 493;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_condition_result_31 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_31 == NUITKA_BOOL_TRUE )
                {
                    goto condexpr_true_13;
                }
                else
                {
                    goto condexpr_false_13;
                }
                condexpr_true_13:;
                tmp_called_name_21 = PyObject_GetItem( locals_ssl_379, const_str_plain_property );

                if ( tmp_called_name_21 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 493;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                if ( tmp_called_name_21 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 493;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_args_element_name_8 = MAKE_FUNCTION_ssl$$$function_26_maximum_version(  );

                ((struct Nuitka_FunctionObject *)tmp_args_element_name_8)->m_closure[0] = outline_4_var___class__;
                Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_8)->m_closure[0] );


                frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 493;
                {
                    PyObject *call_args[] = { tmp_args_element_name_8 };
                    tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_21, call_args );
                }

                Py_DECREF( tmp_called_name_21 );
                Py_DECREF( tmp_args_element_name_8 );
                if ( tmp_dictset_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 493;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                goto condexpr_end_13;
                condexpr_false_13:;
                tmp_called_name_22 = (PyObject *)&PyProperty_Type;
                tmp_args_element_name_9 = MAKE_FUNCTION_ssl$$$function_26_maximum_version(  );

                ((struct Nuitka_FunctionObject *)tmp_args_element_name_9)->m_closure[0] = outline_4_var___class__;
                Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_9)->m_closure[0] );


                frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 493;
                {
                    PyObject *call_args[] = { tmp_args_element_name_9 };
                    tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_22, call_args );
                }

                Py_DECREF( tmp_args_element_name_9 );
                if ( tmp_dictset_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 493;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                condexpr_end_13:;
                tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_maximum_version, tmp_dictset_value );
                Py_DECREF( tmp_dictset_value );
                if ( tmp_res != 0 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 493;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
            }
            {
                PyObject *tmp_called_instance_3;
                PyObject *tmp_args_element_name_10;
                tmp_called_instance_3 = PyObject_GetItem( locals_ssl_379, const_str_plain_maximum_version );

                if ( tmp_called_instance_3 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "maximum_version" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 497;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                if ( tmp_called_instance_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 497;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_args_element_name_10 = MAKE_FUNCTION_ssl$$$function_27_maximum_version(  );



                frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 497;
                {
                    PyObject *call_args[] = { tmp_args_element_name_10 };
                    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_setter, call_args );
                }

                Py_DECREF( tmp_called_instance_3 );
                Py_DECREF( tmp_args_element_name_10 );
                if ( tmp_dictset_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 497;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_maximum_version, tmp_dictset_value );
                Py_DECREF( tmp_dictset_value );
                if ( tmp_res != 0 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 497;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
            }
            branch_no_18:;
        }
        {
            nuitka_bool tmp_condition_result_32;
            PyObject *tmp_called_name_23;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_called_name_24;
            PyObject *tmp_args_element_name_12;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_379, const_str_plain_property );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 501;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_condition_result_32 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_32 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_14;
            }
            else
            {
                goto condexpr_false_14;
            }
            condexpr_true_14:;
            tmp_called_name_23 = PyObject_GetItem( locals_ssl_379, const_str_plain_property );

            if ( tmp_called_name_23 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 501;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }

            if ( tmp_called_name_23 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 501;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_args_element_name_11 = MAKE_FUNCTION_ssl$$$function_28_options(  );

            ((struct Nuitka_FunctionObject *)tmp_args_element_name_11)->m_closure[0] = outline_4_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_11)->m_closure[0] );


            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 501;
            {
                PyObject *call_args[] = { tmp_args_element_name_11 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_23, call_args );
            }

            Py_DECREF( tmp_called_name_23 );
            Py_DECREF( tmp_args_element_name_11 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 501;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            goto condexpr_end_14;
            condexpr_false_14:;
            tmp_called_name_24 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_12 = MAKE_FUNCTION_ssl$$$function_28_options(  );

            ((struct Nuitka_FunctionObject *)tmp_args_element_name_12)->m_closure[0] = outline_4_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_12)->m_closure[0] );


            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 501;
            {
                PyObject *call_args[] = { tmp_args_element_name_12 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_24, call_args );
            }

            Py_DECREF( tmp_args_element_name_12 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 501;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            condexpr_end_14:;
            tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_options, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 501;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_args_element_name_13;
            tmp_called_instance_4 = PyObject_GetItem( locals_ssl_379, const_str_plain_options );

            if ( tmp_called_instance_4 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "options" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 505;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }

            if ( tmp_called_instance_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 505;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_args_element_name_13 = MAKE_FUNCTION_ssl$$$function_29_options(  );



            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 505;
            {
                PyObject *call_args[] = { tmp_args_element_name_13 };
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_setter, call_args );
            }

            Py_DECREF( tmp_called_instance_4 );
            Py_DECREF( tmp_args_element_name_13 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 505;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_options, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 505;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
        }
        {
            nuitka_bool tmp_condition_result_33;
            nuitka_bool tmp_condition_result_34;
            PyObject *tmp_called_name_25;
            PyObject *tmp_call_result_8;
            PyObject *tmp_args_element_name_14;
            PyObject *tmp_mvar_value_40;
            PyObject *tmp_args_element_name_15;
            int tmp_truth_name_6;
            PyObject *tmp_source_name_36;
            PyObject *tmp_mvar_value_41;
            PyObject *tmp_attribute_name_3;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_379, const_str_plain_hasattr );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 509;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_condition_result_34 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_34 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_15;
            }
            else
            {
                goto condexpr_false_15;
            }
            condexpr_true_15:;
            tmp_called_name_25 = PyObject_GetItem( locals_ssl_379, const_str_plain_hasattr );

            if ( tmp_called_name_25 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "hasattr" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 509;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }

            if ( tmp_called_name_25 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 509;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_args_element_name_14 = PyObject_GetItem( locals_ssl_379, const_str_plain__ssl );

            if ( tmp_args_element_name_14 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_40 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

                if (unlikely( tmp_mvar_value_40 == NULL ))
                {
                    tmp_mvar_value_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
                }

                if ( tmp_mvar_value_40 == NULL )
                {
                    Py_DECREF( tmp_called_name_25 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 509;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                tmp_args_element_name_14 = tmp_mvar_value_40;
                Py_INCREF( tmp_args_element_name_14 );
                }
            }

            tmp_args_element_name_15 = const_str_plain_HOSTFLAG_NEVER_CHECK_SUBJECT;
            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 509;
            {
                PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_15 };
                tmp_call_result_8 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_25, call_args );
            }

            Py_DECREF( tmp_called_name_25 );
            Py_DECREF( tmp_args_element_name_14 );
            if ( tmp_call_result_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 509;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_truth_name_6 = CHECK_IF_TRUE( tmp_call_result_8 );
            if ( tmp_truth_name_6 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_call_result_8 );

                exception_lineno = 509;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_condition_result_33 = tmp_truth_name_6 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_call_result_8 );
            goto condexpr_end_15;
            condexpr_false_15:;
            tmp_source_name_36 = PyObject_GetItem( locals_ssl_379, const_str_plain__ssl );

            if ( tmp_source_name_36 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_41 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__ssl );

                if (unlikely( tmp_mvar_value_41 == NULL ))
                {
                    tmp_mvar_value_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ssl );
                }

                if ( tmp_mvar_value_41 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ssl" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 509;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                tmp_source_name_36 = tmp_mvar_value_41;
                Py_INCREF( tmp_source_name_36 );
                }
            }

            tmp_attribute_name_3 = const_str_plain_HOSTFLAG_NEVER_CHECK_SUBJECT;
            tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_36, tmp_attribute_name_3 );
            Py_DECREF( tmp_source_name_36 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 509;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_condition_result_33 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            condexpr_end_15:;
            if ( tmp_condition_result_33 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_19;
            }
            else
            {
                goto branch_no_19;
            }
            branch_yes_19:;
            {
                nuitka_bool tmp_condition_result_35;
                PyObject *tmp_called_name_26;
                PyObject *tmp_args_element_name_16;
                PyObject *tmp_called_name_27;
                PyObject *tmp_args_element_name_17;
                tmp_res = MAPPING_HAS_ITEM( locals_ssl_379, const_str_plain_property );

                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 510;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_condition_result_35 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_35 == NUITKA_BOOL_TRUE )
                {
                    goto condexpr_true_16;
                }
                else
                {
                    goto condexpr_false_16;
                }
                condexpr_true_16:;
                tmp_called_name_26 = PyObject_GetItem( locals_ssl_379, const_str_plain_property );

                if ( tmp_called_name_26 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 510;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                if ( tmp_called_name_26 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 510;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_args_element_name_16 = MAKE_FUNCTION_ssl$$$function_30_hostname_checks_common_name(  );



                frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 510;
                {
                    PyObject *call_args[] = { tmp_args_element_name_16 };
                    tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_26, call_args );
                }

                Py_DECREF( tmp_called_name_26 );
                Py_DECREF( tmp_args_element_name_16 );
                if ( tmp_dictset_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 510;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                goto condexpr_end_16;
                condexpr_false_16:;
                tmp_called_name_27 = (PyObject *)&PyProperty_Type;
                tmp_args_element_name_17 = MAKE_FUNCTION_ssl$$$function_30_hostname_checks_common_name(  );



                frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 510;
                {
                    PyObject *call_args[] = { tmp_args_element_name_17 };
                    tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_27, call_args );
                }

                Py_DECREF( tmp_args_element_name_17 );
                if ( tmp_dictset_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 510;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                condexpr_end_16:;
                tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_hostname_checks_common_name, tmp_dictset_value );
                Py_DECREF( tmp_dictset_value );
                if ( tmp_res != 0 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 510;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
            }
            {
                PyObject *tmp_called_instance_5;
                PyObject *tmp_args_element_name_18;
                tmp_called_instance_5 = PyObject_GetItem( locals_ssl_379, const_str_plain_hostname_checks_common_name );

                if ( tmp_called_instance_5 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "hostname_checks_common_name" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 515;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                if ( tmp_called_instance_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 515;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_args_element_name_18 = MAKE_FUNCTION_ssl$$$function_31_hostname_checks_common_name(  );



                frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 515;
                {
                    PyObject *call_args[] = { tmp_args_element_name_18 };
                    tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_setter, call_args );
                }

                Py_DECREF( tmp_called_instance_5 );
                Py_DECREF( tmp_args_element_name_18 );
                if ( tmp_dictset_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 515;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_hostname_checks_common_name, tmp_dictset_value );
                Py_DECREF( tmp_dictset_value );
                if ( tmp_res != 0 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 515;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
            }
            goto branch_end_19;
            branch_no_19:;
            {
                nuitka_bool tmp_condition_result_36;
                PyObject *tmp_called_name_28;
                PyObject *tmp_args_element_name_19;
                PyObject *tmp_called_name_29;
                PyObject *tmp_args_element_name_20;
                tmp_res = MAPPING_HAS_ITEM( locals_ssl_379, const_str_plain_property );

                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 522;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_condition_result_36 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_36 == NUITKA_BOOL_TRUE )
                {
                    goto condexpr_true_17;
                }
                else
                {
                    goto condexpr_false_17;
                }
                condexpr_true_17:;
                tmp_called_name_28 = PyObject_GetItem( locals_ssl_379, const_str_plain_property );

                if ( tmp_called_name_28 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 522;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }

                if ( tmp_called_name_28 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 522;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                tmp_args_element_name_19 = MAKE_FUNCTION_ssl$$$function_32_hostname_checks_common_name(  );



                frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 522;
                {
                    PyObject *call_args[] = { tmp_args_element_name_19 };
                    tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_28, call_args );
                }

                Py_DECREF( tmp_called_name_28 );
                Py_DECREF( tmp_args_element_name_19 );
                if ( tmp_dictset_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 522;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                goto condexpr_end_17;
                condexpr_false_17:;
                tmp_called_name_29 = (PyObject *)&PyProperty_Type;
                tmp_args_element_name_20 = MAKE_FUNCTION_ssl$$$function_32_hostname_checks_common_name(  );



                frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 522;
                {
                    PyObject *call_args[] = { tmp_args_element_name_20 };
                    tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_29, call_args );
                }

                Py_DECREF( tmp_args_element_name_20 );
                if ( tmp_dictset_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 522;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
                condexpr_end_17:;
                tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_hostname_checks_common_name, tmp_dictset_value );
                Py_DECREF( tmp_dictset_value );
                if ( tmp_res != 0 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 522;
                    type_description_2 = "c";
                    goto frame_exception_exit_6;
                }
            }
            branch_end_19:;
        }
        {
            nuitka_bool tmp_condition_result_37;
            PyObject *tmp_called_name_30;
            PyObject *tmp_args_element_name_21;
            PyObject *tmp_called_name_31;
            PyObject *tmp_args_element_name_22;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_379, const_str_plain_property );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 526;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_condition_result_37 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_37 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_18;
            }
            else
            {
                goto condexpr_false_18;
            }
            condexpr_true_18:;
            tmp_called_name_30 = PyObject_GetItem( locals_ssl_379, const_str_plain_property );

            if ( tmp_called_name_30 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 526;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }

            if ( tmp_called_name_30 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 526;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_args_element_name_21 = MAKE_FUNCTION_ssl$$$function_33_protocol(  );

            ((struct Nuitka_FunctionObject *)tmp_args_element_name_21)->m_closure[0] = outline_4_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_21)->m_closure[0] );


            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 526;
            {
                PyObject *call_args[] = { tmp_args_element_name_21 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_30, call_args );
            }

            Py_DECREF( tmp_called_name_30 );
            Py_DECREF( tmp_args_element_name_21 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 526;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            goto condexpr_end_18;
            condexpr_false_18:;
            tmp_called_name_31 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_22 = MAKE_FUNCTION_ssl$$$function_33_protocol(  );

            ((struct Nuitka_FunctionObject *)tmp_args_element_name_22)->m_closure[0] = outline_4_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_22)->m_closure[0] );


            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 526;
            {
                PyObject *call_args[] = { tmp_args_element_name_22 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_31, call_args );
            }

            Py_DECREF( tmp_args_element_name_22 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 526;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            condexpr_end_18:;
            tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_protocol, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 526;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
        }
        {
            nuitka_bool tmp_condition_result_38;
            PyObject *tmp_called_name_32;
            PyObject *tmp_args_element_name_23;
            PyObject *tmp_called_name_33;
            PyObject *tmp_args_element_name_24;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_379, const_str_plain_property );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 530;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_condition_result_38 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_38 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_19;
            }
            else
            {
                goto condexpr_false_19;
            }
            condexpr_true_19:;
            tmp_called_name_32 = PyObject_GetItem( locals_ssl_379, const_str_plain_property );

            if ( tmp_called_name_32 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 530;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }

            if ( tmp_called_name_32 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 530;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_args_element_name_23 = MAKE_FUNCTION_ssl$$$function_34_verify_flags(  );

            ((struct Nuitka_FunctionObject *)tmp_args_element_name_23)->m_closure[0] = outline_4_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_23)->m_closure[0] );


            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 530;
            {
                PyObject *call_args[] = { tmp_args_element_name_23 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_32, call_args );
            }

            Py_DECREF( tmp_called_name_32 );
            Py_DECREF( tmp_args_element_name_23 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 530;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            goto condexpr_end_19;
            condexpr_false_19:;
            tmp_called_name_33 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_24 = MAKE_FUNCTION_ssl$$$function_34_verify_flags(  );

            ((struct Nuitka_FunctionObject *)tmp_args_element_name_24)->m_closure[0] = outline_4_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_24)->m_closure[0] );


            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 530;
            {
                PyObject *call_args[] = { tmp_args_element_name_24 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_33, call_args );
            }

            Py_DECREF( tmp_args_element_name_24 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 530;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            condexpr_end_19:;
            tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_verify_flags, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 530;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_instance_6;
            PyObject *tmp_args_element_name_25;
            tmp_called_instance_6 = PyObject_GetItem( locals_ssl_379, const_str_plain_verify_flags );

            if ( tmp_called_instance_6 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "verify_flags" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 534;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }

            if ( tmp_called_instance_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 534;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_args_element_name_25 = MAKE_FUNCTION_ssl$$$function_35_verify_flags(  );



            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 534;
            {
                PyObject *call_args[] = { tmp_args_element_name_25 };
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_setter, call_args );
            }

            Py_DECREF( tmp_called_instance_6 );
            Py_DECREF( tmp_args_element_name_25 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 534;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_verify_flags, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 534;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
        }
        {
            nuitka_bool tmp_condition_result_39;
            PyObject *tmp_called_name_34;
            PyObject *tmp_args_element_name_26;
            PyObject *tmp_called_name_35;
            PyObject *tmp_args_element_name_27;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_379, const_str_plain_property );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 538;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_condition_result_39 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_39 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_20;
            }
            else
            {
                goto condexpr_false_20;
            }
            condexpr_true_20:;
            tmp_called_name_34 = PyObject_GetItem( locals_ssl_379, const_str_plain_property );

            if ( tmp_called_name_34 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 538;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }

            if ( tmp_called_name_34 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 538;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_args_element_name_26 = MAKE_FUNCTION_ssl$$$function_36_verify_mode(  );

            ((struct Nuitka_FunctionObject *)tmp_args_element_name_26)->m_closure[0] = outline_4_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_26)->m_closure[0] );


            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 538;
            {
                PyObject *call_args[] = { tmp_args_element_name_26 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_34, call_args );
            }

            Py_DECREF( tmp_called_name_34 );
            Py_DECREF( tmp_args_element_name_26 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 538;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            goto condexpr_end_20;
            condexpr_false_20:;
            tmp_called_name_35 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_27 = MAKE_FUNCTION_ssl$$$function_36_verify_mode(  );

            ((struct Nuitka_FunctionObject *)tmp_args_element_name_27)->m_closure[0] = outline_4_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_27)->m_closure[0] );


            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 538;
            {
                PyObject *call_args[] = { tmp_args_element_name_27 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_35, call_args );
            }

            Py_DECREF( tmp_args_element_name_27 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 538;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            condexpr_end_20:;
            tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_verify_mode, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 538;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_instance_7;
            PyObject *tmp_args_element_name_28;
            tmp_called_instance_7 = PyObject_GetItem( locals_ssl_379, const_str_plain_verify_mode );

            if ( tmp_called_instance_7 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "verify_mode" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 546;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }

            if ( tmp_called_instance_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 546;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_args_element_name_28 = MAKE_FUNCTION_ssl$$$function_37_verify_mode(  );



            frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame.f_lineno = 546;
            {
                PyObject *call_args[] = { tmp_args_element_name_28 };
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_setter, call_args );
            }

            Py_DECREF( tmp_called_instance_7 );
            Py_DECREF( tmp_args_element_name_28 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 546;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
            tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain_verify_mode, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 546;
                type_description_2 = "c";
                goto frame_exception_exit_6;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_2f3dc3967a43757d07b0bed3cdf75e71_6 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_5;

        frame_exception_exit_6:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_2f3dc3967a43757d07b0bed3cdf75e71_6 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_2f3dc3967a43757d07b0bed3cdf75e71_6, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_2f3dc3967a43757d07b0bed3cdf75e71_6->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_2f3dc3967a43757d07b0bed3cdf75e71_6, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_2f3dc3967a43757d07b0bed3cdf75e71_6,
            type_description_2,
            outline_4_var___class__
        );


        // Release cached frame.
        if ( frame_2f3dc3967a43757d07b0bed3cdf75e71_6 == cache_frame_2f3dc3967a43757d07b0bed3cdf75e71_6 )
        {
            Py_DECREF( frame_2f3dc3967a43757d07b0bed3cdf75e71_6 );
        }
        cache_frame_2f3dc3967a43757d07b0bed3cdf75e71_6 = NULL;

        assertFrameObject( frame_2f3dc3967a43757d07b0bed3cdf75e71_6 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_5;

        frame_no_exception_5:;
        goto skip_nested_handling_5;
        nested_frame_exit_5:;

        goto try_except_handler_30;
        skip_nested_handling_5:;
        {
            nuitka_bool tmp_condition_result_40;
            PyObject *tmp_compexpr_left_6;
            PyObject *tmp_compexpr_right_6;
            CHECK_OBJECT( tmp_class_creation_4__bases );
            tmp_compexpr_left_6 = tmp_class_creation_4__bases;
            CHECK_OBJECT( tmp_class_creation_4__bases_orig );
            tmp_compexpr_right_6 = tmp_class_creation_4__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 379;

                goto try_except_handler_30;
            }
            tmp_condition_result_40 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_40 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_20;
            }
            else
            {
                goto branch_no_20;
            }
            branch_yes_20:;
            CHECK_OBJECT( tmp_class_creation_4__bases_orig );
            tmp_dictset_value = tmp_class_creation_4__bases_orig;
            tmp_res = PyObject_SetItem( locals_ssl_379, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 379;

                goto try_except_handler_30;
            }
            branch_no_20:;
        }
        {
            PyObject *tmp_assign_source_120;
            PyObject *tmp_called_name_36;
            PyObject *tmp_args_name_14;
            PyObject *tmp_tuple_element_24;
            PyObject *tmp_kw_name_14;
            CHECK_OBJECT( tmp_class_creation_4__metaclass );
            tmp_called_name_36 = tmp_class_creation_4__metaclass;
            tmp_tuple_element_24 = const_str_plain_SSLContext;
            tmp_args_name_14 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_24 );
            PyTuple_SET_ITEM( tmp_args_name_14, 0, tmp_tuple_element_24 );
            CHECK_OBJECT( tmp_class_creation_4__bases );
            tmp_tuple_element_24 = tmp_class_creation_4__bases;
            Py_INCREF( tmp_tuple_element_24 );
            PyTuple_SET_ITEM( tmp_args_name_14, 1, tmp_tuple_element_24 );
            tmp_tuple_element_24 = locals_ssl_379;
            Py_INCREF( tmp_tuple_element_24 );
            PyTuple_SET_ITEM( tmp_args_name_14, 2, tmp_tuple_element_24 );
            CHECK_OBJECT( tmp_class_creation_4__class_decl_dict );
            tmp_kw_name_14 = tmp_class_creation_4__class_decl_dict;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 379;
            tmp_assign_source_120 = CALL_FUNCTION( tmp_called_name_36, tmp_args_name_14, tmp_kw_name_14 );
            Py_DECREF( tmp_args_name_14 );
            if ( tmp_assign_source_120 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 379;

                goto try_except_handler_30;
            }
            {
                PyObject *old = PyCell_GET( outline_4_var___class__ );
                PyCell_SET( outline_4_var___class__, tmp_assign_source_120 );
                Py_XDECREF( old );
            }

        }
        CHECK_OBJECT( PyCell_GET( outline_4_var___class__ ) );
        tmp_assign_source_119 = PyCell_GET( outline_4_var___class__ );
        Py_INCREF( tmp_assign_source_119 );
        goto try_return_handler_30;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_30:;
        Py_DECREF( locals_ssl_379 );
        locals_ssl_379 = NULL;
        goto try_return_handler_29;
        // Exception handler code:
        try_except_handler_30:;
        exception_keeper_type_28 = exception_type;
        exception_keeper_value_28 = exception_value;
        exception_keeper_tb_28 = exception_tb;
        exception_keeper_lineno_28 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ssl_379 );
        locals_ssl_379 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_28;
        exception_value = exception_keeper_value_28;
        exception_tb = exception_keeper_tb_28;
        exception_lineno = exception_keeper_lineno_28;

        goto try_except_handler_29;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_29:;
        CHECK_OBJECT( (PyObject *)outline_4_var___class__ );
        Py_DECREF( outline_4_var___class__ );
        outline_4_var___class__ = NULL;

        goto outline_result_5;
        // Exception handler code:
        try_except_handler_29:;
        exception_keeper_type_29 = exception_type;
        exception_keeper_value_29 = exception_value;
        exception_keeper_tb_29 = exception_tb;
        exception_keeper_lineno_29 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)outline_4_var___class__ );
        Py_DECREF( outline_4_var___class__ );
        outline_4_var___class__ = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_29;
        exception_value = exception_keeper_value_29;
        exception_tb = exception_keeper_tb_29;
        exception_lineno = exception_keeper_lineno_29;

        goto outline_exception_5;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_5:;
        exception_lineno = 379;
        goto try_except_handler_28;
        outline_result_5:;
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext, tmp_assign_source_119 );
    }
    goto try_end_20;
    // Exception handler code:
    try_except_handler_28:;
    exception_keeper_type_30 = exception_type;
    exception_keeper_value_30 = exception_value;
    exception_keeper_tb_30 = exception_tb;
    exception_keeper_lineno_30 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_4__bases_orig );
    tmp_class_creation_4__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    Py_XDECREF( tmp_class_creation_4__class_decl_dict );
    tmp_class_creation_4__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_4__prepared );
    tmp_class_creation_4__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_30;
    exception_value = exception_keeper_value_30;
    exception_tb = exception_keeper_tb_30;
    exception_lineno = exception_keeper_lineno_30;

    goto frame_exception_exit_1;
    // End of try:
    try_end_20:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__bases_orig );
    Py_DECREF( tmp_class_creation_4__bases_orig );
    tmp_class_creation_4__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__bases );
    Py_DECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class_decl_dict );
    Py_DECREF( tmp_class_creation_4__class_decl_dict );
    tmp_class_creation_4__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__metaclass );
    Py_DECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__prepared );
    Py_DECREF( tmp_class_creation_4__prepared );
    tmp_class_creation_4__prepared = NULL;

    {
        PyObject *tmp_assign_source_121;
        PyObject *tmp_defaults_5;
        PyObject *tmp_tuple_element_25;
        PyObject *tmp_source_name_37;
        PyObject *tmp_mvar_value_42;
        PyObject *tmp_kw_defaults_1;
        tmp_mvar_value_42 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_Purpose );

        if (unlikely( tmp_mvar_value_42 == NULL ))
        {
            tmp_mvar_value_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Purpose );
        }

        if ( tmp_mvar_value_42 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Purpose" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 551;

            goto frame_exception_exit_1;
        }

        tmp_source_name_37 = tmp_mvar_value_42;
        tmp_tuple_element_25 = LOOKUP_ATTRIBUTE( tmp_source_name_37, const_str_plain_SERVER_AUTH );
        if ( tmp_tuple_element_25 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 551;

            goto frame_exception_exit_1;
        }
        tmp_defaults_5 = PyTuple_New( 1 );
        PyTuple_SET_ITEM( tmp_defaults_5, 0, tmp_tuple_element_25 );
        tmp_kw_defaults_1 = PyDict_Copy( const_dict_f68e37ae246dcd2f55c6ccbc7f9fbda7 );
        tmp_assign_source_121 = MAKE_FUNCTION_ssl$$$function_38_create_default_context( tmp_defaults_5, tmp_kw_defaults_1 );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_create_default_context, tmp_assign_source_121 );
    }
    {
        PyObject *tmp_assign_source_122;
        PyObject *tmp_defaults_6;
        PyObject *tmp_tuple_element_26;
        PyObject *tmp_mvar_value_43;
        PyObject *tmp_kw_defaults_2;
        PyObject *tmp_dict_key_7;
        PyObject *tmp_dict_value_7;
        PyObject *tmp_mvar_value_44;
        PyObject *tmp_dict_key_8;
        PyObject *tmp_dict_value_8;
        PyObject *tmp_dict_key_9;
        PyObject *tmp_dict_value_9;
        PyObject *tmp_source_name_38;
        PyObject *tmp_mvar_value_45;
        PyObject *tmp_dict_key_10;
        PyObject *tmp_dict_value_10;
        PyObject *tmp_dict_key_11;
        PyObject *tmp_dict_value_11;
        PyObject *tmp_dict_key_12;
        PyObject *tmp_dict_value_12;
        PyObject *tmp_dict_key_13;
        PyObject *tmp_dict_value_13;
        PyObject *tmp_dict_key_14;
        PyObject *tmp_dict_value_14;
        tmp_mvar_value_43 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PROTOCOL_TLS );

        if (unlikely( tmp_mvar_value_43 == NULL ))
        {
            tmp_mvar_value_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PROTOCOL_TLS );
        }

        if ( tmp_mvar_value_43 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PROTOCOL_TLS" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 581;

            goto frame_exception_exit_1;
        }

        tmp_tuple_element_26 = tmp_mvar_value_43;
        tmp_defaults_6 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_26 );
        PyTuple_SET_ITEM( tmp_defaults_6, 0, tmp_tuple_element_26 );
        tmp_dict_key_7 = const_str_plain_cert_reqs;
        tmp_mvar_value_44 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CERT_NONE );

        if (unlikely( tmp_mvar_value_44 == NULL ))
        {
            tmp_mvar_value_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CERT_NONE );
        }

        if ( tmp_mvar_value_44 == NULL )
        {
            Py_DECREF( tmp_defaults_6 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CERT_NONE" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 581;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_7 = tmp_mvar_value_44;
        tmp_kw_defaults_2 = _PyDict_NewPresized( 8 );
        tmp_res = PyDict_SetItem( tmp_kw_defaults_2, tmp_dict_key_7, tmp_dict_value_7 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_8 = const_str_plain_check_hostname;
        tmp_dict_value_8 = Py_False;
        tmp_res = PyDict_SetItem( tmp_kw_defaults_2, tmp_dict_key_8, tmp_dict_value_8 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_9 = const_str_plain_purpose;
        tmp_mvar_value_45 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_Purpose );

        if (unlikely( tmp_mvar_value_45 == NULL ))
        {
            tmp_mvar_value_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Purpose );
        }

        if ( tmp_mvar_value_45 == NULL )
        {
            Py_DECREF( tmp_defaults_6 );
            Py_DECREF( tmp_kw_defaults_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "Purpose" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 582;

            goto frame_exception_exit_1;
        }

        tmp_source_name_38 = tmp_mvar_value_45;
        tmp_dict_value_9 = LOOKUP_ATTRIBUTE( tmp_source_name_38, const_str_plain_SERVER_AUTH );
        if ( tmp_dict_value_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_defaults_6 );
            Py_DECREF( tmp_kw_defaults_2 );

            exception_lineno = 582;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_kw_defaults_2, tmp_dict_key_9, tmp_dict_value_9 );
        Py_DECREF( tmp_dict_value_9 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_10 = const_str_plain_certfile;
        tmp_dict_value_10 = Py_None;
        tmp_res = PyDict_SetItem( tmp_kw_defaults_2, tmp_dict_key_10, tmp_dict_value_10 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_11 = const_str_plain_keyfile;
        tmp_dict_value_11 = Py_None;
        tmp_res = PyDict_SetItem( tmp_kw_defaults_2, tmp_dict_key_11, tmp_dict_value_11 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_12 = const_str_plain_cafile;
        tmp_dict_value_12 = Py_None;
        tmp_res = PyDict_SetItem( tmp_kw_defaults_2, tmp_dict_key_12, tmp_dict_value_12 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_13 = const_str_plain_capath;
        tmp_dict_value_13 = Py_None;
        tmp_res = PyDict_SetItem( tmp_kw_defaults_2, tmp_dict_key_13, tmp_dict_value_13 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_14 = const_str_plain_cadata;
        tmp_dict_value_14 = Py_None;
        tmp_res = PyDict_SetItem( tmp_kw_defaults_2, tmp_dict_key_14, tmp_dict_value_14 );
        assert( !(tmp_res != 0) );
        tmp_assign_source_122 = MAKE_FUNCTION_ssl$$$function_39__create_unverified_context( tmp_defaults_6, tmp_kw_defaults_2 );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__create_unverified_context, tmp_assign_source_122 );
    }
    {
        PyObject *tmp_assign_source_123;
        PyObject *tmp_mvar_value_46;
        tmp_mvar_value_46 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_create_default_context );

        if (unlikely( tmp_mvar_value_46 == NULL ))
        {
            tmp_mvar_value_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_create_default_context );
        }

        if ( tmp_mvar_value_46 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "create_default_context" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 624;

            goto frame_exception_exit_1;
        }

        tmp_assign_source_123 = tmp_mvar_value_46;
        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__create_default_https_context, tmp_assign_source_123 );
    }
    {
        PyObject *tmp_assign_source_124;
        PyObject *tmp_mvar_value_47;
        tmp_mvar_value_47 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__create_unverified_context );

        if (unlikely( tmp_mvar_value_47 == NULL ))
        {
            tmp_mvar_value_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__create_unverified_context );
        }

        CHECK_OBJECT( tmp_mvar_value_47 );
        tmp_assign_source_124 = tmp_mvar_value_47;
        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain__create_stdlib_context, tmp_assign_source_124 );
    }
    {
        PyObject *tmp_assign_source_125;
        tmp_assign_source_125 = PyDict_New();
        assert( tmp_class_creation_5__class_decl_dict == NULL );
        tmp_class_creation_5__class_decl_dict = tmp_assign_source_125;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_126;
        PyObject *tmp_metaclass_name_5;
        nuitka_bool tmp_condition_result_41;
        PyObject *tmp_key_name_13;
        PyObject *tmp_dict_name_13;
        PyObject *tmp_dict_name_14;
        PyObject *tmp_key_name_14;
        PyObject *tmp_bases_name_5;
        tmp_key_name_13 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_5__class_decl_dict );
        tmp_dict_name_13 = tmp_class_creation_5__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_13, tmp_key_name_13 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 631;

            goto try_except_handler_31;
        }
        tmp_condition_result_41 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_41 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_21;
        }
        else
        {
            goto condexpr_false_21;
        }
        condexpr_true_21:;
        CHECK_OBJECT( tmp_class_creation_5__class_decl_dict );
        tmp_dict_name_14 = tmp_class_creation_5__class_decl_dict;
        tmp_key_name_14 = const_str_plain_metaclass;
        tmp_metaclass_name_5 = DICT_GET_ITEM( tmp_dict_name_14, tmp_key_name_14 );
        if ( tmp_metaclass_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 631;

            goto try_except_handler_31;
        }
        goto condexpr_end_21;
        condexpr_false_21:;
        tmp_metaclass_name_5 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_5 );
        condexpr_end_21:;
        tmp_bases_name_5 = const_tuple_empty;
        tmp_assign_source_126 = SELECT_METACLASS( tmp_metaclass_name_5, tmp_bases_name_5 );
        Py_DECREF( tmp_metaclass_name_5 );
        if ( tmp_assign_source_126 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 631;

            goto try_except_handler_31;
        }
        assert( tmp_class_creation_5__metaclass == NULL );
        tmp_class_creation_5__metaclass = tmp_assign_source_126;
    }
    {
        nuitka_bool tmp_condition_result_42;
        PyObject *tmp_key_name_15;
        PyObject *tmp_dict_name_15;
        tmp_key_name_15 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_5__class_decl_dict );
        tmp_dict_name_15 = tmp_class_creation_5__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_15, tmp_key_name_15 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 631;

            goto try_except_handler_31;
        }
        tmp_condition_result_42 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_42 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_21;
        }
        else
        {
            goto branch_no_21;
        }
        branch_yes_21:;
        CHECK_OBJECT( tmp_class_creation_5__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_5__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 631;

            goto try_except_handler_31;
        }
        branch_no_21:;
    }
    {
        nuitka_bool tmp_condition_result_43;
        PyObject *tmp_source_name_39;
        CHECK_OBJECT( tmp_class_creation_5__metaclass );
        tmp_source_name_39 = tmp_class_creation_5__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_39, const_str_plain___prepare__ );
        tmp_condition_result_43 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_43 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_22;
        }
        else
        {
            goto branch_no_22;
        }
        branch_yes_22:;
        {
            PyObject *tmp_assign_source_127;
            PyObject *tmp_called_name_37;
            PyObject *tmp_source_name_40;
            PyObject *tmp_args_name_15;
            PyObject *tmp_kw_name_15;
            CHECK_OBJECT( tmp_class_creation_5__metaclass );
            tmp_source_name_40 = tmp_class_creation_5__metaclass;
            tmp_called_name_37 = LOOKUP_ATTRIBUTE( tmp_source_name_40, const_str_plain___prepare__ );
            if ( tmp_called_name_37 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 631;

                goto try_except_handler_31;
            }
            tmp_args_name_15 = const_tuple_str_plain_SSLObject_tuple_empty_tuple;
            CHECK_OBJECT( tmp_class_creation_5__class_decl_dict );
            tmp_kw_name_15 = tmp_class_creation_5__class_decl_dict;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 631;
            tmp_assign_source_127 = CALL_FUNCTION( tmp_called_name_37, tmp_args_name_15, tmp_kw_name_15 );
            Py_DECREF( tmp_called_name_37 );
            if ( tmp_assign_source_127 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 631;

                goto try_except_handler_31;
            }
            assert( tmp_class_creation_5__prepared == NULL );
            tmp_class_creation_5__prepared = tmp_assign_source_127;
        }
        {
            nuitka_bool tmp_condition_result_44;
            PyObject *tmp_operand_name_6;
            PyObject *tmp_source_name_41;
            CHECK_OBJECT( tmp_class_creation_5__prepared );
            tmp_source_name_41 = tmp_class_creation_5__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_41, const_str_plain___getitem__ );
            tmp_operand_name_6 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_6 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 631;

                goto try_except_handler_31;
            }
            tmp_condition_result_44 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_44 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_23;
            }
            else
            {
                goto branch_no_23;
            }
            branch_yes_23:;
            {
                PyObject *tmp_raise_type_5;
                PyObject *tmp_raise_value_5;
                PyObject *tmp_left_name_5;
                PyObject *tmp_right_name_5;
                PyObject *tmp_tuple_element_27;
                PyObject *tmp_getattr_target_6;
                PyObject *tmp_getattr_attr_6;
                PyObject *tmp_getattr_default_6;
                PyObject *tmp_source_name_42;
                PyObject *tmp_type_arg_9;
                tmp_raise_type_5 = PyExc_TypeError;
                tmp_left_name_5 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_5__metaclass );
                tmp_getattr_target_6 = tmp_class_creation_5__metaclass;
                tmp_getattr_attr_6 = const_str_plain___name__;
                tmp_getattr_default_6 = const_str_angle_metaclass;
                tmp_tuple_element_27 = BUILTIN_GETATTR( tmp_getattr_target_6, tmp_getattr_attr_6, tmp_getattr_default_6 );
                if ( tmp_tuple_element_27 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 631;

                    goto try_except_handler_31;
                }
                tmp_right_name_5 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_5, 0, tmp_tuple_element_27 );
                CHECK_OBJECT( tmp_class_creation_5__prepared );
                tmp_type_arg_9 = tmp_class_creation_5__prepared;
                tmp_source_name_42 = BUILTIN_TYPE1( tmp_type_arg_9 );
                assert( !(tmp_source_name_42 == NULL) );
                tmp_tuple_element_27 = LOOKUP_ATTRIBUTE( tmp_source_name_42, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_42 );
                if ( tmp_tuple_element_27 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_5 );

                    exception_lineno = 631;

                    goto try_except_handler_31;
                }
                PyTuple_SET_ITEM( tmp_right_name_5, 1, tmp_tuple_element_27 );
                tmp_raise_value_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_5, tmp_right_name_5 );
                Py_DECREF( tmp_right_name_5 );
                if ( tmp_raise_value_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 631;

                    goto try_except_handler_31;
                }
                exception_type = tmp_raise_type_5;
                Py_INCREF( tmp_raise_type_5 );
                exception_value = tmp_raise_value_5;
                exception_lineno = 631;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_31;
            }
            branch_no_23:;
        }
        goto branch_end_22;
        branch_no_22:;
        {
            PyObject *tmp_assign_source_128;
            tmp_assign_source_128 = PyDict_New();
            assert( tmp_class_creation_5__prepared == NULL );
            tmp_class_creation_5__prepared = tmp_assign_source_128;
        }
        branch_end_22:;
    }
    {
        PyObject *tmp_assign_source_129;
        {
            PyObject *tmp_set_locals_5;
            CHECK_OBJECT( tmp_class_creation_5__prepared );
            tmp_set_locals_5 = tmp_class_creation_5__prepared;
            locals_ssl_631 = tmp_set_locals_5;
            Py_INCREF( tmp_set_locals_5 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_ssl;
        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 631;

            goto try_except_handler_33;
        }
        tmp_dictset_value = const_str_digest_b6fbb08e38a8d1423a7161f4ef2729f2;
        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 631;

            goto try_except_handler_33;
        }
        tmp_dictset_value = const_str_plain_SSLObject;
        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 631;

            goto try_except_handler_33;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_ca8bc35da6fc8bd12302bc56dc472f30_7, codeobj_ca8bc35da6fc8bd12302bc56dc472f30, module_ssl, sizeof(void *) );
        frame_ca8bc35da6fc8bd12302bc56dc472f30_7 = cache_frame_ca8bc35da6fc8bd12302bc56dc472f30_7;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_ca8bc35da6fc8bd12302bc56dc472f30_7 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_ca8bc35da6fc8bd12302bc56dc472f30_7 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_40___init__(  );



        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 646;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        {
            nuitka_bool tmp_condition_result_45;
            PyObject *tmp_called_name_38;
            PyObject *tmp_args_element_name_29;
            PyObject *tmp_defaults_7;
            PyObject *tmp_classmethod_arg_3;
            PyObject *tmp_defaults_8;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_631, const_str_plain_classmethod );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 652;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_condition_result_45 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_45 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_22;
            }
            else
            {
                goto condexpr_false_22;
            }
            condexpr_true_22:;
            tmp_called_name_38 = PyObject_GetItem( locals_ssl_631, const_str_plain_classmethod );

            if ( tmp_called_name_38 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "classmethod" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 652;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }

            if ( tmp_called_name_38 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 652;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_defaults_7 = const_tuple_false_none_none_none_tuple;
            Py_INCREF( tmp_defaults_7 );
            tmp_args_element_name_29 = MAKE_FUNCTION_ssl$$$function_41__create( tmp_defaults_7 );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 652;
            {
                PyObject *call_args[] = { tmp_args_element_name_29 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_38, call_args );
            }

            Py_DECREF( tmp_called_name_38 );
            Py_DECREF( tmp_args_element_name_29 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 652;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            goto condexpr_end_22;
            condexpr_false_22:;
            tmp_defaults_8 = const_tuple_false_none_none_none_tuple;
            Py_INCREF( tmp_defaults_8 );
            tmp_classmethod_arg_3 = MAKE_FUNCTION_ssl$$$function_41__create( tmp_defaults_8 );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_3 );
            Py_DECREF( tmp_classmethod_arg_3 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 652;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            condexpr_end_22:;
            tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain__create, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 652;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
        }
        {
            nuitka_bool tmp_condition_result_46;
            PyObject *tmp_called_name_39;
            PyObject *tmp_args_element_name_30;
            PyObject *tmp_called_name_40;
            PyObject *tmp_args_element_name_31;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_631, const_str_plain_property );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 664;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_condition_result_46 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_46 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_23;
            }
            else
            {
                goto condexpr_false_23;
            }
            condexpr_true_23:;
            tmp_called_name_39 = PyObject_GetItem( locals_ssl_631, const_str_plain_property );

            if ( tmp_called_name_39 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 664;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }

            if ( tmp_called_name_39 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 664;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_args_element_name_30 = MAKE_FUNCTION_ssl$$$function_42_context(  );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 664;
            {
                PyObject *call_args[] = { tmp_args_element_name_30 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_39, call_args );
            }

            Py_DECREF( tmp_called_name_39 );
            Py_DECREF( tmp_args_element_name_30 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 664;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            goto condexpr_end_23;
            condexpr_false_23:;
            tmp_called_name_40 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_31 = MAKE_FUNCTION_ssl$$$function_42_context(  );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 664;
            {
                PyObject *call_args[] = { tmp_args_element_name_31 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_40, call_args );
            }

            Py_DECREF( tmp_args_element_name_31 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 664;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            condexpr_end_23:;
            tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_context, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 664;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
        }
        {
            PyObject *tmp_called_instance_8;
            PyObject *tmp_args_element_name_32;
            tmp_called_instance_8 = PyObject_GetItem( locals_ssl_631, const_str_plain_context );

            if ( tmp_called_instance_8 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "context" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 669;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }

            if ( tmp_called_instance_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 669;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_args_element_name_32 = MAKE_FUNCTION_ssl$$$function_43_context(  );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 669;
            {
                PyObject *call_args[] = { tmp_args_element_name_32 };
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_8, const_str_plain_setter, call_args );
            }

            Py_DECREF( tmp_called_instance_8 );
            Py_DECREF( tmp_args_element_name_32 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 669;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_context, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 669;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
        }
        {
            nuitka_bool tmp_condition_result_47;
            PyObject *tmp_called_name_41;
            PyObject *tmp_args_element_name_33;
            PyObject *tmp_called_name_42;
            PyObject *tmp_args_element_name_34;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_631, const_str_plain_property );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 673;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_condition_result_47 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_47 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_24;
            }
            else
            {
                goto condexpr_false_24;
            }
            condexpr_true_24:;
            tmp_called_name_41 = PyObject_GetItem( locals_ssl_631, const_str_plain_property );

            if ( tmp_called_name_41 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 673;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }

            if ( tmp_called_name_41 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 673;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_args_element_name_33 = MAKE_FUNCTION_ssl$$$function_44_session(  );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 673;
            {
                PyObject *call_args[] = { tmp_args_element_name_33 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_41, call_args );
            }

            Py_DECREF( tmp_called_name_41 );
            Py_DECREF( tmp_args_element_name_33 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 673;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            goto condexpr_end_24;
            condexpr_false_24:;
            tmp_called_name_42 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_34 = MAKE_FUNCTION_ssl$$$function_44_session(  );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 673;
            {
                PyObject *call_args[] = { tmp_args_element_name_34 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_42, call_args );
            }

            Py_DECREF( tmp_args_element_name_34 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 673;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            condexpr_end_24:;
            tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_session, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 673;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
        }
        {
            PyObject *tmp_called_instance_9;
            PyObject *tmp_args_element_name_35;
            tmp_called_instance_9 = PyObject_GetItem( locals_ssl_631, const_str_plain_session );

            if ( tmp_called_instance_9 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "session" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 678;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }

            if ( tmp_called_instance_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 678;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_args_element_name_35 = MAKE_FUNCTION_ssl$$$function_45_session(  );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 678;
            {
                PyObject *call_args[] = { tmp_args_element_name_35 };
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_9, const_str_plain_setter, call_args );
            }

            Py_DECREF( tmp_called_instance_9 );
            Py_DECREF( tmp_args_element_name_35 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 678;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_session, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 678;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
        }
        {
            nuitka_bool tmp_condition_result_48;
            PyObject *tmp_called_name_43;
            PyObject *tmp_args_element_name_36;
            PyObject *tmp_called_name_44;
            PyObject *tmp_args_element_name_37;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_631, const_str_plain_property );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 682;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_condition_result_48 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_48 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_25;
            }
            else
            {
                goto condexpr_false_25;
            }
            condexpr_true_25:;
            tmp_called_name_43 = PyObject_GetItem( locals_ssl_631, const_str_plain_property );

            if ( tmp_called_name_43 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 682;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }

            if ( tmp_called_name_43 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 682;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_args_element_name_36 = MAKE_FUNCTION_ssl$$$function_46_session_reused(  );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 682;
            {
                PyObject *call_args[] = { tmp_args_element_name_36 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_43, call_args );
            }

            Py_DECREF( tmp_called_name_43 );
            Py_DECREF( tmp_args_element_name_36 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 682;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            goto condexpr_end_25;
            condexpr_false_25:;
            tmp_called_name_44 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_37 = MAKE_FUNCTION_ssl$$$function_46_session_reused(  );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 682;
            {
                PyObject *call_args[] = { tmp_args_element_name_37 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_44, call_args );
            }

            Py_DECREF( tmp_args_element_name_37 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 682;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            condexpr_end_25:;
            tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_session_reused, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 682;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
        }
        {
            nuitka_bool tmp_condition_result_49;
            PyObject *tmp_called_name_45;
            PyObject *tmp_args_element_name_38;
            PyObject *tmp_called_name_46;
            PyObject *tmp_args_element_name_39;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_631, const_str_plain_property );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 687;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_condition_result_49 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_49 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_26;
            }
            else
            {
                goto condexpr_false_26;
            }
            condexpr_true_26:;
            tmp_called_name_45 = PyObject_GetItem( locals_ssl_631, const_str_plain_property );

            if ( tmp_called_name_45 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 687;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }

            if ( tmp_called_name_45 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 687;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_args_element_name_38 = MAKE_FUNCTION_ssl$$$function_47_server_side(  );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 687;
            {
                PyObject *call_args[] = { tmp_args_element_name_38 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_45, call_args );
            }

            Py_DECREF( tmp_called_name_45 );
            Py_DECREF( tmp_args_element_name_38 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 687;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            goto condexpr_end_26;
            condexpr_false_26:;
            tmp_called_name_46 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_39 = MAKE_FUNCTION_ssl$$$function_47_server_side(  );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 687;
            {
                PyObject *call_args[] = { tmp_args_element_name_39 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_46, call_args );
            }

            Py_DECREF( tmp_args_element_name_39 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 687;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            condexpr_end_26:;
            tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_server_side, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 687;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
        }
        {
            nuitka_bool tmp_condition_result_50;
            PyObject *tmp_called_name_47;
            PyObject *tmp_args_element_name_40;
            PyObject *tmp_called_name_48;
            PyObject *tmp_args_element_name_41;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_631, const_str_plain_property );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 692;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_condition_result_50 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_50 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_27;
            }
            else
            {
                goto condexpr_false_27;
            }
            condexpr_true_27:;
            tmp_called_name_47 = PyObject_GetItem( locals_ssl_631, const_str_plain_property );

            if ( tmp_called_name_47 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 692;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }

            if ( tmp_called_name_47 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 692;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            tmp_args_element_name_40 = MAKE_FUNCTION_ssl$$$function_48_server_hostname(  );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 692;
            {
                PyObject *call_args[] = { tmp_args_element_name_40 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_47, call_args );
            }

            Py_DECREF( tmp_called_name_47 );
            Py_DECREF( tmp_args_element_name_40 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 692;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            goto condexpr_end_27;
            condexpr_false_27:;
            tmp_called_name_48 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_41 = MAKE_FUNCTION_ssl$$$function_48_server_hostname(  );



            frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame.f_lineno = 692;
            {
                PyObject *call_args[] = { tmp_args_element_name_41 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_48, call_args );
            }

            Py_DECREF( tmp_args_element_name_41 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 692;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
            condexpr_end_27:;
            tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_server_hostname, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 692;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
        }
        {
            PyObject *tmp_defaults_9;
            tmp_defaults_9 = const_tuple_int_pos_1024_none_tuple;
            Py_INCREF( tmp_defaults_9 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_49_read( tmp_defaults_9 );



            tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_read, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 698;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_50_write(  );



        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_write, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 710;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        {
            PyObject *tmp_defaults_10;
            tmp_defaults_10 = const_tuple_false_tuple;
            Py_INCREF( tmp_defaults_10 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_51_getpeercert( tmp_defaults_10 );



            tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_getpeercert, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 718;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_52_selected_npn_protocol(  );



        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_selected_npn_protocol, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 727;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_53_selected_alpn_protocol(  );



        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_selected_alpn_protocol, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 734;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_54_cipher(  );



        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_cipher, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 741;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_55_shared_ciphers(  );



        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_shared_ciphers, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 746;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_56_compression(  );



        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_compression, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 752;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_57_pending(  );



        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_pending, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 757;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_58_do_handshake(  );



        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_do_handshake, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 761;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_59_unwrap(  );



        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_unwrap, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 765;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        {
            PyObject *tmp_defaults_11;
            tmp_defaults_11 = const_tuple_str_digest_554140970ff737b96d003bcbb3246411_tuple;
            Py_INCREF( tmp_defaults_11 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_60_get_channel_binding( tmp_defaults_11 );



            tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_get_channel_binding, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 769;
                type_description_2 = "o";
                goto frame_exception_exit_7;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_61_version(  );



        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_version, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 775;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_62_verify_client_post_handshake(  );



        tmp_res = PyObject_SetItem( locals_ssl_631, const_str_plain_verify_client_post_handshake, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 780;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_ca8bc35da6fc8bd12302bc56dc472f30_7 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_6;

        frame_exception_exit_7:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_ca8bc35da6fc8bd12302bc56dc472f30_7 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_ca8bc35da6fc8bd12302bc56dc472f30_7, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_ca8bc35da6fc8bd12302bc56dc472f30_7->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_ca8bc35da6fc8bd12302bc56dc472f30_7, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_ca8bc35da6fc8bd12302bc56dc472f30_7,
            type_description_2,
            outline_5_var___class__
        );


        // Release cached frame.
        if ( frame_ca8bc35da6fc8bd12302bc56dc472f30_7 == cache_frame_ca8bc35da6fc8bd12302bc56dc472f30_7 )
        {
            Py_DECREF( frame_ca8bc35da6fc8bd12302bc56dc472f30_7 );
        }
        cache_frame_ca8bc35da6fc8bd12302bc56dc472f30_7 = NULL;

        assertFrameObject( frame_ca8bc35da6fc8bd12302bc56dc472f30_7 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_6;

        frame_no_exception_6:;
        goto skip_nested_handling_6;
        nested_frame_exit_6:;

        goto try_except_handler_33;
        skip_nested_handling_6:;
        {
            PyObject *tmp_assign_source_130;
            PyObject *tmp_called_name_49;
            PyObject *tmp_args_name_16;
            PyObject *tmp_tuple_element_28;
            PyObject *tmp_kw_name_16;
            CHECK_OBJECT( tmp_class_creation_5__metaclass );
            tmp_called_name_49 = tmp_class_creation_5__metaclass;
            tmp_tuple_element_28 = const_str_plain_SSLObject;
            tmp_args_name_16 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_28 );
            PyTuple_SET_ITEM( tmp_args_name_16, 0, tmp_tuple_element_28 );
            tmp_tuple_element_28 = const_tuple_empty;
            Py_INCREF( tmp_tuple_element_28 );
            PyTuple_SET_ITEM( tmp_args_name_16, 1, tmp_tuple_element_28 );
            tmp_tuple_element_28 = locals_ssl_631;
            Py_INCREF( tmp_tuple_element_28 );
            PyTuple_SET_ITEM( tmp_args_name_16, 2, tmp_tuple_element_28 );
            CHECK_OBJECT( tmp_class_creation_5__class_decl_dict );
            tmp_kw_name_16 = tmp_class_creation_5__class_decl_dict;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 631;
            tmp_assign_source_130 = CALL_FUNCTION( tmp_called_name_49, tmp_args_name_16, tmp_kw_name_16 );
            Py_DECREF( tmp_args_name_16 );
            if ( tmp_assign_source_130 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 631;

                goto try_except_handler_33;
            }
            assert( outline_5_var___class__ == NULL );
            outline_5_var___class__ = tmp_assign_source_130;
        }
        CHECK_OBJECT( outline_5_var___class__ );
        tmp_assign_source_129 = outline_5_var___class__;
        Py_INCREF( tmp_assign_source_129 );
        goto try_return_handler_33;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_33:;
        Py_DECREF( locals_ssl_631 );
        locals_ssl_631 = NULL;
        goto try_return_handler_32;
        // Exception handler code:
        try_except_handler_33:;
        exception_keeper_type_31 = exception_type;
        exception_keeper_value_31 = exception_value;
        exception_keeper_tb_31 = exception_tb;
        exception_keeper_lineno_31 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ssl_631 );
        locals_ssl_631 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_31;
        exception_value = exception_keeper_value_31;
        exception_tb = exception_keeper_tb_31;
        exception_lineno = exception_keeper_lineno_31;

        goto try_except_handler_32;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_32:;
        CHECK_OBJECT( (PyObject *)outline_5_var___class__ );
        Py_DECREF( outline_5_var___class__ );
        outline_5_var___class__ = NULL;

        goto outline_result_6;
        // Exception handler code:
        try_except_handler_32:;
        exception_keeper_type_32 = exception_type;
        exception_keeper_value_32 = exception_value;
        exception_keeper_tb_32 = exception_tb;
        exception_keeper_lineno_32 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_32;
        exception_value = exception_keeper_value_32;
        exception_tb = exception_keeper_tb_32;
        exception_lineno = exception_keeper_lineno_32;

        goto outline_exception_6;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_6:;
        exception_lineno = 631;
        goto try_except_handler_31;
        outline_result_6:;
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLObject, tmp_assign_source_129 );
    }
    goto try_end_21;
    // Exception handler code:
    try_except_handler_31:;
    exception_keeper_type_33 = exception_type;
    exception_keeper_value_33 = exception_value;
    exception_keeper_tb_33 = exception_tb;
    exception_keeper_lineno_33 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class_decl_dict );
    Py_DECREF( tmp_class_creation_5__class_decl_dict );
    tmp_class_creation_5__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_5__prepared );
    tmp_class_creation_5__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_33;
    exception_value = exception_keeper_value_33;
    exception_tb = exception_keeper_tb_33;
    exception_lineno = exception_keeper_lineno_33;

    goto frame_exception_exit_1;
    // End of try:
    try_end_21:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class_decl_dict );
    Py_DECREF( tmp_class_creation_5__class_decl_dict );
    tmp_class_creation_5__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__metaclass );
    Py_DECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__prepared );
    Py_DECREF( tmp_class_creation_5__prepared );
    tmp_class_creation_5__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_131;
        PyObject *tmp_tuple_element_29;
        PyObject *tmp_mvar_value_48;
        tmp_mvar_value_48 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_socket );

        if (unlikely( tmp_mvar_value_48 == NULL ))
        {
            tmp_mvar_value_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_socket );
        }

        if ( tmp_mvar_value_48 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "socket" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 784;

            goto try_except_handler_34;
        }

        tmp_tuple_element_29 = tmp_mvar_value_48;
        tmp_assign_source_131 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_29 );
        PyTuple_SET_ITEM( tmp_assign_source_131, 0, tmp_tuple_element_29 );
        assert( tmp_class_creation_6__bases_orig == NULL );
        tmp_class_creation_6__bases_orig = tmp_assign_source_131;
    }
    {
        PyObject *tmp_assign_source_132;
        PyObject *tmp_dircall_arg1_5;
        CHECK_OBJECT( tmp_class_creation_6__bases_orig );
        tmp_dircall_arg1_5 = tmp_class_creation_6__bases_orig;
        Py_INCREF( tmp_dircall_arg1_5 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_5};
            tmp_assign_source_132 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_132 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;

            goto try_except_handler_34;
        }
        assert( tmp_class_creation_6__bases == NULL );
        tmp_class_creation_6__bases = tmp_assign_source_132;
    }
    {
        PyObject *tmp_assign_source_133;
        tmp_assign_source_133 = PyDict_New();
        assert( tmp_class_creation_6__class_decl_dict == NULL );
        tmp_class_creation_6__class_decl_dict = tmp_assign_source_133;
    }
    {
        PyObject *tmp_assign_source_134;
        PyObject *tmp_metaclass_name_6;
        nuitka_bool tmp_condition_result_51;
        PyObject *tmp_key_name_16;
        PyObject *tmp_dict_name_16;
        PyObject *tmp_dict_name_17;
        PyObject *tmp_key_name_17;
        nuitka_bool tmp_condition_result_52;
        int tmp_truth_name_7;
        PyObject *tmp_type_arg_10;
        PyObject *tmp_subscribed_name_5;
        PyObject *tmp_subscript_name_5;
        PyObject *tmp_bases_name_6;
        tmp_key_name_16 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_6__class_decl_dict );
        tmp_dict_name_16 = tmp_class_creation_6__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_16, tmp_key_name_16 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;

            goto try_except_handler_34;
        }
        tmp_condition_result_51 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_51 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_28;
        }
        else
        {
            goto condexpr_false_28;
        }
        condexpr_true_28:;
        CHECK_OBJECT( tmp_class_creation_6__class_decl_dict );
        tmp_dict_name_17 = tmp_class_creation_6__class_decl_dict;
        tmp_key_name_17 = const_str_plain_metaclass;
        tmp_metaclass_name_6 = DICT_GET_ITEM( tmp_dict_name_17, tmp_key_name_17 );
        if ( tmp_metaclass_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;

            goto try_except_handler_34;
        }
        goto condexpr_end_28;
        condexpr_false_28:;
        CHECK_OBJECT( tmp_class_creation_6__bases );
        tmp_truth_name_7 = CHECK_IF_TRUE( tmp_class_creation_6__bases );
        if ( tmp_truth_name_7 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;

            goto try_except_handler_34;
        }
        tmp_condition_result_52 = tmp_truth_name_7 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_52 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_29;
        }
        else
        {
            goto condexpr_false_29;
        }
        condexpr_true_29:;
        CHECK_OBJECT( tmp_class_creation_6__bases );
        tmp_subscribed_name_5 = tmp_class_creation_6__bases;
        tmp_subscript_name_5 = const_int_0;
        tmp_type_arg_10 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_5, tmp_subscript_name_5, 0 );
        if ( tmp_type_arg_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;

            goto try_except_handler_34;
        }
        tmp_metaclass_name_6 = BUILTIN_TYPE1( tmp_type_arg_10 );
        Py_DECREF( tmp_type_arg_10 );
        if ( tmp_metaclass_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;

            goto try_except_handler_34;
        }
        goto condexpr_end_29;
        condexpr_false_29:;
        tmp_metaclass_name_6 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_6 );
        condexpr_end_29:;
        condexpr_end_28:;
        CHECK_OBJECT( tmp_class_creation_6__bases );
        tmp_bases_name_6 = tmp_class_creation_6__bases;
        tmp_assign_source_134 = SELECT_METACLASS( tmp_metaclass_name_6, tmp_bases_name_6 );
        Py_DECREF( tmp_metaclass_name_6 );
        if ( tmp_assign_source_134 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;

            goto try_except_handler_34;
        }
        assert( tmp_class_creation_6__metaclass == NULL );
        tmp_class_creation_6__metaclass = tmp_assign_source_134;
    }
    {
        nuitka_bool tmp_condition_result_53;
        PyObject *tmp_key_name_18;
        PyObject *tmp_dict_name_18;
        tmp_key_name_18 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_6__class_decl_dict );
        tmp_dict_name_18 = tmp_class_creation_6__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_18, tmp_key_name_18 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;

            goto try_except_handler_34;
        }
        tmp_condition_result_53 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_53 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_24;
        }
        else
        {
            goto branch_no_24;
        }
        branch_yes_24:;
        CHECK_OBJECT( tmp_class_creation_6__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_6__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;

            goto try_except_handler_34;
        }
        branch_no_24:;
    }
    {
        nuitka_bool tmp_condition_result_54;
        PyObject *tmp_source_name_43;
        CHECK_OBJECT( tmp_class_creation_6__metaclass );
        tmp_source_name_43 = tmp_class_creation_6__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_43, const_str_plain___prepare__ );
        tmp_condition_result_54 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_54 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_25;
        }
        else
        {
            goto branch_no_25;
        }
        branch_yes_25:;
        {
            PyObject *tmp_assign_source_135;
            PyObject *tmp_called_name_50;
            PyObject *tmp_source_name_44;
            PyObject *tmp_args_name_17;
            PyObject *tmp_tuple_element_30;
            PyObject *tmp_kw_name_17;
            CHECK_OBJECT( tmp_class_creation_6__metaclass );
            tmp_source_name_44 = tmp_class_creation_6__metaclass;
            tmp_called_name_50 = LOOKUP_ATTRIBUTE( tmp_source_name_44, const_str_plain___prepare__ );
            if ( tmp_called_name_50 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 784;

                goto try_except_handler_34;
            }
            tmp_tuple_element_30 = const_str_plain_SSLSocket;
            tmp_args_name_17 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_30 );
            PyTuple_SET_ITEM( tmp_args_name_17, 0, tmp_tuple_element_30 );
            CHECK_OBJECT( tmp_class_creation_6__bases );
            tmp_tuple_element_30 = tmp_class_creation_6__bases;
            Py_INCREF( tmp_tuple_element_30 );
            PyTuple_SET_ITEM( tmp_args_name_17, 1, tmp_tuple_element_30 );
            CHECK_OBJECT( tmp_class_creation_6__class_decl_dict );
            tmp_kw_name_17 = tmp_class_creation_6__class_decl_dict;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 784;
            tmp_assign_source_135 = CALL_FUNCTION( tmp_called_name_50, tmp_args_name_17, tmp_kw_name_17 );
            Py_DECREF( tmp_called_name_50 );
            Py_DECREF( tmp_args_name_17 );
            if ( tmp_assign_source_135 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 784;

                goto try_except_handler_34;
            }
            assert( tmp_class_creation_6__prepared == NULL );
            tmp_class_creation_6__prepared = tmp_assign_source_135;
        }
        {
            nuitka_bool tmp_condition_result_55;
            PyObject *tmp_operand_name_7;
            PyObject *tmp_source_name_45;
            CHECK_OBJECT( tmp_class_creation_6__prepared );
            tmp_source_name_45 = tmp_class_creation_6__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_45, const_str_plain___getitem__ );
            tmp_operand_name_7 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_7 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 784;

                goto try_except_handler_34;
            }
            tmp_condition_result_55 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_55 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_26;
            }
            else
            {
                goto branch_no_26;
            }
            branch_yes_26:;
            {
                PyObject *tmp_raise_type_6;
                PyObject *tmp_raise_value_6;
                PyObject *tmp_left_name_6;
                PyObject *tmp_right_name_6;
                PyObject *tmp_tuple_element_31;
                PyObject *tmp_getattr_target_7;
                PyObject *tmp_getattr_attr_7;
                PyObject *tmp_getattr_default_7;
                PyObject *tmp_source_name_46;
                PyObject *tmp_type_arg_11;
                tmp_raise_type_6 = PyExc_TypeError;
                tmp_left_name_6 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_6__metaclass );
                tmp_getattr_target_7 = tmp_class_creation_6__metaclass;
                tmp_getattr_attr_7 = const_str_plain___name__;
                tmp_getattr_default_7 = const_str_angle_metaclass;
                tmp_tuple_element_31 = BUILTIN_GETATTR( tmp_getattr_target_7, tmp_getattr_attr_7, tmp_getattr_default_7 );
                if ( tmp_tuple_element_31 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 784;

                    goto try_except_handler_34;
                }
                tmp_right_name_6 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_6, 0, tmp_tuple_element_31 );
                CHECK_OBJECT( tmp_class_creation_6__prepared );
                tmp_type_arg_11 = tmp_class_creation_6__prepared;
                tmp_source_name_46 = BUILTIN_TYPE1( tmp_type_arg_11 );
                assert( !(tmp_source_name_46 == NULL) );
                tmp_tuple_element_31 = LOOKUP_ATTRIBUTE( tmp_source_name_46, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_46 );
                if ( tmp_tuple_element_31 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_6 );

                    exception_lineno = 784;

                    goto try_except_handler_34;
                }
                PyTuple_SET_ITEM( tmp_right_name_6, 1, tmp_tuple_element_31 );
                tmp_raise_value_6 = BINARY_OPERATION_REMAINDER( tmp_left_name_6, tmp_right_name_6 );
                Py_DECREF( tmp_right_name_6 );
                if ( tmp_raise_value_6 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 784;

                    goto try_except_handler_34;
                }
                exception_type = tmp_raise_type_6;
                Py_INCREF( tmp_raise_type_6 );
                exception_value = tmp_raise_value_6;
                exception_lineno = 784;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_34;
            }
            branch_no_26:;
        }
        goto branch_end_25;
        branch_no_25:;
        {
            PyObject *tmp_assign_source_136;
            tmp_assign_source_136 = PyDict_New();
            assert( tmp_class_creation_6__prepared == NULL );
            tmp_class_creation_6__prepared = tmp_assign_source_136;
        }
        branch_end_25:;
    }
    {
        PyObject *tmp_assign_source_137;
        {
            PyObject *tmp_set_locals_6;
            CHECK_OBJECT( tmp_class_creation_6__prepared );
            tmp_set_locals_6 = tmp_class_creation_6__prepared;
            locals_ssl_784 = tmp_set_locals_6;
            Py_INCREF( tmp_set_locals_6 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_ssl;
        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;

            goto try_except_handler_36;
        }
        tmp_dictset_value = const_str_digest_04ce73b765f1cc9fc45cba5d95755307;
        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;

            goto try_except_handler_36;
        }
        tmp_dictset_value = const_str_plain_SSLSocket;
        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;

            goto try_except_handler_36;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_283e017a64c5286699e9bc9396685a36_8, codeobj_283e017a64c5286699e9bc9396685a36, module_ssl, sizeof(void *) );
        frame_283e017a64c5286699e9bc9396685a36_8 = cache_frame_283e017a64c5286699e9bc9396685a36_8;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_283e017a64c5286699e9bc9396685a36_8 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_283e017a64c5286699e9bc9396685a36_8 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_63___init__(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 789;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        {
            nuitka_bool tmp_condition_result_56;
            PyObject *tmp_called_name_51;
            PyObject *tmp_args_element_name_42;
            PyObject *tmp_defaults_12;
            PyObject *tmp_classmethod_arg_4;
            PyObject *tmp_defaults_13;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_784, const_str_plain_classmethod );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 796;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_56 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_56 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_30;
            }
            else
            {
                goto condexpr_false_30;
            }
            condexpr_true_30:;
            tmp_called_name_51 = PyObject_GetItem( locals_ssl_784, const_str_plain_classmethod );

            if ( tmp_called_name_51 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "classmethod" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 796;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }

            if ( tmp_called_name_51 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 796;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            tmp_defaults_12 = const_tuple_false_true_true_none_none_none_tuple;
            Py_INCREF( tmp_defaults_12 );
            tmp_args_element_name_42 = MAKE_FUNCTION_ssl$$$function_64__create( tmp_defaults_12 );



            frame_283e017a64c5286699e9bc9396685a36_8->m_frame.f_lineno = 796;
            {
                PyObject *call_args[] = { tmp_args_element_name_42 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_51, call_args );
            }

            Py_DECREF( tmp_called_name_51 );
            Py_DECREF( tmp_args_element_name_42 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 796;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_30;
            condexpr_false_30:;
            tmp_defaults_13 = const_tuple_false_true_true_none_none_none_tuple;
            Py_INCREF( tmp_defaults_13 );
            tmp_classmethod_arg_4 = MAKE_FUNCTION_ssl$$$function_64__create( tmp_defaults_13 );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_4 );
            Py_DECREF( tmp_classmethod_arg_4 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 796;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            condexpr_end_30:;
            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain__create, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 796;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        {
            nuitka_bool tmp_condition_result_57;
            PyObject *tmp_called_name_52;
            PyObject *tmp_args_element_name_43;
            PyObject *tmp_called_name_53;
            PyObject *tmp_args_element_name_44;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_784, const_str_plain_property );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 859;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_57 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_57 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_31;
            }
            else
            {
                goto condexpr_false_31;
            }
            condexpr_true_31:;
            tmp_called_name_52 = PyObject_GetItem( locals_ssl_784, const_str_plain_property );

            if ( tmp_called_name_52 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 859;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }

            if ( tmp_called_name_52 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 859;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_43 = MAKE_FUNCTION_ssl$$$function_65_context(  );



            frame_283e017a64c5286699e9bc9396685a36_8->m_frame.f_lineno = 859;
            {
                PyObject *call_args[] = { tmp_args_element_name_43 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_52, call_args );
            }

            Py_DECREF( tmp_called_name_52 );
            Py_DECREF( tmp_args_element_name_43 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 859;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_31;
            condexpr_false_31:;
            tmp_called_name_53 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_44 = MAKE_FUNCTION_ssl$$$function_65_context(  );



            frame_283e017a64c5286699e9bc9396685a36_8->m_frame.f_lineno = 859;
            {
                PyObject *call_args[] = { tmp_args_element_name_44 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_53, call_args );
            }

            Py_DECREF( tmp_args_element_name_44 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 859;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            condexpr_end_31:;
            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_context, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 859;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_called_instance_10;
            PyObject *tmp_args_element_name_45;
            tmp_called_instance_10 = PyObject_GetItem( locals_ssl_784, const_str_plain_context );

            if ( tmp_called_instance_10 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "context" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 863;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }

            if ( tmp_called_instance_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 863;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_45 = MAKE_FUNCTION_ssl$$$function_66_context(  );



            frame_283e017a64c5286699e9bc9396685a36_8->m_frame.f_lineno = 863;
            {
                PyObject *call_args[] = { tmp_args_element_name_45 };
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_10, const_str_plain_setter, call_args );
            }

            Py_DECREF( tmp_called_instance_10 );
            Py_DECREF( tmp_args_element_name_45 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 863;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_context, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 863;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        {
            nuitka_bool tmp_condition_result_58;
            PyObject *tmp_called_name_54;
            PyObject *tmp_args_element_name_46;
            PyObject *tmp_called_name_55;
            PyObject *tmp_args_element_name_47;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_784, const_str_plain_property );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 868;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_58 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_58 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_32;
            }
            else
            {
                goto condexpr_false_32;
            }
            condexpr_true_32:;
            tmp_called_name_54 = PyObject_GetItem( locals_ssl_784, const_str_plain_property );

            if ( tmp_called_name_54 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 868;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }

            if ( tmp_called_name_54 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 868;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_46 = MAKE_FUNCTION_ssl$$$function_67_session(  );



            frame_283e017a64c5286699e9bc9396685a36_8->m_frame.f_lineno = 868;
            {
                PyObject *call_args[] = { tmp_args_element_name_46 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_54, call_args );
            }

            Py_DECREF( tmp_called_name_54 );
            Py_DECREF( tmp_args_element_name_46 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 868;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_32;
            condexpr_false_32:;
            tmp_called_name_55 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_47 = MAKE_FUNCTION_ssl$$$function_67_session(  );



            frame_283e017a64c5286699e9bc9396685a36_8->m_frame.f_lineno = 868;
            {
                PyObject *call_args[] = { tmp_args_element_name_47 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_55, call_args );
            }

            Py_DECREF( tmp_args_element_name_47 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 868;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            condexpr_end_32:;
            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_session, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 868;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_called_instance_11;
            PyObject *tmp_args_element_name_48;
            tmp_called_instance_11 = PyObject_GetItem( locals_ssl_784, const_str_plain_session );

            if ( tmp_called_instance_11 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "session" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 874;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }

            if ( tmp_called_instance_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 874;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_48 = MAKE_FUNCTION_ssl$$$function_68_session(  );



            frame_283e017a64c5286699e9bc9396685a36_8->m_frame.f_lineno = 874;
            {
                PyObject *call_args[] = { tmp_args_element_name_48 };
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_11, const_str_plain_setter, call_args );
            }

            Py_DECREF( tmp_called_instance_11 );
            Py_DECREF( tmp_args_element_name_48 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 874;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_session, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 874;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        {
            nuitka_bool tmp_condition_result_59;
            PyObject *tmp_called_name_56;
            PyObject *tmp_args_element_name_49;
            PyObject *tmp_called_name_57;
            PyObject *tmp_args_element_name_50;
            tmp_res = MAPPING_HAS_ITEM( locals_ssl_784, const_str_plain_property );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 880;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_59 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_59 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_33;
            }
            else
            {
                goto condexpr_false_33;
            }
            condexpr_true_33:;
            tmp_called_name_56 = PyObject_GetItem( locals_ssl_784, const_str_plain_property );

            if ( tmp_called_name_56 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "property" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 880;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }

            if ( tmp_called_name_56 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 880;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_49 = MAKE_FUNCTION_ssl$$$function_69_session_reused(  );



            frame_283e017a64c5286699e9bc9396685a36_8->m_frame.f_lineno = 880;
            {
                PyObject *call_args[] = { tmp_args_element_name_49 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_56, call_args );
            }

            Py_DECREF( tmp_called_name_56 );
            Py_DECREF( tmp_args_element_name_49 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 880;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_33;
            condexpr_false_33:;
            tmp_called_name_57 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_50 = MAKE_FUNCTION_ssl$$$function_69_session_reused(  );



            frame_283e017a64c5286699e9bc9396685a36_8->m_frame.f_lineno = 880;
            {
                PyObject *call_args[] = { tmp_args_element_name_50 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_57, call_args );
            }

            Py_DECREF( tmp_args_element_name_50 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 880;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
            condexpr_end_33:;
            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_session_reused, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 880;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_70_dup(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_dup, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 886;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        {
            PyObject *tmp_defaults_14;
            tmp_defaults_14 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_14 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_71__checkClosed( tmp_defaults_14 );



            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain__checkClosed, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 890;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_72__check_connected(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain__check_connected, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 894;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        {
            PyObject *tmp_defaults_15;
            tmp_defaults_15 = const_tuple_int_pos_1024_none_tuple;
            Py_INCREF( tmp_defaults_15 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_73_read( tmp_defaults_15 );



            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_read, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 902;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_74_write(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_write, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 923;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        {
            PyObject *tmp_defaults_16;
            tmp_defaults_16 = const_tuple_false_tuple;
            Py_INCREF( tmp_defaults_16 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_75_getpeercert( tmp_defaults_16 );



            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_getpeercert, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 932;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_76_selected_npn_protocol(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_selected_npn_protocol, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 942;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_77_selected_alpn_protocol(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_selected_alpn_protocol, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 949;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_78_cipher(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_cipher, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 956;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_79_shared_ciphers(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_shared_ciphers, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 963;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_80_compression(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_compression, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 970;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        {
            PyObject *tmp_defaults_17;
            tmp_defaults_17 = const_tuple_int_0_tuple;
            Py_INCREF( tmp_defaults_17 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_81_send( tmp_defaults_17 );

            ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_6_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_send, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 977;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_defaults_18;
            tmp_defaults_18 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_18 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_82_sendto( tmp_defaults_18 );

            ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_6_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_sendto, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 988;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_83_sendmsg(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_sendmsg, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 998;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        {
            PyObject *tmp_defaults_19;
            tmp_defaults_19 = const_tuple_int_0_tuple;
            Py_INCREF( tmp_defaults_19 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_84_sendall( tmp_defaults_19 );

            ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_6_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_sendall, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1004;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_defaults_20;
            tmp_defaults_20 = const_tuple_int_0_none_tuple;
            Py_INCREF( tmp_defaults_20 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_85_sendfile( tmp_defaults_20 );

            ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_6_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_sendfile, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1020;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_defaults_21;
            tmp_defaults_21 = const_tuple_int_pos_1024_int_0_tuple;
            Py_INCREF( tmp_defaults_21 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_86_recv( tmp_defaults_21 );

            ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_6_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_recv, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1030;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_defaults_22;
            tmp_defaults_22 = const_tuple_none_int_0_tuple;
            Py_INCREF( tmp_defaults_22 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_87_recv_into( tmp_defaults_22 );

            ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_6_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_recv_into, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1041;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_defaults_23;
            tmp_defaults_23 = const_tuple_int_pos_1024_int_0_tuple;
            Py_INCREF( tmp_defaults_23 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_88_recvfrom( tmp_defaults_23 );

            ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_6_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_recvfrom, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1056;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_defaults_24;
            tmp_defaults_24 = const_tuple_none_int_0_tuple;
            Py_INCREF( tmp_defaults_24 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_89_recvfrom_into( tmp_defaults_24 );

            ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_6_var___class__;
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_recvfrom_into, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1064;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_90_recvmsg(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_recvmsg, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1072;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_91_recvmsg_into(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_recvmsg_into, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1076;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_92_pending(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_pending, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1080;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_93_shutdown(  );

        ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_6_var___class__;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_shutdown, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1087;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_94_unwrap(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_unwrap, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1092;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_95_verify_client_post_handshake(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_verify_client_post_handshake, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1100;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_96__real_close(  );

        ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_6_var___class__;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain__real_close, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1106;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        {
            PyObject *tmp_defaults_25;
            tmp_defaults_25 = const_tuple_false_tuple;
            Py_INCREF( tmp_defaults_25 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_97_do_handshake( tmp_defaults_25 );



            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_do_handshake, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1110;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_98__real_connect(  );

        ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_6_var___class__;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain__real_connect, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1121;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_99_connect(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_connect, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1147;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_100_connect_ex(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_connect_ex, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1152;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_101_accept(  );

        ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] = outline_6_var___class__;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_dictset_value)->m_closure[0] );


        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_accept, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1157;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }
        {
            PyObject *tmp_defaults_26;
            tmp_defaults_26 = const_tuple_str_digest_554140970ff737b96d003bcbb3246411_tuple;
            Py_INCREF( tmp_defaults_26 );
            tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_102_get_channel_binding( tmp_defaults_26 );



            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_get_channel_binding, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1169;
                type_description_2 = "c";
                goto frame_exception_exit_8;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_ssl$$$function_103_version(  );



        tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain_version, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1183;
            type_description_2 = "c";
            goto frame_exception_exit_8;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_283e017a64c5286699e9bc9396685a36_8 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_7;

        frame_exception_exit_8:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_283e017a64c5286699e9bc9396685a36_8 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_283e017a64c5286699e9bc9396685a36_8, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_283e017a64c5286699e9bc9396685a36_8->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_283e017a64c5286699e9bc9396685a36_8, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_283e017a64c5286699e9bc9396685a36_8,
            type_description_2,
            outline_6_var___class__
        );


        // Release cached frame.
        if ( frame_283e017a64c5286699e9bc9396685a36_8 == cache_frame_283e017a64c5286699e9bc9396685a36_8 )
        {
            Py_DECREF( frame_283e017a64c5286699e9bc9396685a36_8 );
        }
        cache_frame_283e017a64c5286699e9bc9396685a36_8 = NULL;

        assertFrameObject( frame_283e017a64c5286699e9bc9396685a36_8 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_7;

        frame_no_exception_7:;
        goto skip_nested_handling_7;
        nested_frame_exit_7:;

        goto try_except_handler_36;
        skip_nested_handling_7:;
        {
            nuitka_bool tmp_condition_result_60;
            PyObject *tmp_compexpr_left_7;
            PyObject *tmp_compexpr_right_7;
            CHECK_OBJECT( tmp_class_creation_6__bases );
            tmp_compexpr_left_7 = tmp_class_creation_6__bases;
            CHECK_OBJECT( tmp_class_creation_6__bases_orig );
            tmp_compexpr_right_7 = tmp_class_creation_6__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_7, tmp_compexpr_right_7 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 784;

                goto try_except_handler_36;
            }
            tmp_condition_result_60 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_60 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_27;
            }
            else
            {
                goto branch_no_27;
            }
            branch_yes_27:;
            CHECK_OBJECT( tmp_class_creation_6__bases_orig );
            tmp_dictset_value = tmp_class_creation_6__bases_orig;
            tmp_res = PyObject_SetItem( locals_ssl_784, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 784;

                goto try_except_handler_36;
            }
            branch_no_27:;
        }
        {
            PyObject *tmp_assign_source_138;
            PyObject *tmp_called_name_58;
            PyObject *tmp_args_name_18;
            PyObject *tmp_tuple_element_32;
            PyObject *tmp_kw_name_18;
            CHECK_OBJECT( tmp_class_creation_6__metaclass );
            tmp_called_name_58 = tmp_class_creation_6__metaclass;
            tmp_tuple_element_32 = const_str_plain_SSLSocket;
            tmp_args_name_18 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_32 );
            PyTuple_SET_ITEM( tmp_args_name_18, 0, tmp_tuple_element_32 );
            CHECK_OBJECT( tmp_class_creation_6__bases );
            tmp_tuple_element_32 = tmp_class_creation_6__bases;
            Py_INCREF( tmp_tuple_element_32 );
            PyTuple_SET_ITEM( tmp_args_name_18, 1, tmp_tuple_element_32 );
            tmp_tuple_element_32 = locals_ssl_784;
            Py_INCREF( tmp_tuple_element_32 );
            PyTuple_SET_ITEM( tmp_args_name_18, 2, tmp_tuple_element_32 );
            CHECK_OBJECT( tmp_class_creation_6__class_decl_dict );
            tmp_kw_name_18 = tmp_class_creation_6__class_decl_dict;
            frame_5fd67fa0e731842652c5161aa118e079->m_frame.f_lineno = 784;
            tmp_assign_source_138 = CALL_FUNCTION( tmp_called_name_58, tmp_args_name_18, tmp_kw_name_18 );
            Py_DECREF( tmp_args_name_18 );
            if ( tmp_assign_source_138 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 784;

                goto try_except_handler_36;
            }
            {
                PyObject *old = PyCell_GET( outline_6_var___class__ );
                PyCell_SET( outline_6_var___class__, tmp_assign_source_138 );
                Py_XDECREF( old );
            }

        }
        CHECK_OBJECT( PyCell_GET( outline_6_var___class__ ) );
        tmp_assign_source_137 = PyCell_GET( outline_6_var___class__ );
        Py_INCREF( tmp_assign_source_137 );
        goto try_return_handler_36;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_36:;
        Py_DECREF( locals_ssl_784 );
        locals_ssl_784 = NULL;
        goto try_return_handler_35;
        // Exception handler code:
        try_except_handler_36:;
        exception_keeper_type_34 = exception_type;
        exception_keeper_value_34 = exception_value;
        exception_keeper_tb_34 = exception_tb;
        exception_keeper_lineno_34 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_ssl_784 );
        locals_ssl_784 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_34;
        exception_value = exception_keeper_value_34;
        exception_tb = exception_keeper_tb_34;
        exception_lineno = exception_keeper_lineno_34;

        goto try_except_handler_35;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_35:;
        CHECK_OBJECT( (PyObject *)outline_6_var___class__ );
        Py_DECREF( outline_6_var___class__ );
        outline_6_var___class__ = NULL;

        goto outline_result_7;
        // Exception handler code:
        try_except_handler_35:;
        exception_keeper_type_35 = exception_type;
        exception_keeper_value_35 = exception_value;
        exception_keeper_tb_35 = exception_tb;
        exception_keeper_lineno_35 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)outline_6_var___class__ );
        Py_DECREF( outline_6_var___class__ );
        outline_6_var___class__ = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_35;
        exception_value = exception_keeper_value_35;
        exception_tb = exception_keeper_tb_35;
        exception_lineno = exception_keeper_lineno_35;

        goto outline_exception_7;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( ssl );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_7:;
        exception_lineno = 784;
        goto try_except_handler_34;
        outline_result_7:;
        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLSocket, tmp_assign_source_137 );
    }
    goto try_end_22;
    // Exception handler code:
    try_except_handler_34:;
    exception_keeper_type_36 = exception_type;
    exception_keeper_value_36 = exception_value;
    exception_keeper_tb_36 = exception_tb;
    exception_keeper_lineno_36 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_6__bases_orig );
    tmp_class_creation_6__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_6__bases );
    tmp_class_creation_6__bases = NULL;

    Py_XDECREF( tmp_class_creation_6__class_decl_dict );
    tmp_class_creation_6__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_6__prepared );
    tmp_class_creation_6__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_36;
    exception_value = exception_keeper_value_36;
    exception_tb = exception_keeper_tb_36;
    exception_lineno = exception_keeper_lineno_36;

    goto frame_exception_exit_1;
    // End of try:
    try_end_22:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__bases_orig );
    Py_DECREF( tmp_class_creation_6__bases_orig );
    tmp_class_creation_6__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__bases );
    Py_DECREF( tmp_class_creation_6__bases );
    tmp_class_creation_6__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class_decl_dict );
    Py_DECREF( tmp_class_creation_6__class_decl_dict );
    tmp_class_creation_6__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__metaclass );
    Py_DECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__prepared );
    Py_DECREF( tmp_class_creation_6__prepared );
    tmp_class_creation_6__prepared = NULL;

    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_mvar_value_49;
        PyObject *tmp_assattr_target_4;
        PyObject *tmp_mvar_value_50;
        tmp_mvar_value_49 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLSocket );

        if (unlikely( tmp_mvar_value_49 == NULL ))
        {
            tmp_mvar_value_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLSocket );
        }

        if ( tmp_mvar_value_49 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLSocket" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1195;

            goto frame_exception_exit_1;
        }

        tmp_assattr_name_4 = tmp_mvar_value_49;
        tmp_mvar_value_50 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_50 == NULL ))
        {
            tmp_mvar_value_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_50 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1195;

            goto frame_exception_exit_1;
        }

        tmp_assattr_target_4 = tmp_mvar_value_50;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_sslsocket_class, tmp_assattr_name_4 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1195;

            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_mvar_value_51;
        PyObject *tmp_assattr_target_5;
        PyObject *tmp_mvar_value_52;
        tmp_mvar_value_51 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLObject );

        if (unlikely( tmp_mvar_value_51 == NULL ))
        {
            tmp_mvar_value_51 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLObject );
        }

        if ( tmp_mvar_value_51 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLObject" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1196;

            goto frame_exception_exit_1;
        }

        tmp_assattr_name_5 = tmp_mvar_value_51;
        tmp_mvar_value_52 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_SSLContext );

        if (unlikely( tmp_mvar_value_52 == NULL ))
        {
            tmp_mvar_value_52 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLContext );
        }

        if ( tmp_mvar_value_52 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "SSLContext" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1196;

            goto frame_exception_exit_1;
        }

        tmp_assattr_target_5 = tmp_mvar_value_52;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_sslobject_class, tmp_assattr_name_5 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1196;

            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_139;
        PyObject *tmp_defaults_27;
        PyObject *tmp_tuple_element_33;
        PyObject *tmp_mvar_value_53;
        PyObject *tmp_mvar_value_54;
        tmp_tuple_element_33 = Py_None;
        tmp_defaults_27 = PyTuple_New( 9 );
        Py_INCREF( tmp_tuple_element_33 );
        PyTuple_SET_ITEM( tmp_defaults_27, 0, tmp_tuple_element_33 );
        tmp_tuple_element_33 = Py_None;
        Py_INCREF( tmp_tuple_element_33 );
        PyTuple_SET_ITEM( tmp_defaults_27, 1, tmp_tuple_element_33 );
        tmp_tuple_element_33 = Py_False;
        Py_INCREF( tmp_tuple_element_33 );
        PyTuple_SET_ITEM( tmp_defaults_27, 2, tmp_tuple_element_33 );
        tmp_mvar_value_53 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_CERT_NONE );

        if (unlikely( tmp_mvar_value_53 == NULL ))
        {
            tmp_mvar_value_53 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CERT_NONE );
        }

        if ( tmp_mvar_value_53 == NULL )
        {
            Py_DECREF( tmp_defaults_27 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CERT_NONE" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1200;

            goto frame_exception_exit_1;
        }

        tmp_tuple_element_33 = tmp_mvar_value_53;
        Py_INCREF( tmp_tuple_element_33 );
        PyTuple_SET_ITEM( tmp_defaults_27, 3, tmp_tuple_element_33 );
        tmp_mvar_value_54 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PROTOCOL_TLS );

        if (unlikely( tmp_mvar_value_54 == NULL ))
        {
            tmp_mvar_value_54 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PROTOCOL_TLS );
        }

        if ( tmp_mvar_value_54 == NULL )
        {
            Py_DECREF( tmp_defaults_27 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PROTOCOL_TLS" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1201;

            goto frame_exception_exit_1;
        }

        tmp_tuple_element_33 = tmp_mvar_value_54;
        Py_INCREF( tmp_tuple_element_33 );
        PyTuple_SET_ITEM( tmp_defaults_27, 4, tmp_tuple_element_33 );
        tmp_tuple_element_33 = Py_None;
        Py_INCREF( tmp_tuple_element_33 );
        PyTuple_SET_ITEM( tmp_defaults_27, 5, tmp_tuple_element_33 );
        tmp_tuple_element_33 = Py_True;
        Py_INCREF( tmp_tuple_element_33 );
        PyTuple_SET_ITEM( tmp_defaults_27, 6, tmp_tuple_element_33 );
        tmp_tuple_element_33 = Py_True;
        Py_INCREF( tmp_tuple_element_33 );
        PyTuple_SET_ITEM( tmp_defaults_27, 7, tmp_tuple_element_33 );
        tmp_tuple_element_33 = Py_None;
        Py_INCREF( tmp_tuple_element_33 );
        PyTuple_SET_ITEM( tmp_defaults_27, 8, tmp_tuple_element_33 );
        tmp_assign_source_139 = MAKE_FUNCTION_ssl$$$function_104_wrap_socket( tmp_defaults_27 );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_wrap_socket, tmp_assign_source_139 );
    }
    {
        PyObject *tmp_assign_source_140;
        tmp_assign_source_140 = MAKE_FUNCTION_ssl$$$function_105_cert_time_to_seconds(  );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_cert_time_to_seconds, tmp_assign_source_140 );
    }
    {
        PyObject *tmp_assign_source_141;
        tmp_assign_source_141 = const_str_digest_9b02e8f66087246f5290f408cd07f8d6;
        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PEM_HEADER, tmp_assign_source_141 );
    }
    {
        PyObject *tmp_assign_source_142;
        tmp_assign_source_142 = const_str_digest_c9e0ace64f4cd2826bb360e8a68ae1a8;
        UPDATE_STRING_DICT0( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PEM_FOOTER, tmp_assign_source_142 );
    }
    {
        PyObject *tmp_assign_source_143;
        tmp_assign_source_143 = MAKE_FUNCTION_ssl$$$function_106_DER_cert_to_PEM_cert(  );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_DER_cert_to_PEM_cert, tmp_assign_source_143 );
    }
    {
        PyObject *tmp_assign_source_144;
        tmp_assign_source_144 = MAKE_FUNCTION_ssl$$$function_107_PEM_cert_to_DER_cert(  );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PEM_cert_to_DER_cert, tmp_assign_source_144 );
    }
    {
        PyObject *tmp_assign_source_145;
        PyObject *tmp_defaults_28;
        PyObject *tmp_tuple_element_34;
        PyObject *tmp_mvar_value_55;
        tmp_mvar_value_55 = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_PROTOCOL_TLS );

        if (unlikely( tmp_mvar_value_55 == NULL ))
        {
            tmp_mvar_value_55 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PROTOCOL_TLS );
        }

        if ( tmp_mvar_value_55 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PROTOCOL_TLS" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1283;

            goto frame_exception_exit_1;
        }

        tmp_tuple_element_34 = tmp_mvar_value_55;
        tmp_defaults_28 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_34 );
        PyTuple_SET_ITEM( tmp_defaults_28, 0, tmp_tuple_element_34 );
        tmp_tuple_element_34 = Py_None;
        Py_INCREF( tmp_tuple_element_34 );
        PyTuple_SET_ITEM( tmp_defaults_28, 1, tmp_tuple_element_34 );
        tmp_assign_source_145 = MAKE_FUNCTION_ssl$$$function_108_get_server_certificate( tmp_defaults_28 );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_get_server_certificate, tmp_assign_source_145 );
    }

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5fd67fa0e731842652c5161aa118e079 );
#endif
    popFrameStack();

    assertFrameObject( frame_5fd67fa0e731842652c5161aa118e079 );

    goto frame_no_exception_8;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5fd67fa0e731842652c5161aa118e079 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5fd67fa0e731842652c5161aa118e079, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5fd67fa0e731842652c5161aa118e079->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5fd67fa0e731842652c5161aa118e079, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_8:;
    {
        PyObject *tmp_assign_source_146;
        tmp_assign_source_146 = MAKE_FUNCTION_ssl$$$function_109_get_protocol_name(  );



        UPDATE_STRING_DICT1( moduledict_ssl, (Nuitka_StringObject *)const_str_plain_get_protocol_name, tmp_assign_source_146 );
    }

#if _NUITKA_EXPERIMENTAL_PKGUTIL_ITERMODULES
#if 0 && 0
    {
        PyObject *path_value = GET_STRING_DICT_VALUE( moduledict_ssl, (Nuitka_StringObject *)const_str_plain___path__ );

        if (path_value && PyList_CheckExact(path_value) && PyList_Size(path_value) > 0)
        {
            PyObject *path_element = PyList_GetItem( path_value, 0 );

            PyObject *path_importer_cache = PySys_GetObject((char *)"path_importer_cache");
            CHECK_OBJECT( path_importer_cache );

            int res = PyDict_SetItem( path_importer_cache, path_element, (PyObject *)&Nuitka_Loader_Type );
            assert( res == 0 );
        }
    }
#endif
#endif

    return MOD_RETURN_VALUE( module_ssl );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
