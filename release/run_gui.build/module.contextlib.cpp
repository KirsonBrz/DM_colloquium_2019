/* Generated code for Python module 'contextlib'
 * created by Nuitka version 0.6.2
 *
 * This code is in part copyright 2019 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_contextlib" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_contextlib;
PyDictObject *moduledict_contextlib;

/* The declarations of module constants used, if any. */
static PyObject *const_str_plain_cb;
static PyObject *const_str_digest_5dcda8782ba35a75678a91209700af3e;
static PyObject *const_tuple_str_plain_self_str_plain_exc_info_tuple;
static PyObject *const_str_digest_b427544bbbefa85025737b449f92ef67;
static PyObject *const_str_digest_81336c6ee73db5493c214b89c035e61d;
extern PyObject *const_str_plain_inner;
static PyObject *const_tuple_4f1fa4ca5d2d9824e633f94f53baafb9_tuple;
extern PyObject *const_str_plain_result;
extern PyObject *const_str_plain_metaclass;
static PyObject *const_tuple_285275c053ca78d0b5fcb71ea58fcded_tuple;
extern PyObject *const_str_plain___spec__;
static PyObject *const_str_plain_excinfo;
static PyObject *const_str_plain___cause__;
static PyObject *const_str_plain__AsyncGeneratorContextManager;
extern PyObject *const_str_plain___name__;
extern PyObject *const_tuple_str_plain___class___tuple;
extern PyObject *const_str_angle_metaclass;
extern PyObject *const_str_plain_traceback;
extern PyObject *const_str_plain_object;
extern PyObject *const_str_plain___file__;
extern PyObject *const_str_plain_abc;
static PyObject *const_str_digest_013a524d3bf3493644ac1b41fa206eb2;
static PyObject *const_str_plain_pending_raise;
static PyObject *const_str_digest_c12dd3159c30879cf943be20228dc60c;
extern PyObject *const_str_plain_args;
static PyObject *const_str_digest_44fc253913aa80f6b51dedb3b194ecf6;
extern PyObject *const_str_plain___exit__;
static PyObject *const_str_digest_09d5c8d945353368df602f14ef2d947d;
static PyObject *const_str_plain_nullcontext;
static PyObject *const_str_digest_e363b48ed66180ea29569815ae2c814f;
static PyObject *const_str_plain_exctb;
static PyObject *const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple;
extern PyObject *const_str_plain__stream;
static PyObject *const_str_plain_gen;
static PyObject *const_str_digest_069d815edcbe4c452d78970be7a78ac2;
static PyObject *const_str_digest_7d7f62a9e44e7e680c51c869c602a010;
static PyObject *const_list_af5b310e02bd439cf8ca1c65e737fe3b_list;
static PyObject *const_str_digest_53f2bc37130ba4c17f452fdc4d047974;
static PyObject *const_str_digest_14d40be592e224e5e7136c1c40a4b531;
static PyObject *const_str_plain__GeneratorContextManager;
static PyObject *const_str_digest_9b9905bf1735b3c8d0d69a874343ee1c;
static PyObject *const_tuple_str_plain_func_str_plain_helper_tuple;
static PyObject *const_tuple_99e4f7d79998fef56c940fc534bd3d1a_tuple;
static PyObject *const_tuple_ca1557cefb10ceab4fdb9c9136a76a76_tuple;
static PyObject *const_str_digest_b7bfa96e1930f41166a4f32612e692f6;
static PyObject *const_str_digest_266a0e5c654ff0c5f2b193bf2c56d53a;
static PyObject *const_str_digest_a68aae16a095bf20f5b2dce3ef8bbc02;
extern PyObject *const_str_plain_abstractmethod;
extern PyObject *const_str_plain_staticmethod;
extern PyObject *const_str_plain_None;
static PyObject *const_str_digest_361410c9c3db1345a7a5859bf6b7df79;
extern PyObject *const_str_plain_classmethod;
extern PyObject *const_str_plain___enter__;
static PyObject *const_str_plain_new_target;
static PyObject *const_str_digest_292ad321106653ddbe62f853458ccdc4;
static PyObject *const_str_digest_25c2da89c50fb28a7c6a154308bd9afe;
static PyObject *const_tuple_str_plain_self_str_plain_excinfo_tuple;
extern PyObject *const_str_plain_cls;
extern PyObject *const_str_plain_func;
static PyObject *const_str_digest_c3a7e7986afc535e6f02c4ca2ab3a121;
static PyObject *const_str_digest_b577a7297d1ef67501fdbd40a3ef6040;
extern PyObject *const_str_plain_stdout;
static PyObject *const_str_plain_new_stack;
static PyObject *const_str_plain_suppress;
extern PyObject *const_tuple_none_none_none_tuple;
static PyObject *const_str_plain_suppressed_exc;
extern PyObject *const_tuple_true_tuple;
static PyObject *const_str_plain_AbstractContextManager;
static PyObject *const_str_plain___wrapped__;
static PyObject *const_str_digest_bdb887d2ae600fc55f8a3783f325d1b8;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_digest_ab10239cbb13ff94c3252ede7d4d1fce;
extern PyObject *const_str_plain_contextlib;
static PyObject *const_str_plain___subclasshook__;
static PyObject *const_str_digest_492c9a2e0339f0b460e318e83c406d2a;
static PyObject *const_str_plain_AsyncExitStack;
extern PyObject *const_str_plain___debug__;
extern PyObject *const_str_plain___orig_bases__;
static PyObject *const_tuple_str_plain_self_str_plain_enter_result_tuple;
static PyObject *const_tuple_str_plain_args_str_plain_kwds_str_plain_self_str_plain_func_tuple;
static PyObject *const_str_plain__GeneratorContextManagerBase;
static PyObject *const_str_digest_3194f1464a0dbee99d5da6e02a3ee3d6;
extern PyObject *const_str_plain_close;
static PyObject *const_str_digest_a0e0ee5062c8c89817864b9873626e91;
static PyObject *const_str_digest_27a9aa6471512d55712a8b3b3beb97a9;
static PyObject *const_str_plain_enter_result;
static PyObject *const_tuple_str_plain_cm_str_plain_cm_exit_str_plain__exit_wrapper_tuple;
static PyObject *const_str_digest_b09c25223d69ba668f56715025b1580f;
static PyObject *const_str_digest_4dbe0056da4a01eaffbc4834adabb195;
static PyObject *const_tuple_str_plain_cls_str_plain_C_tuple;
static PyObject *const_tuple_b69d8130dfe3195008f41e5d64bfb37e_tuple;
static PyObject *const_str_digest_d00d203588989ad33939a2d912ad1378;
extern PyObject *const_str_plain___qualname__;
static PyObject *const_str_digest_2f96db194079aab1e334d80c67e520d2;
static PyObject *const_str_digest_e8e9e8cf77df5602ad3518afa654e609;
static PyObject *const_str_plain_cb_suppress;
extern PyObject *const_str_plain__collections_abc;
static PyObject *const_str_digest_75420df2bc0eb7333ada17751936a384;
extern PyObject *const_str_plain_throw;
extern PyObject *const_str_plain_wraps;
static PyObject *const_str_plain__exit_wrapper;
static PyObject *const_str_plain_new_exc;
static PyObject *const_str_digest_e945221f7c26341208775e8abf72a8fa;
static PyObject *const_tuple_2c94856944fb81984faf2fe427737e40_tuple;
static PyObject *const_str_plain_helper;
static PyObject *const_str_digest_15c01fc29f9c1a2be6b00d45717358b0;
static PyObject *const_str_plain_redirect_stderr;
static PyObject *const_str_digest_d8ed76b736711588dc0441af0e3acdcb;
extern PyObject *const_str_plain_value;
static PyObject *const_tuple_str_plain__BaseExitStack_tuple_empty_tuple;
extern PyObject *const_tuple_str_plain_self_tuple;
extern PyObject *const_str_plain_collections;
static PyObject *const_str_digest_6ffe76711bdd5b699aa8c216d8ac87ec;
static PyObject *const_str_digest_1bd5d99d6eaccd3aded9fbcf030f961c;
extern PyObject *const_tuple_str_plain_deque_tuple;
static PyObject *const_str_digest_b7f7eed1cf6a5961dffed270fdd5feca;
static PyObject *const_str_plain_pop_all;
static PyObject *const_str_digest_c90ebf416c6b3426c3ced10ea695a8ab;
static PyObject *const_str_digest_9f3d2b5ab4e4cad7444ce685cb22d525;
static PyObject *const_tuple_24294d365f055f3473896705acca5164_tuple;
static PyObject *const_str_digest_0f0d45b1451f7c90ace5341c8d2acc76;
static PyObject *const_str_plain_exit_method;
static PyObject *const_str_plain_push_async_exit;
static PyObject *const_str_plain_athrow;
static PyObject *const_tuple_f7761c758733e94d335a6027b2f1d7bd_tuple;
extern PyObject *const_str_plain_exc_type;
extern PyObject *const_tuple_empty;
static PyObject *const_str_digest_6c74f90a83f8426d3debee986acb6dfb;
static PyObject *const_tuple_str_plain_args_str_plain_kwds_str_plain_func_tuple;
extern PyObject *const_str_plain_append;
extern PyObject *const_str_plain_issubclass;
extern PyObject *const_str_plain_stderr;
static PyObject *const_str_plain__cm_type;
static PyObject *const_str_plain_aclose;
static PyObject *const_tuple_str_plain_self_str_plain_new_target_tuple;
static PyObject *const_str_plain_cm;
static PyObject *const_str_plain__create_exit_wrapper;
static PyObject *const_str_digest_cd9499f90d1fdb125e1fc42bc99bc8bc;
static PyObject *const_str_plain__push_async_cm_exit;
static PyObject *const_str_digest_4cc0ab300f4fe8af2dc122c9eba3d7cc;
static PyObject *const_tuple_str_plain_self_str_plain_exceptions_tuple;
extern PyObject *const_str_plain_exceptions;
static PyObject *const_str_plain__fix_exception_context;
static PyObject *const_str_plain_cm_exit;
static PyObject *const_tuple_str_plain__GeneratorContextManagerBase_tuple_empty_tuple;
static PyObject *const_str_plain__old_targets;
static PyObject *const_str_digest_aa3df32e7619083adf0a2fbf5a235c36;
static PyObject *const_tuple_str_plain_self_str_plain_func_str_plain_inner_tuple;
static PyObject *const_str_plain_received_exc;
static PyObject *const_str_digest_561259968dad5e211e270f1bf7b5ddcc;
static PyObject *const_str_digest_fc380e569c01f57799c4fb3916d89707;
static PyObject *const_str_digest_43d77277e950cc565806fc3c134d250b;
static PyObject *const_str_digest_657b8bde9f38fd964044ea752e7ced2d;
extern PyObject *const_str_plain_contextmanager;
static PyObject *const_tuple_str_plain_self_str_plain_new_stack_tuple;
extern PyObject *const_str_plain__exit;
extern PyObject *const_str_plain_False;
static PyObject *const_str_plain__create_cb_wrapper;
static PyObject *const_str_digest_a35b309c4b1d53a114ad6b7b1cbbc3f0;
extern PyObject *const_str_plain___getitem__;
extern PyObject *const_str_plain___all__;
extern PyObject *const_tuple_str_plain_wraps_tuple;
static PyObject *const_str_plain__exit_callbacks;
static PyObject *const_str_digest_6616e0e68b690f14c87f57dc8a44bd85;
static PyObject *const_tuple_7a9619740519a6b4164e2a052f9465fb_tuple;
static PyObject *const_str_digest_6bf82b52b82827398412049d90b93095;
static PyObject *const_str_digest_3f30b003fbfc4f0bf645c8bc55efc51f;
extern PyObject *const_str_plain_pop;
static PyObject *const_str_plain_exc_details;
extern PyObject *const_int_0;
extern PyObject *const_str_plain_tb;
extern PyObject *const_str_plain_kwds;
static PyObject *const_str_digest_4a605543d290dbdf95f4c339df4f12b9;
static PyObject *const_str_digest_45f4e32fb936425e6aae2a495ddd5db3;
static PyObject *const_tuple_str_plain_self_str_plain_thing_tuple;
static PyObject *const_str_digest_5622473d84a607757f5490c88c2fc06a;
static PyObject *const_str_digest_6eef37f01b16f450b8a600bfc07c366e;
static PyObject *const_str_plain_AbstractAsyncContextManager;
static PyObject *const_str_plain__new_target;
static PyObject *const_str_plain__push_cm_exit;
static PyObject *const_str_digest_5b4233ef7f235a30c90a3520223ec395;
static PyObject *const_str_digest_072d893f430d6100c064aab7d47e5365;
static PyObject *const_str_digest_32920fc73b22ed7a2cae0938236ca756;
static PyObject *const_str_plain___aexit__;
extern PyObject *const_str_plain_redirect_stdout;
static PyObject *const_str_plain_frame_exc;
extern PyObject *const_str_plain_origin;
static PyObject *const_str_digest_88d158957b0ede9fb261f4e63b263f20;
static PyObject *const_str_plain_old_exc;
static PyObject *const_tuple_7b3d388a553c47f52835463197dbad6d_tuple;
extern PyObject *const_str_digest_75fd71b1edada749c2ef7ac810062295;
extern PyObject *const_str_plain_exc_info;
extern PyObject *const_str_plain_C;
static PyObject *const_str_digest_0324378fdaf4c0afbda1d52593df0b3d;
static PyObject *const_str_plain___anext__;
static PyObject *const_str_digest_df1f1d9b030254507b5122a26df9a71a;
static PyObject *const_str_digest_3e88ac70b637d24d9d579630d818ac0c;
extern PyObject *const_str_plain_callback;
extern PyObject *const_str_plain_thing;
extern PyObject *const_str_plain_type;
static PyObject *const_str_plain_exc_context;
static PyObject *const_str_digest_196928cdda2f74dcaa86496536d7d0c7;
static PyObject *const_str_plain_ContextDecorator;
extern PyObject *const_str_plain___cached__;
extern PyObject *const_str_plain_exit;
extern PyObject *const_str_plain___class__;
static PyObject *const_str_plain__create_async_exit_wrapper;
static PyObject *const_str_digest_be6e50fdf69f187f977c4e5d0f4f92c1;
static PyObject *const_str_plain__recreate_cm;
extern PyObject *const_str_plain_push;
static PyObject *const_str_plain_enter_context;
extern PyObject *const_tuple_none_tuple;
extern PyObject *const_str_plain___module__;
extern PyObject *const_tuple_type_object_tuple;
extern PyObject *const_str_plain_functools;
extern PyObject *const_str_plain_sys;
static PyObject *const_str_digest_8925bc3e79b6caccc0000e42e8cb2562;
static PyObject *const_str_plain_push_async_callback;
extern PyObject *const_str_plain_typ;
static PyObject *const_str_digest_738a6c63d8a7f3e6b47adb4108e7c9d1;
static PyObject *const_str_digest_5723e006fbbb84d1de871bcae3bcd023;
static PyObject *const_str_digest_a20d2b369cfee2d243317b2de658a730;
static PyObject *const_str_plain_enter_async_context;
extern PyObject *const_str_plain_doc;
static PyObject *const_str_digest_fb1417f379158cc513e12e6529ffb50b;
extern PyObject *const_int_pos_1;
static PyObject *const_tuple_59ad8b9a7b3958ff248ecbb0d59682e2_tuple;
static PyObject *const_str_plain_new_exc_details;
static PyObject *const_str_digest_de72cb85464cbf04e752b2f7df1e4103;
static PyObject *const_str_digest_d3e49cbb4b25449e156e86388d4299ad;
extern PyObject *const_str_plain_exc;
static PyObject *const_tuple_9bff1fb10d94302cf075ed06fe9c426d_tuple;
static PyObject *const_str_plain__RedirectStream;
extern PyObject *const_str_plain_deque;
static PyObject *const_str_plain__check_methods;
static PyObject *const_str_digest_b4cbc7dbf1044832ac051ba8cf22b782;
static PyObject *const_str_digest_82cfb07b0e6277928c3fe172bffa179f;
static PyObject *const_str_digest_d310a8f23c19ced2e835b7bda8daeaea;
extern PyObject *const_str_plain_exc_value;
static PyObject *const_str_plain_is_sync;
static PyObject *const_str_digest_767308c1e3e7512bcaf23b84f8ac277a;
static PyObject *const_str_plain_ExitStack;
static PyObject *const_str_plain_excinst;
extern PyObject *const_str_plain___prepare__;
static PyObject *const_str_plain__exceptions;
extern PyObject *const_str_plain___init__;
extern PyObject *const_str_plain_exctype;
static PyObject *const_tuple_type_StopIteration_type_StopAsyncIteration_tuple;
static PyObject *const_str_digest_454729390f92fd60b48378f2e1aa3db0;
static PyObject *const_tuple_e3d25ea3287460ab60449763727613f6_tuple;
extern PyObject *const_str_plain_self;
static PyObject *const_str_digest_c9273566575fea99bfeae6de0a02b843;
static PyObject *const_str_plain__BaseExitStack;
static PyObject *const_str_plain___context__;
extern PyObject *const_str_plain___call__;
static PyObject *const_str_digest_8a1dccae593581f4052d7559e1c2ae2c;
static PyObject *const_str_plain_fixed_ctx;
static PyObject *const_str_digest_dd701e09dbf36c7cd84ab2997f9a35cf;
static PyObject *const_str_digest_15e936ef3374424b98cf9aa15867b234;
static PyObject *const_str_digest_639ebec650f2fbedf493b5dd0b28ed77;
static PyObject *const_str_digest_496479db0a523e2af9244fc0d8332ffd;
static PyObject *const_tuple_4056a0ef07ec9188d15ce9b607833855_tuple;
extern PyObject *const_str_plain_has_location;
extern PyObject *const_str_plain___self__;
static PyObject *const_str_digest_a2a896f97269a5c37899adbc499b9280;
static PyObject *const_str_plain__push_exit_callback;
static PyObject *const_str_digest_568a33c9e2d9c0e121adfde0743aa87a;
static PyObject *const_str_digest_1d16a40cf452909202a07d4a8894ff9f;
static PyObject *const_str_digest_25a5c522ea5890a2f0329489df61d4e7;
static PyObject *const_str_plain__create_async_cb_wrapper;
static PyObject *const_str_plain___aenter__;
static PyObject *const_str_plain_ABC;
static PyObject *const_str_plain_asynccontextmanager;
static PyObject *const_str_plain_closing;
static PyObject *const_tuple_str_plain_self_str_plain_callback_str_plain_is_sync_tuple;
static PyObject *const_str_digest_04bc19c38b15a93519f8e990f6a13da6;
static PyObject *const_str_digest_37d3501df59cc79d8d4db5901783de2a;
static PyObject *const_str_plain__cb_type;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants( void )
{
    const_str_plain_cb = UNSTREAM_STRING_ASCII( &constant_bin[ 69160 ], 2, 1 );
    const_str_digest_5dcda8782ba35a75678a91209700af3e = UNSTREAM_STRING_ASCII( &constant_bin[ 69162 ], 34, 0 );
    const_tuple_str_plain_self_str_plain_exc_info_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_exc_info_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_exc_info_tuple, 1, const_str_plain_exc_info ); Py_INCREF( const_str_plain_exc_info );
    const_str_digest_b427544bbbefa85025737b449f92ef67 = UNSTREAM_STRING_ASCII( &constant_bin[ 69196 ], 24, 0 );
    const_str_digest_81336c6ee73db5493c214b89c035e61d = UNSTREAM_STRING_ASCII( &constant_bin[ 69220 ], 179, 0 );
    const_tuple_4f1fa4ca5d2d9824e633f94f53baafb9_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_4f1fa4ca5d2d9824e633f94f53baafb9_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_4f1fa4ca5d2d9824e633f94f53baafb9_tuple, 1, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_4f1fa4ca5d2d9824e633f94f53baafb9_tuple, 2, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_4f1fa4ca5d2d9824e633f94f53baafb9_tuple, 3, const_str_plain_traceback ); Py_INCREF( const_str_plain_traceback );
    PyTuple_SET_ITEM( const_tuple_4f1fa4ca5d2d9824e633f94f53baafb9_tuple, 4, const_str_plain_exc ); Py_INCREF( const_str_plain_exc );
    const_tuple_285275c053ca78d0b5fcb71ea58fcded_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_285275c053ca78d0b5fcb71ea58fcded_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_cm = UNSTREAM_STRING_ASCII( &constant_bin[ 53130 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_285275c053ca78d0b5fcb71ea58fcded_tuple, 1, const_str_plain_cm ); Py_INCREF( const_str_plain_cm );
    const_str_plain_cm_exit = UNSTREAM_STRING_ASCII( &constant_bin[ 69399 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_285275c053ca78d0b5fcb71ea58fcded_tuple, 2, const_str_plain_cm_exit ); Py_INCREF( const_str_plain_cm_exit );
    const_str_plain__exit_wrapper = UNSTREAM_STRING_ASCII( &constant_bin[ 69406 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_285275c053ca78d0b5fcb71ea58fcded_tuple, 3, const_str_plain__exit_wrapper ); Py_INCREF( const_str_plain__exit_wrapper );
    const_str_plain_excinfo = UNSTREAM_STRING_ASCII( &constant_bin[ 69419 ], 7, 1 );
    const_str_plain___cause__ = UNSTREAM_STRING_ASCII( &constant_bin[ 69426 ], 9, 1 );
    const_str_plain__AsyncGeneratorContextManager = UNSTREAM_STRING_ASCII( &constant_bin[ 69435 ], 29, 1 );
    const_str_digest_013a524d3bf3493644ac1b41fa206eb2 = UNSTREAM_STRING_ASCII( &constant_bin[ 69464 ], 37, 0 );
    const_str_plain_pending_raise = UNSTREAM_STRING_ASCII( &constant_bin[ 69501 ], 13, 1 );
    const_str_digest_c12dd3159c30879cf943be20228dc60c = UNSTREAM_STRING_ASCII( &constant_bin[ 69514 ], 18, 0 );
    const_str_digest_44fc253913aa80f6b51dedb3b194ecf6 = UNSTREAM_STRING_ASCII( &constant_bin[ 69532 ], 76, 0 );
    const_str_digest_09d5c8d945353368df602f14ef2d947d = UNSTREAM_STRING_ASCII( &constant_bin[ 69608 ], 33, 0 );
    const_str_plain_nullcontext = UNSTREAM_STRING_ASCII( &constant_bin[ 69641 ], 11, 1 );
    const_str_digest_e363b48ed66180ea29569815ae2c814f = UNSTREAM_STRING_ASCII( &constant_bin[ 69652 ], 62, 0 );
    const_str_plain_exctb = UNSTREAM_STRING_ASCII( &constant_bin[ 69714 ], 5, 1 );
    const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple = PyTuple_New( 11 );
    PyTuple_SET_ITEM( const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_exc_details = UNSTREAM_STRING_ASCII( &constant_bin[ 69719 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple, 1, const_str_plain_exc_details ); Py_INCREF( const_str_plain_exc_details );
    const_str_plain_received_exc = UNSTREAM_STRING_ASCII( &constant_bin[ 69730 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple, 2, const_str_plain_received_exc ); Py_INCREF( const_str_plain_received_exc );
    const_str_plain_frame_exc = UNSTREAM_STRING_ASCII( &constant_bin[ 69742 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple, 3, const_str_plain_frame_exc ); Py_INCREF( const_str_plain_frame_exc );
    const_str_plain__fix_exception_context = UNSTREAM_STRING_ASCII( &constant_bin[ 69751 ], 22, 1 );
    PyTuple_SET_ITEM( const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple, 4, const_str_plain__fix_exception_context ); Py_INCREF( const_str_plain__fix_exception_context );
    const_str_plain_suppressed_exc = UNSTREAM_STRING_ASCII( &constant_bin[ 69773 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple, 5, const_str_plain_suppressed_exc ); Py_INCREF( const_str_plain_suppressed_exc );
    PyTuple_SET_ITEM( const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple, 6, const_str_plain_pending_raise ); Py_INCREF( const_str_plain_pending_raise );
    const_str_plain_is_sync = UNSTREAM_STRING_ASCII( &constant_bin[ 69787 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple, 7, const_str_plain_is_sync ); Py_INCREF( const_str_plain_is_sync );
    PyTuple_SET_ITEM( const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple, 8, const_str_plain_cb ); Py_INCREF( const_str_plain_cb );
    const_str_plain_new_exc_details = UNSTREAM_STRING_ASCII( &constant_bin[ 69794 ], 15, 1 );
    PyTuple_SET_ITEM( const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple, 9, const_str_plain_new_exc_details ); Py_INCREF( const_str_plain_new_exc_details );
    const_str_plain_fixed_ctx = UNSTREAM_STRING_ASCII( &constant_bin[ 69809 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple, 10, const_str_plain_fixed_ctx ); Py_INCREF( const_str_plain_fixed_ctx );
    const_str_plain_gen = UNSTREAM_STRING_ASCII( &constant_bin[ 409 ], 3, 1 );
    const_str_digest_069d815edcbe4c452d78970be7a78ac2 = UNSTREAM_STRING_ASCII( &constant_bin[ 69818 ], 18, 0 );
    const_str_digest_7d7f62a9e44e7e680c51c869c602a010 = UNSTREAM_STRING_ASCII( &constant_bin[ 69836 ], 34, 0 );
    const_list_af5b310e02bd439cf8ca1c65e737fe3b_list = PyList_New( 12 );
    const_str_plain_asynccontextmanager = UNSTREAM_STRING_ASCII( &constant_bin[ 69870 ], 19, 1 );
    PyList_SET_ITEM( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list, 0, const_str_plain_asynccontextmanager ); Py_INCREF( const_str_plain_asynccontextmanager );
    PyList_SET_ITEM( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list, 1, const_str_plain_contextmanager ); Py_INCREF( const_str_plain_contextmanager );
    const_str_plain_closing = UNSTREAM_STRING_ASCII( &constant_bin[ 69889 ], 7, 1 );
    PyList_SET_ITEM( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list, 2, const_str_plain_closing ); Py_INCREF( const_str_plain_closing );
    PyList_SET_ITEM( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list, 3, const_str_plain_nullcontext ); Py_INCREF( const_str_plain_nullcontext );
    const_str_plain_AbstractContextManager = UNSTREAM_STRING_ASCII( &constant_bin[ 69896 ], 22, 1 );
    PyList_SET_ITEM( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list, 4, const_str_plain_AbstractContextManager ); Py_INCREF( const_str_plain_AbstractContextManager );
    const_str_plain_AbstractAsyncContextManager = UNSTREAM_STRING_ASCII( &constant_bin[ 69918 ], 27, 1 );
    PyList_SET_ITEM( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list, 5, const_str_plain_AbstractAsyncContextManager ); Py_INCREF( const_str_plain_AbstractAsyncContextManager );
    const_str_plain_AsyncExitStack = UNSTREAM_STRING_ASCII( &constant_bin[ 69196 ], 14, 1 );
    PyList_SET_ITEM( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list, 6, const_str_plain_AsyncExitStack ); Py_INCREF( const_str_plain_AsyncExitStack );
    const_str_plain_ContextDecorator = UNSTREAM_STRING_ASCII( &constant_bin[ 69945 ], 16, 1 );
    PyList_SET_ITEM( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list, 7, const_str_plain_ContextDecorator ); Py_INCREF( const_str_plain_ContextDecorator );
    const_str_plain_ExitStack = UNSTREAM_STRING_ASCII( &constant_bin[ 69201 ], 9, 1 );
    PyList_SET_ITEM( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list, 8, const_str_plain_ExitStack ); Py_INCREF( const_str_plain_ExitStack );
    PyList_SET_ITEM( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list, 9, const_str_plain_redirect_stdout ); Py_INCREF( const_str_plain_redirect_stdout );
    const_str_plain_redirect_stderr = UNSTREAM_STRING_ASCII( &constant_bin[ 69961 ], 15, 1 );
    PyList_SET_ITEM( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list, 10, const_str_plain_redirect_stderr ); Py_INCREF( const_str_plain_redirect_stderr );
    const_str_plain_suppress = UNSTREAM_STRING_ASCII( &constant_bin[ 60799 ], 8, 1 );
    PyList_SET_ITEM( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list, 11, const_str_plain_suppress ); Py_INCREF( const_str_plain_suppress );
    const_str_digest_53f2bc37130ba4c17f452fdc4d047974 = UNSTREAM_STRING_ASCII( &constant_bin[ 69976 ], 30, 0 );
    const_str_digest_14d40be592e224e5e7136c1c40a4b531 = UNSTREAM_STRING_ASCII( &constant_bin[ 70006 ], 35, 0 );
    const_str_plain__GeneratorContextManager = UNSTREAM_STRING_ASCII( &constant_bin[ 69162 ], 24, 1 );
    const_str_digest_9b9905bf1735b3c8d0d69a874343ee1c = UNSTREAM_STRING_ASCII( &constant_bin[ 70041 ], 64, 0 );
    const_tuple_str_plain_func_str_plain_helper_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_func_str_plain_helper_tuple, 0, const_str_plain_func ); Py_INCREF( const_str_plain_func );
    const_str_plain_helper = UNSTREAM_STRING_ASCII( &constant_bin[ 70105 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_func_str_plain_helper_tuple, 1, const_str_plain_helper ); Py_INCREF( const_str_plain_helper );
    const_tuple_99e4f7d79998fef56c940fc534bd3d1a_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_99e4f7d79998fef56c940fc534bd3d1a_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_99e4f7d79998fef56c940fc534bd3d1a_tuple, 1, const_str_plain_cm ); Py_INCREF( const_str_plain_cm );
    const_str_plain__cm_type = UNSTREAM_STRING_ASCII( &constant_bin[ 70111 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_99e4f7d79998fef56c940fc534bd3d1a_tuple, 2, const_str_plain__cm_type ); Py_INCREF( const_str_plain__cm_type );
    PyTuple_SET_ITEM( const_tuple_99e4f7d79998fef56c940fc534bd3d1a_tuple, 3, const_str_plain__exit ); Py_INCREF( const_str_plain__exit );
    PyTuple_SET_ITEM( const_tuple_99e4f7d79998fef56c940fc534bd3d1a_tuple, 4, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_tuple_ca1557cefb10ceab4fdb9c9136a76a76_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_ca1557cefb10ceab4fdb9c9136a76a76_tuple, 0, const_str_plain_exc_type ); Py_INCREF( const_str_plain_exc_type );
    PyTuple_SET_ITEM( const_tuple_ca1557cefb10ceab4fdb9c9136a76a76_tuple, 1, const_str_plain_exc ); Py_INCREF( const_str_plain_exc );
    PyTuple_SET_ITEM( const_tuple_ca1557cefb10ceab4fdb9c9136a76a76_tuple, 2, const_str_plain_tb ); Py_INCREF( const_str_plain_tb );
    PyTuple_SET_ITEM( const_tuple_ca1557cefb10ceab4fdb9c9136a76a76_tuple, 3, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_ca1557cefb10ceab4fdb9c9136a76a76_tuple, 4, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_ca1557cefb10ceab4fdb9c9136a76a76_tuple, 5, const_str_plain_kwds ); Py_INCREF( const_str_plain_kwds );
    const_str_digest_b7bfa96e1930f41166a4f32612e692f6 = UNSTREAM_STRING_ASCII( &constant_bin[ 70119 ], 34, 0 );
    const_str_digest_266a0e5c654ff0c5f2b193bf2c56d53a = UNSTREAM_STRING_ASCII( &constant_bin[ 70153 ], 28, 0 );
    const_str_digest_a68aae16a095bf20f5b2dce3ef8bbc02 = UNSTREAM_STRING_ASCII( &constant_bin[ 70181 ], 32, 0 );
    const_str_digest_361410c9c3db1345a7a5859bf6b7df79 = UNSTREAM_STRING_ASCII( &constant_bin[ 70213 ], 46, 0 );
    const_str_plain_new_target = UNSTREAM_STRING_ASCII( &constant_bin[ 70259 ], 10, 1 );
    const_str_digest_292ad321106653ddbe62f853458ccdc4 = UNSTREAM_STRING_ASCII( &constant_bin[ 70269 ], 57, 0 );
    const_str_digest_25c2da89c50fb28a7c6a154308bd9afe = UNSTREAM_STRING_ASCII( &constant_bin[ 70041 ], 41, 0 );
    const_tuple_str_plain_self_str_plain_excinfo_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_excinfo_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_excinfo_tuple, 1, const_str_plain_excinfo ); Py_INCREF( const_str_plain_excinfo );
    const_str_digest_c3a7e7986afc535e6f02c4ca2ab3a121 = UNSTREAM_STRING_ASCII( &constant_bin[ 70326 ], 56, 0 );
    const_str_digest_b577a7297d1ef67501fdbd40a3ef6040 = UNSTREAM_STRING_ASCII( &constant_bin[ 70382 ], 171, 0 );
    const_str_plain_new_stack = UNSTREAM_STRING_ASCII( &constant_bin[ 70553 ], 9, 1 );
    const_str_plain___wrapped__ = UNSTREAM_STRING_ASCII( &constant_bin[ 70562 ], 11, 1 );
    const_str_digest_bdb887d2ae600fc55f8a3783f325d1b8 = UNSTREAM_STRING_ASCII( &constant_bin[ 70573 ], 39, 0 );
    const_str_digest_ab10239cbb13ff94c3252ede7d4d1fce = UNSTREAM_STRING_ASCII( &constant_bin[ 70612 ], 21, 0 );
    const_str_plain___subclasshook__ = UNSTREAM_STRING_ASCII( &constant_bin[ 70596 ], 16, 1 );
    const_str_digest_492c9a2e0339f0b460e318e83c406d2a = UNSTREAM_STRING_ASCII( &constant_bin[ 70633 ], 29, 0 );
    const_tuple_str_plain_self_str_plain_enter_result_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_enter_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_enter_result = UNSTREAM_STRING_ASCII( &constant_bin[ 70662 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_enter_result_tuple, 1, const_str_plain_enter_result ); Py_INCREF( const_str_plain_enter_result );
    const_tuple_str_plain_args_str_plain_kwds_str_plain_self_str_plain_func_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwds_str_plain_self_str_plain_func_tuple, 0, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwds_str_plain_self_str_plain_func_tuple, 1, const_str_plain_kwds ); Py_INCREF( const_str_plain_kwds );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwds_str_plain_self_str_plain_func_tuple, 2, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwds_str_plain_self_str_plain_func_tuple, 3, const_str_plain_func ); Py_INCREF( const_str_plain_func );
    const_str_plain__GeneratorContextManagerBase = UNSTREAM_STRING_ASCII( &constant_bin[ 69464 ], 28, 1 );
    const_str_digest_3194f1464a0dbee99d5da6e02a3ee3d6 = UNSTREAM_STRING_ASCII( &constant_bin[ 70674 ], 20, 0 );
    const_str_digest_a0e0ee5062c8c89817864b9873626e91 = UNSTREAM_STRING_ASCII( &constant_bin[ 70694 ], 24, 0 );
    const_str_digest_27a9aa6471512d55712a8b3b3beb97a9 = UNSTREAM_STRING_ASCII( &constant_bin[ 70718 ], 319, 0 );
    const_tuple_str_plain_cm_str_plain_cm_exit_str_plain__exit_wrapper_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cm_str_plain_cm_exit_str_plain__exit_wrapper_tuple, 0, const_str_plain_cm ); Py_INCREF( const_str_plain_cm );
    PyTuple_SET_ITEM( const_tuple_str_plain_cm_str_plain_cm_exit_str_plain__exit_wrapper_tuple, 1, const_str_plain_cm_exit ); Py_INCREF( const_str_plain_cm_exit );
    PyTuple_SET_ITEM( const_tuple_str_plain_cm_str_plain_cm_exit_str_plain__exit_wrapper_tuple, 2, const_str_plain__exit_wrapper ); Py_INCREF( const_str_plain__exit_wrapper );
    const_str_digest_b09c25223d69ba668f56715025b1580f = UNSTREAM_STRING_ASCII( &constant_bin[ 71037 ], 475, 0 );
    const_str_digest_4dbe0056da4a01eaffbc4834adabb195 = UNSTREAM_STRING_ASCII( &constant_bin[ 71512 ], 25, 0 );
    const_tuple_str_plain_cls_str_plain_C_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_C_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_C_tuple, 1, const_str_plain_C ); Py_INCREF( const_str_plain_C );
    const_tuple_b69d8130dfe3195008f41e5d64bfb37e_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_b69d8130dfe3195008f41e5d64bfb37e_tuple, 0, const_str_plain_exc_type ); Py_INCREF( const_str_plain_exc_type );
    PyTuple_SET_ITEM( const_tuple_b69d8130dfe3195008f41e5d64bfb37e_tuple, 1, const_str_plain_exc ); Py_INCREF( const_str_plain_exc );
    PyTuple_SET_ITEM( const_tuple_b69d8130dfe3195008f41e5d64bfb37e_tuple, 2, const_str_plain_tb ); Py_INCREF( const_str_plain_tb );
    PyTuple_SET_ITEM( const_tuple_b69d8130dfe3195008f41e5d64bfb37e_tuple, 3, const_str_plain_cm_exit ); Py_INCREF( const_str_plain_cm_exit );
    PyTuple_SET_ITEM( const_tuple_b69d8130dfe3195008f41e5d64bfb37e_tuple, 4, const_str_plain_cm ); Py_INCREF( const_str_plain_cm );
    const_str_digest_d00d203588989ad33939a2d912ad1378 = UNSTREAM_STRING_ASCII( &constant_bin[ 71537 ], 31, 0 );
    const_str_digest_2f96db194079aab1e334d80c67e520d2 = UNSTREAM_STRING_ASCII( &constant_bin[ 71568 ], 32, 0 );
    const_str_digest_e8e9e8cf77df5602ad3518afa654e609 = UNSTREAM_STRING_ASCII( &constant_bin[ 71600 ], 21, 0 );
    const_str_plain_cb_suppress = UNSTREAM_STRING_ASCII( &constant_bin[ 71621 ], 11, 1 );
    const_str_digest_75420df2bc0eb7333ada17751936a384 = UNSTREAM_STRING_ASCII( &constant_bin[ 71632 ], 310, 0 );
    const_str_plain_new_exc = UNSTREAM_STRING_ASCII( &constant_bin[ 69794 ], 7, 1 );
    const_str_digest_e945221f7c26341208775e8abf72a8fa = UNSTREAM_STRING_ASCII( &constant_bin[ 71942 ], 33, 0 );
    const_tuple_2c94856944fb81984faf2fe427737e40_tuple = PyTuple_New( 12 );
    PyTuple_SET_ITEM( const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 1, const_str_plain_exc_details ); Py_INCREF( const_str_plain_exc_details );
    PyTuple_SET_ITEM( const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 2, const_str_plain_received_exc ); Py_INCREF( const_str_plain_received_exc );
    PyTuple_SET_ITEM( const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 3, const_str_plain_frame_exc ); Py_INCREF( const_str_plain_frame_exc );
    PyTuple_SET_ITEM( const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 4, const_str_plain__fix_exception_context ); Py_INCREF( const_str_plain__fix_exception_context );
    PyTuple_SET_ITEM( const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 5, const_str_plain_suppressed_exc ); Py_INCREF( const_str_plain_suppressed_exc );
    PyTuple_SET_ITEM( const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 6, const_str_plain_pending_raise ); Py_INCREF( const_str_plain_pending_raise );
    PyTuple_SET_ITEM( const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 7, const_str_plain_is_sync ); Py_INCREF( const_str_plain_is_sync );
    PyTuple_SET_ITEM( const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 8, const_str_plain_cb ); Py_INCREF( const_str_plain_cb );
    PyTuple_SET_ITEM( const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 9, const_str_plain_cb_suppress ); Py_INCREF( const_str_plain_cb_suppress );
    PyTuple_SET_ITEM( const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 10, const_str_plain_new_exc_details ); Py_INCREF( const_str_plain_new_exc_details );
    PyTuple_SET_ITEM( const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 11, const_str_plain_fixed_ctx ); Py_INCREF( const_str_plain_fixed_ctx );
    const_str_digest_15c01fc29f9c1a2be6b00d45717358b0 = UNSTREAM_STRING_ASCII( &constant_bin[ 71975 ], 50, 0 );
    const_str_digest_d8ed76b736711588dc0441af0e3acdcb = UNSTREAM_STRING_ASCII( &constant_bin[ 72025 ], 25, 0 );
    const_tuple_str_plain__BaseExitStack_tuple_empty_tuple = PyTuple_New( 2 );
    const_str_plain__BaseExitStack = UNSTREAM_STRING_ASCII( &constant_bin[ 69608 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__BaseExitStack_tuple_empty_tuple, 0, const_str_plain__BaseExitStack ); Py_INCREF( const_str_plain__BaseExitStack );
    PyTuple_SET_ITEM( const_tuple_str_plain__BaseExitStack_tuple_empty_tuple, 1, const_tuple_empty ); Py_INCREF( const_tuple_empty );
    const_str_digest_6ffe76711bdd5b699aa8c216d8ac87ec = UNSTREAM_STRING_ASCII( &constant_bin[ 72050 ], 66, 0 );
    const_str_digest_1bd5d99d6eaccd3aded9fbcf030f961c = UNSTREAM_STRING_ASCII( &constant_bin[ 72116 ], 20, 0 );
    const_str_digest_b7f7eed1cf6a5961dffed270fdd5feca = UNSTREAM_STRING_ASCII( &constant_bin[ 72136 ], 34, 0 );
    const_str_plain_pop_all = UNSTREAM_STRING_ASCII( &constant_bin[ 72170 ], 7, 1 );
    const_str_digest_c90ebf416c6b3426c3ced10ea695a8ab = UNSTREAM_STRING_ASCII( &constant_bin[ 72177 ], 57, 0 );
    const_str_digest_9f3d2b5ab4e4cad7444ce685cb22d525 = UNSTREAM_STRING_ASCII( &constant_bin[ 72234 ], 335, 0 );
    const_tuple_24294d365f055f3473896705acca5164_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_24294d365f055f3473896705acca5164_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_24294d365f055f3473896705acca5164_tuple, 1, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_24294d365f055f3473896705acca5164_tuple, 2, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_24294d365f055f3473896705acca5164_tuple, 3, const_str_plain_kwds ); Py_INCREF( const_str_plain_kwds );
    PyTuple_SET_ITEM( const_tuple_24294d365f055f3473896705acca5164_tuple, 4, const_str_plain__exit_wrapper ); Py_INCREF( const_str_plain__exit_wrapper );
    const_str_digest_0f0d45b1451f7c90ace5341c8d2acc76 = UNSTREAM_STRING_ASCII( &constant_bin[ 72569 ], 24, 0 );
    const_str_plain_exit_method = UNSTREAM_STRING_ASCII( &constant_bin[ 72593 ], 11, 1 );
    const_str_plain_push_async_exit = UNSTREAM_STRING_ASCII( &constant_bin[ 69991 ], 15, 1 );
    const_str_plain_athrow = UNSTREAM_STRING_ASCII( &constant_bin[ 72604 ], 6, 1 );
    const_tuple_f7761c758733e94d335a6027b2f1d7bd_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_f7761c758733e94d335a6027b2f1d7bd_tuple, 0, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_f7761c758733e94d335a6027b2f1d7bd_tuple, 1, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_f7761c758733e94d335a6027b2f1d7bd_tuple, 2, const_str_plain_kwds ); Py_INCREF( const_str_plain_kwds );
    PyTuple_SET_ITEM( const_tuple_f7761c758733e94d335a6027b2f1d7bd_tuple, 3, const_str_plain__exit_wrapper ); Py_INCREF( const_str_plain__exit_wrapper );
    const_str_digest_6c74f90a83f8426d3debee986acb6dfb = UNSTREAM_STRING_ASCII( &constant_bin[ 72610 ], 37, 0 );
    const_tuple_str_plain_args_str_plain_kwds_str_plain_func_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwds_str_plain_func_tuple, 0, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwds_str_plain_func_tuple, 1, const_str_plain_kwds ); Py_INCREF( const_str_plain_kwds );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwds_str_plain_func_tuple, 2, const_str_plain_func ); Py_INCREF( const_str_plain_func );
    const_str_plain_aclose = UNSTREAM_STRING_ASCII( &constant_bin[ 70627 ], 6, 1 );
    const_tuple_str_plain_self_str_plain_new_target_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_new_target_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_new_target_tuple, 1, const_str_plain_new_target ); Py_INCREF( const_str_plain_new_target );
    const_str_plain__create_exit_wrapper = UNSTREAM_STRING_ASCII( &constant_bin[ 72647 ], 20, 1 );
    const_str_digest_cd9499f90d1fdb125e1fc42bc99bc8bc = UNSTREAM_STRING_ASCII( &constant_bin[ 72667 ], 58, 0 );
    const_str_plain__push_async_cm_exit = UNSTREAM_STRING_ASCII( &constant_bin[ 69851 ], 19, 1 );
    const_str_digest_4cc0ab300f4fe8af2dc122c9eba3d7cc = UNSTREAM_STRING_ASCII( &constant_bin[ 72725 ], 25, 0 );
    const_tuple_str_plain_self_str_plain_exceptions_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_exceptions_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_exceptions_tuple, 1, const_str_plain_exceptions ); Py_INCREF( const_str_plain_exceptions );
    const_tuple_str_plain__GeneratorContextManagerBase_tuple_empty_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain__GeneratorContextManagerBase_tuple_empty_tuple, 0, const_str_plain__GeneratorContextManagerBase ); Py_INCREF( const_str_plain__GeneratorContextManagerBase );
    PyTuple_SET_ITEM( const_tuple_str_plain__GeneratorContextManagerBase_tuple_empty_tuple, 1, const_tuple_empty ); Py_INCREF( const_tuple_empty );
    const_str_plain__old_targets = UNSTREAM_STRING_ASCII( &constant_bin[ 72750 ], 12, 1 );
    const_str_digest_aa3df32e7619083adf0a2fbf5a235c36 = UNSTREAM_STRING_ASCII( &constant_bin[ 72762 ], 270, 0 );
    const_tuple_str_plain_self_str_plain_func_str_plain_inner_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_func_str_plain_inner_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_func_str_plain_inner_tuple, 1, const_str_plain_func ); Py_INCREF( const_str_plain_func );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_func_str_plain_inner_tuple, 2, const_str_plain_inner ); Py_INCREF( const_str_plain_inner );
    const_str_digest_561259968dad5e211e270f1bf7b5ddcc = UNSTREAM_STRING_ASCII( &constant_bin[ 73032 ], 22, 0 );
    const_str_digest_fc380e569c01f57799c4fb3916d89707 = UNSTREAM_STRING_ASCII( &constant_bin[ 73054 ], 67, 0 );
    const_str_digest_43d77277e950cc565806fc3c134d250b = UNSTREAM_STRING_ASCII( &constant_bin[ 73121 ], 22, 0 );
    const_str_digest_657b8bde9f38fd964044ea752e7ced2d = UNSTREAM_STRING_ASCII( &constant_bin[ 73143 ], 19, 0 );
    const_tuple_str_plain_self_str_plain_new_stack_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_new_stack_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_new_stack_tuple, 1, const_str_plain_new_stack ); Py_INCREF( const_str_plain_new_stack );
    const_str_plain__create_cb_wrapper = UNSTREAM_STRING_ASCII( &constant_bin[ 69623 ], 18, 1 );
    const_str_digest_a35b309c4b1d53a114ad6b7b1cbbc3f0 = UNSTREAM_STRING_ASCII( &constant_bin[ 73162 ], 28, 0 );
    const_str_plain__exit_callbacks = UNSTREAM_STRING_ASCII( &constant_bin[ 73190 ], 15, 1 );
    const_str_digest_6616e0e68b690f14c87f57dc8a44bd85 = UNSTREAM_STRING_ASCII( &constant_bin[ 73205 ], 48, 0 );
    const_tuple_7a9619740519a6b4164e2a052f9465fb_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_7a9619740519a6b4164e2a052f9465fb_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7a9619740519a6b4164e2a052f9465fb_tuple, 1, const_str_plain_typ ); Py_INCREF( const_str_plain_typ );
    PyTuple_SET_ITEM( const_tuple_7a9619740519a6b4164e2a052f9465fb_tuple, 2, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_7a9619740519a6b4164e2a052f9465fb_tuple, 3, const_str_plain_traceback ); Py_INCREF( const_str_plain_traceback );
    PyTuple_SET_ITEM( const_tuple_7a9619740519a6b4164e2a052f9465fb_tuple, 4, const_str_plain_exc ); Py_INCREF( const_str_plain_exc );
    const_str_digest_6bf82b52b82827398412049d90b93095 = UNSTREAM_STRING_ASCII( &constant_bin[ 73253 ], 509, 0 );
    const_str_digest_3f30b003fbfc4f0bf645c8bc55efc51f = UNSTREAM_STRING_ASCII( &constant_bin[ 73762 ], 92, 0 );
    const_str_digest_4a605543d290dbdf95f4c339df4f12b9 = UNSTREAM_STRING_ASCII( &constant_bin[ 73854 ], 40, 0 );
    const_str_digest_45f4e32fb936425e6aae2a495ddd5db3 = UNSTREAM_STRING_ASCII( &constant_bin[ 73894 ], 59, 0 );
    const_tuple_str_plain_self_str_plain_thing_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_thing_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_thing_tuple, 1, const_str_plain_thing ); Py_INCREF( const_str_plain_thing );
    const_str_digest_5622473d84a607757f5490c88c2fc06a = UNSTREAM_STRING_ASCII( &constant_bin[ 73953 ], 44, 0 );
    const_str_digest_6eef37f01b16f450b8a600bfc07c366e = UNSTREAM_STRING_ASCII( &constant_bin[ 73997 ], 13, 0 );
    const_str_plain__new_target = UNSTREAM_STRING_ASCII( &constant_bin[ 74010 ], 11, 1 );
    const_str_plain__push_cm_exit = UNSTREAM_STRING_ASCII( &constant_bin[ 73177 ], 13, 1 );
    const_str_digest_5b4233ef7f235a30c90a3520223ec395 = UNSTREAM_STRING_ASCII( &constant_bin[ 74021 ], 17, 0 );
    const_str_digest_072d893f430d6100c064aab7d47e5365 = UNSTREAM_STRING_ASCII( &constant_bin[ 74038 ], 38, 0 );
    const_str_digest_32920fc73b22ed7a2cae0938236ca756 = UNSTREAM_STRING_ASCII( &constant_bin[ 74076 ], 39, 0 );
    const_str_plain___aexit__ = UNSTREAM_STRING_ASCII( &constant_bin[ 69211 ], 9, 1 );
    const_str_digest_88d158957b0ede9fb261f4e63b263f20 = UNSTREAM_STRING_ASCII( &constant_bin[ 74115 ], 44, 0 );
    const_str_plain_old_exc = UNSTREAM_STRING_ASCII( &constant_bin[ 74159 ], 7, 1 );
    const_tuple_7b3d388a553c47f52835463197dbad6d_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_7b3d388a553c47f52835463197dbad6d_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7b3d388a553c47f52835463197dbad6d_tuple, 1, const_str_plain_exctype ); Py_INCREF( const_str_plain_exctype );
    const_str_plain_excinst = UNSTREAM_STRING_ASCII( &constant_bin[ 74166 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_7b3d388a553c47f52835463197dbad6d_tuple, 2, const_str_plain_excinst ); Py_INCREF( const_str_plain_excinst );
    PyTuple_SET_ITEM( const_tuple_7b3d388a553c47f52835463197dbad6d_tuple, 3, const_str_plain_exctb ); Py_INCREF( const_str_plain_exctb );
    const_str_digest_0324378fdaf4c0afbda1d52593df0b3d = UNSTREAM_STRING_ASCII( &constant_bin[ 72667 ], 35, 0 );
    const_str_plain___anext__ = UNSTREAM_STRING_ASCII( &constant_bin[ 74173 ], 9, 1 );
    const_str_digest_df1f1d9b030254507b5122a26df9a71a = UNSTREAM_STRING_ASCII( &constant_bin[ 74182 ], 34, 0 );
    const_str_digest_3e88ac70b637d24d9d579630d818ac0c = UNSTREAM_STRING_ASCII( &constant_bin[ 74216 ], 471, 0 );
    const_str_plain_exc_context = UNSTREAM_STRING_ASCII( &constant_bin[ 74687 ], 11, 1 );
    const_str_digest_196928cdda2f74dcaa86496536d7d0c7 = UNSTREAM_STRING_ASCII( &constant_bin[ 74698 ], 52, 0 );
    const_str_plain__create_async_exit_wrapper = UNSTREAM_STRING_ASCII( &constant_bin[ 70056 ], 26, 1 );
    const_str_digest_be6e50fdf69f187f977c4e5d0f4f92c1 = UNSTREAM_STRING_ASCII( &constant_bin[ 74750 ], 17, 0 );
    const_str_plain__recreate_cm = UNSTREAM_STRING_ASCII( &constant_bin[ 70650 ], 12, 1 );
    const_str_plain_enter_context = UNSTREAM_STRING_ASCII( &constant_bin[ 70168 ], 13, 1 );
    const_str_digest_8925bc3e79b6caccc0000e42e8cb2562 = UNSTREAM_STRING_ASCII( &constant_bin[ 74767 ], 395, 0 );
    const_str_plain_push_async_callback = UNSTREAM_STRING_ASCII( &constant_bin[ 74197 ], 19, 1 );
    const_str_digest_738a6c63d8a7f3e6b47adb4108e7c9d1 = UNSTREAM_STRING_ASCII( &constant_bin[ 75162 ], 16, 0 );
    const_str_digest_5723e006fbbb84d1de871bcae3bcd023 = UNSTREAM_STRING_ASCII( &constant_bin[ 75178 ], 23, 0 );
    const_str_digest_a20d2b369cfee2d243317b2de658a730 = UNSTREAM_STRING_ASCII( &constant_bin[ 75201 ], 19, 0 );
    const_str_plain_enter_async_context = UNSTREAM_STRING_ASCII( &constant_bin[ 70134 ], 19, 1 );
    const_str_digest_fb1417f379158cc513e12e6529ffb50b = UNSTREAM_STRING_ASCII( &constant_bin[ 75220 ], 291, 0 );
    const_tuple_59ad8b9a7b3958ff248ecbb0d59682e2_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_59ad8b9a7b3958ff248ecbb0d59682e2_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_59ad8b9a7b3958ff248ecbb0d59682e2_tuple, 1, const_str_plain_func ); Py_INCREF( const_str_plain_func );
    PyTuple_SET_ITEM( const_tuple_59ad8b9a7b3958ff248ecbb0d59682e2_tuple, 2, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_59ad8b9a7b3958ff248ecbb0d59682e2_tuple, 3, const_str_plain_kwds ); Py_INCREF( const_str_plain_kwds );
    PyTuple_SET_ITEM( const_tuple_59ad8b9a7b3958ff248ecbb0d59682e2_tuple, 4, const_str_plain_doc ); Py_INCREF( const_str_plain_doc );
    const_str_digest_de72cb85464cbf04e752b2f7df1e4103 = UNSTREAM_STRING_ASCII( &constant_bin[ 75511 ], 56, 0 );
    const_str_digest_d3e49cbb4b25449e156e86388d4299ad = UNSTREAM_STRING_ASCII( &constant_bin[ 75567 ], 23, 0 );
    const_tuple_9bff1fb10d94302cf075ed06fe9c426d_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_9bff1fb10d94302cf075ed06fe9c426d_tuple, 0, const_str_plain_new_exc ); Py_INCREF( const_str_plain_new_exc );
    PyTuple_SET_ITEM( const_tuple_9bff1fb10d94302cf075ed06fe9c426d_tuple, 1, const_str_plain_old_exc ); Py_INCREF( const_str_plain_old_exc );
    PyTuple_SET_ITEM( const_tuple_9bff1fb10d94302cf075ed06fe9c426d_tuple, 2, const_str_plain_exc_context ); Py_INCREF( const_str_plain_exc_context );
    PyTuple_SET_ITEM( const_tuple_9bff1fb10d94302cf075ed06fe9c426d_tuple, 3, const_str_plain_frame_exc ); Py_INCREF( const_str_plain_frame_exc );
    const_str_plain__RedirectStream = UNSTREAM_STRING_ASCII( &constant_bin[ 70694 ], 15, 1 );
    const_str_plain__check_methods = UNSTREAM_STRING_ASCII( &constant_bin[ 75590 ], 14, 1 );
    const_str_digest_b4cbc7dbf1044832ac051ba8cf22b782 = UNSTREAM_STRING_ASCII( &constant_bin[ 75604 ], 306, 0 );
    const_str_digest_82cfb07b0e6277928c3fe172bffa179f = UNSTREAM_STRING_ASCII( &constant_bin[ 70006 ], 21, 0 );
    const_str_digest_d310a8f23c19ced2e835b7bda8daeaea = UNSTREAM_STRING_ASCII( &constant_bin[ 75910 ], 30, 0 );
    const_str_digest_767308c1e3e7512bcaf23b84f8ac277a = UNSTREAM_STRING_ASCII( &constant_bin[ 75940 ], 17, 0 );
    const_str_plain__exceptions = UNSTREAM_STRING_ASCII( &constant_bin[ 75957 ], 11, 1 );
    const_tuple_type_StopIteration_type_StopAsyncIteration_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_type_StopIteration_type_StopAsyncIteration_tuple, 0, (PyObject *)PyExc_StopIteration ); Py_INCREF( (PyObject *)PyExc_StopIteration );
    PyTuple_SET_ITEM( const_tuple_type_StopIteration_type_StopAsyncIteration_tuple, 1, (PyObject *)PyExc_StopAsyncIteration ); Py_INCREF( (PyObject *)PyExc_StopAsyncIteration );
    const_str_digest_454729390f92fd60b48378f2e1aa3db0 = UNSTREAM_STRING_ASCII( &constant_bin[ 69652 ], 39, 0 );
    const_tuple_e3d25ea3287460ab60449763727613f6_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_e3d25ea3287460ab60449763727613f6_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_e3d25ea3287460ab60449763727613f6_tuple, 1, const_str_plain_exit ); Py_INCREF( const_str_plain_exit );
    const_str_plain__cb_type = UNSTREAM_STRING_ASCII( &constant_bin[ 75968 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_e3d25ea3287460ab60449763727613f6_tuple, 2, const_str_plain__cb_type ); Py_INCREF( const_str_plain__cb_type );
    PyTuple_SET_ITEM( const_tuple_e3d25ea3287460ab60449763727613f6_tuple, 3, const_str_plain_exit_method ); Py_INCREF( const_str_plain_exit_method );
    const_str_digest_c9273566575fea99bfeae6de0a02b843 = UNSTREAM_STRING_ASCII( &constant_bin[ 75976 ], 40, 0 );
    const_str_plain___context__ = UNSTREAM_STRING_ASCII( &constant_bin[ 76016 ], 11, 1 );
    const_str_digest_8a1dccae593581f4052d7559e1c2ae2c = UNSTREAM_STRING_ASCII( &constant_bin[ 76027 ], 37, 0 );
    const_str_digest_dd701e09dbf36c7cd84ab2997f9a35cf = UNSTREAM_STRING_ASCII( &constant_bin[ 76064 ], 74, 0 );
    const_str_digest_15e936ef3374424b98cf9aa15867b234 = UNSTREAM_STRING_ASCII( &constant_bin[ 76138 ], 37, 0 );
    const_str_digest_639ebec650f2fbedf493b5dd0b28ed77 = UNSTREAM_STRING_ASCII( &constant_bin[ 76175 ], 64, 0 );
    const_str_digest_496479db0a523e2af9244fc0d8332ffd = UNSTREAM_STRING_ASCII( &constant_bin[ 76239 ], 102, 0 );
    const_tuple_4056a0ef07ec9188d15ce9b607833855_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_4056a0ef07ec9188d15ce9b607833855_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_4056a0ef07ec9188d15ce9b607833855_tuple, 1, const_str_plain_exc_type ); Py_INCREF( const_str_plain_exc_type );
    PyTuple_SET_ITEM( const_tuple_4056a0ef07ec9188d15ce9b607833855_tuple, 2, const_str_plain_exc_value ); Py_INCREF( const_str_plain_exc_value );
    PyTuple_SET_ITEM( const_tuple_4056a0ef07ec9188d15ce9b607833855_tuple, 3, const_str_plain_traceback ); Py_INCREF( const_str_plain_traceback );
    const_str_digest_a2a896f97269a5c37899adbc499b9280 = UNSTREAM_STRING_ASCII( &constant_bin[ 76341 ], 19, 0 );
    const_str_plain__push_exit_callback = UNSTREAM_STRING_ASCII( &constant_bin[ 72151 ], 19, 1 );
    const_str_digest_568a33c9e2d9c0e121adfde0743aa87a = UNSTREAM_STRING_ASCII( &constant_bin[ 76360 ], 35, 0 );
    const_str_digest_1d16a40cf452909202a07d4a8894ff9f = UNSTREAM_STRING_ASCII( &constant_bin[ 76395 ], 16, 0 );
    const_str_digest_25a5c522ea5890a2f0329489df61d4e7 = UNSTREAM_STRING_ASCII( &constant_bin[ 76411 ], 37, 0 );
    const_str_plain__create_async_cb_wrapper = UNSTREAM_STRING_ASCII( &constant_bin[ 69667 ], 24, 1 );
    const_str_plain___aenter__ = UNSTREAM_STRING_ASCII( &constant_bin[ 69372 ], 10, 1 );
    const_str_plain_ABC = UNSTREAM_STRING_ASCII( &constant_bin[ 76448 ], 3, 1 );
    const_tuple_str_plain_self_str_plain_callback_str_plain_is_sync_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_is_sync_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_is_sync_tuple, 1, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_is_sync_tuple, 2, const_str_plain_is_sync ); Py_INCREF( const_str_plain_is_sync );
    const_str_digest_04bc19c38b15a93519f8e990f6a13da6 = UNSTREAM_STRING_ASCII( &constant_bin[ 76451 ], 15, 0 );
    const_str_digest_37d3501df59cc79d8d4db5901783de2a = UNSTREAM_STRING_ASCII( &constant_bin[ 76466 ], 321, 0 );

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_contextlib( void )
{
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_16be74c7884d209762a4409719331de6;
static PyCodeObject *codeobj_5b202f99d1876fb8487deeef8d71a950;
static PyCodeObject *codeobj_4035f91cc3ac63d7d4c73c33cc6faa55;
static PyCodeObject *codeobj_10e144bd8ccb0415c605cd7bc640b3ce;
static PyCodeObject *codeobj_c04d551e7f2d47bde603a86a6cbab618;
static PyCodeObject *codeobj_4bcab7a51e5ec620770a43dbb3c4a947;
static PyCodeObject *codeobj_ed080fdeb1d9225b601fa380040f8380;
static PyCodeObject *codeobj_5bce12272bd0320f1ba68a2377afbf7f;
static PyCodeObject *codeobj_425d97b102abf105a65464ebdd2a370d;
static PyCodeObject *codeobj_234568fa88d264a070f886691f02cf17;
static PyCodeObject *codeobj_01fcb8cd929b0c4b32cd16ad15de112a;
static PyCodeObject *codeobj_abe4ba583c817761ab022d36929753d8;
static PyCodeObject *codeobj_ad0164f70f9718d4c84eac4493bd0b3f;
static PyCodeObject *codeobj_775fcfc9e192e06247503a9be4ac57a1;
static PyCodeObject *codeobj_d62b1f4472ae7081578940b4d26b2c48;
static PyCodeObject *codeobj_97a372fac4573135deb7dd07cd85c86d;
static PyCodeObject *codeobj_1053119921a56c2bea8a426f0019c955;
static PyCodeObject *codeobj_09fd19dda9487a9928a1b4ed8c1ffc15;
static PyCodeObject *codeobj_608aec0519dfe3b8eecdb746943b25e8;
static PyCodeObject *codeobj_ab6d63e978e1252c4db14ab08bb51a49;
static PyCodeObject *codeobj_9b5da5032c05507da8147f4e6f99b839;
static PyCodeObject *codeobj_8fec8b0032b947333ecb2ffba5c36fda;
static PyCodeObject *codeobj_8e9cb589a8f7d924c7e618eca92361d5;
static PyCodeObject *codeobj_b1c128d48b192bedb6577a8b7160a717;
static PyCodeObject *codeobj_ea577d827d21f03b7109facb03bac09c;
static PyCodeObject *codeobj_d50e67012bb275ea8e91c1af19ae7625;
static PyCodeObject *codeobj_483345fee779ba1705e61c19617f3712;
static PyCodeObject *codeobj_df97ed3424cb10a88b4203af3cf76740;
static PyCodeObject *codeobj_67a1e3a1c0061e332d3094ae30557685;
static PyCodeObject *codeobj_1b47f9f1ce467f7f75848449b2718fa6;
static PyCodeObject *codeobj_5319d6795f1312e749b7f025eaaf1c46;
static PyCodeObject *codeobj_dd8108231668e71787c3c868f3031f9b;
static PyCodeObject *codeobj_7289da3863f64141e779df033dfe8c6d;
static PyCodeObject *codeobj_e3c17e4fc256ae365524c8cbb1598249;
static PyCodeObject *codeobj_6e54b004743913720c86884cf47d4c7b;
static PyCodeObject *codeobj_b4139367cf6f902d8f012d68c18fbdff;
static PyCodeObject *codeobj_209a810c6ebd52b561796e0f9bae79be;
static PyCodeObject *codeobj_3f39158aafe18f3b316031d137e3a7af;
static PyCodeObject *codeobj_3010ebafdd9c4ae5d6be7668f47fd0ff;
static PyCodeObject *codeobj_34b0278e9808572c069bceb941715927;
static PyCodeObject *codeobj_cd00d3f4cbbe7bcc26349b3d24f73b5a;
static PyCodeObject *codeobj_bff15e44f163505d42b2d15a38f2c81c;
static PyCodeObject *codeobj_f6bfedafdf345fc87a24d5cc8030c305;
static PyCodeObject *codeobj_50f7458fdc57dfdb87cc1909e09be3ec;
static PyCodeObject *codeobj_b314dfc24cfb446bc412a4b84347e7bb;
static PyCodeObject *codeobj_c5e0bdefa48e79d21cad1e6b166e62e9;
static PyCodeObject *codeobj_c28aa9caf0be431315f136ca024fd8ff;
static PyCodeObject *codeobj_79334a1036d8c97f06c39c18817bf2f2;
static PyCodeObject *codeobj_bbfd4ac0f959c684210adaa396b9a35a;
static PyCodeObject *codeobj_472f3c61d3963d5dcde030560103997b;
static PyCodeObject *codeobj_b7274d5d850f21d60dd43edeab664be5;
static PyCodeObject *codeobj_5e7507c3fa2f8357a290571a7c2c87fb;
static PyCodeObject *codeobj_e2bc8f99006d30c55dd2a8eecf6821aa;
static PyCodeObject *codeobj_cb08c024b4d4f770d9b5cdd06dc0c2d8;
static PyCodeObject *codeobj_ae091acc94155ceeb0d0b8a3dab512c6;
static PyCodeObject *codeobj_86d241f5735172421d3744f63bc43116;
static PyCodeObject *codeobj_535fe3b96fc9f66283c68667446d44b4;
static PyCodeObject *codeobj_d11d44405c07a698ba8f0ab99d8d0e2a;
static PyCodeObject *codeobj_6bd1f91ac15dd8324cd978b80269b375;
static PyCodeObject *codeobj_5d897d4474259a7128af7713d0e7b885;
static PyCodeObject *codeobj_c9d7fea79421b5192503141dd6b626fa;
static PyCodeObject *codeobj_b5aa3e2dedb8972036672150e4e23f41;
static PyCodeObject *codeobj_c2b386b5b585286d75c620b41f07f6f9;
static PyCodeObject *codeobj_b32d399f13c7f5cb32706e7e8544adcd;
static PyCodeObject *codeobj_fe180fc33126050a85ed6c97d75eb435;
static PyCodeObject *codeobj_de02ad5f3ecd8dc39711a0813e03c5e9;
static PyCodeObject *codeobj_2415601356a99a081119e44dfac162fa;
static PyCodeObject *codeobj_ac1633f3fdcf108561287a9aaae4de40;
static PyCodeObject *codeobj_3eea89dad8802f791e00692828406a41;
static PyCodeObject *codeobj_45e2cf9544c4a969db74b67d603ee00d;
static PyCodeObject *codeobj_2ceeed769613aea7ec41a0a0032b3f6d;
static PyCodeObject *codeobj_87f04e9c08916a537b9d28a0c7179091;
static PyCodeObject *codeobj_d7fd5dc9be95290492bee556cea09260;
static PyCodeObject *codeobj_780dcd518a86239b52f6ae1915c129d3;

static void createModuleCodeObjects(void)
{
    module_filename_obj = MAKE_RELATIVE_PATH( const_str_digest_6eef37f01b16f450b8a600bfc07c366e );
    codeobj_16be74c7884d209762a4409719331de6 = MAKE_CODEOBJ( module_filename_obj, const_str_digest_a2a896f97269a5c37899adbc499b9280, 1, const_tuple_empty, 0, 0, CO_NOFREE );
    codeobj_5b202f99d1876fb8487deeef8d71a950 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_AbstractAsyncContextManager, 34, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_4035f91cc3ac63d7d4c73c33cc6faa55 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_AbstractContextManager, 14, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_10e144bd8ccb0415c605cd7bc640b3ce = MAKE_CODEOBJ( module_filename_obj, const_str_plain_AsyncExitStack, 523, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_c04d551e7f2d47bde603a86a6cbab618 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ContextDecorator, 55, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_4bcab7a51e5ec620770a43dbb3c4a947 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ExitStack, 454, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_ed080fdeb1d9225b601fa380040f8380 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__AsyncGeneratorContextManager, 165, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_5bce12272bd0320f1ba68a2377afbf7f = MAKE_CODEOBJ( module_filename_obj, const_str_plain__BaseExitStack, 371, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_425d97b102abf105a65464ebdd2a370d = MAKE_CODEOBJ( module_filename_obj, const_str_plain__GeneratorContextManager, 98, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_234568fa88d264a070f886691f02cf17 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__GeneratorContextManagerBase, 78, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_01fcb8cd929b0c4b32cd16ad15de112a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__RedirectStream, 301, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_abe4ba583c817761ab022d36929753d8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___aenter__, 38, const_tuple_str_plain_self_tuple, 1, 0, CO_COROUTINE | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ad0164f70f9718d4c84eac4493bd0b3f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___aenter__, 168, const_tuple_str_plain_self_tuple, 1, 0, CO_COROUTINE | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_775fcfc9e192e06247503a9be4ac57a1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___aenter__, 602, const_tuple_str_plain_self_tuple, 1, 0, CO_COROUTINE | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d62b1f4472ae7081578940b4d26b2c48 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___aexit__, 42, const_tuple_4056a0ef07ec9188d15ce9b607833855_tuple, 4, 0, CO_COROUTINE | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_97a372fac4573135deb7dd07cd85c86d = MAKE_CODEOBJ( module_filename_obj, const_str_plain___aexit__, 174, const_tuple_7a9619740519a6b4164e2a052f9465fb_tuple, 4, 0, CO_COROUTINE | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1053119921a56c2bea8a426f0019c955 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___aexit__, 605, const_tuple_2c94856944fb81984faf2fe427737e40_tuple, 1, 0, CO_COROUTINE | CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_NOFREE );
    codeobj_09fd19dda9487a9928a1b4ed8c1ffc15 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___call__, 70, const_tuple_str_plain_self_str_plain_func_str_plain_inner_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_608aec0519dfe3b8eecdb746943b25e8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___enter__, 18, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ab6d63e978e1252c4db14ab08bb51a49 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___enter__, 107, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9b5da5032c05507da8147f4e6f99b839 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___enter__, 295, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8fec8b0032b947333ecb2ffba5c36fda = MAKE_CODEOBJ( module_filename_obj, const_str_plain___enter__, 310, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8e9cb589a8f7d924c7e618eca92361d5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___enter__, 355, const_tuple_str_plain_self_tuple, 1, 0, CO_NOFREE );
    codeobj_b1c128d48b192bedb6577a8b7160a717 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___enter__, 465, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ea577d827d21f03b7109facb03bac09c = MAKE_CODEOBJ( module_filename_obj, const_str_plain___enter__, 673, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d50e67012bb275ea8e91c1af19ae7625 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___exit__, 22, const_tuple_4056a0ef07ec9188d15ce9b607833855_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_483345fee779ba1705e61c19617f3712 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___exit__, 116, const_tuple_4f1fa4ca5d2d9824e633f94f53baafb9_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_df97ed3424cb10a88b4203af3cf76740 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___exit__, 297, const_tuple_str_plain_self_str_plain_exc_info_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_NOFREE );
    codeobj_67a1e3a1c0061e332d3094ae30557685 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___exit__, 315, const_tuple_7b3d388a553c47f52835463197dbad6d_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1b47f9f1ce467f7f75848449b2718fa6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___exit__, 358, const_tuple_7b3d388a553c47f52835463197dbad6d_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5319d6795f1312e749b7f025eaaf1c46 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___exit__, 468, const_tuple_c3f1cedc9785be0202d0c503283d5fdc_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_NOFREE );
    codeobj_dd8108231668e71787c3c868f3031f9b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___exit__, 676, const_tuple_str_plain_self_str_plain_excinfo_tuple, 1, 0, CO_VARARGS | CO_NOFREE );
    codeobj_7289da3863f64141e779df033dfe8c6d = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 81, const_tuple_59ad8b9a7b3958ff248ecbb0d59682e2_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e3c17e4fc256ae365524c8cbb1598249 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 293, const_tuple_str_plain_self_str_plain_thing_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6e54b004743913720c86884cf47d4c7b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 305, const_tuple_str_plain_self_str_plain_new_target_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b4139367cf6f902d8f012d68c18fbdff = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 352, const_tuple_str_plain_self_str_plain_exceptions_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_NOFREE );
    codeobj_209a810c6ebd52b561796e0f9bae79be = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 386, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3f39158aafe18f3b316031d137e3a7af = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 670, const_tuple_str_plain_self_str_plain_enter_result_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3010ebafdd9c4ae5d6be7668f47fd0ff = MAKE_CODEOBJ( module_filename_obj, const_str_plain___subclasshook__, 27, const_tuple_str_plain_cls_str_plain_C_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_34b0278e9808572c069bceb941715927 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___subclasshook__, 47, const_tuple_str_plain_cls_str_plain_C_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cd00d3f4cbbe7bcc26349b3d24f73b5a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__create_async_cb_wrapper, 542, const_tuple_f7761c758733e94d335a6027b2f1d7bd_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_bff15e44f163505d42b2d15a38f2c81c = MAKE_CODEOBJ( module_filename_obj, const_str_plain__create_async_exit_wrapper, 536, const_tuple_str_plain_cm_str_plain_cm_exit_str_plain__exit_wrapper_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f6bfedafdf345fc87a24d5cc8030c305 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__create_cb_wrapper, 380, const_tuple_f7761c758733e94d335a6027b2f1d7bd_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_50f7458fdc57dfdb87cc1909e09be3ec = MAKE_CODEOBJ( module_filename_obj, const_str_plain__create_exit_wrapper, 374, const_tuple_str_plain_cm_str_plain_cm_exit_str_plain__exit_wrapper_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b314dfc24cfb446bc412a4b84347e7bb = MAKE_CODEOBJ( module_filename_obj, const_str_plain__exit_wrapper, 376, const_tuple_b69d8130dfe3195008f41e5d64bfb37e_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_c5e0bdefa48e79d21cad1e6b166e62e9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__exit_wrapper, 382, const_tuple_ca1557cefb10ceab4fdb9c9136a76a76_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_c28aa9caf0be431315f136ca024fd8ff = MAKE_CODEOBJ( module_filename_obj, const_str_plain__exit_wrapper, 538, const_tuple_b69d8130dfe3195008f41e5d64bfb37e_tuple, 3, 0, CO_COROUTINE | CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_79334a1036d8c97f06c39c18817bf2f2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__exit_wrapper, 544, const_tuple_ca1557cefb10ceab4fdb9c9136a76a76_tuple, 3, 0, CO_COROUTINE | CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_bbfd4ac0f959c684210adaa396b9a35a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__fix_exception_context, 474, const_tuple_9bff1fb10d94302cf075ed06fe9c426d_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_472f3c61d3963d5dcde030560103997b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__fix_exception_context, 611, const_tuple_9bff1fb10d94302cf075ed06fe9c426d_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_b7274d5d850f21d60dd43edeab664be5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__push_async_cm_exit, 595, const_tuple_285275c053ca78d0b5fcb71ea58fcded_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5e7507c3fa2f8357a290571a7c2c87fb = MAKE_CODEOBJ( module_filename_obj, const_str_plain__push_cm_exit, 443, const_tuple_285275c053ca78d0b5fcb71ea58fcded_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e2bc8f99006d30c55dd2a8eecf6821aa = MAKE_CODEOBJ( module_filename_obj, const_str_plain__push_exit_callback, 449, const_tuple_str_plain_self_str_plain_callback_str_plain_is_sync_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cb08c024b4d4f770d9b5cdd06dc0c2d8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__recreate_cm, 58, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ae091acc94155ceeb0d0b8a3dab512c6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__recreate_cm, 101, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_86d241f5735172421d3744f63bc43116 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_aclose, 591, const_tuple_str_plain_self_tuple, 1, 0, CO_COROUTINE | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_535fe3b96fc9f66283c68667446d44b4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_asynccontextmanager, 243, const_tuple_str_plain_func_str_plain_helper_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d11d44405c07a698ba8f0ab99d8d0e2a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_callback, 430, const_tuple_24294d365f055f3473896705acca5164_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_6bd1f91ac15dd8324cd978b80269b375 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_close, 517, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5d897d4474259a7128af7713d0e7b885 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_closing, 276, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_c9d7fea79421b5192503141dd6b626fa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_contextmanager, 210, const_tuple_str_plain_func_str_plain_helper_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b5aa3e2dedb8972036672150e4e23f41 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_enter_async_context, 548, const_tuple_99e4f7d79998fef56c940fc534bd3d1a_tuple, 2, 0, CO_COROUTINE | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c2b386b5b585286d75c620b41f07f6f9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_enter_context, 416, const_tuple_99e4f7d79998fef56c940fc534bd3d1a_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b32d399f13c7f5cb32706e7e8544adcd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_helper, 237, const_tuple_str_plain_args_str_plain_kwds_str_plain_func_tuple, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS );
    codeobj_fe180fc33126050a85ed6c97d75eb435 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_helper, 270, const_tuple_str_plain_args_str_plain_kwds_str_plain_func_tuple, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS );
    codeobj_de02ad5f3ecd8dc39711a0813e03c5e9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_inner, 71, const_tuple_str_plain_args_str_plain_kwds_str_plain_self_str_plain_func_tuple, 0, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS );
    codeobj_2415601356a99a081119e44dfac162fa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_nullcontext, 659, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_ac1633f3fdcf108561287a9aaae4de40 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pop_all, 389, const_tuple_str_plain_self_str_plain_new_stack_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3eea89dad8802f791e00692828406a41 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_push, 396, const_tuple_e3d25ea3287460ab60449763727613f6_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_45e2cf9544c4a969db74b67d603ee00d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_push_async_callback, 578, const_tuple_24294d365f055f3473896705acca5164_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_2ceeed769613aea7ec41a0a0032b3f6d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_push_async_exit, 560, const_tuple_e3d25ea3287460ab60449763727613f6_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_87f04e9c08916a537b9d28a0c7179091 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_redirect_stderr, 335, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_d7fd5dc9be95290492bee556cea09260 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_redirect_stdout, 319, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
    codeobj_780dcd518a86239b52f6ae1915c129d3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_suppress, 341, const_tuple_str_plain___class___tuple, 0, 0, CO_NOFREE );
}

// The module function declarations.
static PyObject *contextlib$$$function_4___aenter__$$$coroutine_1___aenter___maker( void );


static PyObject *contextlib$$$function_5___aexit__$$$coroutine_1___aexit___maker( void );


static PyObject *contextlib$$$function_13___aenter__$$$coroutine_1___aenter___maker( void );


static PyObject *contextlib$$$function_14___aexit__$$$coroutine_1___aexit___maker( void );


static PyObject *contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_maker( void );


static PyObject *contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_maker( void );


static PyObject *contextlib$$$function_40_enter_async_context$$$coroutine_1_enter_async_context_maker( void );


static PyObject *contextlib$$$function_43_aclose$$$coroutine_1_aclose_maker( void );


static PyObject *contextlib$$$function_45___aenter__$$$coroutine_1___aenter___maker( void );


static PyObject *contextlib$$$function_46___aexit__$$$coroutine_1___aexit___maker( void );


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_1__mro_entries_conversion( PyObject **python_pars );


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_5_complex_call_helper_star_list_star_dict( PyObject **python_pars );


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_8_complex_call_helper_pos_star_list_star_dict( PyObject **python_pars );


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_2_complex_call_helper_star_list( PyObject **python_pars );


static PyObject *MAKE_FUNCTION_contextlib$$$function_10__recreate_cm(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_11___enter__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_12___exit__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_13___aenter__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_14___aexit__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_15_contextmanager(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_15_contextmanager$$$function_1_helper(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_16_asynccontextmanager(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_16_asynccontextmanager$$$function_1_helper(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_17___init__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_18___enter__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_19___exit__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_1___enter__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_20___init__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_21___enter__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_22___exit__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_23___init__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_24___enter__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_25___exit__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_26__create_exit_wrapper(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_26__create_exit_wrapper$$$function_1__exit_wrapper(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_27__create_cb_wrapper(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_27__create_cb_wrapper$$$function_1__exit_wrapper(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_28___init__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_29_pop_all(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_2___exit__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_30_push(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_31_enter_context(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_32_callback(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_33__push_cm_exit(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_34__push_exit_callback( PyObject *defaults );


static PyObject *MAKE_FUNCTION_contextlib$$$function_35___enter__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_36___exit__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_36___exit__$$$function_1__fix_exception_context(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_37_close(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_38__create_async_exit_wrapper(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_39__create_async_cb_wrapper(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_3___subclasshook__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_40_enter_async_context(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_41_push_async_exit(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_42_push_async_callback(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_43_aclose(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_44__push_async_cm_exit(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_45___aenter__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_46___aexit__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_46___aexit__$$$coroutine_1___aexit__$$$function_1__fix_exception_context(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_47___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_contextlib$$$function_48___enter__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_49___exit__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_4___aenter__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_5___aexit__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_6___subclasshook__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_7__recreate_cm(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_8___call__(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_8___call__$$$function_1_inner(  );


static PyObject *MAKE_FUNCTION_contextlib$$$function_9___init__(  );


// The module function definitions.
static PyObject *impl_contextlib$$$function_1___enter__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    CHECK_OBJECT( par_self );
    tmp_return_value = par_self;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_1___enter__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_1___enter__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_2___exit__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exc_type = python_pars[ 1 ];
    PyObject *par_exc_value = python_pars[ 2 ];
    PyObject *par_traceback = python_pars[ 3 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_2___exit__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_value );
    Py_DECREF( par_exc_value );
    par_exc_value = NULL;

    CHECK_OBJECT( (PyObject *)par_traceback );
    Py_DECREF( par_traceback );
    par_traceback = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_value );
    Py_DECREF( par_exc_value );
    par_exc_value = NULL;

    CHECK_OBJECT( (PyObject *)par_traceback );
    Py_DECREF( par_traceback );
    par_traceback = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_2___exit__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_3___subclasshook__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_C = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_3010ebafdd9c4ae5d6be7668f47fd0ff;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3010ebafdd9c4ae5d6be7668f47fd0ff = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3010ebafdd9c4ae5d6be7668f47fd0ff, codeobj_3010ebafdd9c4ae5d6be7668f47fd0ff, module_contextlib, sizeof(void *)+sizeof(void *) );
    frame_3010ebafdd9c4ae5d6be7668f47fd0ff = cache_frame_3010ebafdd9c4ae5d6be7668f47fd0ff;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3010ebafdd9c4ae5d6be7668f47fd0ff );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3010ebafdd9c4ae5d6be7668f47fd0ff ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_cls );
        tmp_compexpr_left_1 = par_cls;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "AbstractContextManager" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 29;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__collections_abc );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__collections_abc );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_collections_abc" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 30;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_C );
            tmp_args_element_name_1 = par_C;
            tmp_args_element_name_2 = const_str_plain___enter__;
            tmp_args_element_name_3 = const_str_plain___exit__;
            frame_3010ebafdd9c4ae5d6be7668f47fd0ff->m_frame.f_lineno = 30;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain__check_methods, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 30;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3010ebafdd9c4ae5d6be7668f47fd0ff );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3010ebafdd9c4ae5d6be7668f47fd0ff );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3010ebafdd9c4ae5d6be7668f47fd0ff );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3010ebafdd9c4ae5d6be7668f47fd0ff, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3010ebafdd9c4ae5d6be7668f47fd0ff->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3010ebafdd9c4ae5d6be7668f47fd0ff, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3010ebafdd9c4ae5d6be7668f47fd0ff,
        type_description_1,
        par_cls,
        par_C
    );


    // Release cached frame.
    if ( frame_3010ebafdd9c4ae5d6be7668f47fd0ff == cache_frame_3010ebafdd9c4ae5d6be7668f47fd0ff )
    {
        Py_DECREF( frame_3010ebafdd9c4ae5d6be7668f47fd0ff );
    }
    cache_frame_3010ebafdd9c4ae5d6be7668f47fd0ff = NULL;

    assertFrameObject( frame_3010ebafdd9c4ae5d6be7668f47fd0ff );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_3___subclasshook__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_C );
    Py_DECREF( par_C );
    par_C = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_C );
    Py_DECREF( par_C );
    par_C = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_3___subclasshook__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_4___aenter__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = contextlib$$$function_4___aenter__$$$coroutine_1___aenter___maker();

    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_4___aenter__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_4___aenter__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct contextlib$$$function_4___aenter__$$$coroutine_1___aenter___locals {
    char const *type_description_1;
    PyObject *tmp_return_value;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
};

static PyObject *contextlib$$$function_4___aenter__$$$coroutine_1___aenter___context( struct Nuitka_CoroutineObject *coroutine, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)coroutine );
    assert( Nuitka_Coroutine_Check( (PyObject *)coroutine ) );

    // Heap access if used.
    struct contextlib$$$function_4___aenter__$$$coroutine_1___aenter___locals *coroutine_heap = (struct contextlib$$$function_4___aenter__$$$coroutine_1___aenter___locals *)coroutine->m_heap_storage;

    // Dispatch to yield based on return label index:


    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    coroutine_heap->type_description_1 = NULL;
    coroutine_heap->tmp_return_value = NULL;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    // Actual coroutine body.
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_abe4ba583c817761ab022d36929753d8, module_contextlib, sizeof(void *) );
    coroutine->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( coroutine->m_frame );
    assert( Py_REFCNT( coroutine->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    coroutine->m_frame->m_frame.f_gen = (PyObject *)coroutine;
#endif

    Py_CLEAR( coroutine->m_frame->m_frame.f_back );

    coroutine->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( coroutine->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &coroutine->m_frame->m_frame;
    Py_INCREF( coroutine->m_frame );

    Nuitka_Frame_MarkAsExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        coroutine->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( coroutine->m_frame->m_frame.f_exc_type == Py_None ) coroutine->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_type );
    coroutine->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_value );
    coroutine->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_traceback );
#else
        coroutine->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( coroutine->m_exc_state.exc_type == Py_None ) coroutine->m_exc_state.exc_type = NULL;
        Py_XINCREF( coroutine->m_exc_state.exc_type );
        coroutine->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_value );
        coroutine->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
    {

        coroutine_heap->exception_type = PyExc_NameError;
        Py_INCREF( coroutine_heap->exception_type );
        coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
        coroutine_heap->exception_tb = NULL;
        NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
        CHAIN_EXCEPTION( coroutine_heap->exception_value );

        coroutine_heap->exception_lineno = 40;
        coroutine_heap->type_description_1 = "c";
        goto frame_exception_exit_1;
    }

    coroutine_heap->tmp_return_value = PyCell_GET( coroutine->m_closure[0] );
    Py_INCREF( coroutine_heap->tmp_return_value );
    goto frame_return_exit_1;

    Nuitka_Frame_MarkAsNotExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( coroutine->m_frame );
    goto frame_no_exception_1;

    frame_return_exit_1:;

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );
    goto function_return_exit;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( coroutine_heap->exception_type ) )
    {
        if ( coroutine_heap->exception_tb == NULL )
        {
            coroutine_heap->exception_tb = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_lineno );
        }
        else if ( coroutine_heap->exception_tb->tb_frame != &coroutine->m_frame->m_frame )
        {
            coroutine_heap->exception_tb = ADD_TRACEBACK( coroutine_heap->exception_tb, coroutine->m_frame, coroutine_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)coroutine->m_frame,
            coroutine_heap->type_description_1,
            coroutine->m_closure[0]
        );


        // Release cached frame.
        if ( coroutine->m_frame == cache_m_frame )
        {
            Py_DECREF( coroutine->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( coroutine->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must be present.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_4___aenter__$$$coroutine_1___aenter__ );

    function_exception_exit:
    assert( coroutine_heap->exception_type );
    RESTORE_ERROR_OCCURRED( coroutine_heap->exception_type, coroutine_heap->exception_value, coroutine_heap->exception_tb );
    return NULL;
    function_return_exit:;

    coroutine->m_returned = coroutine_heap->tmp_return_value;

    return NULL;

}

static PyObject *contextlib$$$function_4___aenter__$$$coroutine_1___aenter___maker( void )
{
    return Nuitka_Coroutine_New(
        contextlib$$$function_4___aenter__$$$coroutine_1___aenter___context,
        module_contextlib,
        const_str_plain___aenter__,
        const_str_digest_072d893f430d6100c064aab7d47e5365,
        codeobj_abe4ba583c817761ab022d36929753d8,
        1,
        sizeof(struct contextlib$$$function_4___aenter__$$$coroutine_1___aenter___locals)
    );
}


static PyObject *impl_contextlib$$$function_5___aexit__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exc_type = python_pars[ 1 ];
    PyObject *par_exc_value = python_pars[ 2 ];
    PyObject *par_traceback = python_pars[ 3 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = contextlib$$$function_5___aexit__$$$coroutine_1___aexit___maker();



    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_5___aexit__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_value );
    Py_DECREF( par_exc_value );
    par_exc_value = NULL;

    CHECK_OBJECT( (PyObject *)par_traceback );
    Py_DECREF( par_traceback );
    par_traceback = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_value );
    Py_DECREF( par_exc_value );
    par_exc_value = NULL;

    CHECK_OBJECT( (PyObject *)par_traceback );
    Py_DECREF( par_traceback );
    par_traceback = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_5___aexit__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct contextlib$$$function_5___aexit__$$$coroutine_1___aexit___locals {
    PyObject *tmp_return_value;
};

static PyObject *contextlib$$$function_5___aexit__$$$coroutine_1___aexit___context( struct Nuitka_CoroutineObject *coroutine, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)coroutine );
    assert( Nuitka_Coroutine_Check( (PyObject *)coroutine ) );

    // Heap access if used.
    struct contextlib$$$function_5___aexit__$$$coroutine_1___aexit___locals *coroutine_heap = (struct contextlib$$$function_5___aexit__$$$coroutine_1___aexit___locals *)coroutine->m_heap_storage;

    // Dispatch to yield based on return label index:


    // Local variable initialization
    coroutine_heap->tmp_return_value = NULL;

    // Actual coroutine body.
    coroutine_heap->tmp_return_value = Py_None;
    Py_INCREF( coroutine_heap->tmp_return_value );
    goto function_return_exit;

    // Return statement must be present.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_5___aexit__$$$coroutine_1___aexit__ );


    return NULL;
    function_return_exit:;

    coroutine->m_returned = coroutine_heap->tmp_return_value;

    return NULL;

}

static PyObject *contextlib$$$function_5___aexit__$$$coroutine_1___aexit___maker( void )
{
    return Nuitka_Coroutine_New(
        contextlib$$$function_5___aexit__$$$coroutine_1___aexit___context,
        module_contextlib,
        const_str_plain___aexit__,
        const_str_digest_15e936ef3374424b98cf9aa15867b234,
        codeobj_d62b1f4472ae7081578940b4d26b2c48,
        0,
        sizeof(struct contextlib$$$function_5___aexit__$$$coroutine_1___aexit___locals)
    );
}


static PyObject *impl_contextlib$$$function_6___subclasshook__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_C = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_34b0278e9808572c069bceb941715927;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_34b0278e9808572c069bceb941715927 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_34b0278e9808572c069bceb941715927, codeobj_34b0278e9808572c069bceb941715927, module_contextlib, sizeof(void *)+sizeof(void *) );
    frame_34b0278e9808572c069bceb941715927 = cache_frame_34b0278e9808572c069bceb941715927;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_34b0278e9808572c069bceb941715927 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_34b0278e9808572c069bceb941715927 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_cls );
        tmp_compexpr_left_1 = par_cls;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AbstractAsyncContextManager );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AbstractAsyncContextManager );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "AbstractAsyncContextManager" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 49;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__collections_abc );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__collections_abc );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_collections_abc" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 50;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_C );
            tmp_args_element_name_1 = par_C;
            tmp_args_element_name_2 = const_str_plain___aenter__;
            tmp_args_element_name_3 = const_str_plain___aexit__;
            frame_34b0278e9808572c069bceb941715927->m_frame.f_lineno = 50;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain__check_methods, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 50;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_34b0278e9808572c069bceb941715927 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_34b0278e9808572c069bceb941715927 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_34b0278e9808572c069bceb941715927 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_34b0278e9808572c069bceb941715927, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_34b0278e9808572c069bceb941715927->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_34b0278e9808572c069bceb941715927, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_34b0278e9808572c069bceb941715927,
        type_description_1,
        par_cls,
        par_C
    );


    // Release cached frame.
    if ( frame_34b0278e9808572c069bceb941715927 == cache_frame_34b0278e9808572c069bceb941715927 )
    {
        Py_DECREF( frame_34b0278e9808572c069bceb941715927 );
    }
    cache_frame_34b0278e9808572c069bceb941715927 = NULL;

    assertFrameObject( frame_34b0278e9808572c069bceb941715927 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_6___subclasshook__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_C );
    Py_DECREF( par_C );
    par_C = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_C );
    Py_DECREF( par_C );
    par_C = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_6___subclasshook__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_7__recreate_cm( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    CHECK_OBJECT( par_self );
    tmp_return_value = par_self;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_7__recreate_cm );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_7__recreate_cm );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_8___call__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_func = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_inner = NULL;
    struct Nuitka_FrameObject *frame_09fd19dda9487a9928a1b4ed8c1ffc15;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_09fd19dda9487a9928a1b4ed8c1ffc15 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_09fd19dda9487a9928a1b4ed8c1ffc15, codeobj_09fd19dda9487a9928a1b4ed8c1ffc15, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_09fd19dda9487a9928a1b4ed8c1ffc15 = cache_frame_09fd19dda9487a9928a1b4ed8c1ffc15;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_09fd19dda9487a9928a1b4ed8c1ffc15 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_09fd19dda9487a9928a1b4ed8c1ffc15 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_wraps );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "wraps" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 71;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_func ) );
        tmp_args_element_name_1 = PyCell_GET( par_func );
        frame_09fd19dda9487a9928a1b4ed8c1ffc15->m_frame.f_lineno = 71;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 71;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = MAKE_FUNCTION_contextlib$$$function_8___call__$$$function_1_inner(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = par_func;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[1] );


        frame_09fd19dda9487a9928a1b4ed8c1ffc15->m_frame.f_lineno = 71;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 71;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert( var_inner == NULL );
        var_inner = tmp_assign_source_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_09fd19dda9487a9928a1b4ed8c1ffc15 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_09fd19dda9487a9928a1b4ed8c1ffc15 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_09fd19dda9487a9928a1b4ed8c1ffc15, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_09fd19dda9487a9928a1b4ed8c1ffc15->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_09fd19dda9487a9928a1b4ed8c1ffc15, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_09fd19dda9487a9928a1b4ed8c1ffc15,
        type_description_1,
        par_self,
        par_func,
        var_inner
    );


    // Release cached frame.
    if ( frame_09fd19dda9487a9928a1b4ed8c1ffc15 == cache_frame_09fd19dda9487a9928a1b4ed8c1ffc15 )
    {
        Py_DECREF( frame_09fd19dda9487a9928a1b4ed8c1ffc15 );
    }
    cache_frame_09fd19dda9487a9928a1b4ed8c1ffc15 = NULL;

    assertFrameObject( frame_09fd19dda9487a9928a1b4ed8c1ffc15 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_inner );
    tmp_return_value = var_inner;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_8___call__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    CHECK_OBJECT( (PyObject *)var_inner );
    Py_DECREF( var_inner );
    var_inner = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_8___call__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_8___call__$$$function_1_inner( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_args = python_pars[ 0 ];
    PyObject *par_kwds = python_pars[ 1 ];
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__exit = NULL;
    nuitka_bool tmp_with_1__indicator = NUITKA_BOOL_UNASSIGNED;
    PyObject *tmp_with_1__source = NULL;
    struct Nuitka_FrameObject *frame_de02ad5f3ecd8dc39711a0813e03c5e9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    static struct Nuitka_FrameObject *cache_frame_de02ad5f3ecd8dc39711a0813e03c5e9 = NULL;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_de02ad5f3ecd8dc39711a0813e03c5e9, codeobj_de02ad5f3ecd8dc39711a0813e03c5e9, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_de02ad5f3ecd8dc39711a0813e03c5e9 = cache_frame_de02ad5f3ecd8dc39711a0813e03c5e9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_de02ad5f3ecd8dc39711a0813e03c5e9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_de02ad5f3ecd8dc39711a0813e03c5e9 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        if ( PyCell_GET( self->m_closure[1] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 73;
            type_description_1 = "oocc";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = PyCell_GET( self->m_closure[1] );
        frame_de02ad5f3ecd8dc39711a0813e03c5e9->m_frame.f_lineno = 73;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__recreate_cm );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 73;
            type_description_1 = "oocc";
            goto try_except_handler_2;
        }
        assert( tmp_with_1__source == NULL );
        tmp_with_1__source = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( tmp_with_1__source );
        tmp_source_name_1 = tmp_with_1__source;
        tmp_called_name_1 = LOOKUP_SPECIAL( tmp_source_name_1, const_str_plain___enter__ );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 73;
            type_description_1 = "oocc";
            goto try_except_handler_2;
        }
        frame_de02ad5f3ecd8dc39711a0813e03c5e9->m_frame.f_lineno = 73;
        tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 73;
            type_description_1 = "oocc";
            goto try_except_handler_2;
        }
        assert( tmp_with_1__enter == NULL );
        tmp_with_1__enter = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( tmp_with_1__source );
        tmp_source_name_2 = tmp_with_1__source;
        tmp_assign_source_3 = LOOKUP_SPECIAL( tmp_source_name_2, const_str_plain___exit__ );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 73;
            type_description_1 = "oocc";
            goto try_except_handler_2;
        }
        assert( tmp_with_1__exit == NULL );
        tmp_with_1__exit = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_assign_source_4;
        tmp_assign_source_4 = NUITKA_BOOL_TRUE;
        tmp_with_1__indicator = tmp_assign_source_4;
    }
    // Tried code:
    // Tried code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_dircall_arg3_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "func" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 74;
            type_description_1 = "oocc";
            goto try_except_handler_4;
        }

        tmp_dircall_arg1_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_args );
        tmp_dircall_arg2_1 = par_args;
        CHECK_OBJECT( par_kwds );
        tmp_dircall_arg3_1 = par_kwds;
        Py_INCREF( tmp_dircall_arg1_1 );
        Py_INCREF( tmp_dircall_arg2_1 );
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_5_complex_call_helper_star_list_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 74;
            type_description_1 = "oocc";
            goto try_except_handler_4;
        }
        goto try_return_handler_3;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_8___call__$$$function_1_inner );
    return NULL;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_de02ad5f3ecd8dc39711a0813e03c5e9, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_de02ad5f3ecd8dc39711a0813e03c5e9, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_BaseException;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 73;
            type_description_1 = "oocc";
            goto try_except_handler_5;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_assign_source_5;
            tmp_assign_source_5 = NUITKA_BOOL_FALSE;
            tmp_with_1__indicator = tmp_assign_source_5;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_called_name_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( tmp_with_1__exit );
            tmp_called_name_2 = tmp_with_1__exit;
            tmp_args_element_name_1 = EXC_TYPE(PyThreadState_GET());
            tmp_args_element_name_2 = EXC_VALUE(PyThreadState_GET());
            tmp_args_element_name_3 = EXC_TRACEBACK(PyThreadState_GET());
            frame_de02ad5f3ecd8dc39711a0813e03c5e9->m_frame.f_lineno = 73;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_operand_name_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
            }

            if ( tmp_operand_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 73;
                type_description_1 = "oocc";
                goto try_except_handler_5;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            Py_DECREF( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 73;
                type_description_1 = "oocc";
                goto try_except_handler_5;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 73;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_de02ad5f3ecd8dc39711a0813e03c5e9->m_frame) frame_de02ad5f3ecd8dc39711a0813e03c5e9->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "oocc";
            goto try_except_handler_5;
            branch_no_2:;
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 73;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_de02ad5f3ecd8dc39711a0813e03c5e9->m_frame) frame_de02ad5f3ecd8dc39711a0813e03c5e9->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oocc";
        goto try_except_handler_5;
        branch_end_1:;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_3;
    // End of try:
    try_end_1:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    goto try_end_2;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_8___call__$$$function_1_inner );
    return NULL;
    // End of try:
    try_end_2:;
    goto try_end_3;
    // Return handler code:
    try_return_handler_3:;
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( tmp_with_1__exit );
        tmp_called_name_3 = tmp_with_1__exit;
        frame_de02ad5f3ecd8dc39711a0813e03c5e9->m_frame.f_lineno = 73;
        tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 73;
            type_description_1 = "oocc";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    goto try_return_handler_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        nuitka_bool tmp_condition_result_3;
        nuitka_bool tmp_compexpr_left_2;
        nuitka_bool tmp_compexpr_right_2;
        assert( tmp_with_1__indicator != NUITKA_BOOL_UNASSIGNED);
        tmp_compexpr_left_2 = tmp_with_1__indicator;
        tmp_compexpr_right_2 = NUITKA_BOOL_TRUE;
        tmp_condition_result_3 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_call_result_2;
            CHECK_OBJECT( tmp_with_1__exit );
            tmp_called_name_4 = tmp_with_1__exit;
            frame_de02ad5f3ecd8dc39711a0813e03c5e9->m_frame.f_lineno = 73;
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                Py_DECREF( exception_keeper_type_3 );
                Py_XDECREF( exception_keeper_value_3 );
                Py_XDECREF( exception_keeper_tb_3 );

                exception_lineno = 73;
                type_description_1 = "oocc";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_3:;
    }
    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_2;
    // End of try:
    try_end_3:;
    {
        nuitka_bool tmp_condition_result_4;
        nuitka_bool tmp_compexpr_left_3;
        nuitka_bool tmp_compexpr_right_3;
        assert( tmp_with_1__indicator != NUITKA_BOOL_UNASSIGNED);
        tmp_compexpr_left_3 = tmp_with_1__indicator;
        tmp_compexpr_right_3 = NUITKA_BOOL_TRUE;
        tmp_condition_result_4 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_call_result_3;
            CHECK_OBJECT( tmp_with_1__exit );
            tmp_called_name_5 = tmp_with_1__exit;
            frame_de02ad5f3ecd8dc39711a0813e03c5e9->m_frame.f_lineno = 73;
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 73;
                type_description_1 = "oocc";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        branch_no_4:;
    }
    goto try_end_4;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_de02ad5f3ecd8dc39711a0813e03c5e9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_de02ad5f3ecd8dc39711a0813e03c5e9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_de02ad5f3ecd8dc39711a0813e03c5e9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_de02ad5f3ecd8dc39711a0813e03c5e9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_de02ad5f3ecd8dc39711a0813e03c5e9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_de02ad5f3ecd8dc39711a0813e03c5e9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_de02ad5f3ecd8dc39711a0813e03c5e9,
        type_description_1,
        par_args,
        par_kwds,
        self->m_closure[1],
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_de02ad5f3ecd8dc39711a0813e03c5e9 == cache_frame_de02ad5f3ecd8dc39711a0813e03c5e9 )
    {
        Py_DECREF( frame_de02ad5f3ecd8dc39711a0813e03c5e9 );
    }
    cache_frame_de02ad5f3ecd8dc39711a0813e03c5e9 = NULL;

    assertFrameObject( frame_de02ad5f3ecd8dc39711a0813e03c5e9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_8___call__$$$function_1_inner );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_8___call__$$$function_1_inner );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_9___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_func = python_pars[ 1 ];
    PyObject *par_args = python_pars[ 2 ];
    PyObject *par_kwds = python_pars[ 3 ];
    PyObject *var_doc = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_7289da3863f64141e779df033dfe8c6d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_7289da3863f64141e779df033dfe8c6d = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7289da3863f64141e779df033dfe8c6d, codeobj_7289da3863f64141e779df033dfe8c6d, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7289da3863f64141e779df033dfe8c6d = cache_frame_7289da3863f64141e779df033dfe8c6d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7289da3863f64141e779df033dfe8c6d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7289da3863f64141e779df033dfe8c6d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_dircall_arg3_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_func );
        tmp_dircall_arg1_1 = par_func;
        CHECK_OBJECT( par_args );
        tmp_dircall_arg2_1 = par_args;
        CHECK_OBJECT( par_kwds );
        tmp_dircall_arg3_1 = par_kwds;
        Py_INCREF( tmp_dircall_arg1_1 );
        Py_INCREF( tmp_dircall_arg2_1 );
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_assattr_name_1 = impl___internal__$$$function_5_complex_call_helper_star_list_star_dict( dir_call_args );
        }
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 82;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_gen, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 82;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_tuple_element_1;
        CHECK_OBJECT( par_func );
        tmp_tuple_element_1 = par_func;
        tmp_iter_arg_1 = PyTuple_New( 3 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_iter_arg_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_args );
        tmp_tuple_element_1 = par_args;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_iter_arg_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwds );
        tmp_tuple_element_1 = par_kwds;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_iter_arg_1, 2, tmp_tuple_element_1 );
        tmp_assign_source_1 = MAKE_UNPACK_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        assert( !(tmp_assign_source_1 == NULL) );
        assert( tmp_tuple_unpack_1__source_iter == NULL );
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_1;
    }
    // Tried code:
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_2 = UNPACK_NEXT( tmp_unpack_1, 0, 3 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "ooooo";
            exception_lineno = 83;
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__element_1 == NULL );
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_2, 1, 3 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "ooooo";
            exception_lineno = 83;
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__element_2 == NULL );
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_unpack_3;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_3 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_3, 2, 3 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "ooooo";
            exception_lineno = 83;
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__element_3 == NULL );
        tmp_tuple_unpack_1__element_3 = tmp_assign_source_4;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assattr_name_2 = tmp_tuple_unpack_1__element_1;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_func, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 83;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assattr_name_3 = tmp_tuple_unpack_1__element_2;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_args, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 83;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_3 );
        tmp_assattr_name_4 = tmp_tuple_unpack_1__element_3;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_kwds, tmp_assattr_name_4 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 83;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_3 );
    tmp_tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_tuple_unpack_1__element_3 );
    tmp_tuple_unpack_1__element_3 = NULL;

    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_getattr_target_1;
        PyObject *tmp_getattr_attr_1;
        PyObject *tmp_getattr_default_1;
        CHECK_OBJECT( par_func );
        tmp_getattr_target_1 = par_func;
        tmp_getattr_attr_1 = const_str_plain___doc__;
        tmp_getattr_default_1 = Py_None;
        tmp_assign_source_5 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 85;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_doc == NULL );
        var_doc = tmp_assign_source_5;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_doc );
        tmp_compexpr_left_1 = var_doc;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_source_name_1;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT( par_self );
            tmp_type_arg_1 = par_self;
            tmp_source_name_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
            assert( !(tmp_source_name_1 == NULL) );
            tmp_assign_source_6 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___doc__ );
            Py_DECREF( tmp_source_name_1 );
            if ( tmp_assign_source_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 87;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_doc;
                assert( old != NULL );
                var_doc = tmp_assign_source_6;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        CHECK_OBJECT( var_doc );
        tmp_assattr_name_5 = var_doc;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_5 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain___doc__, tmp_assattr_name_5 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 88;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7289da3863f64141e779df033dfe8c6d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7289da3863f64141e779df033dfe8c6d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7289da3863f64141e779df033dfe8c6d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7289da3863f64141e779df033dfe8c6d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7289da3863f64141e779df033dfe8c6d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7289da3863f64141e779df033dfe8c6d,
        type_description_1,
        par_self,
        par_func,
        par_args,
        par_kwds,
        var_doc
    );


    // Release cached frame.
    if ( frame_7289da3863f64141e779df033dfe8c6d == cache_frame_7289da3863f64141e779df033dfe8c6d )
    {
        Py_DECREF( frame_7289da3863f64141e779df033dfe8c6d );
    }
    cache_frame_7289da3863f64141e779df033dfe8c6d = NULL;

    assertFrameObject( frame_7289da3863f64141e779df033dfe8c6d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_9___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    CHECK_OBJECT( (PyObject *)var_doc );
    Py_DECREF( var_doc );
    var_doc = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    Py_XDECREF( var_doc );
    var_doc = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_9___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_10__recreate_cm( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_ae091acc94155ceeb0d0b8a3dab512c6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ae091acc94155ceeb0d0b8a3dab512c6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ae091acc94155ceeb0d0b8a3dab512c6, codeobj_ae091acc94155ceeb0d0b8a3dab512c6, module_contextlib, sizeof(void *) );
    frame_ae091acc94155ceeb0d0b8a3dab512c6 = cache_frame_ae091acc94155ceeb0d0b8a3dab512c6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ae091acc94155ceeb0d0b8a3dab512c6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ae091acc94155ceeb0d0b8a3dab512c6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_1 );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_func );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_args );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_kwds );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            Py_DECREF( tmp_args_element_name_2 );

            exception_lineno = 105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_ae091acc94155ceeb0d0b8a3dab512c6->m_frame.f_lineno = 105;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ae091acc94155ceeb0d0b8a3dab512c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ae091acc94155ceeb0d0b8a3dab512c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ae091acc94155ceeb0d0b8a3dab512c6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ae091acc94155ceeb0d0b8a3dab512c6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ae091acc94155ceeb0d0b8a3dab512c6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ae091acc94155ceeb0d0b8a3dab512c6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ae091acc94155ceeb0d0b8a3dab512c6,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ae091acc94155ceeb0d0b8a3dab512c6 == cache_frame_ae091acc94155ceeb0d0b8a3dab512c6 )
    {
        Py_DECREF( frame_ae091acc94155ceeb0d0b8a3dab512c6 );
    }
    cache_frame_ae091acc94155ceeb0d0b8a3dab512c6 = NULL;

    assertFrameObject( frame_ae091acc94155ceeb0d0b8a3dab512c6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_10__recreate_cm );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_10__recreate_cm );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_11___enter__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_ab6d63e978e1252c4db14ab08bb51a49;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_ab6d63e978e1252c4db14ab08bb51a49 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ab6d63e978e1252c4db14ab08bb51a49, codeobj_ab6d63e978e1252c4db14ab08bb51a49, module_contextlib, sizeof(void *) );
    frame_ab6d63e978e1252c4db14ab08bb51a49 = cache_frame_ab6d63e978e1252c4db14ab08bb51a49;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ab6d63e978e1252c4db14ab08bb51a49 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ab6d63e978e1252c4db14ab08bb51a49 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_attrdel_target_1;
        CHECK_OBJECT( par_self );
        tmp_attrdel_target_1 = par_self;
        tmp_res = PyObject_DelAttr( tmp_attrdel_target_1, const_str_plain_args );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 110;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_attrdel_target_2;
        CHECK_OBJECT( par_self );
        tmp_attrdel_target_2 = par_self;
        tmp_res = PyObject_DelAttr( tmp_attrdel_target_2, const_str_plain_kwds );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 110;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_attrdel_target_3;
        CHECK_OBJECT( par_self );
        tmp_attrdel_target_3 = par_self;
        tmp_res = PyObject_DelAttr( tmp_attrdel_target_3, const_str_plain_func );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 110;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }
    // Tried code:
    {
        PyObject *tmp_value_name_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_value_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gen );
        if ( tmp_value_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 112;
            type_description_1 = "o";
            goto try_except_handler_2;
        }
        tmp_return_value = ITERATOR_NEXT( tmp_value_name_1 );
        Py_DECREF( tmp_value_name_1 );
        if ( tmp_return_value == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "o";
            exception_lineno = 112;
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_11___enter__ );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_ab6d63e978e1252c4db14ab08bb51a49, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_ab6d63e978e1252c4db14ab08bb51a49, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_StopIteration;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 113;
            type_description_1 = "o";
            goto try_except_handler_3;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_raise_cause_1;
            tmp_make_exception_arg_1 = const_str_digest_43d77277e950cc565806fc3c134d250b;
            frame_ab6d63e978e1252c4db14ab08bb51a49->m_frame.f_lineno = 114;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_RuntimeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            tmp_raise_cause_1 = Py_None;
            exception_type = tmp_raise_type_1;
            exception_value = NULL;
            Py_INCREF( tmp_raise_cause_1 );
            exception_lineno = 114;
            RAISE_EXCEPTION_WITH_CAUSE( &exception_type, &exception_value, &exception_tb, tmp_raise_cause_1 );
            type_description_1 = "o";
            goto try_except_handler_3;
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 111;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_ab6d63e978e1252c4db14ab08bb51a49->m_frame) frame_ab6d63e978e1252c4db14ab08bb51a49->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "o";
        goto try_except_handler_3;
        branch_end_1:;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_11___enter__ );
    return NULL;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab6d63e978e1252c4db14ab08bb51a49 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab6d63e978e1252c4db14ab08bb51a49 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ab6d63e978e1252c4db14ab08bb51a49 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ab6d63e978e1252c4db14ab08bb51a49, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ab6d63e978e1252c4db14ab08bb51a49->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ab6d63e978e1252c4db14ab08bb51a49, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ab6d63e978e1252c4db14ab08bb51a49,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ab6d63e978e1252c4db14ab08bb51a49 == cache_frame_ab6d63e978e1252c4db14ab08bb51a49 )
    {
        Py_DECREF( frame_ab6d63e978e1252c4db14ab08bb51a49 );
    }
    cache_frame_ab6d63e978e1252c4db14ab08bb51a49 = NULL;

    assertFrameObject( frame_ab6d63e978e1252c4db14ab08bb51a49 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_11___enter__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_11___enter__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_12___exit__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_type = python_pars[ 1 ];
    PyObject *par_value = python_pars[ 2 ];
    PyObject *par_traceback = python_pars[ 3 ];
    PyObject *var_exc = NULL;
    struct Nuitka_FrameObject *frame_483345fee779ba1705e61c19617f3712;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_preserved_type_2;
    PyObject *exception_preserved_value_2;
    PyTracebackObject *exception_preserved_tb_2;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    static struct Nuitka_FrameObject *cache_frame_483345fee779ba1705e61c19617f3712 = NULL;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_483345fee779ba1705e61c19617f3712, codeobj_483345fee779ba1705e61c19617f3712, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_483345fee779ba1705e61c19617f3712 = cache_frame_483345fee779ba1705e61c19617f3712;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_483345fee779ba1705e61c19617f3712 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_483345fee779ba1705e61c19617f3712 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        // Tried code:
        {
            PyObject *tmp_value_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_next_value_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_value_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gen );
            if ( tmp_value_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 119;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            tmp_next_value_1 = ITERATOR_NEXT( tmp_value_name_1 );
            Py_DECREF( tmp_value_name_1 );
            if ( tmp_next_value_1 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "ooooo";
                exception_lineno = 119;
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_next_value_1 );
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_type_1 );
        exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_value_1 );
        exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
        Py_XINCREF( exception_preserved_tb_1 );

        if ( exception_keeper_tb_1 == NULL )
        {
            exception_keeper_tb_1 = MAKE_TRACEBACK( frame_483345fee779ba1705e61c19617f3712, exception_keeper_lineno_1 );
        }
        else if ( exception_keeper_lineno_1 != 0 )
        {
            exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_483345fee779ba1705e61c19617f3712, exception_keeper_lineno_1 );
        }

        NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
        PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        // Tried code:
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
            tmp_compexpr_right_2 = PyExc_StopIteration;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 120;
                type_description_1 = "ooooo";
                goto try_except_handler_3;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            tmp_return_value = Py_False;
            Py_INCREF( tmp_return_value );
            goto try_return_handler_3;
            goto branch_end_2;
            branch_no_2:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 118;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_483345fee779ba1705e61c19617f3712->m_frame) frame_483345fee779ba1705e61c19617f3712->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "ooooo";
            goto try_except_handler_3;
            branch_end_2:;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib$$$function_12___exit__ );
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        // Restore previous exception.
        SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
        goto frame_return_exit_1;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Restore previous exception.
        SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto frame_exception_exit_1;
        // End of try:
        // End of try:
        try_end_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_82cfb07b0e6277928c3fe172bffa179f;
            frame_483345fee779ba1705e61c19617f3712->m_frame.f_lineno = 123;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_RuntimeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 123;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            CHECK_OBJECT( par_value );
            tmp_compexpr_left_3 = par_value;
            tmp_compexpr_right_3 = Py_None;
            tmp_condition_result_3 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_1;
                PyObject *tmp_called_name_1;
                CHECK_OBJECT( par_type );
                tmp_called_name_1 = par_type;
                frame_483345fee779ba1705e61c19617f3712->m_frame.f_lineno = 128;
                tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
                if ( tmp_assign_source_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 128;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = par_value;
                    assert( old != NULL );
                    par_value = tmp_assign_source_1;
                    Py_DECREF( old );
                }

            }
            branch_no_3:;
        }
        // Tried code:
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_gen );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 130;
                type_description_1 = "ooooo";
                goto try_except_handler_4;
            }
            CHECK_OBJECT( par_type );
            tmp_args_element_name_1 = par_type;
            CHECK_OBJECT( par_value );
            tmp_args_element_name_2 = par_value;
            CHECK_OBJECT( par_traceback );
            tmp_args_element_name_3 = par_traceback;
            frame_483345fee779ba1705e61c19617f3712->m_frame.f_lineno = 130;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_throw, call_args );
            }

            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 130;
                type_description_1 = "ooooo";
                goto try_except_handler_4;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto try_end_2;
        // Exception handler code:
        try_except_handler_4:;
        exception_keeper_type_3 = exception_type;
        exception_keeper_value_3 = exception_value;
        exception_keeper_tb_3 = exception_tb;
        exception_keeper_lineno_3 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        exception_preserved_type_2 = EXC_TYPE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_type_2 );
        exception_preserved_value_2 = EXC_VALUE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_value_2 );
        exception_preserved_tb_2 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
        Py_XINCREF( exception_preserved_tb_2 );

        if ( exception_keeper_tb_3 == NULL )
        {
            exception_keeper_tb_3 = MAKE_TRACEBACK( frame_483345fee779ba1705e61c19617f3712, exception_keeper_lineno_3 );
        }
        else if ( exception_keeper_lineno_3 != 0 )
        {
            exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_483345fee779ba1705e61c19617f3712, exception_keeper_lineno_3 );
        }

        NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
        PyException_SetTraceback( exception_keeper_value_3, (PyObject *)exception_keeper_tb_3 );
        PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
        // Tried code:
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            tmp_compexpr_left_4 = EXC_TYPE(PyThreadState_GET());
            tmp_compexpr_right_4 = PyExc_StopIteration;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 131;
                type_description_1 = "ooooo";
                goto try_except_handler_5;
            }
            tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_assign_source_2;
                tmp_assign_source_2 = EXC_VALUE(PyThreadState_GET());
                assert( var_exc == NULL );
                Py_INCREF( tmp_assign_source_2 );
                var_exc = tmp_assign_source_2;
            }
            // Tried code:
            {
                PyObject *tmp_compexpr_left_5;
                PyObject *tmp_compexpr_right_5;
                CHECK_OBJECT( var_exc );
                tmp_compexpr_left_5 = var_exc;
                CHECK_OBJECT( par_value );
                tmp_compexpr_right_5 = par_value;
                tmp_return_value = ( tmp_compexpr_left_5 != tmp_compexpr_right_5 ) ? Py_True : Py_False;
                Py_INCREF( tmp_return_value );
                goto try_return_handler_6;
            }
            // tried codes exits in all cases
            NUITKA_CANNOT_GET_HERE( contextlib$$$function_12___exit__ );
            return NULL;
            // Return handler code:
            try_return_handler_6:;
            Py_XDECREF( var_exc );
            var_exc = NULL;

            goto try_return_handler_5;
            // End of try:
            goto branch_end_4;
            branch_no_4:;
            {
                nuitka_bool tmp_condition_result_5;
                PyObject *tmp_compexpr_left_6;
                PyObject *tmp_compexpr_right_6;
                tmp_compexpr_left_6 = EXC_TYPE(PyThreadState_GET());
                tmp_compexpr_right_6 = PyExc_RuntimeError;
                tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_6, tmp_compexpr_right_6 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 136;
                    type_description_1 = "ooooo";
                    goto try_except_handler_5;
                }
                tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_5;
                }
                else
                {
                    goto branch_no_5;
                }
                branch_yes_5:;
                {
                    PyObject *tmp_assign_source_3;
                    tmp_assign_source_3 = EXC_VALUE(PyThreadState_GET());
                    assert( var_exc == NULL );
                    Py_INCREF( tmp_assign_source_3 );
                    var_exc = tmp_assign_source_3;
                }
                // Tried code:
                {
                    nuitka_bool tmp_condition_result_6;
                    PyObject *tmp_compexpr_left_7;
                    PyObject *tmp_compexpr_right_7;
                    CHECK_OBJECT( var_exc );
                    tmp_compexpr_left_7 = var_exc;
                    CHECK_OBJECT( par_value );
                    tmp_compexpr_right_7 = par_value;
                    tmp_condition_result_6 = ( tmp_compexpr_left_7 == tmp_compexpr_right_7 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_6;
                    }
                    else
                    {
                        goto branch_no_6;
                    }
                    branch_yes_6:;
                    tmp_return_value = Py_False;
                    Py_INCREF( tmp_return_value );
                    goto try_return_handler_7;
                    branch_no_6:;
                }
                {
                    nuitka_bool tmp_condition_result_7;
                    int tmp_and_left_truth_1;
                    nuitka_bool tmp_and_left_value_1;
                    nuitka_bool tmp_and_right_value_1;
                    PyObject *tmp_compexpr_left_8;
                    PyObject *tmp_compexpr_right_8;
                    PyObject *tmp_compexpr_left_9;
                    PyObject *tmp_compexpr_right_9;
                    PyObject *tmp_source_name_3;
                    CHECK_OBJECT( par_type );
                    tmp_compexpr_left_8 = par_type;
                    tmp_compexpr_right_8 = PyExc_StopIteration;
                    tmp_and_left_value_1 = ( tmp_compexpr_left_8 == tmp_compexpr_right_8 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
                    if ( tmp_and_left_truth_1 == 1 )
                    {
                        goto and_right_1;
                    }
                    else
                    {
                        goto and_left_1;
                    }
                    and_right_1:;
                    CHECK_OBJECT( var_exc );
                    tmp_source_name_3 = var_exc;
                    tmp_compexpr_left_9 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___cause__ );
                    if ( tmp_compexpr_left_9 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 143;
                        type_description_1 = "ooooo";
                        goto try_except_handler_7;
                    }
                    CHECK_OBJECT( par_value );
                    tmp_compexpr_right_9 = par_value;
                    tmp_and_right_value_1 = ( tmp_compexpr_left_9 == tmp_compexpr_right_9 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    Py_DECREF( tmp_compexpr_left_9 );
                    tmp_condition_result_7 = tmp_and_right_value_1;
                    goto and_end_1;
                    and_left_1:;
                    tmp_condition_result_7 = tmp_and_left_value_1;
                    and_end_1:;
                    if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_7;
                    }
                    else
                    {
                        goto branch_no_7;
                    }
                    branch_yes_7:;
                    tmp_return_value = Py_False;
                    Py_INCREF( tmp_return_value );
                    goto try_return_handler_7;
                    branch_no_7:;
                }
                tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                if (unlikely( tmp_result == false ))
                {
                    exception_lineno = 145;
                }

                if (exception_tb && exception_tb->tb_frame == &frame_483345fee779ba1705e61c19617f3712->m_frame) frame_483345fee779ba1705e61c19617f3712->m_frame.f_lineno = exception_tb->tb_lineno;
                type_description_1 = "ooooo";
                goto try_except_handler_7;
                // tried codes exits in all cases
                NUITKA_CANNOT_GET_HERE( contextlib$$$function_12___exit__ );
                return NULL;
                // Return handler code:
                try_return_handler_7:;
                Py_XDECREF( var_exc );
                var_exc = NULL;

                goto try_return_handler_5;
                // Exception handler code:
                try_except_handler_7:;
                exception_keeper_type_4 = exception_type;
                exception_keeper_value_4 = exception_value;
                exception_keeper_tb_4 = exception_tb;
                exception_keeper_lineno_4 = exception_lineno;
                exception_type = NULL;
                exception_value = NULL;
                exception_tb = NULL;
                exception_lineno = 0;

                Py_XDECREF( var_exc );
                var_exc = NULL;

                // Re-raise.
                exception_type = exception_keeper_type_4;
                exception_value = exception_keeper_value_4;
                exception_tb = exception_keeper_tb_4;
                exception_lineno = exception_keeper_lineno_4;

                goto try_except_handler_5;
                // End of try:
                goto branch_end_5;
                branch_no_5:;
                {
                    nuitka_bool tmp_condition_result_8;
                    PyObject *tmp_compexpr_left_10;
                    PyObject *tmp_compexpr_right_10;
                    PyObject *tmp_subscribed_name_1;
                    PyObject *tmp_called_instance_2;
                    PyObject *tmp_mvar_value_1;
                    PyObject *tmp_subscript_name_1;
                    tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_sys );

                    if (unlikely( tmp_mvar_value_1 == NULL ))
                    {
                        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
                    }

                    if ( tmp_mvar_value_1 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
                        exception_tb = NULL;
                        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                        CHAIN_EXCEPTION( exception_value );

                        exception_lineno = 158;
                        type_description_1 = "ooooo";
                        goto try_except_handler_5;
                    }

                    tmp_called_instance_2 = tmp_mvar_value_1;
                    frame_483345fee779ba1705e61c19617f3712->m_frame.f_lineno = 158;
                    tmp_subscribed_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_exc_info );
                    if ( tmp_subscribed_name_1 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 158;
                        type_description_1 = "ooooo";
                        goto try_except_handler_5;
                    }
                    tmp_subscript_name_1 = const_int_pos_1;
                    tmp_compexpr_left_10 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 1 );
                    Py_DECREF( tmp_subscribed_name_1 );
                    if ( tmp_compexpr_left_10 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 158;
                        type_description_1 = "ooooo";
                        goto try_except_handler_5;
                    }
                    CHECK_OBJECT( par_value );
                    tmp_compexpr_right_10 = par_value;
                    tmp_condition_result_8 = ( tmp_compexpr_left_10 == tmp_compexpr_right_10 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    Py_DECREF( tmp_compexpr_left_10 );
                    if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_8;
                    }
                    else
                    {
                        goto branch_no_8;
                    }
                    branch_yes_8:;
                    tmp_return_value = Py_False;
                    Py_INCREF( tmp_return_value );
                    goto try_return_handler_5;
                    branch_no_8:;
                }
                tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                if (unlikely( tmp_result == false ))
                {
                    exception_lineno = 160;
                }

                if (exception_tb && exception_tb->tb_frame == &frame_483345fee779ba1705e61c19617f3712->m_frame) frame_483345fee779ba1705e61c19617f3712->m_frame.f_lineno = exception_tb->tb_lineno;
                type_description_1 = "ooooo";
                goto try_except_handler_5;
                branch_end_5:;
            }
            branch_end_4:;
        }
        goto try_end_3;
        // Return handler code:
        try_return_handler_5:;
        // Restore previous exception.
        SET_CURRENT_EXCEPTION( exception_preserved_type_2, exception_preserved_value_2, exception_preserved_tb_2 );
        goto frame_return_exit_1;
        // Exception handler code:
        try_except_handler_5:;
        exception_keeper_type_5 = exception_type;
        exception_keeper_value_5 = exception_value;
        exception_keeper_tb_5 = exception_tb;
        exception_keeper_lineno_5 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Restore previous exception.
        SET_CURRENT_EXCEPTION( exception_preserved_type_2, exception_preserved_value_2, exception_preserved_tb_2 );
        // Re-raise.
        exception_type = exception_keeper_type_5;
        exception_value = exception_keeper_value_5;
        exception_tb = exception_keeper_tb_5;
        exception_lineno = exception_keeper_lineno_5;

        goto frame_exception_exit_1;
        // End of try:
        try_end_3:;
        goto try_end_2;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib$$$function_12___exit__ );
        return NULL;
        // End of try:
        try_end_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_14d40be592e224e5e7136c1c40a4b531;
            frame_483345fee779ba1705e61c19617f3712->m_frame.f_lineno = 161;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_RuntimeError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 161;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_483345fee779ba1705e61c19617f3712 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_483345fee779ba1705e61c19617f3712 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_483345fee779ba1705e61c19617f3712 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_483345fee779ba1705e61c19617f3712, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_483345fee779ba1705e61c19617f3712->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_483345fee779ba1705e61c19617f3712, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_483345fee779ba1705e61c19617f3712,
        type_description_1,
        par_self,
        par_type,
        par_value,
        par_traceback,
        var_exc
    );


    // Release cached frame.
    if ( frame_483345fee779ba1705e61c19617f3712 == cache_frame_483345fee779ba1705e61c19617f3712 )
    {
        Py_DECREF( frame_483345fee779ba1705e61c19617f3712 );
    }
    cache_frame_483345fee779ba1705e61c19617f3712 = NULL;

    assertFrameObject( frame_483345fee779ba1705e61c19617f3712 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_12___exit__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_traceback );
    Py_DECREF( par_traceback );
    par_traceback = NULL;

    Py_XDECREF( var_exc );
    var_exc = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_traceback );
    Py_DECREF( par_traceback );
    par_traceback = NULL;

    Py_XDECREF( var_exc );
    var_exc = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_12___exit__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_13___aenter__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = contextlib$$$function_13___aenter__$$$coroutine_1___aenter___maker();

    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_13___aenter__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_13___aenter__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct contextlib$$$function_13___aenter__$$$coroutine_1___aenter___locals {
    char const *type_description_1;
    PyObject *tmp_return_value;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *contextlib$$$function_13___aenter__$$$coroutine_1___aenter___context( struct Nuitka_CoroutineObject *coroutine, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)coroutine );
    assert( Nuitka_Coroutine_Check( (PyObject *)coroutine ) );

    // Heap access if used.
    struct contextlib$$$function_13___aenter__$$$coroutine_1___aenter___locals *coroutine_heap = (struct contextlib$$$function_13___aenter__$$$coroutine_1___aenter___locals *)coroutine->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(coroutine->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    coroutine_heap->type_description_1 = NULL;
    coroutine_heap->tmp_return_value = NULL;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    // Actual coroutine body.
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_ad0164f70f9718d4c84eac4493bd0b3f, module_contextlib, sizeof(void *) );
    coroutine->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( coroutine->m_frame );
    assert( Py_REFCNT( coroutine->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    coroutine->m_frame->m_frame.f_gen = (PyObject *)coroutine;
#endif

    Py_CLEAR( coroutine->m_frame->m_frame.f_back );

    coroutine->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( coroutine->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &coroutine->m_frame->m_frame;
    Py_INCREF( coroutine->m_frame );

    Nuitka_Frame_MarkAsExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        coroutine->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( coroutine->m_frame->m_frame.f_exc_type == Py_None ) coroutine->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_type );
    coroutine->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_value );
    coroutine->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_traceback );
#else
        coroutine->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( coroutine->m_exc_state.exc_type == Py_None ) coroutine->m_exc_state.exc_type = NULL;
        Py_XINCREF( coroutine->m_exc_state.exc_type );
        coroutine->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_value );
        coroutine->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        coroutine->m_frame->m_frame.f_lineno = 170;
        if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 170;
            coroutine_heap->type_description_1 = "c";
            goto try_except_handler_1;
        }

        tmp_source_name_1 = PyCell_GET( coroutine->m_closure[0] );
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gen );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 170;
            coroutine_heap->type_description_1 = "c";
            goto try_except_handler_1;
        }
        coroutine->m_frame->m_frame.f_lineno = 170;
        tmp_expression_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain___anext__ );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_expression_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 170;
            coroutine_heap->type_description_1 = "c";
            goto try_except_handler_1;
        }
        tmp_expression_name_1 = ASYNC_AWAIT( tmp_expression_name_2, await_normal );
        Py_DECREF( tmp_expression_name_2 );
        if ( tmp_expression_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 170;
            coroutine_heap->type_description_1 = "c";
            goto try_except_handler_1;
        }
        Nuitka_PreserveHeap( coroutine_heap->yield_tmps, &tmp_expression_name_2, sizeof(PyObject *), &tmp_called_instance_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), NULL );
        coroutine->m_yield_return_index = 1;
        coroutine->m_yieldfrom = tmp_expression_name_1;
        coroutine->m_awaiting = true;
        return NULL;

        yield_return_1:
        Nuitka_RestoreHeap( coroutine_heap->yield_tmps, &tmp_expression_name_2, sizeof(PyObject *), &tmp_called_instance_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), NULL );
        coroutine->m_awaiting = false;

        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 170;
            coroutine_heap->type_description_1 = "c";
            goto try_except_handler_1;
        }
        coroutine_heap->tmp_return_value = yield_return_value;
        if ( coroutine_heap->tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 170;
            coroutine_heap->type_description_1 = "c";
            goto try_except_handler_1;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_13___aenter__$$$coroutine_1___aenter__ );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    coroutine_heap->exception_keeper_type_1 = coroutine_heap->exception_type;
    coroutine_heap->exception_keeper_value_1 = coroutine_heap->exception_value;
    coroutine_heap->exception_keeper_tb_1 = coroutine_heap->exception_tb;
    coroutine_heap->exception_keeper_lineno_1 = coroutine_heap->exception_lineno;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    // Preserve existing published exception.
    coroutine_heap->exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( coroutine_heap->exception_preserved_type_1 );
    coroutine_heap->exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( coroutine_heap->exception_preserved_value_1 );
    coroutine_heap->exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( coroutine_heap->exception_preserved_tb_1 );

    if ( coroutine_heap->exception_keeper_tb_1 == NULL )
    {
        coroutine_heap->exception_keeper_tb_1 = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_keeper_lineno_1 );
    }
    else if ( coroutine_heap->exception_keeper_lineno_1 != 0 )
    {
        coroutine_heap->exception_keeper_tb_1 = ADD_TRACEBACK( coroutine_heap->exception_keeper_tb_1, coroutine->m_frame, coroutine_heap->exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &coroutine_heap->exception_keeper_type_1, &coroutine_heap->exception_keeper_value_1, &coroutine_heap->exception_keeper_tb_1 );
    PyException_SetTraceback( coroutine_heap->exception_keeper_value_1, (PyObject *)coroutine_heap->exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &coroutine_heap->exception_keeper_type_1, &coroutine_heap->exception_keeper_value_1, &coroutine_heap->exception_keeper_tb_1 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_StopAsyncIteration;
        coroutine_heap->tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( coroutine_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 171;
            coroutine_heap->type_description_1 = "c";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( coroutine_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_raise_cause_1;
            tmp_make_exception_arg_1 = const_str_digest_43d77277e950cc565806fc3c134d250b;
            coroutine->m_frame->m_frame.f_lineno = 172;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_RuntimeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            tmp_raise_cause_1 = Py_None;
            coroutine_heap->exception_type = tmp_raise_type_1;
            coroutine_heap->exception_value = NULL;
            Py_INCREF( tmp_raise_cause_1 );
            coroutine_heap->exception_lineno = 172;
            RAISE_EXCEPTION_WITH_CAUSE( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb, tmp_raise_cause_1 );
            coroutine_heap->type_description_1 = "c";
            goto try_except_handler_2;
        }
        goto branch_end_1;
        branch_no_1:;
        coroutine_heap->tmp_result = RERAISE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
        if (unlikely( coroutine_heap->tmp_result == false ))
        {
            coroutine_heap->exception_lineno = 169;
        }

        if (coroutine_heap->exception_tb && coroutine_heap->exception_tb->tb_frame == &coroutine->m_frame->m_frame) coroutine->m_frame->m_frame.f_lineno = coroutine_heap->exception_tb->tb_lineno;
        coroutine_heap->type_description_1 = "c";
        goto try_except_handler_2;
        branch_end_1:;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_13___aenter__$$$coroutine_1___aenter__ );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    coroutine_heap->exception_keeper_type_2 = coroutine_heap->exception_type;
    coroutine_heap->exception_keeper_value_2 = coroutine_heap->exception_value;
    coroutine_heap->exception_keeper_tb_2 = coroutine_heap->exception_tb;
    coroutine_heap->exception_keeper_lineno_2 = coroutine_heap->exception_lineno;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( coroutine_heap->exception_preserved_type_1, coroutine_heap->exception_preserved_value_1, coroutine_heap->exception_preserved_tb_1 );
    // Re-raise.
    coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_2;
    coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_2;
    coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_2;
    coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    // End of try:

    Nuitka_Frame_MarkAsNotExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( coroutine->m_frame );
    goto frame_no_exception_1;

    frame_return_exit_1:;

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );
    goto function_return_exit;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( coroutine_heap->exception_type ) )
    {
        if ( coroutine_heap->exception_tb == NULL )
        {
            coroutine_heap->exception_tb = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_lineno );
        }
        else if ( coroutine_heap->exception_tb->tb_frame != &coroutine->m_frame->m_frame )
        {
            coroutine_heap->exception_tb = ADD_TRACEBACK( coroutine_heap->exception_tb, coroutine->m_frame, coroutine_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)coroutine->m_frame,
            coroutine_heap->type_description_1,
            coroutine->m_closure[0]
        );


        // Release cached frame.
        if ( coroutine->m_frame == cache_m_frame )
        {
            Py_DECREF( coroutine->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( coroutine->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must be present.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_13___aenter__$$$coroutine_1___aenter__ );

    function_exception_exit:
    assert( coroutine_heap->exception_type );
    RESTORE_ERROR_OCCURRED( coroutine_heap->exception_type, coroutine_heap->exception_value, coroutine_heap->exception_tb );
    return NULL;
    function_return_exit:;

    coroutine->m_returned = coroutine_heap->tmp_return_value;

    return NULL;

}

static PyObject *contextlib$$$function_13___aenter__$$$coroutine_1___aenter___maker( void )
{
    return Nuitka_Coroutine_New(
        contextlib$$$function_13___aenter__$$$coroutine_1___aenter___context,
        module_contextlib,
        const_str_plain___aenter__,
        const_str_digest_c9273566575fea99bfeae6de0a02b843,
        codeobj_ad0164f70f9718d4c84eac4493bd0b3f,
        1,
        sizeof(struct contextlib$$$function_13___aenter__$$$coroutine_1___aenter___locals)
    );
}


static PyObject *impl_contextlib$$$function_14___aexit__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_typ = PyCell_NEW1( python_pars[ 1 ] );
    struct Nuitka_CellObject *par_value = PyCell_NEW1( python_pars[ 2 ] );
    struct Nuitka_CellObject *par_traceback = PyCell_NEW1( python_pars[ 3 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = contextlib$$$function_14___aexit__$$$coroutine_1___aexit___maker();

    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] );
    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[1] = par_traceback;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[1] );
    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[2] = par_typ;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[2] );
    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[3] = par_value;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[3] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_14___aexit__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_typ );
    Py_DECREF( par_typ );
    par_typ = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_traceback );
    Py_DECREF( par_traceback );
    par_traceback = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_typ );
    Py_DECREF( par_typ );
    par_typ = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_traceback );
    Py_DECREF( par_traceback );
    par_traceback = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_14___aexit__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct contextlib$$$function_14___aexit__$$$coroutine_1___aexit___locals {
    PyObject *var_exc;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    int tmp_res;
    PyObject *tmp_return_value;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *exception_preserved_type_2;
    PyObject *exception_preserved_value_2;
    PyTracebackObject *exception_preserved_tb_2;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    int exception_keeper_lineno_8;
};

static PyObject *contextlib$$$function_14___aexit__$$$coroutine_1___aexit___context( struct Nuitka_CoroutineObject *coroutine, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)coroutine );
    assert( Nuitka_Coroutine_Check( (PyObject *)coroutine ) );

    // Heap access if used.
    struct contextlib$$$function_14___aexit__$$$coroutine_1___aexit___locals *coroutine_heap = (struct contextlib$$$function_14___aexit__$$$coroutine_1___aexit___locals *)coroutine->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(coroutine->m_yield_return_index) {
    case 2: goto yield_return_2;
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    coroutine_heap->var_exc = NULL;
    coroutine_heap->type_description_1 = NULL;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;
    coroutine_heap->tmp_return_value = NULL;

    // Actual coroutine body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_97a372fac4573135deb7dd07cd85c86d, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    coroutine->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( coroutine->m_frame );
    assert( Py_REFCNT( coroutine->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    coroutine->m_frame->m_frame.f_gen = (PyObject *)coroutine;
#endif

    Py_CLEAR( coroutine->m_frame->m_frame.f_back );

    coroutine->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( coroutine->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &coroutine->m_frame->m_frame;
    Py_INCREF( coroutine->m_frame );

    Nuitka_Frame_MarkAsExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        coroutine->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( coroutine->m_frame->m_frame.f_exc_type == Py_None ) coroutine->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_type );
    coroutine->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_value );
    coroutine->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_traceback );
#else
        coroutine->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( coroutine->m_exc_state.exc_type == Py_None ) coroutine->m_exc_state.exc_type = NULL;
        Py_XINCREF( coroutine->m_exc_state.exc_type );
        coroutine->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_value );
        coroutine->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        if ( PyCell_GET( coroutine->m_closure[2] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "typ" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 175;
            coroutine_heap->type_description_1 = "cccco";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_1 = PyCell_GET( coroutine->m_closure[2] );
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        // Tried code:
        {
            PyObject *tmp_expression_name_1;
            PyObject *tmp_expression_name_2;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_await_result_1;
            coroutine->m_frame->m_frame.f_lineno = 177;
            if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
            {

                coroutine_heap->exception_type = PyExc_NameError;
                Py_INCREF( coroutine_heap->exception_type );
                coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                coroutine_heap->exception_tb = NULL;
                NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                CHAIN_EXCEPTION( coroutine_heap->exception_value );

                coroutine_heap->exception_lineno = 177;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_2;
            }

            tmp_source_name_1 = PyCell_GET( coroutine->m_closure[0] );
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gen );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 177;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_2;
            }
            coroutine->m_frame->m_frame.f_lineno = 177;
            tmp_expression_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain___anext__ );
            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_expression_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 177;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_2;
            }
            tmp_expression_name_1 = ASYNC_AWAIT( tmp_expression_name_2, await_normal );
            Py_DECREF( tmp_expression_name_2 );
            if ( tmp_expression_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 177;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_2;
            }
            Nuitka_PreserveHeap( coroutine_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_expression_name_2, sizeof(PyObject *), &tmp_called_instance_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), NULL );
            coroutine->m_yield_return_index = 1;
            coroutine->m_yieldfrom = tmp_expression_name_1;
            coroutine->m_awaiting = true;
            return NULL;

            yield_return_1:
            Nuitka_RestoreHeap( coroutine_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_expression_name_2, sizeof(PyObject *), &tmp_called_instance_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), NULL );
            coroutine->m_awaiting = false;

            if ( yield_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 177;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_2;
            }
            tmp_await_result_1 = yield_return_value;
            if ( tmp_await_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 177;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_await_result_1 );
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        coroutine_heap->exception_keeper_type_1 = coroutine_heap->exception_type;
        coroutine_heap->exception_keeper_value_1 = coroutine_heap->exception_value;
        coroutine_heap->exception_keeper_tb_1 = coroutine_heap->exception_tb;
        coroutine_heap->exception_keeper_lineno_1 = coroutine_heap->exception_lineno;
        coroutine_heap->exception_type = NULL;
        coroutine_heap->exception_value = NULL;
        coroutine_heap->exception_tb = NULL;
        coroutine_heap->exception_lineno = 0;

        // Preserve existing published exception.
        coroutine_heap->exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
        Py_XINCREF( coroutine_heap->exception_preserved_type_1 );
        coroutine_heap->exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
        Py_XINCREF( coroutine_heap->exception_preserved_value_1 );
        coroutine_heap->exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
        Py_XINCREF( coroutine_heap->exception_preserved_tb_1 );

        if ( coroutine_heap->exception_keeper_tb_1 == NULL )
        {
            coroutine_heap->exception_keeper_tb_1 = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_keeper_lineno_1 );
        }
        else if ( coroutine_heap->exception_keeper_lineno_1 != 0 )
        {
            coroutine_heap->exception_keeper_tb_1 = ADD_TRACEBACK( coroutine_heap->exception_keeper_tb_1, coroutine->m_frame, coroutine_heap->exception_keeper_lineno_1 );
        }

        NORMALIZE_EXCEPTION( &coroutine_heap->exception_keeper_type_1, &coroutine_heap->exception_keeper_value_1, &coroutine_heap->exception_keeper_tb_1 );
        PyException_SetTraceback( coroutine_heap->exception_keeper_value_1, (PyObject *)coroutine_heap->exception_keeper_tb_1 );
        PUBLISH_EXCEPTION( &coroutine_heap->exception_keeper_type_1, &coroutine_heap->exception_keeper_value_1, &coroutine_heap->exception_keeper_tb_1 );
        // Tried code:
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
            tmp_compexpr_right_2 = PyExc_StopAsyncIteration;
            coroutine_heap->tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( coroutine_heap->tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 178;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_3;
            }
            tmp_condition_result_2 = ( coroutine_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            coroutine_heap->tmp_return_value = Py_None;
            Py_INCREF( coroutine_heap->tmp_return_value );
            goto try_return_handler_3;
            goto branch_end_2;
            branch_no_2:;
            coroutine_heap->tmp_result = RERAISE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            if (unlikely( coroutine_heap->tmp_result == false ))
            {
                coroutine_heap->exception_lineno = 176;
            }

            if (coroutine_heap->exception_tb && coroutine_heap->exception_tb->tb_frame == &coroutine->m_frame->m_frame) coroutine->m_frame->m_frame.f_lineno = coroutine_heap->exception_tb->tb_lineno;
            coroutine_heap->type_description_1 = "cccco";
            goto try_except_handler_3;
            branch_end_2:;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib$$$function_14___aexit__$$$coroutine_1___aexit__ );
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        // Restore previous exception.
        SET_CURRENT_EXCEPTION( coroutine_heap->exception_preserved_type_1, coroutine_heap->exception_preserved_value_1, coroutine_heap->exception_preserved_tb_1 );
        goto frame_return_exit_1;
        // Exception handler code:
        try_except_handler_3:;
        coroutine_heap->exception_keeper_type_2 = coroutine_heap->exception_type;
        coroutine_heap->exception_keeper_value_2 = coroutine_heap->exception_value;
        coroutine_heap->exception_keeper_tb_2 = coroutine_heap->exception_tb;
        coroutine_heap->exception_keeper_lineno_2 = coroutine_heap->exception_lineno;
        coroutine_heap->exception_type = NULL;
        coroutine_heap->exception_value = NULL;
        coroutine_heap->exception_tb = NULL;
        coroutine_heap->exception_lineno = 0;

        // Restore previous exception.
        SET_CURRENT_EXCEPTION( coroutine_heap->exception_preserved_type_1, coroutine_heap->exception_preserved_value_1, coroutine_heap->exception_preserved_tb_1 );
        // Re-raise.
        coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_2;
        coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_2;
        coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_2;
        coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_2;

        goto frame_exception_exit_1;
        // End of try:
        // End of try:
        try_end_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_82cfb07b0e6277928c3fe172bffa179f;
            coroutine->m_frame->m_frame.f_lineno = 181;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_RuntimeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            coroutine_heap->exception_type = tmp_raise_type_1;
            coroutine_heap->exception_lineno = 181;
            RAISE_EXCEPTION_WITH_TYPE( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            coroutine_heap->type_description_1 = "cccco";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            if ( PyCell_GET( coroutine->m_closure[3] ) == NULL )
            {

                coroutine_heap->exception_type = PyExc_NameError;
                Py_INCREF( coroutine_heap->exception_type );
                coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "value" );
                coroutine_heap->exception_tb = NULL;
                NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                CHAIN_EXCEPTION( coroutine_heap->exception_value );

                coroutine_heap->exception_lineno = 183;
                coroutine_heap->type_description_1 = "cccco";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_left_3 = PyCell_GET( coroutine->m_closure[3] );
            tmp_compexpr_right_3 = Py_None;
            tmp_condition_result_3 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_1;
                PyObject *tmp_called_name_1;
                if ( PyCell_GET( coroutine->m_closure[2] ) == NULL )
                {

                    coroutine_heap->exception_type = PyExc_NameError;
                    Py_INCREF( coroutine_heap->exception_type );
                    coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "typ" );
                    coroutine_heap->exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                    CHAIN_EXCEPTION( coroutine_heap->exception_value );

                    coroutine_heap->exception_lineno = 184;
                    coroutine_heap->type_description_1 = "cccco";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_1 = PyCell_GET( coroutine->m_closure[2] );
                coroutine->m_frame->m_frame.f_lineno = 184;
                tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
                if ( tmp_assign_source_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                    coroutine_heap->exception_lineno = 184;
                    coroutine_heap->type_description_1 = "cccco";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = PyCell_GET( coroutine->m_closure[3] );
                    PyCell_SET( coroutine->m_closure[3], tmp_assign_source_1 );
                    Py_XDECREF( old );
                }

            }
            branch_no_3:;
        }
        // Tried code:
        {
            PyObject *tmp_expression_name_3;
            PyObject *tmp_expression_name_4;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_await_result_2;
            coroutine->m_frame->m_frame.f_lineno = 188;
            if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
            {

                coroutine_heap->exception_type = PyExc_NameError;
                Py_INCREF( coroutine_heap->exception_type );
                coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                coroutine_heap->exception_tb = NULL;
                NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                CHAIN_EXCEPTION( coroutine_heap->exception_value );

                coroutine_heap->exception_lineno = 188;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_4;
            }

            tmp_source_name_3 = PyCell_GET( coroutine->m_closure[0] );
            tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gen );
            if ( tmp_source_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 188;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_4;
            }
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_athrow );
            Py_DECREF( tmp_source_name_2 );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 188;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_4;
            }
            if ( PyCell_GET( coroutine->m_closure[2] ) == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                coroutine_heap->exception_type = PyExc_NameError;
                Py_INCREF( coroutine_heap->exception_type );
                coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "typ" );
                coroutine_heap->exception_tb = NULL;
                NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                CHAIN_EXCEPTION( coroutine_heap->exception_value );

                coroutine_heap->exception_lineno = 188;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_4;
            }

            tmp_args_element_name_1 = PyCell_GET( coroutine->m_closure[2] );
            if ( PyCell_GET( coroutine->m_closure[3] ) == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                coroutine_heap->exception_type = PyExc_NameError;
                Py_INCREF( coroutine_heap->exception_type );
                coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "value" );
                coroutine_heap->exception_tb = NULL;
                NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                CHAIN_EXCEPTION( coroutine_heap->exception_value );

                coroutine_heap->exception_lineno = 188;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_4;
            }

            tmp_args_element_name_2 = PyCell_GET( coroutine->m_closure[3] );
            if ( PyCell_GET( coroutine->m_closure[1] ) == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                coroutine_heap->exception_type = PyExc_NameError;
                Py_INCREF( coroutine_heap->exception_type );
                coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "traceback" );
                coroutine_heap->exception_tb = NULL;
                NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                CHAIN_EXCEPTION( coroutine_heap->exception_value );

                coroutine_heap->exception_lineno = 188;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_4;
            }

            tmp_args_element_name_3 = PyCell_GET( coroutine->m_closure[1] );
            coroutine->m_frame->m_frame.f_lineno = 188;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_expression_name_4 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            if ( tmp_expression_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 188;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_4;
            }
            tmp_expression_name_3 = ASYNC_AWAIT( tmp_expression_name_4, await_normal );
            Py_DECREF( tmp_expression_name_4 );
            if ( tmp_expression_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 188;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_4;
            }
            Nuitka_PreserveHeap( coroutine_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_expression_name_4, sizeof(PyObject *), &tmp_called_name_2, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), &tmp_source_name_3, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_args_element_name_2, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), NULL );
            coroutine->m_yield_return_index = 2;
            coroutine->m_yieldfrom = tmp_expression_name_3;
            coroutine->m_awaiting = true;
            return NULL;

            yield_return_2:
            Nuitka_RestoreHeap( coroutine_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_expression_name_4, sizeof(PyObject *), &tmp_called_name_2, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), &tmp_source_name_3, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_args_element_name_2, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), NULL );
            coroutine->m_awaiting = false;

            if ( yield_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 188;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_4;
            }
            tmp_await_result_2 = yield_return_value;
            if ( tmp_await_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 188;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_4;
            }
            Py_DECREF( tmp_await_result_2 );
        }
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_14d40be592e224e5e7136c1c40a4b531;
            coroutine->m_frame->m_frame.f_lineno = 189;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_RuntimeError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            coroutine_heap->exception_type = tmp_raise_type_2;
            coroutine_heap->exception_lineno = 189;
            RAISE_EXCEPTION_WITH_TYPE( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            coroutine_heap->type_description_1 = "cccco";
            goto try_except_handler_4;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib$$$function_14___aexit__$$$coroutine_1___aexit__ );
        return NULL;
        // Exception handler code:
        try_except_handler_4:;
        coroutine_heap->exception_keeper_type_3 = coroutine_heap->exception_type;
        coroutine_heap->exception_keeper_value_3 = coroutine_heap->exception_value;
        coroutine_heap->exception_keeper_tb_3 = coroutine_heap->exception_tb;
        coroutine_heap->exception_keeper_lineno_3 = coroutine_heap->exception_lineno;
        coroutine_heap->exception_type = NULL;
        coroutine_heap->exception_value = NULL;
        coroutine_heap->exception_tb = NULL;
        coroutine_heap->exception_lineno = 0;

        // Preserve existing published exception.
        coroutine_heap->exception_preserved_type_2 = EXC_TYPE(PyThreadState_GET());
        Py_XINCREF( coroutine_heap->exception_preserved_type_2 );
        coroutine_heap->exception_preserved_value_2 = EXC_VALUE(PyThreadState_GET());
        Py_XINCREF( coroutine_heap->exception_preserved_value_2 );
        coroutine_heap->exception_preserved_tb_2 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
        Py_XINCREF( coroutine_heap->exception_preserved_tb_2 );

        if ( coroutine_heap->exception_keeper_tb_3 == NULL )
        {
            coroutine_heap->exception_keeper_tb_3 = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_keeper_lineno_3 );
        }
        else if ( coroutine_heap->exception_keeper_lineno_3 != 0 )
        {
            coroutine_heap->exception_keeper_tb_3 = ADD_TRACEBACK( coroutine_heap->exception_keeper_tb_3, coroutine->m_frame, coroutine_heap->exception_keeper_lineno_3 );
        }

        NORMALIZE_EXCEPTION( &coroutine_heap->exception_keeper_type_3, &coroutine_heap->exception_keeper_value_3, &coroutine_heap->exception_keeper_tb_3 );
        PyException_SetTraceback( coroutine_heap->exception_keeper_value_3, (PyObject *)coroutine_heap->exception_keeper_tb_3 );
        PUBLISH_EXCEPTION( &coroutine_heap->exception_keeper_type_3, &coroutine_heap->exception_keeper_value_3, &coroutine_heap->exception_keeper_tb_3 );
        // Tried code:
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            tmp_compexpr_left_4 = EXC_TYPE(PyThreadState_GET());
            tmp_compexpr_right_4 = PyExc_StopAsyncIteration;
            coroutine_heap->tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( coroutine_heap->tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 190;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_5;
            }
            tmp_condition_result_4 = ( coroutine_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_assign_source_2;
                tmp_assign_source_2 = EXC_VALUE(PyThreadState_GET());
                assert( coroutine_heap->var_exc == NULL );
                Py_INCREF( tmp_assign_source_2 );
                coroutine_heap->var_exc = tmp_assign_source_2;
            }
            // Tried code:
            {
                PyObject *tmp_compexpr_left_5;
                PyObject *tmp_compexpr_right_5;
                CHECK_OBJECT( coroutine_heap->var_exc );
                tmp_compexpr_left_5 = coroutine_heap->var_exc;
                if ( PyCell_GET( coroutine->m_closure[3] ) == NULL )
                {

                    coroutine_heap->exception_type = PyExc_NameError;
                    Py_INCREF( coroutine_heap->exception_type );
                    coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "value" );
                    coroutine_heap->exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                    CHAIN_EXCEPTION( coroutine_heap->exception_value );

                    coroutine_heap->exception_lineno = 191;
                    coroutine_heap->type_description_1 = "cccco";
                    goto try_except_handler_6;
                }

                tmp_compexpr_right_5 = PyCell_GET( coroutine->m_closure[3] );
                coroutine_heap->tmp_return_value = ( tmp_compexpr_left_5 != tmp_compexpr_right_5 ) ? Py_True : Py_False;
                Py_INCREF( coroutine_heap->tmp_return_value );
                goto try_return_handler_6;
            }
            // tried codes exits in all cases
            NUITKA_CANNOT_GET_HERE( contextlib$$$function_14___aexit__$$$coroutine_1___aexit__ );
            return NULL;
            // Return handler code:
            try_return_handler_6:;
            Py_XDECREF( coroutine_heap->var_exc );
            coroutine_heap->var_exc = NULL;

            goto try_return_handler_5;
            // Exception handler code:
            try_except_handler_6:;
            coroutine_heap->exception_keeper_type_4 = coroutine_heap->exception_type;
            coroutine_heap->exception_keeper_value_4 = coroutine_heap->exception_value;
            coroutine_heap->exception_keeper_tb_4 = coroutine_heap->exception_tb;
            coroutine_heap->exception_keeper_lineno_4 = coroutine_heap->exception_lineno;
            coroutine_heap->exception_type = NULL;
            coroutine_heap->exception_value = NULL;
            coroutine_heap->exception_tb = NULL;
            coroutine_heap->exception_lineno = 0;

            Py_XDECREF( coroutine_heap->var_exc );
            coroutine_heap->var_exc = NULL;

            // Re-raise.
            coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_4;
            coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_4;
            coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_4;
            coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_4;

            goto try_except_handler_5;
            // End of try:
            goto branch_end_4;
            branch_no_4:;
            {
                nuitka_bool tmp_condition_result_5;
                PyObject *tmp_compexpr_left_6;
                PyObject *tmp_compexpr_right_6;
                tmp_compexpr_left_6 = EXC_TYPE(PyThreadState_GET());
                tmp_compexpr_right_6 = PyExc_RuntimeError;
                coroutine_heap->tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_6, tmp_compexpr_right_6 );
                if ( coroutine_heap->tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                    coroutine_heap->exception_lineno = 192;
                    coroutine_heap->type_description_1 = "cccco";
                    goto try_except_handler_5;
                }
                tmp_condition_result_5 = ( coroutine_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_5;
                }
                else
                {
                    goto branch_no_5;
                }
                branch_yes_5:;
                {
                    PyObject *tmp_assign_source_3;
                    tmp_assign_source_3 = EXC_VALUE(PyThreadState_GET());
                    assert( coroutine_heap->var_exc == NULL );
                    Py_INCREF( tmp_assign_source_3 );
                    coroutine_heap->var_exc = tmp_assign_source_3;
                }
                // Tried code:
                {
                    nuitka_bool tmp_condition_result_6;
                    PyObject *tmp_compexpr_left_7;
                    PyObject *tmp_compexpr_right_7;
                    CHECK_OBJECT( coroutine_heap->var_exc );
                    tmp_compexpr_left_7 = coroutine_heap->var_exc;
                    if ( PyCell_GET( coroutine->m_closure[3] ) == NULL )
                    {

                        coroutine_heap->exception_type = PyExc_NameError;
                        Py_INCREF( coroutine_heap->exception_type );
                        coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "value" );
                        coroutine_heap->exception_tb = NULL;
                        NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                        CHAIN_EXCEPTION( coroutine_heap->exception_value );

                        coroutine_heap->exception_lineno = 193;
                        coroutine_heap->type_description_1 = "cccco";
                        goto try_except_handler_7;
                    }

                    tmp_compexpr_right_7 = PyCell_GET( coroutine->m_closure[3] );
                    tmp_condition_result_6 = ( tmp_compexpr_left_7 == tmp_compexpr_right_7 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_6;
                    }
                    else
                    {
                        goto branch_no_6;
                    }
                    branch_yes_6:;
                    coroutine_heap->tmp_return_value = Py_False;
                    Py_INCREF( coroutine_heap->tmp_return_value );
                    goto try_return_handler_7;
                    branch_no_6:;
                }
                {
                    nuitka_bool tmp_condition_result_7;
                    PyObject *tmp_isinstance_inst_1;
                    PyObject *tmp_isinstance_cls_1;
                    if ( PyCell_GET( coroutine->m_closure[3] ) == NULL )
                    {

                        coroutine_heap->exception_type = PyExc_NameError;
                        Py_INCREF( coroutine_heap->exception_type );
                        coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "value" );
                        coroutine_heap->exception_tb = NULL;
                        NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                        CHAIN_EXCEPTION( coroutine_heap->exception_value );

                        coroutine_heap->exception_lineno = 201;
                        coroutine_heap->type_description_1 = "cccco";
                        goto try_except_handler_7;
                    }

                    tmp_isinstance_inst_1 = PyCell_GET( coroutine->m_closure[3] );
                    tmp_isinstance_cls_1 = const_tuple_type_StopIteration_type_StopAsyncIteration_tuple;
                    coroutine_heap->tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
                    if ( coroutine_heap->tmp_res == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                        coroutine_heap->exception_lineno = 201;
                        coroutine_heap->type_description_1 = "cccco";
                        goto try_except_handler_7;
                    }
                    tmp_condition_result_7 = ( coroutine_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_7;
                    }
                    else
                    {
                        goto branch_no_7;
                    }
                    branch_yes_7:;
                    {
                        nuitka_bool tmp_condition_result_8;
                        PyObject *tmp_compexpr_left_8;
                        PyObject *tmp_compexpr_right_8;
                        PyObject *tmp_source_name_4;
                        CHECK_OBJECT( coroutine_heap->var_exc );
                        tmp_source_name_4 = coroutine_heap->var_exc;
                        tmp_compexpr_left_8 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain___cause__ );
                        if ( tmp_compexpr_left_8 == NULL )
                        {
                            assert( ERROR_OCCURRED() );

                            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                            coroutine_heap->exception_lineno = 202;
                            coroutine_heap->type_description_1 = "cccco";
                            goto try_except_handler_7;
                        }
                        if ( PyCell_GET( coroutine->m_closure[3] ) == NULL )
                        {
                            Py_DECREF( tmp_compexpr_left_8 );
                            coroutine_heap->exception_type = PyExc_NameError;
                            Py_INCREF( coroutine_heap->exception_type );
                            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "value" );
                            coroutine_heap->exception_tb = NULL;
                            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                            CHAIN_EXCEPTION( coroutine_heap->exception_value );

                            coroutine_heap->exception_lineno = 202;
                            coroutine_heap->type_description_1 = "cccco";
                            goto try_except_handler_7;
                        }

                        tmp_compexpr_right_8 = PyCell_GET( coroutine->m_closure[3] );
                        tmp_condition_result_8 = ( tmp_compexpr_left_8 == tmp_compexpr_right_8 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                        Py_DECREF( tmp_compexpr_left_8 );
                        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
                        {
                            goto branch_yes_8;
                        }
                        else
                        {
                            goto branch_no_8;
                        }
                        branch_yes_8:;
                        coroutine_heap->tmp_return_value = Py_False;
                        Py_INCREF( coroutine_heap->tmp_return_value );
                        goto try_return_handler_7;
                        branch_no_8:;
                    }
                    branch_no_7:;
                }
                coroutine_heap->tmp_result = RERAISE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                if (unlikely( coroutine_heap->tmp_result == false ))
                {
                    coroutine_heap->exception_lineno = 204;
                }

                if (coroutine_heap->exception_tb && coroutine_heap->exception_tb->tb_frame == &coroutine->m_frame->m_frame) coroutine->m_frame->m_frame.f_lineno = coroutine_heap->exception_tb->tb_lineno;
                coroutine_heap->type_description_1 = "cccco";
                goto try_except_handler_7;
                // tried codes exits in all cases
                NUITKA_CANNOT_GET_HERE( contextlib$$$function_14___aexit__$$$coroutine_1___aexit__ );
                return NULL;
                // Return handler code:
                try_return_handler_7:;
                Py_XDECREF( coroutine_heap->var_exc );
                coroutine_heap->var_exc = NULL;

                goto try_return_handler_5;
                // Exception handler code:
                try_except_handler_7:;
                coroutine_heap->exception_keeper_type_5 = coroutine_heap->exception_type;
                coroutine_heap->exception_keeper_value_5 = coroutine_heap->exception_value;
                coroutine_heap->exception_keeper_tb_5 = coroutine_heap->exception_tb;
                coroutine_heap->exception_keeper_lineno_5 = coroutine_heap->exception_lineno;
                coroutine_heap->exception_type = NULL;
                coroutine_heap->exception_value = NULL;
                coroutine_heap->exception_tb = NULL;
                coroutine_heap->exception_lineno = 0;

                Py_XDECREF( coroutine_heap->var_exc );
                coroutine_heap->var_exc = NULL;

                // Re-raise.
                coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_5;
                coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_5;
                coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_5;
                coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_5;

                goto try_except_handler_5;
                // End of try:
                goto branch_end_5;
                branch_no_5:;
                {
                    nuitka_bool tmp_condition_result_9;
                    PyObject *tmp_compexpr_left_9;
                    PyObject *tmp_compexpr_right_9;
                    tmp_compexpr_left_9 = EXC_TYPE(PyThreadState_GET());
                    tmp_compexpr_right_9 = PyExc_BaseException;
                    coroutine_heap->tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_9, tmp_compexpr_right_9 );
                    if ( coroutine_heap->tmp_res == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                        coroutine_heap->exception_lineno = 205;
                        coroutine_heap->type_description_1 = "cccco";
                        goto try_except_handler_5;
                    }
                    tmp_condition_result_9 = ( coroutine_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_9;
                    }
                    else
                    {
                        goto branch_no_9;
                    }
                    branch_yes_9:;
                    {
                        PyObject *tmp_assign_source_4;
                        tmp_assign_source_4 = EXC_VALUE(PyThreadState_GET());
                        assert( coroutine_heap->var_exc == NULL );
                        Py_INCREF( tmp_assign_source_4 );
                        coroutine_heap->var_exc = tmp_assign_source_4;
                    }
                    // Tried code:
                    {
                        nuitka_bool tmp_condition_result_10;
                        PyObject *tmp_compexpr_left_10;
                        PyObject *tmp_compexpr_right_10;
                        CHECK_OBJECT( coroutine_heap->var_exc );
                        tmp_compexpr_left_10 = coroutine_heap->var_exc;
                        if ( PyCell_GET( coroutine->m_closure[3] ) == NULL )
                        {

                            coroutine_heap->exception_type = PyExc_NameError;
                            Py_INCREF( coroutine_heap->exception_type );
                            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "value" );
                            coroutine_heap->exception_tb = NULL;
                            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                            CHAIN_EXCEPTION( coroutine_heap->exception_value );

                            coroutine_heap->exception_lineno = 206;
                            coroutine_heap->type_description_1 = "cccco";
                            goto try_except_handler_8;
                        }

                        tmp_compexpr_right_10 = PyCell_GET( coroutine->m_closure[3] );
                        tmp_condition_result_10 = ( tmp_compexpr_left_10 != tmp_compexpr_right_10 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                        if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
                        {
                            goto branch_yes_10;
                        }
                        else
                        {
                            goto branch_no_10;
                        }
                        branch_yes_10:;
                        coroutine_heap->tmp_result = RERAISE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                        if (unlikely( coroutine_heap->tmp_result == false ))
                        {
                            coroutine_heap->exception_lineno = 207;
                        }

                        if (coroutine_heap->exception_tb && coroutine_heap->exception_tb->tb_frame == &coroutine->m_frame->m_frame) coroutine->m_frame->m_frame.f_lineno = coroutine_heap->exception_tb->tb_lineno;
                        coroutine_heap->type_description_1 = "cccco";
                        goto try_except_handler_8;
                        branch_no_10:;
                    }
                    goto try_end_2;
                    // Exception handler code:
                    try_except_handler_8:;
                    coroutine_heap->exception_keeper_type_6 = coroutine_heap->exception_type;
                    coroutine_heap->exception_keeper_value_6 = coroutine_heap->exception_value;
                    coroutine_heap->exception_keeper_tb_6 = coroutine_heap->exception_tb;
                    coroutine_heap->exception_keeper_lineno_6 = coroutine_heap->exception_lineno;
                    coroutine_heap->exception_type = NULL;
                    coroutine_heap->exception_value = NULL;
                    coroutine_heap->exception_tb = NULL;
                    coroutine_heap->exception_lineno = 0;

                    Py_XDECREF( coroutine_heap->var_exc );
                    coroutine_heap->var_exc = NULL;

                    // Re-raise.
                    coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_6;
                    coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_6;
                    coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_6;
                    coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_6;

                    goto try_except_handler_5;
                    // End of try:
                    try_end_2:;
                    Py_XDECREF( coroutine_heap->var_exc );
                    coroutine_heap->var_exc = NULL;

                    goto branch_end_9;
                    branch_no_9:;
                    coroutine_heap->tmp_result = RERAISE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                    if (unlikely( coroutine_heap->tmp_result == false ))
                    {
                        coroutine_heap->exception_lineno = 187;
                    }

                    if (coroutine_heap->exception_tb && coroutine_heap->exception_tb->tb_frame == &coroutine->m_frame->m_frame) coroutine->m_frame->m_frame.f_lineno = coroutine_heap->exception_tb->tb_lineno;
                    coroutine_heap->type_description_1 = "cccco";
                    goto try_except_handler_5;
                    branch_end_9:;
                }
                branch_end_5:;
            }
            branch_end_4:;
        }
        goto try_end_3;
        // Return handler code:
        try_return_handler_5:;
        // Restore previous exception.
        SET_CURRENT_EXCEPTION( coroutine_heap->exception_preserved_type_2, coroutine_heap->exception_preserved_value_2, coroutine_heap->exception_preserved_tb_2 );
        goto frame_return_exit_1;
        // Exception handler code:
        try_except_handler_5:;
        coroutine_heap->exception_keeper_type_7 = coroutine_heap->exception_type;
        coroutine_heap->exception_keeper_value_7 = coroutine_heap->exception_value;
        coroutine_heap->exception_keeper_tb_7 = coroutine_heap->exception_tb;
        coroutine_heap->exception_keeper_lineno_7 = coroutine_heap->exception_lineno;
        coroutine_heap->exception_type = NULL;
        coroutine_heap->exception_value = NULL;
        coroutine_heap->exception_tb = NULL;
        coroutine_heap->exception_lineno = 0;

        // Restore previous exception.
        SET_CURRENT_EXCEPTION( coroutine_heap->exception_preserved_type_2, coroutine_heap->exception_preserved_value_2, coroutine_heap->exception_preserved_tb_2 );
        // Re-raise.
        coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_7;
        coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_7;
        coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_7;
        coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_7;

        goto frame_exception_exit_1;
        // End of try:
        try_end_3:;
        // Restore previous exception.
        SET_CURRENT_EXCEPTION( coroutine_heap->exception_preserved_type_2, coroutine_heap->exception_preserved_value_2, coroutine_heap->exception_preserved_tb_2 );
        goto try_end_4;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib$$$function_14___aexit__$$$coroutine_1___aexit__ );
        return NULL;
        // End of try:
        try_end_4:;
        branch_end_1:;
    }

    Nuitka_Frame_MarkAsNotExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( coroutine->m_frame );
    goto frame_no_exception_1;

    frame_return_exit_1:;

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );
    goto try_return_handler_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( coroutine_heap->exception_type ) )
    {
        if ( coroutine_heap->exception_tb == NULL )
        {
            coroutine_heap->exception_tb = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_lineno );
        }
        else if ( coroutine_heap->exception_tb->tb_frame != &coroutine->m_frame->m_frame )
        {
            coroutine_heap->exception_tb = ADD_TRACEBACK( coroutine_heap->exception_tb, coroutine->m_frame, coroutine_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)coroutine->m_frame,
            coroutine_heap->type_description_1,
            coroutine->m_closure[0],
            coroutine->m_closure[2],
            coroutine->m_closure[3],
            coroutine->m_closure[1],
            coroutine_heap->var_exc
        );


        // Release cached frame.
        if ( coroutine->m_frame == cache_m_frame )
        {
            Py_DECREF( coroutine->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( coroutine->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    coroutine_heap->tmp_return_value = Py_None;
    Py_INCREF( coroutine_heap->tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_14___aexit__$$$coroutine_1___aexit__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( coroutine_heap->var_exc );
    coroutine_heap->var_exc = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    coroutine_heap->exception_keeper_type_8 = coroutine_heap->exception_type;
    coroutine_heap->exception_keeper_value_8 = coroutine_heap->exception_value;
    coroutine_heap->exception_keeper_tb_8 = coroutine_heap->exception_tb;
    coroutine_heap->exception_keeper_lineno_8 = coroutine_heap->exception_lineno;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    Py_XDECREF( coroutine_heap->var_exc );
    coroutine_heap->var_exc = NULL;

    // Re-raise.
    coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_8;
    coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_8;
    coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_8;
    coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_8;

    goto function_exception_exit;
    // End of try:

    // Return statement must be present.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_14___aexit__$$$coroutine_1___aexit__ );

    function_exception_exit:
    assert( coroutine_heap->exception_type );
    RESTORE_ERROR_OCCURRED( coroutine_heap->exception_type, coroutine_heap->exception_value, coroutine_heap->exception_tb );
    return NULL;
    function_return_exit:;

    coroutine->m_returned = coroutine_heap->tmp_return_value;

    return NULL;

}

static PyObject *contextlib$$$function_14___aexit__$$$coroutine_1___aexit___maker( void )
{
    return Nuitka_Coroutine_New(
        contextlib$$$function_14___aexit__$$$coroutine_1___aexit___context,
        module_contextlib,
        const_str_plain___aexit__,
        const_str_digest_32920fc73b22ed7a2cae0938236ca756,
        codeobj_97a372fac4573135deb7dd07cd85c86d,
        4,
        sizeof(struct contextlib$$$function_14___aexit__$$$coroutine_1___aexit___locals)
    );
}


static PyObject *impl_contextlib$$$function_15_contextmanager( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_func = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *var_helper = NULL;
    struct Nuitka_FrameObject *frame_c9d7fea79421b5192503141dd6b626fa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c9d7fea79421b5192503141dd6b626fa = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c9d7fea79421b5192503141dd6b626fa, codeobj_c9d7fea79421b5192503141dd6b626fa, module_contextlib, sizeof(void *)+sizeof(void *) );
    frame_c9d7fea79421b5192503141dd6b626fa = cache_frame_c9d7fea79421b5192503141dd6b626fa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c9d7fea79421b5192503141dd6b626fa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c9d7fea79421b5192503141dd6b626fa ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_wraps );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "wraps" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 237;
            type_description_1 = "co";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_func ) );
        tmp_args_element_name_1 = PyCell_GET( par_func );
        frame_c9d7fea79421b5192503141dd6b626fa->m_frame.f_lineno = 237;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 237;
            type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = MAKE_FUNCTION_contextlib$$$function_15_contextmanager$$$function_1_helper(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = par_func;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] );


        frame_c9d7fea79421b5192503141dd6b626fa->m_frame.f_lineno = 237;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 237;
            type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        assert( var_helper == NULL );
        var_helper = tmp_assign_source_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c9d7fea79421b5192503141dd6b626fa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c9d7fea79421b5192503141dd6b626fa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c9d7fea79421b5192503141dd6b626fa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c9d7fea79421b5192503141dd6b626fa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c9d7fea79421b5192503141dd6b626fa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c9d7fea79421b5192503141dd6b626fa,
        type_description_1,
        par_func,
        var_helper
    );


    // Release cached frame.
    if ( frame_c9d7fea79421b5192503141dd6b626fa == cache_frame_c9d7fea79421b5192503141dd6b626fa )
    {
        Py_DECREF( frame_c9d7fea79421b5192503141dd6b626fa );
    }
    cache_frame_c9d7fea79421b5192503141dd6b626fa = NULL;

    assertFrameObject( frame_c9d7fea79421b5192503141dd6b626fa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_helper );
    tmp_return_value = var_helper;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_15_contextmanager );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    CHECK_OBJECT( (PyObject *)var_helper );
    Py_DECREF( var_helper );
    var_helper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_15_contextmanager );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_15_contextmanager$$$function_1_helper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_args = python_pars[ 0 ];
    PyObject *par_kwds = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_b32d399f13c7f5cb32706e7e8544adcd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b32d399f13c7f5cb32706e7e8544adcd = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b32d399f13c7f5cb32706e7e8544adcd, codeobj_b32d399f13c7f5cb32706e7e8544adcd, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b32d399f13c7f5cb32706e7e8544adcd = cache_frame_b32d399f13c7f5cb32706e7e8544adcd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b32d399f13c7f5cb32706e7e8544adcd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b32d399f13c7f5cb32706e7e8544adcd ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__GeneratorContextManager );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__GeneratorContextManager );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_GeneratorContextManager" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 239;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "func" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 239;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_args );
        tmp_args_element_name_2 = par_args;
        CHECK_OBJECT( par_kwds );
        tmp_args_element_name_3 = par_kwds;
        frame_b32d399f13c7f5cb32706e7e8544adcd->m_frame.f_lineno = 239;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 239;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b32d399f13c7f5cb32706e7e8544adcd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b32d399f13c7f5cb32706e7e8544adcd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b32d399f13c7f5cb32706e7e8544adcd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b32d399f13c7f5cb32706e7e8544adcd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b32d399f13c7f5cb32706e7e8544adcd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b32d399f13c7f5cb32706e7e8544adcd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b32d399f13c7f5cb32706e7e8544adcd,
        type_description_1,
        par_args,
        par_kwds,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_b32d399f13c7f5cb32706e7e8544adcd == cache_frame_b32d399f13c7f5cb32706e7e8544adcd )
    {
        Py_DECREF( frame_b32d399f13c7f5cb32706e7e8544adcd );
    }
    cache_frame_b32d399f13c7f5cb32706e7e8544adcd = NULL;

    assertFrameObject( frame_b32d399f13c7f5cb32706e7e8544adcd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_15_contextmanager$$$function_1_helper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_15_contextmanager$$$function_1_helper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_16_asynccontextmanager( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_func = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *var_helper = NULL;
    struct Nuitka_FrameObject *frame_535fe3b96fc9f66283c68667446d44b4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_535fe3b96fc9f66283c68667446d44b4 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_535fe3b96fc9f66283c68667446d44b4, codeobj_535fe3b96fc9f66283c68667446d44b4, module_contextlib, sizeof(void *)+sizeof(void *) );
    frame_535fe3b96fc9f66283c68667446d44b4 = cache_frame_535fe3b96fc9f66283c68667446d44b4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_535fe3b96fc9f66283c68667446d44b4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_535fe3b96fc9f66283c68667446d44b4 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_wraps );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "wraps" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 270;
            type_description_1 = "co";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_func ) );
        tmp_args_element_name_1 = PyCell_GET( par_func );
        frame_535fe3b96fc9f66283c68667446d44b4->m_frame.f_lineno = 270;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 270;
            type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = MAKE_FUNCTION_contextlib$$$function_16_asynccontextmanager$$$function_1_helper(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = par_func;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] );


        frame_535fe3b96fc9f66283c68667446d44b4->m_frame.f_lineno = 270;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 270;
            type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        assert( var_helper == NULL );
        var_helper = tmp_assign_source_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_535fe3b96fc9f66283c68667446d44b4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_535fe3b96fc9f66283c68667446d44b4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_535fe3b96fc9f66283c68667446d44b4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_535fe3b96fc9f66283c68667446d44b4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_535fe3b96fc9f66283c68667446d44b4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_535fe3b96fc9f66283c68667446d44b4,
        type_description_1,
        par_func,
        var_helper
    );


    // Release cached frame.
    if ( frame_535fe3b96fc9f66283c68667446d44b4 == cache_frame_535fe3b96fc9f66283c68667446d44b4 )
    {
        Py_DECREF( frame_535fe3b96fc9f66283c68667446d44b4 );
    }
    cache_frame_535fe3b96fc9f66283c68667446d44b4 = NULL;

    assertFrameObject( frame_535fe3b96fc9f66283c68667446d44b4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_helper );
    tmp_return_value = var_helper;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_16_asynccontextmanager );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    CHECK_OBJECT( (PyObject *)var_helper );
    Py_DECREF( var_helper );
    var_helper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_16_asynccontextmanager );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_16_asynccontextmanager$$$function_1_helper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_args = python_pars[ 0 ];
    PyObject *par_kwds = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_fe180fc33126050a85ed6c97d75eb435;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_fe180fc33126050a85ed6c97d75eb435 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fe180fc33126050a85ed6c97d75eb435, codeobj_fe180fc33126050a85ed6c97d75eb435, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_fe180fc33126050a85ed6c97d75eb435 = cache_frame_fe180fc33126050a85ed6c97d75eb435;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fe180fc33126050a85ed6c97d75eb435 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fe180fc33126050a85ed6c97d75eb435 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__AsyncGeneratorContextManager );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__AsyncGeneratorContextManager );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_AsyncGeneratorContextManager" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 272;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "func" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 272;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_args );
        tmp_args_element_name_2 = par_args;
        CHECK_OBJECT( par_kwds );
        tmp_args_element_name_3 = par_kwds;
        frame_fe180fc33126050a85ed6c97d75eb435->m_frame.f_lineno = 272;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 272;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fe180fc33126050a85ed6c97d75eb435 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fe180fc33126050a85ed6c97d75eb435 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fe180fc33126050a85ed6c97d75eb435 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fe180fc33126050a85ed6c97d75eb435, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fe180fc33126050a85ed6c97d75eb435->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fe180fc33126050a85ed6c97d75eb435, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fe180fc33126050a85ed6c97d75eb435,
        type_description_1,
        par_args,
        par_kwds,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_fe180fc33126050a85ed6c97d75eb435 == cache_frame_fe180fc33126050a85ed6c97d75eb435 )
    {
        Py_DECREF( frame_fe180fc33126050a85ed6c97d75eb435 );
    }
    cache_frame_fe180fc33126050a85ed6c97d75eb435 = NULL;

    assertFrameObject( frame_fe180fc33126050a85ed6c97d75eb435 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_16_asynccontextmanager$$$function_1_helper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_16_asynccontextmanager$$$function_1_helper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_17___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_thing = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_e3c17e4fc256ae365524c8cbb1598249;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e3c17e4fc256ae365524c8cbb1598249 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e3c17e4fc256ae365524c8cbb1598249, codeobj_e3c17e4fc256ae365524c8cbb1598249, module_contextlib, sizeof(void *)+sizeof(void *) );
    frame_e3c17e4fc256ae365524c8cbb1598249 = cache_frame_e3c17e4fc256ae365524c8cbb1598249;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e3c17e4fc256ae365524c8cbb1598249 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e3c17e4fc256ae365524c8cbb1598249 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_thing );
        tmp_assattr_name_1 = par_thing;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_thing, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 294;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e3c17e4fc256ae365524c8cbb1598249 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e3c17e4fc256ae365524c8cbb1598249 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e3c17e4fc256ae365524c8cbb1598249, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e3c17e4fc256ae365524c8cbb1598249->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e3c17e4fc256ae365524c8cbb1598249, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e3c17e4fc256ae365524c8cbb1598249,
        type_description_1,
        par_self,
        par_thing
    );


    // Release cached frame.
    if ( frame_e3c17e4fc256ae365524c8cbb1598249 == cache_frame_e3c17e4fc256ae365524c8cbb1598249 )
    {
        Py_DECREF( frame_e3c17e4fc256ae365524c8cbb1598249 );
    }
    cache_frame_e3c17e4fc256ae365524c8cbb1598249 = NULL;

    assertFrameObject( frame_e3c17e4fc256ae365524c8cbb1598249 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_17___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_thing );
    Py_DECREF( par_thing );
    par_thing = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_thing );
    Py_DECREF( par_thing );
    par_thing = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_17___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_18___enter__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_9b5da5032c05507da8147f4e6f99b839;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9b5da5032c05507da8147f4e6f99b839 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9b5da5032c05507da8147f4e6f99b839, codeobj_9b5da5032c05507da8147f4e6f99b839, module_contextlib, sizeof(void *) );
    frame_9b5da5032c05507da8147f4e6f99b839 = cache_frame_9b5da5032c05507da8147f4e6f99b839;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9b5da5032c05507da8147f4e6f99b839 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9b5da5032c05507da8147f4e6f99b839 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_thing );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 296;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b5da5032c05507da8147f4e6f99b839 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b5da5032c05507da8147f4e6f99b839 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b5da5032c05507da8147f4e6f99b839 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9b5da5032c05507da8147f4e6f99b839, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9b5da5032c05507da8147f4e6f99b839->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9b5da5032c05507da8147f4e6f99b839, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9b5da5032c05507da8147f4e6f99b839,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_9b5da5032c05507da8147f4e6f99b839 == cache_frame_9b5da5032c05507da8147f4e6f99b839 )
    {
        Py_DECREF( frame_9b5da5032c05507da8147f4e6f99b839 );
    }
    cache_frame_9b5da5032c05507da8147f4e6f99b839 = NULL;

    assertFrameObject( frame_9b5da5032c05507da8147f4e6f99b839 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_18___enter__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_18___enter__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_19___exit__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exc_info = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_df97ed3424cb10a88b4203af3cf76740;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_df97ed3424cb10a88b4203af3cf76740 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_df97ed3424cb10a88b4203af3cf76740, codeobj_df97ed3424cb10a88b4203af3cf76740, module_contextlib, sizeof(void *)+sizeof(void *) );
    frame_df97ed3424cb10a88b4203af3cf76740 = cache_frame_df97ed3424cb10a88b4203af3cf76740;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_df97ed3424cb10a88b4203af3cf76740 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_df97ed3424cb10a88b4203af3cf76740 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_thing );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 298;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_df97ed3424cb10a88b4203af3cf76740->m_frame.f_lineno = 298;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_close );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 298;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df97ed3424cb10a88b4203af3cf76740 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df97ed3424cb10a88b4203af3cf76740 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_df97ed3424cb10a88b4203af3cf76740, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_df97ed3424cb10a88b4203af3cf76740->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_df97ed3424cb10a88b4203af3cf76740, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_df97ed3424cb10a88b4203af3cf76740,
        type_description_1,
        par_self,
        par_exc_info
    );


    // Release cached frame.
    if ( frame_df97ed3424cb10a88b4203af3cf76740 == cache_frame_df97ed3424cb10a88b4203af3cf76740 )
    {
        Py_DECREF( frame_df97ed3424cb10a88b4203af3cf76740 );
    }
    cache_frame_df97ed3424cb10a88b4203af3cf76740 = NULL;

    assertFrameObject( frame_df97ed3424cb10a88b4203af3cf76740 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_19___exit__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_info );
    Py_DECREF( par_exc_info );
    par_exc_info = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_info );
    Py_DECREF( par_exc_info );
    par_exc_info = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_19___exit__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_20___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_new_target = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_6e54b004743913720c86884cf47d4c7b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6e54b004743913720c86884cf47d4c7b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6e54b004743913720c86884cf47d4c7b, codeobj_6e54b004743913720c86884cf47d4c7b, module_contextlib, sizeof(void *)+sizeof(void *) );
    frame_6e54b004743913720c86884cf47d4c7b = cache_frame_6e54b004743913720c86884cf47d4c7b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6e54b004743913720c86884cf47d4c7b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6e54b004743913720c86884cf47d4c7b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_new_target );
        tmp_assattr_name_1 = par_new_target;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__new_target, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 306;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        tmp_assattr_name_2 = PyList_New( 0 );
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__old_targets, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 308;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6e54b004743913720c86884cf47d4c7b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6e54b004743913720c86884cf47d4c7b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6e54b004743913720c86884cf47d4c7b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6e54b004743913720c86884cf47d4c7b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6e54b004743913720c86884cf47d4c7b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6e54b004743913720c86884cf47d4c7b,
        type_description_1,
        par_self,
        par_new_target
    );


    // Release cached frame.
    if ( frame_6e54b004743913720c86884cf47d4c7b == cache_frame_6e54b004743913720c86884cf47d4c7b )
    {
        Py_DECREF( frame_6e54b004743913720c86884cf47d4c7b );
    }
    cache_frame_6e54b004743913720c86884cf47d4c7b = NULL;

    assertFrameObject( frame_6e54b004743913720c86884cf47d4c7b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_20___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_new_target );
    Py_DECREF( par_new_target );
    par_new_target = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_new_target );
    Py_DECREF( par_new_target );
    par_new_target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_20___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_21___enter__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_8fec8b0032b947333ecb2ffba5c36fda;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_8fec8b0032b947333ecb2ffba5c36fda = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8fec8b0032b947333ecb2ffba5c36fda, codeobj_8fec8b0032b947333ecb2ffba5c36fda, module_contextlib, sizeof(void *) );
    frame_8fec8b0032b947333ecb2ffba5c36fda = cache_frame_8fec8b0032b947333ecb2ffba5c36fda;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8fec8b0032b947333ecb2ffba5c36fda );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8fec8b0032b947333ecb2ffba5c36fda ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_getattr_target_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_getattr_attr_1;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__old_targets );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 311;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 311;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_sys );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 311;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_getattr_target_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_getattr_attr_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__stream );
        if ( tmp_getattr_attr_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 311;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, NULL );
        Py_DECREF( tmp_getattr_attr_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 311;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_8fec8b0032b947333ecb2ffba5c36fda->m_frame.f_lineno = 311;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 311;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_setattr_target_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_setattr_attr_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_setattr_value_1;
        PyObject *tmp_source_name_5;
        PyObject *tmp_capi_result_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_sys );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 312;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_setattr_target_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_setattr_attr_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__stream );
        if ( tmp_setattr_attr_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 312;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_setattr_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__new_target );
        if ( tmp_setattr_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_setattr_attr_1 );

            exception_lineno = 312;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_capi_result_1 = BUILTIN_SETATTR( tmp_setattr_target_1, tmp_setattr_attr_1, tmp_setattr_value_1 );
        Py_DECREF( tmp_setattr_attr_1 );
        Py_DECREF( tmp_setattr_value_1 );
        if ( tmp_capi_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 312;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_source_name_6;
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__new_target );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 313;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8fec8b0032b947333ecb2ffba5c36fda );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8fec8b0032b947333ecb2ffba5c36fda );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8fec8b0032b947333ecb2ffba5c36fda );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8fec8b0032b947333ecb2ffba5c36fda, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8fec8b0032b947333ecb2ffba5c36fda->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8fec8b0032b947333ecb2ffba5c36fda, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8fec8b0032b947333ecb2ffba5c36fda,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8fec8b0032b947333ecb2ffba5c36fda == cache_frame_8fec8b0032b947333ecb2ffba5c36fda )
    {
        Py_DECREF( frame_8fec8b0032b947333ecb2ffba5c36fda );
    }
    cache_frame_8fec8b0032b947333ecb2ffba5c36fda = NULL;

    assertFrameObject( frame_8fec8b0032b947333ecb2ffba5c36fda );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_21___enter__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_21___enter__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_22___exit__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exctype = python_pars[ 1 ];
    PyObject *par_excinst = python_pars[ 2 ];
    PyObject *par_exctb = python_pars[ 3 ];
    struct Nuitka_FrameObject *frame_67a1e3a1c0061e332d3094ae30557685;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_67a1e3a1c0061e332d3094ae30557685 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_67a1e3a1c0061e332d3094ae30557685, codeobj_67a1e3a1c0061e332d3094ae30557685, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_67a1e3a1c0061e332d3094ae30557685 = cache_frame_67a1e3a1c0061e332d3094ae30557685;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_67a1e3a1c0061e332d3094ae30557685 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_67a1e3a1c0061e332d3094ae30557685 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_setattr_target_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_setattr_attr_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_setattr_value_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_capi_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_sys );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 316;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_setattr_target_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_setattr_attr_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__stream );
        if ( tmp_setattr_attr_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 316;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__old_targets );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_setattr_attr_1 );

            exception_lineno = 316;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_67a1e3a1c0061e332d3094ae30557685->m_frame.f_lineno = 316;
        tmp_setattr_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_pop );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_setattr_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_setattr_attr_1 );

            exception_lineno = 316;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_capi_result_1 = BUILTIN_SETATTR( tmp_setattr_target_1, tmp_setattr_attr_1, tmp_setattr_value_1 );
        Py_DECREF( tmp_setattr_attr_1 );
        Py_DECREF( tmp_setattr_value_1 );
        if ( tmp_capi_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 316;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_67a1e3a1c0061e332d3094ae30557685 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_67a1e3a1c0061e332d3094ae30557685 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_67a1e3a1c0061e332d3094ae30557685, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_67a1e3a1c0061e332d3094ae30557685->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_67a1e3a1c0061e332d3094ae30557685, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_67a1e3a1c0061e332d3094ae30557685,
        type_description_1,
        par_self,
        par_exctype,
        par_excinst,
        par_exctb
    );


    // Release cached frame.
    if ( frame_67a1e3a1c0061e332d3094ae30557685 == cache_frame_67a1e3a1c0061e332d3094ae30557685 )
    {
        Py_DECREF( frame_67a1e3a1c0061e332d3094ae30557685 );
    }
    cache_frame_67a1e3a1c0061e332d3094ae30557685 = NULL;

    assertFrameObject( frame_67a1e3a1c0061e332d3094ae30557685 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_22___exit__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exctype );
    Py_DECREF( par_exctype );
    par_exctype = NULL;

    CHECK_OBJECT( (PyObject *)par_excinst );
    Py_DECREF( par_excinst );
    par_excinst = NULL;

    CHECK_OBJECT( (PyObject *)par_exctb );
    Py_DECREF( par_exctb );
    par_exctb = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exctype );
    Py_DECREF( par_exctype );
    par_exctype = NULL;

    CHECK_OBJECT( (PyObject *)par_excinst );
    Py_DECREF( par_excinst );
    par_excinst = NULL;

    CHECK_OBJECT( (PyObject *)par_exctb );
    Py_DECREF( par_exctb );
    par_exctb = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_22___exit__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_23___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exceptions = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_b4139367cf6f902d8f012d68c18fbdff;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b4139367cf6f902d8f012d68c18fbdff = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b4139367cf6f902d8f012d68c18fbdff, codeobj_b4139367cf6f902d8f012d68c18fbdff, module_contextlib, sizeof(void *)+sizeof(void *) );
    frame_b4139367cf6f902d8f012d68c18fbdff = cache_frame_b4139367cf6f902d8f012d68c18fbdff;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b4139367cf6f902d8f012d68c18fbdff );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b4139367cf6f902d8f012d68c18fbdff ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_exceptions );
        tmp_assattr_name_1 = par_exceptions;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__exceptions, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 353;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b4139367cf6f902d8f012d68c18fbdff );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b4139367cf6f902d8f012d68c18fbdff );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b4139367cf6f902d8f012d68c18fbdff, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b4139367cf6f902d8f012d68c18fbdff->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b4139367cf6f902d8f012d68c18fbdff, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b4139367cf6f902d8f012d68c18fbdff,
        type_description_1,
        par_self,
        par_exceptions
    );


    // Release cached frame.
    if ( frame_b4139367cf6f902d8f012d68c18fbdff == cache_frame_b4139367cf6f902d8f012d68c18fbdff )
    {
        Py_DECREF( frame_b4139367cf6f902d8f012d68c18fbdff );
    }
    cache_frame_b4139367cf6f902d8f012d68c18fbdff = NULL;

    assertFrameObject( frame_b4139367cf6f902d8f012d68c18fbdff );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_23___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exceptions );
    Py_DECREF( par_exceptions );
    par_exceptions = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exceptions );
    Py_DECREF( par_exceptions );
    par_exceptions = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_23___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_24___enter__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_24___enter__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_24___enter__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_25___exit__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exctype = python_pars[ 1 ];
    PyObject *par_excinst = python_pars[ 2 ];
    PyObject *par_exctb = python_pars[ 3 ];
    struct Nuitka_FrameObject *frame_1b47f9f1ce467f7f75848449b2718fa6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1b47f9f1ce467f7f75848449b2718fa6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1b47f9f1ce467f7f75848449b2718fa6, codeobj_1b47f9f1ce467f7f75848449b2718fa6, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1b47f9f1ce467f7f75848449b2718fa6 = cache_frame_1b47f9f1ce467f7f75848449b2718fa6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1b47f9f1ce467f7f75848449b2718fa6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1b47f9f1ce467f7f75848449b2718fa6 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_exctype );
        tmp_compexpr_left_1 = par_exctype;
        tmp_compexpr_right_1 = Py_None;
        tmp_and_left_value_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? Py_True : Py_False;
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_issubclass );
        assert( tmp_called_name_1 != NULL );
        CHECK_OBJECT( par_exctype );
        tmp_args_element_name_1 = par_exctype;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__exceptions );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 368;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_1b47f9f1ce467f7f75848449b2718fa6->m_frame.f_lineno = 368;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_and_right_value_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 368;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        Py_INCREF( tmp_and_left_value_1 );
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b47f9f1ce467f7f75848449b2718fa6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b47f9f1ce467f7f75848449b2718fa6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b47f9f1ce467f7f75848449b2718fa6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1b47f9f1ce467f7f75848449b2718fa6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1b47f9f1ce467f7f75848449b2718fa6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1b47f9f1ce467f7f75848449b2718fa6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1b47f9f1ce467f7f75848449b2718fa6,
        type_description_1,
        par_self,
        par_exctype,
        par_excinst,
        par_exctb
    );


    // Release cached frame.
    if ( frame_1b47f9f1ce467f7f75848449b2718fa6 == cache_frame_1b47f9f1ce467f7f75848449b2718fa6 )
    {
        Py_DECREF( frame_1b47f9f1ce467f7f75848449b2718fa6 );
    }
    cache_frame_1b47f9f1ce467f7f75848449b2718fa6 = NULL;

    assertFrameObject( frame_1b47f9f1ce467f7f75848449b2718fa6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_25___exit__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exctype );
    Py_DECREF( par_exctype );
    par_exctype = NULL;

    CHECK_OBJECT( (PyObject *)par_excinst );
    Py_DECREF( par_excinst );
    par_excinst = NULL;

    CHECK_OBJECT( (PyObject *)par_exctb );
    Py_DECREF( par_exctb );
    par_exctb = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exctype );
    Py_DECREF( par_exctype );
    par_exctype = NULL;

    CHECK_OBJECT( (PyObject *)par_excinst );
    Py_DECREF( par_excinst );
    par_excinst = NULL;

    CHECK_OBJECT( (PyObject *)par_exctb );
    Py_DECREF( par_exctb );
    par_exctb = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_25___exit__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_26__create_exit_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_cm = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_cm_exit = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var__exit_wrapper = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = MAKE_FUNCTION_contextlib$$$function_26__create_exit_wrapper$$$function_1__exit_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] = par_cm;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] = par_cm_exit;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] );


        assert( var__exit_wrapper == NULL );
        var__exit_wrapper = tmp_assign_source_1;
    }
    // Tried code:
    CHECK_OBJECT( var__exit_wrapper );
    tmp_return_value = var__exit_wrapper;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_26__create_exit_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cm );
    Py_DECREF( par_cm );
    par_cm = NULL;

    CHECK_OBJECT( (PyObject *)par_cm_exit );
    Py_DECREF( par_cm_exit );
    par_cm_exit = NULL;

    CHECK_OBJECT( (PyObject *)var__exit_wrapper );
    Py_DECREF( var__exit_wrapper );
    var__exit_wrapper = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_26__create_exit_wrapper );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_26__create_exit_wrapper$$$function_1__exit_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_exc_type = python_pars[ 0 ];
    PyObject *par_exc = python_pars[ 1 ];
    PyObject *par_tb = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_b314dfc24cfb446bc412a4b84347e7bb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b314dfc24cfb446bc412a4b84347e7bb = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b314dfc24cfb446bc412a4b84347e7bb, codeobj_b314dfc24cfb446bc412a4b84347e7bb, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b314dfc24cfb446bc412a4b84347e7bb = cache_frame_b314dfc24cfb446bc412a4b84347e7bb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b314dfc24cfb446bc412a4b84347e7bb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b314dfc24cfb446bc412a4b84347e7bb ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        if ( PyCell_GET( self->m_closure[1] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "cm_exit" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 377;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = PyCell_GET( self->m_closure[1] );
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "cm" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 377;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_exc_type );
        tmp_args_element_name_2 = par_exc_type;
        CHECK_OBJECT( par_exc );
        tmp_args_element_name_3 = par_exc;
        CHECK_OBJECT( par_tb );
        tmp_args_element_name_4 = par_tb;
        frame_b314dfc24cfb446bc412a4b84347e7bb->m_frame.f_lineno = 377;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 377;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b314dfc24cfb446bc412a4b84347e7bb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b314dfc24cfb446bc412a4b84347e7bb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b314dfc24cfb446bc412a4b84347e7bb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b314dfc24cfb446bc412a4b84347e7bb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b314dfc24cfb446bc412a4b84347e7bb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b314dfc24cfb446bc412a4b84347e7bb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b314dfc24cfb446bc412a4b84347e7bb,
        type_description_1,
        par_exc_type,
        par_exc,
        par_tb,
        self->m_closure[1],
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_b314dfc24cfb446bc412a4b84347e7bb == cache_frame_b314dfc24cfb446bc412a4b84347e7bb )
    {
        Py_DECREF( frame_b314dfc24cfb446bc412a4b84347e7bb );
    }
    cache_frame_b314dfc24cfb446bc412a4b84347e7bb = NULL;

    assertFrameObject( frame_b314dfc24cfb446bc412a4b84347e7bb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_26__create_exit_wrapper$$$function_1__exit_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc );
    Py_DECREF( par_exc );
    par_exc = NULL;

    CHECK_OBJECT( (PyObject *)par_tb );
    Py_DECREF( par_tb );
    par_tb = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc );
    Py_DECREF( par_exc );
    par_exc = NULL;

    CHECK_OBJECT( (PyObject *)par_tb );
    Py_DECREF( par_tb );
    par_tb = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_26__create_exit_wrapper$$$function_1__exit_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_27__create_cb_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_args = PyCell_NEW1( python_pars[ 1 ] );
    struct Nuitka_CellObject *par_kwds = PyCell_NEW1( python_pars[ 2 ] );
    PyObject *var__exit_wrapper = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = MAKE_FUNCTION_contextlib$$$function_27__create_cb_wrapper$$$function_1__exit_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] = par_args;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] = par_callback;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] );
        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[2] = par_kwds;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[2] );


        assert( var__exit_wrapper == NULL );
        var__exit_wrapper = tmp_assign_source_1;
    }
    // Tried code:
    CHECK_OBJECT( var__exit_wrapper );
    tmp_return_value = var__exit_wrapper;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_27__create_cb_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    CHECK_OBJECT( (PyObject *)var__exit_wrapper );
    Py_DECREF( var__exit_wrapper );
    var__exit_wrapper = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_27__create_cb_wrapper );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_27__create_cb_wrapper$$$function_1__exit_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_exc_type = python_pars[ 0 ];
    PyObject *par_exc = python_pars[ 1 ];
    PyObject *par_tb = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_c5e0bdefa48e79d21cad1e6b166e62e9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c5e0bdefa48e79d21cad1e6b166e62e9 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c5e0bdefa48e79d21cad1e6b166e62e9, codeobj_c5e0bdefa48e79d21cad1e6b166e62e9, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c5e0bdefa48e79d21cad1e6b166e62e9 = cache_frame_c5e0bdefa48e79d21cad1e6b166e62e9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c5e0bdefa48e79d21cad1e6b166e62e9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c5e0bdefa48e79d21cad1e6b166e62e9 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_dircall_arg3_1;
        PyObject *tmp_call_result_1;
        if ( PyCell_GET( self->m_closure[1] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 383;
            type_description_1 = "oooccc";
            goto frame_exception_exit_1;
        }

        tmp_dircall_arg1_1 = PyCell_GET( self->m_closure[1] );
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "args" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 383;
            type_description_1 = "oooccc";
            goto frame_exception_exit_1;
        }

        tmp_dircall_arg2_1 = PyCell_GET( self->m_closure[0] );
        if ( PyCell_GET( self->m_closure[2] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "kwds" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 383;
            type_description_1 = "oooccc";
            goto frame_exception_exit_1;
        }

        tmp_dircall_arg3_1 = PyCell_GET( self->m_closure[2] );
        Py_INCREF( tmp_dircall_arg1_1 );
        Py_INCREF( tmp_dircall_arg2_1 );
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_call_result_1 = impl___internal__$$$function_5_complex_call_helper_star_list_star_dict( dir_call_args );
        }
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 383;
            type_description_1 = "oooccc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c5e0bdefa48e79d21cad1e6b166e62e9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c5e0bdefa48e79d21cad1e6b166e62e9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c5e0bdefa48e79d21cad1e6b166e62e9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c5e0bdefa48e79d21cad1e6b166e62e9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c5e0bdefa48e79d21cad1e6b166e62e9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c5e0bdefa48e79d21cad1e6b166e62e9,
        type_description_1,
        par_exc_type,
        par_exc,
        par_tb,
        self->m_closure[1],
        self->m_closure[0],
        self->m_closure[2]
    );


    // Release cached frame.
    if ( frame_c5e0bdefa48e79d21cad1e6b166e62e9 == cache_frame_c5e0bdefa48e79d21cad1e6b166e62e9 )
    {
        Py_DECREF( frame_c5e0bdefa48e79d21cad1e6b166e62e9 );
    }
    cache_frame_c5e0bdefa48e79d21cad1e6b166e62e9 = NULL;

    assertFrameObject( frame_c5e0bdefa48e79d21cad1e6b166e62e9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_27__create_cb_wrapper$$$function_1__exit_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc );
    Py_DECREF( par_exc );
    par_exc = NULL;

    CHECK_OBJECT( (PyObject *)par_tb );
    Py_DECREF( par_tb );
    par_tb = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc );
    Py_DECREF( par_exc );
    par_exc = NULL;

    CHECK_OBJECT( (PyObject *)par_tb );
    Py_DECREF( par_tb );
    par_tb = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_27__create_cb_wrapper$$$function_1__exit_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_28___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_209a810c6ebd52b561796e0f9bae79be;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_209a810c6ebd52b561796e0f9bae79be = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_209a810c6ebd52b561796e0f9bae79be, codeobj_209a810c6ebd52b561796e0f9bae79be, module_contextlib, sizeof(void *) );
    frame_209a810c6ebd52b561796e0f9bae79be = cache_frame_209a810c6ebd52b561796e0f9bae79be;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_209a810c6ebd52b561796e0f9bae79be );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_209a810c6ebd52b561796e0f9bae79be ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_deque );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deque );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "deque" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 387;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_209a810c6ebd52b561796e0f9bae79be->m_frame.f_lineno = 387;
        tmp_assattr_name_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 387;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__exit_callbacks, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 387;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_209a810c6ebd52b561796e0f9bae79be );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_209a810c6ebd52b561796e0f9bae79be );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_209a810c6ebd52b561796e0f9bae79be, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_209a810c6ebd52b561796e0f9bae79be->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_209a810c6ebd52b561796e0f9bae79be, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_209a810c6ebd52b561796e0f9bae79be,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_209a810c6ebd52b561796e0f9bae79be == cache_frame_209a810c6ebd52b561796e0f9bae79be )
    {
        Py_DECREF( frame_209a810c6ebd52b561796e0f9bae79be );
    }
    cache_frame_209a810c6ebd52b561796e0f9bae79be = NULL;

    assertFrameObject( frame_209a810c6ebd52b561796e0f9bae79be );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_28___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_28___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_29_pop_all( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_new_stack = NULL;
    struct Nuitka_FrameObject *frame_ac1633f3fdcf108561287a9aaae4de40;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_ac1633f3fdcf108561287a9aaae4de40 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ac1633f3fdcf108561287a9aaae4de40, codeobj_ac1633f3fdcf108561287a9aaae4de40, module_contextlib, sizeof(void *)+sizeof(void *) );
    frame_ac1633f3fdcf108561287a9aaae4de40 = cache_frame_ac1633f3fdcf108561287a9aaae4de40;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ac1633f3fdcf108561287a9aaae4de40 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ac1633f3fdcf108561287a9aaae4de40 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_type_arg_1;
        CHECK_OBJECT( par_self );
        tmp_type_arg_1 = par_self;
        tmp_called_name_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
        assert( !(tmp_called_name_1 == NULL) );
        frame_ac1633f3fdcf108561287a9aaae4de40->m_frame.f_lineno = 391;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 391;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_new_stack == NULL );
        var_new_stack = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__exit_callbacks );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 392;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_new_stack );
        tmp_assattr_target_1 = var_new_stack;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__exit_callbacks, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 392;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_deque );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deque );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "deque" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 393;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        frame_ac1633f3fdcf108561287a9aaae4de40->m_frame.f_lineno = 393;
        tmp_assattr_name_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 393;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__exit_callbacks, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 393;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac1633f3fdcf108561287a9aaae4de40 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac1633f3fdcf108561287a9aaae4de40 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ac1633f3fdcf108561287a9aaae4de40, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ac1633f3fdcf108561287a9aaae4de40->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ac1633f3fdcf108561287a9aaae4de40, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ac1633f3fdcf108561287a9aaae4de40,
        type_description_1,
        par_self,
        var_new_stack
    );


    // Release cached frame.
    if ( frame_ac1633f3fdcf108561287a9aaae4de40 == cache_frame_ac1633f3fdcf108561287a9aaae4de40 )
    {
        Py_DECREF( frame_ac1633f3fdcf108561287a9aaae4de40 );
    }
    cache_frame_ac1633f3fdcf108561287a9aaae4de40 = NULL;

    assertFrameObject( frame_ac1633f3fdcf108561287a9aaae4de40 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_new_stack );
    tmp_return_value = var_new_stack;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_29_pop_all );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_new_stack );
    Py_DECREF( var_new_stack );
    var_new_stack = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_new_stack );
    var_new_stack = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_29_pop_all );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_30_push( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exit = python_pars[ 1 ];
    PyObject *var__cb_type = NULL;
    PyObject *var_exit_method = NULL;
    nuitka_bool tmp_try_except_1__unhandled_indicator = NUITKA_BOOL_UNASSIGNED;
    struct Nuitka_FrameObject *frame_3eea89dad8802f791e00692828406a41;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    static struct Nuitka_FrameObject *cache_frame_3eea89dad8802f791e00692828406a41 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_type_arg_1;
        CHECK_OBJECT( par_exit );
        tmp_type_arg_1 = par_exit;
        tmp_assign_source_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
        assert( !(tmp_assign_source_1 == NULL) );
        assert( var__cb_type == NULL );
        var__cb_type = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_assign_source_2;
        tmp_assign_source_2 = NUITKA_BOOL_TRUE;
        tmp_try_except_1__unhandled_indicator = tmp_assign_source_2;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3eea89dad8802f791e00692828406a41, codeobj_3eea89dad8802f791e00692828406a41, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3eea89dad8802f791e00692828406a41 = cache_frame_3eea89dad8802f791e00692828406a41;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3eea89dad8802f791e00692828406a41 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3eea89dad8802f791e00692828406a41 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    // Tried code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( var__cb_type );
        tmp_source_name_1 = var__cb_type;
        tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___exit__ );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 408;
            type_description_1 = "oooo";
            goto try_except_handler_3;
        }
        assert( var_exit_method == NULL );
        var_exit_method = tmp_assign_source_3;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        nuitka_bool tmp_assign_source_4;
        tmp_assign_source_4 = NUITKA_BOOL_FALSE;
        tmp_try_except_1__unhandled_indicator = tmp_assign_source_4;
    }
    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_3eea89dad8802f791e00692828406a41, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_3eea89dad8802f791e00692828406a41, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_AttributeError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 409;
            type_description_1 = "oooo";
            goto try_except_handler_4;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( par_exit );
            tmp_args_element_name_1 = par_exit;
            frame_3eea89dad8802f791e00692828406a41->m_frame.f_lineno = 411;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__push_exit_callback, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 411;
                type_description_1 = "oooo";
                goto try_except_handler_4;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 407;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_3eea89dad8802f791e00692828406a41->m_frame) frame_3eea89dad8802f791e00692828406a41->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooo";
        goto try_except_handler_4;
        branch_end_1:;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_30_push );
    return NULL;
    // End of try:
    try_end_1:;
    {
        nuitka_bool tmp_condition_result_2;
        nuitka_bool tmp_compexpr_left_2;
        nuitka_bool tmp_compexpr_right_2;
        assert( tmp_try_except_1__unhandled_indicator != NUITKA_BOOL_UNASSIGNED);
        tmp_compexpr_left_2 = tmp_try_except_1__unhandled_indicator;
        tmp_compexpr_right_2 = NUITKA_BOOL_TRUE;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__push_cm_exit );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 413;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( par_exit );
            tmp_args_element_name_2 = par_exit;
            if ( var_exit_method == NULL )
            {
                Py_DECREF( tmp_called_name_1 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "exit_method" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 413;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }

            tmp_args_element_name_3 = var_exit_method;
            frame_3eea89dad8802f791e00692828406a41->m_frame.f_lineno = 413;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 413;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_2:;
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3eea89dad8802f791e00692828406a41 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3eea89dad8802f791e00692828406a41 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3eea89dad8802f791e00692828406a41, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3eea89dad8802f791e00692828406a41->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3eea89dad8802f791e00692828406a41, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3eea89dad8802f791e00692828406a41,
        type_description_1,
        par_self,
        par_exit,
        var__cb_type,
        var_exit_method
    );


    // Release cached frame.
    if ( frame_3eea89dad8802f791e00692828406a41 == cache_frame_3eea89dad8802f791e00692828406a41 )
    {
        Py_DECREF( frame_3eea89dad8802f791e00692828406a41 );
    }
    cache_frame_3eea89dad8802f791e00692828406a41 = NULL;

    assertFrameObject( frame_3eea89dad8802f791e00692828406a41 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( par_exit );
    tmp_return_value = par_exit;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_30_push );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exit );
    Py_DECREF( par_exit );
    par_exit = NULL;

    CHECK_OBJECT( (PyObject *)var__cb_type );
    Py_DECREF( var__cb_type );
    var__cb_type = NULL;

    Py_XDECREF( var_exit_method );
    var_exit_method = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exit );
    Py_DECREF( par_exit );
    par_exit = NULL;

    CHECK_OBJECT( (PyObject *)var__cb_type );
    Py_DECREF( var__cb_type );
    var__cb_type = NULL;

    Py_XDECREF( var_exit_method );
    var_exit_method = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_30_push );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_31_enter_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cm = python_pars[ 1 ];
    PyObject *var__cm_type = NULL;
    PyObject *var__exit = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_c2b386b5b585286d75c620b41f07f6f9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c2b386b5b585286d75c620b41f07f6f9 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_type_arg_1;
        CHECK_OBJECT( par_cm );
        tmp_type_arg_1 = par_cm;
        tmp_assign_source_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
        assert( !(tmp_assign_source_1 == NULL) );
        assert( var__cm_type == NULL );
        var__cm_type = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c2b386b5b585286d75c620b41f07f6f9, codeobj_c2b386b5b585286d75c620b41f07f6f9, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c2b386b5b585286d75c620b41f07f6f9 = cache_frame_c2b386b5b585286d75c620b41f07f6f9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c2b386b5b585286d75c620b41f07f6f9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c2b386b5b585286d75c620b41f07f6f9 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( var__cm_type );
        tmp_source_name_1 = var__cm_type;
        tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___exit__ );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 425;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var__exit == NULL );
        var__exit = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( var__cm_type );
        tmp_called_instance_1 = var__cm_type;
        CHECK_OBJECT( par_cm );
        tmp_args_element_name_1 = par_cm;
        frame_c2b386b5b585286d75c620b41f07f6f9->m_frame.f_lineno = 426;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___enter__, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 426;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        CHECK_OBJECT( par_cm );
        tmp_args_element_name_2 = par_cm;
        CHECK_OBJECT( var__exit );
        tmp_args_element_name_3 = var__exit;
        frame_c2b386b5b585286d75c620b41f07f6f9->m_frame.f_lineno = 427;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain__push_cm_exit, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 427;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c2b386b5b585286d75c620b41f07f6f9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c2b386b5b585286d75c620b41f07f6f9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c2b386b5b585286d75c620b41f07f6f9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c2b386b5b585286d75c620b41f07f6f9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c2b386b5b585286d75c620b41f07f6f9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c2b386b5b585286d75c620b41f07f6f9,
        type_description_1,
        par_self,
        par_cm,
        var__cm_type,
        var__exit,
        var_result
    );


    // Release cached frame.
    if ( frame_c2b386b5b585286d75c620b41f07f6f9 == cache_frame_c2b386b5b585286d75c620b41f07f6f9 )
    {
        Py_DECREF( frame_c2b386b5b585286d75c620b41f07f6f9 );
    }
    cache_frame_c2b386b5b585286d75c620b41f07f6f9 = NULL;

    assertFrameObject( frame_c2b386b5b585286d75c620b41f07f6f9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_result );
    tmp_return_value = var_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_31_enter_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cm );
    Py_DECREF( par_cm );
    par_cm = NULL;

    CHECK_OBJECT( (PyObject *)var__cm_type );
    Py_DECREF( var__cm_type );
    var__cm_type = NULL;

    CHECK_OBJECT( (PyObject *)var__exit );
    Py_DECREF( var__exit );
    var__exit = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cm );
    Py_DECREF( par_cm );
    par_cm = NULL;

    CHECK_OBJECT( (PyObject *)var__cm_type );
    Py_DECREF( var__cm_type );
    var__cm_type = NULL;

    Py_XDECREF( var__exit );
    var__exit = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_31_enter_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_32_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    PyObject *par_args = python_pars[ 2 ];
    PyObject *par_kwds = python_pars[ 3 ];
    PyObject *var__exit_wrapper = NULL;
    struct Nuitka_FrameObject *frame_d11d44405c07a698ba8f0ab99d8d0e2a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_d11d44405c07a698ba8f0ab99d8d0e2a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d11d44405c07a698ba8f0ab99d8d0e2a, codeobj_d11d44405c07a698ba8f0ab99d8d0e2a, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d11d44405c07a698ba8f0ab99d8d0e2a = cache_frame_d11d44405c07a698ba8f0ab99d8d0e2a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d11d44405c07a698ba8f0ab99d8d0e2a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d11d44405c07a698ba8f0ab99d8d0e2a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        PyObject *tmp_dircall_arg4_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__create_cb_wrapper );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 435;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_callback );
        tmp_tuple_element_1 = par_callback;
        tmp_dircall_arg2_1 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_args );
        tmp_dircall_arg3_1 = par_args;
        CHECK_OBJECT( par_kwds );
        tmp_dircall_arg4_1 = par_kwds;
        Py_INCREF( tmp_dircall_arg3_1 );
        Py_INCREF( tmp_dircall_arg4_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
            tmp_assign_source_1 = impl___internal__$$$function_8_complex_call_helper_pos_star_list_star_dict( dir_call_args );
        }
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 435;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var__exit_wrapper == NULL );
        var__exit_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_callback );
        tmp_assattr_name_1 = par_callback;
        CHECK_OBJECT( var__exit_wrapper );
        tmp_assattr_target_1 = var__exit_wrapper;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain___wrapped__, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 439;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( var__exit_wrapper );
        tmp_args_element_name_1 = var__exit_wrapper;
        frame_d11d44405c07a698ba8f0ab99d8d0e2a->m_frame.f_lineno = 440;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__push_exit_callback, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 440;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d11d44405c07a698ba8f0ab99d8d0e2a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d11d44405c07a698ba8f0ab99d8d0e2a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d11d44405c07a698ba8f0ab99d8d0e2a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d11d44405c07a698ba8f0ab99d8d0e2a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d11d44405c07a698ba8f0ab99d8d0e2a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d11d44405c07a698ba8f0ab99d8d0e2a,
        type_description_1,
        par_self,
        par_callback,
        par_args,
        par_kwds,
        var__exit_wrapper
    );


    // Release cached frame.
    if ( frame_d11d44405c07a698ba8f0ab99d8d0e2a == cache_frame_d11d44405c07a698ba8f0ab99d8d0e2a )
    {
        Py_DECREF( frame_d11d44405c07a698ba8f0ab99d8d0e2a );
    }
    cache_frame_d11d44405c07a698ba8f0ab99d8d0e2a = NULL;

    assertFrameObject( frame_d11d44405c07a698ba8f0ab99d8d0e2a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( par_callback );
    tmp_return_value = par_callback;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_32_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    CHECK_OBJECT( (PyObject *)var__exit_wrapper );
    Py_DECREF( var__exit_wrapper );
    var__exit_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    Py_XDECREF( var__exit_wrapper );
    var__exit_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_32_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_33__push_cm_exit( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cm = python_pars[ 1 ];
    PyObject *par_cm_exit = python_pars[ 2 ];
    PyObject *var__exit_wrapper = NULL;
    struct Nuitka_FrameObject *frame_5e7507c3fa2f8357a290571a7c2c87fb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_5e7507c3fa2f8357a290571a7c2c87fb = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5e7507c3fa2f8357a290571a7c2c87fb, codeobj_5e7507c3fa2f8357a290571a7c2c87fb, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5e7507c3fa2f8357a290571a7c2c87fb = cache_frame_5e7507c3fa2f8357a290571a7c2c87fb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5e7507c3fa2f8357a290571a7c2c87fb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5e7507c3fa2f8357a290571a7c2c87fb ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_cm );
        tmp_args_element_name_1 = par_cm;
        CHECK_OBJECT( par_cm_exit );
        tmp_args_element_name_2 = par_cm_exit;
        frame_5e7507c3fa2f8357a290571a7c2c87fb->m_frame.f_lineno = 445;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain__create_exit_wrapper, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 445;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var__exit_wrapper == NULL );
        var__exit_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_cm );
        tmp_assattr_name_1 = par_cm;
        CHECK_OBJECT( var__exit_wrapper );
        tmp_assattr_target_1 = var__exit_wrapper;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain___self__, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 446;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        CHECK_OBJECT( var__exit_wrapper );
        tmp_args_element_name_3 = var__exit_wrapper;
        tmp_args_element_name_4 = Py_True;
        frame_5e7507c3fa2f8357a290571a7c2c87fb->m_frame.f_lineno = 447;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain__push_exit_callback, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 447;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5e7507c3fa2f8357a290571a7c2c87fb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5e7507c3fa2f8357a290571a7c2c87fb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5e7507c3fa2f8357a290571a7c2c87fb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5e7507c3fa2f8357a290571a7c2c87fb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5e7507c3fa2f8357a290571a7c2c87fb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5e7507c3fa2f8357a290571a7c2c87fb,
        type_description_1,
        par_self,
        par_cm,
        par_cm_exit,
        var__exit_wrapper
    );


    // Release cached frame.
    if ( frame_5e7507c3fa2f8357a290571a7c2c87fb == cache_frame_5e7507c3fa2f8357a290571a7c2c87fb )
    {
        Py_DECREF( frame_5e7507c3fa2f8357a290571a7c2c87fb );
    }
    cache_frame_5e7507c3fa2f8357a290571a7c2c87fb = NULL;

    assertFrameObject( frame_5e7507c3fa2f8357a290571a7c2c87fb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_33__push_cm_exit );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cm );
    Py_DECREF( par_cm );
    par_cm = NULL;

    CHECK_OBJECT( (PyObject *)par_cm_exit );
    Py_DECREF( par_cm_exit );
    par_cm_exit = NULL;

    CHECK_OBJECT( (PyObject *)var__exit_wrapper );
    Py_DECREF( var__exit_wrapper );
    var__exit_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cm );
    Py_DECREF( par_cm );
    par_cm = NULL;

    CHECK_OBJECT( (PyObject *)par_cm_exit );
    Py_DECREF( par_cm_exit );
    par_cm_exit = NULL;

    Py_XDECREF( var__exit_wrapper );
    var__exit_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_33__push_cm_exit );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_34__push_exit_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    PyObject *par_is_sync = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_e2bc8f99006d30c55dd2a8eecf6821aa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e2bc8f99006d30c55dd2a8eecf6821aa = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e2bc8f99006d30c55dd2a8eecf6821aa, codeobj_e2bc8f99006d30c55dd2a8eecf6821aa, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e2bc8f99006d30c55dd2a8eecf6821aa = cache_frame_e2bc8f99006d30c55dd2a8eecf6821aa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e2bc8f99006d30c55dd2a8eecf6821aa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e2bc8f99006d30c55dd2a8eecf6821aa ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_tuple_element_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__exit_callbacks );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_is_sync );
        tmp_tuple_element_1 = par_is_sync;
        tmp_args_element_name_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_element_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_callback );
        tmp_tuple_element_1 = par_callback;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_element_name_1, 1, tmp_tuple_element_1 );
        frame_e2bc8f99006d30c55dd2a8eecf6821aa->m_frame.f_lineno = 450;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2bc8f99006d30c55dd2a8eecf6821aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2bc8f99006d30c55dd2a8eecf6821aa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e2bc8f99006d30c55dd2a8eecf6821aa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e2bc8f99006d30c55dd2a8eecf6821aa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e2bc8f99006d30c55dd2a8eecf6821aa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e2bc8f99006d30c55dd2a8eecf6821aa,
        type_description_1,
        par_self,
        par_callback,
        par_is_sync
    );


    // Release cached frame.
    if ( frame_e2bc8f99006d30c55dd2a8eecf6821aa == cache_frame_e2bc8f99006d30c55dd2a8eecf6821aa )
    {
        Py_DECREF( frame_e2bc8f99006d30c55dd2a8eecf6821aa );
    }
    cache_frame_e2bc8f99006d30c55dd2a8eecf6821aa = NULL;

    assertFrameObject( frame_e2bc8f99006d30c55dd2a8eecf6821aa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_34__push_exit_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_is_sync );
    Py_DECREF( par_is_sync );
    par_is_sync = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_is_sync );
    Py_DECREF( par_is_sync );
    par_is_sync = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_34__push_exit_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_35___enter__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    CHECK_OBJECT( par_self );
    tmp_return_value = par_self;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_35___enter__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_35___enter__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_36___exit__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exc_details = python_pars[ 1 ];
    nuitka_bool var_received_exc = NUITKA_BOOL_UNASSIGNED;
    struct Nuitka_CellObject *var_frame_exc = PyCell_EMPTY();
    PyObject *var__fix_exception_context = NULL;
    PyObject *var_suppressed_exc = NULL;
    PyObject *var_pending_raise = NULL;
    PyObject *var_is_sync = NULL;
    PyObject *var_cb = NULL;
    PyObject *var_new_exc_details = NULL;
    PyObject *var_fixed_ctx = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_5319d6795f1312e749b7f025eaaf1c46;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_preserved_type_2;
    PyObject *exception_preserved_value_2;
    PyTracebackObject *exception_preserved_tb_2;
    bool tmp_result;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_5319d6795f1312e749b7f025eaaf1c46 = NULL;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5319d6795f1312e749b7f025eaaf1c46, codeobj_5319d6795f1312e749b7f025eaaf1c46, module_contextlib, sizeof(nuitka_bool)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5319d6795f1312e749b7f025eaaf1c46 = cache_frame_5319d6795f1312e749b7f025eaaf1c46;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5319d6795f1312e749b7f025eaaf1c46 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5319d6795f1312e749b7f025eaaf1c46 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_assign_source_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT( par_exc_details );
        tmp_subscribed_name_1 = par_exc_details;
        tmp_subscript_name_1 = const_int_0;
        tmp_compexpr_left_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 469;
            type_description_1 = "oobcooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_assign_source_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        var_received_exc = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_sys );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 473;
            type_description_1 = "oobcooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_5319d6795f1312e749b7f025eaaf1c46->m_frame.f_lineno = 473;
        tmp_subscribed_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_exc_info );
        if ( tmp_subscribed_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 473;
            type_description_1 = "oobcooooooo";
            goto frame_exception_exit_1;
        }
        tmp_subscript_name_2 = const_int_pos_1;
        tmp_assign_source_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 1 );
        Py_DECREF( tmp_subscribed_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 473;
            type_description_1 = "oobcooooooo";
            goto frame_exception_exit_1;
        }
        assert( PyCell_GET( var_frame_exc ) == NULL );
        PyCell_SET( var_frame_exc, tmp_assign_source_2 );

    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = MAKE_FUNCTION_contextlib$$$function_36___exit__$$$function_1__fix_exception_context(  );

        ((struct Nuitka_FunctionObject *)tmp_assign_source_3)->m_closure[0] = var_frame_exc;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_3)->m_closure[0] );


        assert( var__fix_exception_context == NULL );
        var__fix_exception_context = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        tmp_assign_source_4 = Py_False;
        assert( var_suppressed_exc == NULL );
        Py_INCREF( tmp_assign_source_4 );
        var_suppressed_exc = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        tmp_assign_source_5 = Py_False;
        assert( var_pending_raise == NULL );
        Py_INCREF( tmp_assign_source_5 );
        var_pending_raise = tmp_assign_source_5;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__exit_callbacks );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 492;
            type_description_1 = "oobcooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 492;
            type_description_1 = "oobcooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__exit_callbacks );
        if ( tmp_called_instance_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 493;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_2;
        }
        frame_5319d6795f1312e749b7f025eaaf1c46->m_frame.f_lineno = 493;
        tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_pop );
        Py_DECREF( tmp_called_instance_2 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 493;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_2;
        }
        tmp_assign_source_6 = MAKE_UNPACK_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 493;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__source_iter;
            tmp_tuple_unpack_1__source_iter = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_7 = UNPACK_NEXT( tmp_unpack_1, 0, 2 );
        if ( tmp_assign_source_7 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oobcooooooo";
            exception_lineno = 493;
            goto try_except_handler_3;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_1;
            tmp_tuple_unpack_1__element_1 = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_8 = UNPACK_NEXT( tmp_unpack_2, 1, 2 );
        if ( tmp_assign_source_8 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oobcooooooo";
            exception_lineno = 493;
            goto try_except_handler_3;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_2;
            tmp_tuple_unpack_1__element_2 = tmp_assign_source_8;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "oobcooooooo";
                    exception_lineno = 493;
                    goto try_except_handler_3;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "oobcooooooo";
            exception_lineno = 493;
            goto try_except_handler_3;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_9;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_9 = tmp_tuple_unpack_1__element_1;
        {
            PyObject *old = var_is_sync;
            var_is_sync = tmp_assign_source_9;
            Py_INCREF( var_is_sync );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_10;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_10 = tmp_tuple_unpack_1__element_2;
        {
            PyObject *old = var_cb;
            var_cb = tmp_assign_source_10;
            Py_INCREF( var_cb );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_is_sync );
        tmp_operand_name_2 = var_is_sync;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 494;
            type_description_1 = "oobcooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF( tmp_raise_type_1 );
            exception_lineno = 494;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oobcooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    // Tried code:
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_call_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( var_cb );
        tmp_dircall_arg1_1 = var_cb;
        if ( par_exc_details == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "exc_details" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 496;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_4;
        }

        tmp_dircall_arg2_1 = par_exc_details;
        Py_INCREF( tmp_dircall_arg1_1 );
        Py_INCREF( tmp_dircall_arg2_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1};
            tmp_call_result_1 = impl___internal__$$$function_2_complex_call_helper_star_list( dir_call_args );
        }
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 496;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_4;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_call_result_1 );

            exception_lineno = 496;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_4;
        }
        tmp_condition_result_3 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_1 );
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_11;
            tmp_assign_source_11 = Py_True;
            {
                PyObject *old = var_suppressed_exc;
                var_suppressed_exc = tmp_assign_source_11;
                Py_INCREF( var_suppressed_exc );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_12;
            tmp_assign_source_12 = Py_False;
            {
                PyObject *old = var_pending_raise;
                var_pending_raise = tmp_assign_source_12;
                Py_INCREF( var_pending_raise );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_13;
            tmp_assign_source_13 = const_tuple_none_none_none_tuple;
            {
                PyObject *old = par_exc_details;
                par_exc_details = tmp_assign_source_13;
                Py_INCREF( par_exc_details );
                Py_XDECREF( old );
            }

        }
        branch_no_3:;
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_3 == NULL )
    {
        exception_keeper_tb_3 = MAKE_TRACEBACK( frame_5319d6795f1312e749b7f025eaaf1c46, exception_keeper_lineno_3 );
    }
    else if ( exception_keeper_lineno_3 != 0 )
    {
        exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_5319d6795f1312e749b7f025eaaf1c46, exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    PyException_SetTraceback( exception_keeper_value_3, (PyObject *)exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    // Tried code:
    {
        PyObject *tmp_assign_source_14;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_sys );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 501;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_5;
        }

        tmp_called_instance_3 = tmp_mvar_value_2;
        frame_5319d6795f1312e749b7f025eaaf1c46->m_frame.f_lineno = 501;
        tmp_assign_source_14 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_exc_info );
        if ( tmp_assign_source_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 501;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_5;
        }
        {
            PyObject *old = var_new_exc_details;
            var_new_exc_details = tmp_assign_source_14;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_subscript_name_4;
        CHECK_OBJECT( var__fix_exception_context );
        tmp_called_name_1 = var__fix_exception_context;
        CHECK_OBJECT( var_new_exc_details );
        tmp_subscribed_name_3 = var_new_exc_details;
        tmp_subscript_name_3 = const_int_pos_1;
        tmp_args_element_name_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 503;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_5;
        }
        if ( par_exc_details == NULL )
        {
            Py_DECREF( tmp_args_element_name_1 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "exc_details" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 503;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_5;
        }

        tmp_subscribed_name_4 = par_exc_details;
        tmp_subscript_name_4 = const_int_pos_1;
        tmp_args_element_name_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 1 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 503;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_5;
        }
        frame_5319d6795f1312e749b7f025eaaf1c46->m_frame.f_lineno = 503;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 503;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_5;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    {
        PyObject *tmp_assign_source_15;
        tmp_assign_source_15 = Py_True;
        {
            PyObject *old = var_pending_raise;
            var_pending_raise = tmp_assign_source_15;
            Py_INCREF( var_pending_raise );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_16;
        CHECK_OBJECT( var_new_exc_details );
        tmp_assign_source_16 = var_new_exc_details;
        {
            PyObject *old = par_exc_details;
            par_exc_details = tmp_assign_source_16;
            Py_INCREF( par_exc_details );
            Py_XDECREF( old );
        }

    }
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    goto try_end_3;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_36___exit__ );
    return NULL;
    // End of try:
    try_end_3:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 492;
        type_description_1 = "oobcooooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_truth_name_2;
        if ( var_pending_raise == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "pending_raise" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 506;
            type_description_1 = "oobcooooooo";
            goto frame_exception_exit_1;
        }

        tmp_truth_name_2 = CHECK_IF_TRUE( var_pending_raise );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 506;
            type_description_1 = "oobcooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        // Tried code:
        {
            PyObject *tmp_assign_source_17;
            PyObject *tmp_source_name_3;
            PyObject *tmp_subscribed_name_5;
            PyObject *tmp_subscript_name_5;
            if ( par_exc_details == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "exc_details" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 510;
                type_description_1 = "oobcooooooo";
                goto try_except_handler_6;
            }

            tmp_subscribed_name_5 = par_exc_details;
            tmp_subscript_name_5 = const_int_pos_1;
            tmp_source_name_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_5, tmp_subscript_name_5, 1 );
            if ( tmp_source_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 510;
                type_description_1 = "oobcooooooo";
                goto try_except_handler_6;
            }
            tmp_assign_source_17 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___context__ );
            Py_DECREF( tmp_source_name_3 );
            if ( tmp_assign_source_17 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 510;
                type_description_1 = "oobcooooooo";
                goto try_except_handler_6;
            }
            assert( var_fixed_ctx == NULL );
            var_fixed_ctx = tmp_assign_source_17;
        }
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_subscribed_name_6;
            PyObject *tmp_subscript_name_6;
            if ( par_exc_details == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "exc_details" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 511;
                type_description_1 = "oobcooooooo";
                goto try_except_handler_6;
            }

            tmp_subscribed_name_6 = par_exc_details;
            tmp_subscript_name_6 = const_int_pos_1;
            tmp_raise_type_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_6, tmp_subscript_name_6, 1 );
            if ( tmp_raise_type_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 511;
                type_description_1 = "oobcooooooo";
                goto try_except_handler_6;
            }
            exception_type = tmp_raise_type_2;
            exception_lineno = 511;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oobcooooooo";
            goto try_except_handler_6;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib$$$function_36___exit__ );
        return NULL;
        // Exception handler code:
        try_except_handler_6:;
        exception_keeper_type_5 = exception_type;
        exception_keeper_value_5 = exception_value;
        exception_keeper_tb_5 = exception_tb;
        exception_keeper_lineno_5 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        exception_preserved_type_2 = EXC_TYPE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_type_2 );
        exception_preserved_value_2 = EXC_VALUE(PyThreadState_GET());
        Py_XINCREF( exception_preserved_value_2 );
        exception_preserved_tb_2 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
        Py_XINCREF( exception_preserved_tb_2 );

        if ( exception_keeper_tb_5 == NULL )
        {
            exception_keeper_tb_5 = MAKE_TRACEBACK( frame_5319d6795f1312e749b7f025eaaf1c46, exception_keeper_lineno_5 );
        }
        else if ( exception_keeper_lineno_5 != 0 )
        {
            exception_keeper_tb_5 = ADD_TRACEBACK( exception_keeper_tb_5, frame_5319d6795f1312e749b7f025eaaf1c46, exception_keeper_lineno_5 );
        }

        NORMALIZE_EXCEPTION( &exception_keeper_type_5, &exception_keeper_value_5, &exception_keeper_tb_5 );
        PyException_SetTraceback( exception_keeper_value_5, (PyObject *)exception_keeper_tb_5 );
        PUBLISH_EXCEPTION( &exception_keeper_type_5, &exception_keeper_value_5, &exception_keeper_tb_5 );
        // Tried code:
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
            tmp_compexpr_right_2 = PyExc_BaseException;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 512;
                type_description_1 = "oobcooooooo";
                goto try_except_handler_7;
            }
            tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_5;
            }
            else
            {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_assattr_name_1;
                PyObject *tmp_assattr_target_1;
                PyObject *tmp_subscribed_name_7;
                PyObject *tmp_subscript_name_7;
                if ( var_fixed_ctx == NULL )
                {

                    exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "fixed_ctx" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 513;
                    type_description_1 = "oobcooooooo";
                    goto try_except_handler_7;
                }

                tmp_assattr_name_1 = var_fixed_ctx;
                if ( par_exc_details == NULL )
                {

                    exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "exc_details" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 513;
                    type_description_1 = "oobcooooooo";
                    goto try_except_handler_7;
                }

                tmp_subscribed_name_7 = par_exc_details;
                tmp_subscript_name_7 = const_int_pos_1;
                tmp_assattr_target_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_7, tmp_subscript_name_7, 1 );
                if ( tmp_assattr_target_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 513;
                    type_description_1 = "oobcooooooo";
                    goto try_except_handler_7;
                }
                tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain___context__, tmp_assattr_name_1 );
                Py_DECREF( tmp_assattr_target_1 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 513;
                    type_description_1 = "oobcooooooo";
                    goto try_except_handler_7;
                }
            }
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 514;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_5319d6795f1312e749b7f025eaaf1c46->m_frame) frame_5319d6795f1312e749b7f025eaaf1c46->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_7;
            goto branch_end_5;
            branch_no_5:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 507;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_5319d6795f1312e749b7f025eaaf1c46->m_frame) frame_5319d6795f1312e749b7f025eaaf1c46->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "oobcooooooo";
            goto try_except_handler_7;
            branch_end_5:;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib$$$function_36___exit__ );
        return NULL;
        // Exception handler code:
        try_except_handler_7:;
        exception_keeper_type_6 = exception_type;
        exception_keeper_value_6 = exception_value;
        exception_keeper_tb_6 = exception_tb;
        exception_keeper_lineno_6 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Restore previous exception.
        SET_CURRENT_EXCEPTION( exception_preserved_type_2, exception_preserved_value_2, exception_preserved_tb_2 );
        // Re-raise.
        exception_type = exception_keeper_type_6;
        exception_value = exception_keeper_value_6;
        exception_tb = exception_keeper_tb_6;
        exception_lineno = exception_keeper_lineno_6;

        goto frame_exception_exit_1;
        // End of try:
        // End of try:
        branch_no_4:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        assert( var_received_exc != NUITKA_BOOL_UNASSIGNED);
        tmp_and_left_value_1 = ( var_received_exc == NUITKA_BOOL_TRUE ) ? Py_True : Py_False;
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 515;
            type_description_1 = "oobcooooooo";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        if ( var_suppressed_exc == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "suppressed_exc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 515;
            type_description_1 = "oobcooooooo";
            goto frame_exception_exit_1;
        }

        tmp_and_right_value_1 = var_suppressed_exc;
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5319d6795f1312e749b7f025eaaf1c46 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5319d6795f1312e749b7f025eaaf1c46 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5319d6795f1312e749b7f025eaaf1c46 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5319d6795f1312e749b7f025eaaf1c46, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5319d6795f1312e749b7f025eaaf1c46->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5319d6795f1312e749b7f025eaaf1c46, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5319d6795f1312e749b7f025eaaf1c46,
        type_description_1,
        par_self,
        par_exc_details,
        (int)var_received_exc,
        var_frame_exc,
        var__fix_exception_context,
        var_suppressed_exc,
        var_pending_raise,
        var_is_sync,
        var_cb,
        var_new_exc_details,
        var_fixed_ctx
    );


    // Release cached frame.
    if ( frame_5319d6795f1312e749b7f025eaaf1c46 == cache_frame_5319d6795f1312e749b7f025eaaf1c46 )
    {
        Py_DECREF( frame_5319d6795f1312e749b7f025eaaf1c46 );
    }
    cache_frame_5319d6795f1312e749b7f025eaaf1c46 = NULL;

    assertFrameObject( frame_5319d6795f1312e749b7f025eaaf1c46 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_36___exit__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_exc_details );
    par_exc_details = NULL;

    CHECK_OBJECT( (PyObject *)var_frame_exc );
    Py_DECREF( var_frame_exc );
    var_frame_exc = NULL;

    CHECK_OBJECT( (PyObject *)var__fix_exception_context );
    Py_DECREF( var__fix_exception_context );
    var__fix_exception_context = NULL;

    Py_XDECREF( var_suppressed_exc );
    var_suppressed_exc = NULL;

    Py_XDECREF( var_pending_raise );
    var_pending_raise = NULL;

    Py_XDECREF( var_is_sync );
    var_is_sync = NULL;

    Py_XDECREF( var_cb );
    var_cb = NULL;

    Py_XDECREF( var_new_exc_details );
    var_new_exc_details = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_exc_details );
    par_exc_details = NULL;

    CHECK_OBJECT( (PyObject *)var_frame_exc );
    Py_DECREF( var_frame_exc );
    var_frame_exc = NULL;

    Py_XDECREF( var__fix_exception_context );
    var__fix_exception_context = NULL;

    Py_XDECREF( var_suppressed_exc );
    var_suppressed_exc = NULL;

    Py_XDECREF( var_pending_raise );
    var_pending_raise = NULL;

    Py_XDECREF( var_is_sync );
    var_is_sync = NULL;

    Py_XDECREF( var_cb );
    var_cb = NULL;

    Py_XDECREF( var_new_exc_details );
    var_new_exc_details = NULL;

    Py_XDECREF( var_fixed_ctx );
    var_fixed_ctx = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_36___exit__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_36___exit__$$$function_1__fix_exception_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_new_exc = python_pars[ 0 ];
    PyObject *par_old_exc = python_pars[ 1 ];
    PyObject *var_exc_context = NULL;
    struct Nuitka_FrameObject *frame_bbfd4ac0f959c684210adaa396b9a35a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_bbfd4ac0f959c684210adaa396b9a35a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bbfd4ac0f959c684210adaa396b9a35a, codeobj_bbfd4ac0f959c684210adaa396b9a35a, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_bbfd4ac0f959c684210adaa396b9a35a = cache_frame_bbfd4ac0f959c684210adaa396b9a35a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bbfd4ac0f959c684210adaa396b9a35a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bbfd4ac0f959c684210adaa396b9a35a ) == 2 ); // Frame stack

    // Framed code:
    loop_start_1:;
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_new_exc );
        tmp_source_name_1 = par_new_exc;
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___context__ );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 477;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_exc_context;
            var_exc_context = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_exc_context );
        tmp_compexpr_left_1 = var_exc_context;
        CHECK_OBJECT( par_old_exc );
        tmp_compexpr_right_1 = par_old_exc;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT( var_exc_context );
        tmp_compexpr_left_2 = var_exc_context;
        tmp_compexpr_right_2 = Py_None;
        tmp_or_left_value_1 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( var_exc_context );
        tmp_compexpr_left_3 = var_exc_context;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "frame_exc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 481;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_3 = PyCell_GET( self->m_closure[0] );
        tmp_or_right_value_1 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_2 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_2 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        goto loop_end_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( var_exc_context );
        tmp_assign_source_2 = var_exc_context;
        {
            PyObject *old = par_new_exc;
            assert( old != NULL );
            par_new_exc = tmp_assign_source_2;
            Py_INCREF( par_new_exc );
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 476;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_old_exc );
        tmp_assattr_name_1 = par_old_exc;
        CHECK_OBJECT( par_new_exc );
        tmp_assattr_target_1 = par_new_exc;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain___context__, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 486;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bbfd4ac0f959c684210adaa396b9a35a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_bbfd4ac0f959c684210adaa396b9a35a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bbfd4ac0f959c684210adaa396b9a35a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bbfd4ac0f959c684210adaa396b9a35a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bbfd4ac0f959c684210adaa396b9a35a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bbfd4ac0f959c684210adaa396b9a35a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bbfd4ac0f959c684210adaa396b9a35a,
        type_description_1,
        par_new_exc,
        par_old_exc,
        var_exc_context,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_bbfd4ac0f959c684210adaa396b9a35a == cache_frame_bbfd4ac0f959c684210adaa396b9a35a )
    {
        Py_DECREF( frame_bbfd4ac0f959c684210adaa396b9a35a );
    }
    cache_frame_bbfd4ac0f959c684210adaa396b9a35a = NULL;

    assertFrameObject( frame_bbfd4ac0f959c684210adaa396b9a35a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_36___exit__$$$function_1__fix_exception_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_new_exc );
    Py_DECREF( par_new_exc );
    par_new_exc = NULL;

    CHECK_OBJECT( (PyObject *)par_old_exc );
    Py_DECREF( par_old_exc );
    par_old_exc = NULL;

    CHECK_OBJECT( (PyObject *)var_exc_context );
    Py_DECREF( var_exc_context );
    var_exc_context = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_new_exc );
    Py_DECREF( par_new_exc );
    par_new_exc = NULL;

    CHECK_OBJECT( (PyObject *)par_old_exc );
    Py_DECREF( par_old_exc );
    par_old_exc = NULL;

    Py_XDECREF( var_exc_context );
    var_exc_context = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_36___exit__$$$function_1__fix_exception_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_37_close( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6bd1f91ac15dd8324cd978b80269b375;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6bd1f91ac15dd8324cd978b80269b375 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6bd1f91ac15dd8324cd978b80269b375, codeobj_6bd1f91ac15dd8324cd978b80269b375, module_contextlib, sizeof(void *) );
    frame_6bd1f91ac15dd8324cd978b80269b375 = cache_frame_6bd1f91ac15dd8324cd978b80269b375;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6bd1f91ac15dd8324cd978b80269b375 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6bd1f91ac15dd8324cd978b80269b375 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_6bd1f91ac15dd8324cd978b80269b375->m_frame.f_lineno = 519;
        tmp_call_result_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain___exit__, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 519;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6bd1f91ac15dd8324cd978b80269b375 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6bd1f91ac15dd8324cd978b80269b375 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6bd1f91ac15dd8324cd978b80269b375, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6bd1f91ac15dd8324cd978b80269b375->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6bd1f91ac15dd8324cd978b80269b375, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6bd1f91ac15dd8324cd978b80269b375,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6bd1f91ac15dd8324cd978b80269b375 == cache_frame_6bd1f91ac15dd8324cd978b80269b375 )
    {
        Py_DECREF( frame_6bd1f91ac15dd8324cd978b80269b375 );
    }
    cache_frame_6bd1f91ac15dd8324cd978b80269b375 = NULL;

    assertFrameObject( frame_6bd1f91ac15dd8324cd978b80269b375 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_37_close );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_37_close );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_38__create_async_exit_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_cm = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_cm_exit = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var__exit_wrapper = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = MAKE_FUNCTION_contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] = par_cm;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] = par_cm_exit;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] );


        assert( var__exit_wrapper == NULL );
        var__exit_wrapper = tmp_assign_source_1;
    }
    // Tried code:
    CHECK_OBJECT( var__exit_wrapper );
    tmp_return_value = var__exit_wrapper;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_38__create_async_exit_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cm );
    Py_DECREF( par_cm );
    par_cm = NULL;

    CHECK_OBJECT( (PyObject *)par_cm_exit );
    Py_DECREF( par_cm_exit );
    par_cm_exit = NULL;

    CHECK_OBJECT( (PyObject *)var__exit_wrapper );
    Py_DECREF( var__exit_wrapper );
    var__exit_wrapper = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_38__create_async_exit_wrapper );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_exc_type = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_exc = PyCell_NEW1( python_pars[ 1 ] );
    struct Nuitka_CellObject *par_tb = PyCell_NEW1( python_pars[ 2 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_maker();

    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] = self->m_closure[0];
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] );
    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[1] = self->m_closure[1];
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[1] );
    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[2] = par_exc;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[2] );
    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[3] = par_exc_type;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[3] );
    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[4] = par_tb;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[4] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc );
    Py_DECREF( par_exc );
    par_exc = NULL;

    CHECK_OBJECT( (PyObject *)par_tb );
    Py_DECREF( par_tb );
    par_tb = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc );
    Py_DECREF( par_exc );
    par_exc = NULL;

    CHECK_OBJECT( (PyObject *)par_tb );
    Py_DECREF( par_tb );
    par_tb = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_locals {
    char const *type_description_1;
    PyObject *tmp_return_value;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
};

static PyObject *contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_context( struct Nuitka_CoroutineObject *coroutine, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)coroutine );
    assert( Nuitka_Coroutine_Check( (PyObject *)coroutine ) );

    // Heap access if used.
    struct contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_locals *coroutine_heap = (struct contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_locals *)coroutine->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(coroutine->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    coroutine_heap->type_description_1 = NULL;
    coroutine_heap->tmp_return_value = NULL;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    // Actual coroutine body.
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_c28aa9caf0be431315f136ca024fd8ff, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    coroutine->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( coroutine->m_frame );
    assert( Py_REFCNT( coroutine->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    coroutine->m_frame->m_frame.f_gen = (PyObject *)coroutine;
#endif

    Py_CLEAR( coroutine->m_frame->m_frame.f_back );

    coroutine->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( coroutine->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &coroutine->m_frame->m_frame;
    Py_INCREF( coroutine->m_frame );

    Nuitka_Frame_MarkAsExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        coroutine->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( coroutine->m_frame->m_frame.f_exc_type == Py_None ) coroutine->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_type );
    coroutine->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_value );
    coroutine->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_traceback );
#else
        coroutine->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( coroutine->m_exc_state.exc_type == Py_None ) coroutine->m_exc_state.exc_type = NULL;
        Py_XINCREF( coroutine->m_exc_state.exc_type );
        coroutine->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_value );
        coroutine->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        coroutine->m_frame->m_frame.f_lineno = 539;
        if ( PyCell_GET( coroutine->m_closure[1] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "cm_exit" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 539;
            coroutine_heap->type_description_1 = "ccccc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = PyCell_GET( coroutine->m_closure[1] );
        if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "cm" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 539;
            coroutine_heap->type_description_1 = "ccccc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET( coroutine->m_closure[0] );
        if ( PyCell_GET( coroutine->m_closure[3] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "exc_type" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 539;
            coroutine_heap->type_description_1 = "ccccc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_2 = PyCell_GET( coroutine->m_closure[3] );
        if ( PyCell_GET( coroutine->m_closure[2] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "exc" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 539;
            coroutine_heap->type_description_1 = "ccccc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_3 = PyCell_GET( coroutine->m_closure[2] );
        if ( PyCell_GET( coroutine->m_closure[4] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "tb" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 539;
            coroutine_heap->type_description_1 = "ccccc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_4 = PyCell_GET( coroutine->m_closure[4] );
        coroutine->m_frame->m_frame.f_lineno = 539;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_expression_name_2 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_1, call_args );
        }

        if ( tmp_expression_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 539;
            coroutine_heap->type_description_1 = "ccccc";
            goto frame_exception_exit_1;
        }
        tmp_expression_name_1 = ASYNC_AWAIT( tmp_expression_name_2, await_normal );
        Py_DECREF( tmp_expression_name_2 );
        if ( tmp_expression_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 539;
            coroutine_heap->type_description_1 = "ccccc";
            goto frame_exception_exit_1;
        }
        Nuitka_PreserveHeap( coroutine_heap->yield_tmps, &tmp_expression_name_2, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_args_element_name_2, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), &tmp_args_element_name_4, sizeof(PyObject *), NULL );
        coroutine->m_yield_return_index = 1;
        coroutine->m_yieldfrom = tmp_expression_name_1;
        coroutine->m_awaiting = true;
        return NULL;

        yield_return_1:
        Nuitka_RestoreHeap( coroutine_heap->yield_tmps, &tmp_expression_name_2, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_args_element_name_2, sizeof(PyObject *), &tmp_args_element_name_3, sizeof(PyObject *), &tmp_args_element_name_4, sizeof(PyObject *), NULL );
        coroutine->m_awaiting = false;

        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 539;
            coroutine_heap->type_description_1 = "ccccc";
            goto frame_exception_exit_1;
        }
        coroutine_heap->tmp_return_value = yield_return_value;
        if ( coroutine_heap->tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 539;
            coroutine_heap->type_description_1 = "ccccc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

    Nuitka_Frame_MarkAsNotExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( coroutine->m_frame );
    goto frame_no_exception_1;

    frame_return_exit_1:;

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );
    goto function_return_exit;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( coroutine_heap->exception_type ) )
    {
        if ( coroutine_heap->exception_tb == NULL )
        {
            coroutine_heap->exception_tb = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_lineno );
        }
        else if ( coroutine_heap->exception_tb->tb_frame != &coroutine->m_frame->m_frame )
        {
            coroutine_heap->exception_tb = ADD_TRACEBACK( coroutine_heap->exception_tb, coroutine->m_frame, coroutine_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)coroutine->m_frame,
            coroutine_heap->type_description_1,
            coroutine->m_closure[3],
            coroutine->m_closure[2],
            coroutine->m_closure[4],
            coroutine->m_closure[1],
            coroutine->m_closure[0]
        );


        // Release cached frame.
        if ( coroutine->m_frame == cache_m_frame )
        {
            Py_DECREF( coroutine->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( coroutine->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must be present.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper );

    function_exception_exit:
    assert( coroutine_heap->exception_type );
    RESTORE_ERROR_OCCURRED( coroutine_heap->exception_type, coroutine_heap->exception_value, coroutine_heap->exception_tb );
    return NULL;
    function_return_exit:;

    coroutine->m_returned = coroutine_heap->tmp_return_value;

    return NULL;

}

static PyObject *contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_maker( void )
{
    return Nuitka_Coroutine_New(
        contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_context,
        module_contextlib,
        const_str_plain__exit_wrapper,
        const_str_digest_9b9905bf1735b3c8d0d69a874343ee1c,
        codeobj_c28aa9caf0be431315f136ca024fd8ff,
        5,
        sizeof(struct contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_locals)
    );
}


static PyObject *impl_contextlib$$$function_39__create_async_cb_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_args = PyCell_NEW1( python_pars[ 1 ] );
    struct Nuitka_CellObject *par_kwds = PyCell_NEW1( python_pars[ 2 ] );
    PyObject *var__exit_wrapper = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = MAKE_FUNCTION_contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] = par_args;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] = par_callback;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] );
        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[2] = par_kwds;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[2] );


        assert( var__exit_wrapper == NULL );
        var__exit_wrapper = tmp_assign_source_1;
    }
    // Tried code:
    CHECK_OBJECT( var__exit_wrapper );
    tmp_return_value = var__exit_wrapper;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_39__create_async_cb_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    CHECK_OBJECT( (PyObject *)var__exit_wrapper );
    Py_DECREF( var__exit_wrapper );
    var__exit_wrapper = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_39__create_async_cb_wrapper );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_exc_type = python_pars[ 0 ];
    PyObject *par_exc = python_pars[ 1 ];
    PyObject *par_tb = python_pars[ 2 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_maker();

    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] = self->m_closure[0];
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] );
    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[1] = self->m_closure[1];
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[1] );
    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[2] = self->m_closure[2];
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[2] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc );
    Py_DECREF( par_exc );
    par_exc = NULL;

    CHECK_OBJECT( (PyObject *)par_tb );
    Py_DECREF( par_tb );
    par_tb = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc );
    Py_DECREF( par_exc );
    par_exc = NULL;

    CHECK_OBJECT( (PyObject *)par_tb );
    Py_DECREF( par_tb );
    par_tb = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_locals {
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *tmp_return_value;
};

static PyObject *contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_context( struct Nuitka_CoroutineObject *coroutine, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)coroutine );
    assert( Nuitka_Coroutine_Check( (PyObject *)coroutine ) );

    // Heap access if used.
    struct contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_locals *coroutine_heap = (struct contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_locals *)coroutine->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(coroutine->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    coroutine_heap->type_description_1 = NULL;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;
    coroutine_heap->tmp_return_value = NULL;

    // Actual coroutine body.
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_79334a1036d8c97f06c39c18817bf2f2, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    coroutine->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( coroutine->m_frame );
    assert( Py_REFCNT( coroutine->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    coroutine->m_frame->m_frame.f_gen = (PyObject *)coroutine;
#endif

    Py_CLEAR( coroutine->m_frame->m_frame.f_back );

    coroutine->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( coroutine->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &coroutine->m_frame->m_frame;
    Py_INCREF( coroutine->m_frame );

    Nuitka_Frame_MarkAsExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        coroutine->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( coroutine->m_frame->m_frame.f_exc_type == Py_None ) coroutine->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_type );
    coroutine->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_value );
    coroutine->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_traceback );
#else
        coroutine->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( coroutine->m_exc_state.exc_type == Py_None ) coroutine->m_exc_state.exc_type = NULL;
        Py_XINCREF( coroutine->m_exc_state.exc_type );
        coroutine->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_value );
        coroutine->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_dircall_arg3_1;
        PyObject *tmp_await_result_1;
        coroutine->m_frame->m_frame.f_lineno = 545;
        if ( PyCell_GET( coroutine->m_closure[1] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 545;
            coroutine_heap->type_description_1 = "NNNccc";
            goto frame_exception_exit_1;
        }

        tmp_dircall_arg1_1 = PyCell_GET( coroutine->m_closure[1] );
        if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "args" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 545;
            coroutine_heap->type_description_1 = "NNNccc";
            goto frame_exception_exit_1;
        }

        tmp_dircall_arg2_1 = PyCell_GET( coroutine->m_closure[0] );
        if ( PyCell_GET( coroutine->m_closure[2] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "kwds" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 545;
            coroutine_heap->type_description_1 = "NNNccc";
            goto frame_exception_exit_1;
        }

        tmp_dircall_arg3_1 = PyCell_GET( coroutine->m_closure[2] );
        Py_INCREF( tmp_dircall_arg1_1 );
        Py_INCREF( tmp_dircall_arg2_1 );
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_expression_name_2 = impl___internal__$$$function_5_complex_call_helper_star_list_star_dict( dir_call_args );
        }
        if ( tmp_expression_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 545;
            coroutine_heap->type_description_1 = "NNNccc";
            goto frame_exception_exit_1;
        }
        tmp_expression_name_1 = ASYNC_AWAIT( tmp_expression_name_2, await_normal );
        Py_DECREF( tmp_expression_name_2 );
        if ( tmp_expression_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 545;
            coroutine_heap->type_description_1 = "NNNccc";
            goto frame_exception_exit_1;
        }
        Nuitka_PreserveHeap( coroutine_heap->yield_tmps, &tmp_expression_name_2, sizeof(PyObject *), &tmp_dircall_arg1_1, sizeof(PyObject *), &tmp_dircall_arg2_1, sizeof(PyObject *), &tmp_dircall_arg3_1, sizeof(PyObject *), NULL );
        coroutine->m_yield_return_index = 1;
        coroutine->m_yieldfrom = tmp_expression_name_1;
        coroutine->m_awaiting = true;
        return NULL;

        yield_return_1:
        Nuitka_RestoreHeap( coroutine_heap->yield_tmps, &tmp_expression_name_2, sizeof(PyObject *), &tmp_dircall_arg1_1, sizeof(PyObject *), &tmp_dircall_arg2_1, sizeof(PyObject *), &tmp_dircall_arg3_1, sizeof(PyObject *), NULL );
        coroutine->m_awaiting = false;

        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 545;
            coroutine_heap->type_description_1 = "NNNccc";
            goto frame_exception_exit_1;
        }
        tmp_await_result_1 = yield_return_value;
        if ( tmp_await_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 545;
            coroutine_heap->type_description_1 = "NNNccc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_await_result_1 );
    }

    Nuitka_Frame_MarkAsNotExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( coroutine->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( coroutine_heap->exception_type ) )
    {
        if ( coroutine_heap->exception_tb == NULL )
        {
            coroutine_heap->exception_tb = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_lineno );
        }
        else if ( coroutine_heap->exception_tb->tb_frame != &coroutine->m_frame->m_frame )
        {
            coroutine_heap->exception_tb = ADD_TRACEBACK( coroutine_heap->exception_tb, coroutine->m_frame, coroutine_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)coroutine->m_frame,
            coroutine_heap->type_description_1,
            NULL,
            NULL,
            NULL,
            coroutine->m_closure[1],
            coroutine->m_closure[0],
            coroutine->m_closure[2]
        );


        // Release cached frame.
        if ( coroutine->m_frame == cache_m_frame )
        {
            Py_DECREF( coroutine->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( coroutine->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    coroutine_heap->tmp_return_value = Py_None;
    Py_INCREF( coroutine_heap->tmp_return_value );
    goto function_return_exit;

    // Return statement must be present.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper );

    function_exception_exit:
    assert( coroutine_heap->exception_type );
    RESTORE_ERROR_OCCURRED( coroutine_heap->exception_type, coroutine_heap->exception_value, coroutine_heap->exception_tb );
    return NULL;
    function_return_exit:;

    coroutine->m_returned = coroutine_heap->tmp_return_value;

    return NULL;

}

static PyObject *contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_maker( void )
{
    return Nuitka_Coroutine_New(
        contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_context,
        module_contextlib,
        const_str_plain__exit_wrapper,
        const_str_digest_e363b48ed66180ea29569815ae2c814f,
        codeobj_79334a1036d8c97f06c39c18817bf2f2,
        3,
        sizeof(struct contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper$$$coroutine_1__exit_wrapper_locals)
    );
}


static PyObject *impl_contextlib$$$function_40_enter_async_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_cm = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = contextlib$$$function_40_enter_async_context$$$coroutine_1_enter_async_context_maker();

    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] = par_cm;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] );
    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[1] = par_self;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[1] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_40_enter_async_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cm );
    Py_DECREF( par_cm );
    par_cm = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cm );
    Py_DECREF( par_cm );
    par_cm = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_40_enter_async_context );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct contextlib$$$function_40_enter_async_context$$$coroutine_1_enter_async_context_locals {
    PyObject *var__cm_type;
    PyObject *var__exit;
    PyObject *var_result;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *tmp_return_value;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
};

static PyObject *contextlib$$$function_40_enter_async_context$$$coroutine_1_enter_async_context_context( struct Nuitka_CoroutineObject *coroutine, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)coroutine );
    assert( Nuitka_Coroutine_Check( (PyObject *)coroutine ) );

    // Heap access if used.
    struct contextlib$$$function_40_enter_async_context$$$coroutine_1_enter_async_context_locals *coroutine_heap = (struct contextlib$$$function_40_enter_async_context$$$coroutine_1_enter_async_context_locals *)coroutine->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(coroutine->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    coroutine_heap->var__cm_type = NULL;
    coroutine_heap->var__exit = NULL;
    coroutine_heap->var_result = NULL;
    coroutine_heap->type_description_1 = NULL;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;
    coroutine_heap->tmp_return_value = NULL;

    // Actual coroutine body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_b5aa3e2dedb8972036672150e4e23f41, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    coroutine->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( coroutine->m_frame );
    assert( Py_REFCNT( coroutine->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    coroutine->m_frame->m_frame.f_gen = (PyObject *)coroutine;
#endif

    Py_CLEAR( coroutine->m_frame->m_frame.f_back );

    coroutine->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( coroutine->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &coroutine->m_frame->m_frame;
    Py_INCREF( coroutine->m_frame );

    Nuitka_Frame_MarkAsExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        coroutine->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( coroutine->m_frame->m_frame.f_exc_type == Py_None ) coroutine->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_type );
    coroutine->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_value );
    coroutine->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_traceback );
#else
        coroutine->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( coroutine->m_exc_state.exc_type == Py_None ) coroutine->m_exc_state.exc_type = NULL;
        Py_XINCREF( coroutine->m_exc_state.exc_type );
        coroutine->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_value );
        coroutine->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_type_arg_1;
        if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "cm" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 554;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }

        tmp_type_arg_1 = PyCell_GET( coroutine->m_closure[0] );
        tmp_assign_source_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 554;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }
        assert( coroutine_heap->var__cm_type == NULL );
        coroutine_heap->var__cm_type = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( coroutine_heap->var__cm_type );
        tmp_source_name_1 = coroutine_heap->var__cm_type;
        tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___aexit__ );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 555;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }
        assert( coroutine_heap->var__exit == NULL );
        coroutine_heap->var__exit = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_1;
        coroutine->m_frame->m_frame.f_lineno = 556;
        CHECK_OBJECT( coroutine_heap->var__cm_type );
        tmp_source_name_2 = coroutine_heap->var__cm_type;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___aenter__ );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 556;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }
        if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "cm" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 556;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET( coroutine->m_closure[0] );
        coroutine->m_frame->m_frame.f_lineno = 556;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_expression_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_expression_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 556;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }
        tmp_expression_name_1 = ASYNC_AWAIT( tmp_expression_name_2, await_normal );
        Py_DECREF( tmp_expression_name_2 );
        if ( tmp_expression_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 556;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }
        Nuitka_PreserveHeap( coroutine_heap->yield_tmps, &tmp_expression_name_2, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), NULL );
        coroutine->m_yield_return_index = 1;
        coroutine->m_yieldfrom = tmp_expression_name_1;
        coroutine->m_awaiting = true;
        return NULL;

        yield_return_1:
        Nuitka_RestoreHeap( coroutine_heap->yield_tmps, &tmp_expression_name_2, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), NULL );
        coroutine->m_awaiting = false;

        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 556;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = yield_return_value;
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 556;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }
        assert( coroutine_heap->var_result == NULL );
        coroutine_heap->var_result = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        if ( PyCell_GET( coroutine->m_closure[1] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 557;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = PyCell_GET( coroutine->m_closure[1] );
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__push_async_cm_exit );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 557;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }
        if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "cm" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 557;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_2 = PyCell_GET( coroutine->m_closure[0] );
        CHECK_OBJECT( coroutine_heap->var__exit );
        tmp_args_element_name_3 = coroutine_heap->var__exit;
        coroutine->m_frame->m_frame.f_lineno = 557;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 557;
            coroutine_heap->type_description_1 = "ccooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

    Nuitka_Frame_MarkAsNotExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( coroutine->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( coroutine_heap->exception_type ) )
    {
        if ( coroutine_heap->exception_tb == NULL )
        {
            coroutine_heap->exception_tb = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_lineno );
        }
        else if ( coroutine_heap->exception_tb->tb_frame != &coroutine->m_frame->m_frame )
        {
            coroutine_heap->exception_tb = ADD_TRACEBACK( coroutine_heap->exception_tb, coroutine->m_frame, coroutine_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)coroutine->m_frame,
            coroutine_heap->type_description_1,
            coroutine->m_closure[1],
            coroutine->m_closure[0],
            coroutine_heap->var__cm_type,
            coroutine_heap->var__exit,
            coroutine_heap->var_result
        );


        // Release cached frame.
        if ( coroutine->m_frame == cache_m_frame )
        {
            Py_DECREF( coroutine->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( coroutine->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( coroutine_heap->var_result );
    coroutine_heap->tmp_return_value = coroutine_heap->var_result;
    Py_INCREF( coroutine_heap->tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_40_enter_async_context$$$coroutine_1_enter_async_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)coroutine_heap->var__cm_type );
    Py_DECREF( coroutine_heap->var__cm_type );
    coroutine_heap->var__cm_type = NULL;

    CHECK_OBJECT( (PyObject *)coroutine_heap->var__exit );
    Py_DECREF( coroutine_heap->var__exit );
    coroutine_heap->var__exit = NULL;

    CHECK_OBJECT( (PyObject *)coroutine_heap->var_result );
    Py_DECREF( coroutine_heap->var_result );
    coroutine_heap->var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    coroutine_heap->exception_keeper_type_1 = coroutine_heap->exception_type;
    coroutine_heap->exception_keeper_value_1 = coroutine_heap->exception_value;
    coroutine_heap->exception_keeper_tb_1 = coroutine_heap->exception_tb;
    coroutine_heap->exception_keeper_lineno_1 = coroutine_heap->exception_lineno;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    Py_XDECREF( coroutine_heap->var__cm_type );
    coroutine_heap->var__cm_type = NULL;

    Py_XDECREF( coroutine_heap->var__exit );
    coroutine_heap->var__exit = NULL;

    Py_XDECREF( coroutine_heap->var_result );
    coroutine_heap->var_result = NULL;

    // Re-raise.
    coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_1;
    coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_1;
    coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_1;
    coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must be present.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_40_enter_async_context$$$coroutine_1_enter_async_context );

    function_exception_exit:
    assert( coroutine_heap->exception_type );
    RESTORE_ERROR_OCCURRED( coroutine_heap->exception_type, coroutine_heap->exception_value, coroutine_heap->exception_tb );
    return NULL;
    function_return_exit:;

    coroutine->m_returned = coroutine_heap->tmp_return_value;

    return NULL;

}

static PyObject *contextlib$$$function_40_enter_async_context$$$coroutine_1_enter_async_context_maker( void )
{
    return Nuitka_Coroutine_New(
        contextlib$$$function_40_enter_async_context$$$coroutine_1_enter_async_context_context,
        module_contextlib,
        const_str_plain_enter_async_context,
        const_str_digest_b7bfa96e1930f41166a4f32612e692f6,
        codeobj_b5aa3e2dedb8972036672150e4e23f41,
        2,
        sizeof(struct contextlib$$$function_40_enter_async_context$$$coroutine_1_enter_async_context_locals)
    );
}


static PyObject *impl_contextlib$$$function_41_push_async_exit( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exit = python_pars[ 1 ];
    PyObject *var__cb_type = NULL;
    PyObject *var_exit_method = NULL;
    nuitka_bool tmp_try_except_1__unhandled_indicator = NUITKA_BOOL_UNASSIGNED;
    struct Nuitka_FrameObject *frame_2ceeed769613aea7ec41a0a0032b3f6d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    static struct Nuitka_FrameObject *cache_frame_2ceeed769613aea7ec41a0a0032b3f6d = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_type_arg_1;
        CHECK_OBJECT( par_exit );
        tmp_type_arg_1 = par_exit;
        tmp_assign_source_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
        assert( !(tmp_assign_source_1 == NULL) );
        assert( var__cb_type == NULL );
        var__cb_type = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_assign_source_2;
        tmp_assign_source_2 = NUITKA_BOOL_TRUE;
        tmp_try_except_1__unhandled_indicator = tmp_assign_source_2;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2ceeed769613aea7ec41a0a0032b3f6d, codeobj_2ceeed769613aea7ec41a0a0032b3f6d, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_2ceeed769613aea7ec41a0a0032b3f6d = cache_frame_2ceeed769613aea7ec41a0a0032b3f6d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2ceeed769613aea7ec41a0a0032b3f6d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2ceeed769613aea7ec41a0a0032b3f6d ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    // Tried code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( var__cb_type );
        tmp_source_name_1 = var__cb_type;
        tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___aexit__ );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 570;
            type_description_1 = "oooo";
            goto try_except_handler_3;
        }
        assert( var_exit_method == NULL );
        var_exit_method = tmp_assign_source_3;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        nuitka_bool tmp_assign_source_4;
        tmp_assign_source_4 = NUITKA_BOOL_FALSE;
        tmp_try_except_1__unhandled_indicator = tmp_assign_source_4;
    }
    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_type_1 );
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( exception_preserved_value_1 );
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( exception_preserved_tb_1 );

    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_2ceeed769613aea7ec41a0a0032b3f6d, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_2ceeed769613aea7ec41a0a0032b3f6d, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PyException_SetTraceback( exception_keeper_value_1, (PyObject *)exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_AttributeError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 571;
            type_description_1 = "oooo";
            goto try_except_handler_4;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( par_exit );
            tmp_args_element_name_1 = par_exit;
            tmp_args_element_name_2 = Py_False;
            frame_2ceeed769613aea7ec41a0a0032b3f6d->m_frame.f_lineno = 573;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain__push_exit_callback, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 573;
                type_description_1 = "oooo";
                goto try_except_handler_4;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 569;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_2ceeed769613aea7ec41a0a0032b3f6d->m_frame) frame_2ceeed769613aea7ec41a0a0032b3f6d->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooo";
        goto try_except_handler_4;
        branch_end_1:;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1 );
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_41_push_async_exit );
    return NULL;
    // End of try:
    try_end_1:;
    {
        nuitka_bool tmp_condition_result_2;
        nuitka_bool tmp_compexpr_left_2;
        nuitka_bool tmp_compexpr_right_2;
        assert( tmp_try_except_1__unhandled_indicator != NUITKA_BOOL_UNASSIGNED);
        tmp_compexpr_left_2 = tmp_try_except_1__unhandled_indicator;
        tmp_compexpr_right_2 = NUITKA_BOOL_TRUE;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__push_async_cm_exit );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 575;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( par_exit );
            tmp_args_element_name_3 = par_exit;
            if ( var_exit_method == NULL )
            {
                Py_DECREF( tmp_called_name_1 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "exit_method" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 575;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }

            tmp_args_element_name_4 = var_exit_method;
            frame_2ceeed769613aea7ec41a0a0032b3f6d->m_frame.f_lineno = 575;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 575;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_2:;
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2ceeed769613aea7ec41a0a0032b3f6d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2ceeed769613aea7ec41a0a0032b3f6d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2ceeed769613aea7ec41a0a0032b3f6d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2ceeed769613aea7ec41a0a0032b3f6d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2ceeed769613aea7ec41a0a0032b3f6d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2ceeed769613aea7ec41a0a0032b3f6d,
        type_description_1,
        par_self,
        par_exit,
        var__cb_type,
        var_exit_method
    );


    // Release cached frame.
    if ( frame_2ceeed769613aea7ec41a0a0032b3f6d == cache_frame_2ceeed769613aea7ec41a0a0032b3f6d )
    {
        Py_DECREF( frame_2ceeed769613aea7ec41a0a0032b3f6d );
    }
    cache_frame_2ceeed769613aea7ec41a0a0032b3f6d = NULL;

    assertFrameObject( frame_2ceeed769613aea7ec41a0a0032b3f6d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( par_exit );
    tmp_return_value = par_exit;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_41_push_async_exit );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exit );
    Py_DECREF( par_exit );
    par_exit = NULL;

    CHECK_OBJECT( (PyObject *)var__cb_type );
    Py_DECREF( var__cb_type );
    var__cb_type = NULL;

    Py_XDECREF( var_exit_method );
    var_exit_method = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exit );
    Py_DECREF( par_exit );
    par_exit = NULL;

    CHECK_OBJECT( (PyObject *)var__cb_type );
    Py_DECREF( var__cb_type );
    var__cb_type = NULL;

    Py_XDECREF( var_exit_method );
    var_exit_method = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_41_push_async_exit );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_42_push_async_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    PyObject *par_args = python_pars[ 2 ];
    PyObject *par_kwds = python_pars[ 3 ];
    PyObject *var__exit_wrapper = NULL;
    struct Nuitka_FrameObject *frame_45e2cf9544c4a969db74b67d603ee00d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_45e2cf9544c4a969db74b67d603ee00d = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_45e2cf9544c4a969db74b67d603ee00d, codeobj_45e2cf9544c4a969db74b67d603ee00d, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_45e2cf9544c4a969db74b67d603ee00d = cache_frame_45e2cf9544c4a969db74b67d603ee00d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_45e2cf9544c4a969db74b67d603ee00d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_45e2cf9544c4a969db74b67d603ee00d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        PyObject *tmp_dircall_arg4_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__create_async_cb_wrapper );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 583;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_callback );
        tmp_tuple_element_1 = par_callback;
        tmp_dircall_arg2_1 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_args );
        tmp_dircall_arg3_1 = par_args;
        CHECK_OBJECT( par_kwds );
        tmp_dircall_arg4_1 = par_kwds;
        Py_INCREF( tmp_dircall_arg3_1 );
        Py_INCREF( tmp_dircall_arg4_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
            tmp_assign_source_1 = impl___internal__$$$function_8_complex_call_helper_pos_star_list_star_dict( dir_call_args );
        }
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 583;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var__exit_wrapper == NULL );
        var__exit_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_callback );
        tmp_assattr_name_1 = par_callback;
        CHECK_OBJECT( var__exit_wrapper );
        tmp_assattr_target_1 = var__exit_wrapper;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain___wrapped__, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 587;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( var__exit_wrapper );
        tmp_args_element_name_1 = var__exit_wrapper;
        tmp_args_element_name_2 = Py_False;
        frame_45e2cf9544c4a969db74b67d603ee00d->m_frame.f_lineno = 588;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain__push_exit_callback, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 588;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_45e2cf9544c4a969db74b67d603ee00d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_45e2cf9544c4a969db74b67d603ee00d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_45e2cf9544c4a969db74b67d603ee00d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_45e2cf9544c4a969db74b67d603ee00d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_45e2cf9544c4a969db74b67d603ee00d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_45e2cf9544c4a969db74b67d603ee00d,
        type_description_1,
        par_self,
        par_callback,
        par_args,
        par_kwds,
        var__exit_wrapper
    );


    // Release cached frame.
    if ( frame_45e2cf9544c4a969db74b67d603ee00d == cache_frame_45e2cf9544c4a969db74b67d603ee00d )
    {
        Py_DECREF( frame_45e2cf9544c4a969db74b67d603ee00d );
    }
    cache_frame_45e2cf9544c4a969db74b67d603ee00d = NULL;

    assertFrameObject( frame_45e2cf9544c4a969db74b67d603ee00d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( par_callback );
    tmp_return_value = par_callback;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_42_push_async_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    CHECK_OBJECT( (PyObject *)var__exit_wrapper );
    Py_DECREF( var__exit_wrapper );
    var__exit_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwds );
    Py_DECREF( par_kwds );
    par_kwds = NULL;

    Py_XDECREF( var__exit_wrapper );
    var__exit_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_42_push_async_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_43_aclose( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = contextlib$$$function_43_aclose$$$coroutine_1_aclose_maker();

    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_43_aclose );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_43_aclose );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct contextlib$$$function_43_aclose$$$coroutine_1_aclose_locals {
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *tmp_return_value;
};

static PyObject *contextlib$$$function_43_aclose$$$coroutine_1_aclose_context( struct Nuitka_CoroutineObject *coroutine, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)coroutine );
    assert( Nuitka_Coroutine_Check( (PyObject *)coroutine ) );

    // Heap access if used.
    struct contextlib$$$function_43_aclose$$$coroutine_1_aclose_locals *coroutine_heap = (struct contextlib$$$function_43_aclose$$$coroutine_1_aclose_locals *)coroutine->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(coroutine->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    coroutine_heap->type_description_1 = NULL;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;
    coroutine_heap->tmp_return_value = NULL;

    // Actual coroutine body.
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_86d241f5735172421d3744f63bc43116, module_contextlib, sizeof(void *) );
    coroutine->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( coroutine->m_frame );
    assert( Py_REFCNT( coroutine->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    coroutine->m_frame->m_frame.f_gen = (PyObject *)coroutine;
#endif

    Py_CLEAR( coroutine->m_frame->m_frame.f_back );

    coroutine->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( coroutine->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &coroutine->m_frame->m_frame;
    Py_INCREF( coroutine->m_frame );

    Nuitka_Frame_MarkAsExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        coroutine->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( coroutine->m_frame->m_frame.f_exc_type == Py_None ) coroutine->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_type );
    coroutine->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_value );
    coroutine->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_traceback );
#else
        coroutine->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( coroutine->m_exc_state.exc_type == Py_None ) coroutine->m_exc_state.exc_type = NULL;
        Py_XINCREF( coroutine->m_exc_state.exc_type );
        coroutine->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_value );
        coroutine->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_await_result_1;
        coroutine->m_frame->m_frame.f_lineno = 593;
        if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 593;
            coroutine_heap->type_description_1 = "c";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = PyCell_GET( coroutine->m_closure[0] );
        coroutine->m_frame->m_frame.f_lineno = 593;
        tmp_expression_name_2 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain___aexit__, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

        if ( tmp_expression_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 593;
            coroutine_heap->type_description_1 = "c";
            goto frame_exception_exit_1;
        }
        tmp_expression_name_1 = ASYNC_AWAIT( tmp_expression_name_2, await_normal );
        Py_DECREF( tmp_expression_name_2 );
        if ( tmp_expression_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 593;
            coroutine_heap->type_description_1 = "c";
            goto frame_exception_exit_1;
        }
        Nuitka_PreserveHeap( coroutine_heap->yield_tmps, &tmp_expression_name_2, sizeof(PyObject *), &tmp_called_instance_1, sizeof(PyObject *), NULL );
        coroutine->m_yield_return_index = 1;
        coroutine->m_yieldfrom = tmp_expression_name_1;
        coroutine->m_awaiting = true;
        return NULL;

        yield_return_1:
        Nuitka_RestoreHeap( coroutine_heap->yield_tmps, &tmp_expression_name_2, sizeof(PyObject *), &tmp_called_instance_1, sizeof(PyObject *), NULL );
        coroutine->m_awaiting = false;

        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 593;
            coroutine_heap->type_description_1 = "c";
            goto frame_exception_exit_1;
        }
        tmp_await_result_1 = yield_return_value;
        if ( tmp_await_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 593;
            coroutine_heap->type_description_1 = "c";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_await_result_1 );
    }

    Nuitka_Frame_MarkAsNotExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( coroutine->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( coroutine_heap->exception_type ) )
    {
        if ( coroutine_heap->exception_tb == NULL )
        {
            coroutine_heap->exception_tb = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_lineno );
        }
        else if ( coroutine_heap->exception_tb->tb_frame != &coroutine->m_frame->m_frame )
        {
            coroutine_heap->exception_tb = ADD_TRACEBACK( coroutine_heap->exception_tb, coroutine->m_frame, coroutine_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)coroutine->m_frame,
            coroutine_heap->type_description_1,
            coroutine->m_closure[0]
        );


        // Release cached frame.
        if ( coroutine->m_frame == cache_m_frame )
        {
            Py_DECREF( coroutine->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( coroutine->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    coroutine_heap->tmp_return_value = Py_None;
    Py_INCREF( coroutine_heap->tmp_return_value );
    goto function_return_exit;

    // Return statement must be present.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_43_aclose$$$coroutine_1_aclose );

    function_exception_exit:
    assert( coroutine_heap->exception_type );
    RESTORE_ERROR_OCCURRED( coroutine_heap->exception_type, coroutine_heap->exception_value, coroutine_heap->exception_tb );
    return NULL;
    function_return_exit:;

    coroutine->m_returned = coroutine_heap->tmp_return_value;

    return NULL;

}

static PyObject *contextlib$$$function_43_aclose$$$coroutine_1_aclose_maker( void )
{
    return Nuitka_Coroutine_New(
        contextlib$$$function_43_aclose$$$coroutine_1_aclose_context,
        module_contextlib,
        const_str_plain_aclose,
        const_str_digest_ab10239cbb13ff94c3252ede7d4d1fce,
        codeobj_86d241f5735172421d3744f63bc43116,
        1,
        sizeof(struct contextlib$$$function_43_aclose$$$coroutine_1_aclose_locals)
    );
}


static PyObject *impl_contextlib$$$function_44__push_async_cm_exit( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cm = python_pars[ 1 ];
    PyObject *par_cm_exit = python_pars[ 2 ];
    PyObject *var__exit_wrapper = NULL;
    struct Nuitka_FrameObject *frame_b7274d5d850f21d60dd43edeab664be5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b7274d5d850f21d60dd43edeab664be5 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b7274d5d850f21d60dd43edeab664be5, codeobj_b7274d5d850f21d60dd43edeab664be5, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b7274d5d850f21d60dd43edeab664be5 = cache_frame_b7274d5d850f21d60dd43edeab664be5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b7274d5d850f21d60dd43edeab664be5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b7274d5d850f21d60dd43edeab664be5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_cm );
        tmp_args_element_name_1 = par_cm;
        CHECK_OBJECT( par_cm_exit );
        tmp_args_element_name_2 = par_cm_exit;
        frame_b7274d5d850f21d60dd43edeab664be5->m_frame.f_lineno = 598;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain__create_async_exit_wrapper, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 598;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var__exit_wrapper == NULL );
        var__exit_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_cm );
        tmp_assattr_name_1 = par_cm;
        CHECK_OBJECT( var__exit_wrapper );
        tmp_assattr_target_1 = var__exit_wrapper;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain___self__, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 599;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        CHECK_OBJECT( var__exit_wrapper );
        tmp_args_element_name_3 = var__exit_wrapper;
        tmp_args_element_name_4 = Py_False;
        frame_b7274d5d850f21d60dd43edeab664be5->m_frame.f_lineno = 600;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain__push_exit_callback, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 600;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b7274d5d850f21d60dd43edeab664be5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b7274d5d850f21d60dd43edeab664be5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b7274d5d850f21d60dd43edeab664be5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b7274d5d850f21d60dd43edeab664be5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b7274d5d850f21d60dd43edeab664be5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b7274d5d850f21d60dd43edeab664be5,
        type_description_1,
        par_self,
        par_cm,
        par_cm_exit,
        var__exit_wrapper
    );


    // Release cached frame.
    if ( frame_b7274d5d850f21d60dd43edeab664be5 == cache_frame_b7274d5d850f21d60dd43edeab664be5 )
    {
        Py_DECREF( frame_b7274d5d850f21d60dd43edeab664be5 );
    }
    cache_frame_b7274d5d850f21d60dd43edeab664be5 = NULL;

    assertFrameObject( frame_b7274d5d850f21d60dd43edeab664be5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_44__push_async_cm_exit );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cm );
    Py_DECREF( par_cm );
    par_cm = NULL;

    CHECK_OBJECT( (PyObject *)par_cm_exit );
    Py_DECREF( par_cm_exit );
    par_cm_exit = NULL;

    CHECK_OBJECT( (PyObject *)var__exit_wrapper );
    Py_DECREF( var__exit_wrapper );
    var__exit_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cm );
    Py_DECREF( par_cm );
    par_cm = NULL;

    CHECK_OBJECT( (PyObject *)par_cm_exit );
    Py_DECREF( par_cm_exit );
    par_cm_exit = NULL;

    Py_XDECREF( var__exit_wrapper );
    var__exit_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_44__push_async_cm_exit );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_45___aenter__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = contextlib$$$function_45___aenter__$$$coroutine_1___aenter___maker();

    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_45___aenter__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_45___aenter__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct contextlib$$$function_45___aenter__$$$coroutine_1___aenter___locals {
    char const *type_description_1;
    PyObject *tmp_return_value;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
};

static PyObject *contextlib$$$function_45___aenter__$$$coroutine_1___aenter___context( struct Nuitka_CoroutineObject *coroutine, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)coroutine );
    assert( Nuitka_Coroutine_Check( (PyObject *)coroutine ) );

    // Heap access if used.
    struct contextlib$$$function_45___aenter__$$$coroutine_1___aenter___locals *coroutine_heap = (struct contextlib$$$function_45___aenter__$$$coroutine_1___aenter___locals *)coroutine->m_heap_storage;

    // Dispatch to yield based on return label index:


    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    coroutine_heap->type_description_1 = NULL;
    coroutine_heap->tmp_return_value = NULL;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    // Actual coroutine body.
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_775fcfc9e192e06247503a9be4ac57a1, module_contextlib, sizeof(void *) );
    coroutine->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( coroutine->m_frame );
    assert( Py_REFCNT( coroutine->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    coroutine->m_frame->m_frame.f_gen = (PyObject *)coroutine;
#endif

    Py_CLEAR( coroutine->m_frame->m_frame.f_back );

    coroutine->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( coroutine->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &coroutine->m_frame->m_frame;
    Py_INCREF( coroutine->m_frame );

    Nuitka_Frame_MarkAsExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        coroutine->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( coroutine->m_frame->m_frame.f_exc_type == Py_None ) coroutine->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_type );
    coroutine->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_value );
    coroutine->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_traceback );
#else
        coroutine->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( coroutine->m_exc_state.exc_type == Py_None ) coroutine->m_exc_state.exc_type = NULL;
        Py_XINCREF( coroutine->m_exc_state.exc_type );
        coroutine->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_value );
        coroutine->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
    {

        coroutine_heap->exception_type = PyExc_NameError;
        Py_INCREF( coroutine_heap->exception_type );
        coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
        coroutine_heap->exception_tb = NULL;
        NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
        CHAIN_EXCEPTION( coroutine_heap->exception_value );

        coroutine_heap->exception_lineno = 603;
        coroutine_heap->type_description_1 = "c";
        goto frame_exception_exit_1;
    }

    coroutine_heap->tmp_return_value = PyCell_GET( coroutine->m_closure[0] );
    Py_INCREF( coroutine_heap->tmp_return_value );
    goto frame_return_exit_1;

    Nuitka_Frame_MarkAsNotExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( coroutine->m_frame );
    goto frame_no_exception_1;

    frame_return_exit_1:;

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );
    goto function_return_exit;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( coroutine_heap->exception_type ) )
    {
        if ( coroutine_heap->exception_tb == NULL )
        {
            coroutine_heap->exception_tb = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_lineno );
        }
        else if ( coroutine_heap->exception_tb->tb_frame != &coroutine->m_frame->m_frame )
        {
            coroutine_heap->exception_tb = ADD_TRACEBACK( coroutine_heap->exception_tb, coroutine->m_frame, coroutine_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)coroutine->m_frame,
            coroutine_heap->type_description_1,
            coroutine->m_closure[0]
        );


        // Release cached frame.
        if ( coroutine->m_frame == cache_m_frame )
        {
            Py_DECREF( coroutine->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( coroutine->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must be present.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_45___aenter__$$$coroutine_1___aenter__ );

    function_exception_exit:
    assert( coroutine_heap->exception_type );
    RESTORE_ERROR_OCCURRED( coroutine_heap->exception_type, coroutine_heap->exception_value, coroutine_heap->exception_tb );
    return NULL;
    function_return_exit:;

    coroutine->m_returned = coroutine_heap->tmp_return_value;

    return NULL;

}

static PyObject *contextlib$$$function_45___aenter__$$$coroutine_1___aenter___maker( void )
{
    return Nuitka_Coroutine_New(
        contextlib$$$function_45___aenter__$$$coroutine_1___aenter___context,
        module_contextlib,
        const_str_plain___aenter__,
        const_str_digest_4cc0ab300f4fe8af2dc122c9eba3d7cc,
        codeobj_775fcfc9e192e06247503a9be4ac57a1,
        1,
        sizeof(struct contextlib$$$function_45___aenter__$$$coroutine_1___aenter___locals)
    );
}


static PyObject *impl_contextlib$$$function_46___aexit__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_exc_details = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = contextlib$$$function_46___aexit__$$$coroutine_1___aexit___maker();

    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] = par_exc_details;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[0] );
    ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[1] = par_self;
    Py_INCREF( ((struct Nuitka_CoroutineObject *)tmp_return_value)->m_closure[1] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_46___aexit__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_details );
    Py_DECREF( par_exc_details );
    par_exc_details = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_details );
    Py_DECREF( par_exc_details );
    par_exc_details = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_46___aexit__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct contextlib$$$function_46___aexit__$$$coroutine_1___aexit___locals {
    nuitka_bool var_received_exc;
    struct Nuitka_CellObject *var_frame_exc;
    PyObject *var__fix_exception_context;
    PyObject *var_suppressed_exc;
    PyObject *var_pending_raise;
    PyObject *var_is_sync;
    PyObject *var_cb;
    PyObject *var_cb_suppress;
    PyObject *var_new_exc_details;
    PyObject *var_fixed_ctx;
    PyObject *tmp_tuple_unpack_1__element_1;
    PyObject *tmp_tuple_unpack_1__element_2;
    PyObject *tmp_tuple_unpack_1__source_iter;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    int exception_keeper_lineno_5;
    PyObject *exception_preserved_type_2;
    PyObject *exception_preserved_value_2;
    PyTracebackObject *exception_preserved_tb_2;
    bool tmp_result;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    int exception_keeper_lineno_6;
    PyObject *tmp_return_value;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    int exception_keeper_lineno_7;
};

static PyObject *contextlib$$$function_46___aexit__$$$coroutine_1___aexit___context( struct Nuitka_CoroutineObject *coroutine, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)coroutine );
    assert( Nuitka_Coroutine_Check( (PyObject *)coroutine ) );

    // Heap access if used.
    struct contextlib$$$function_46___aexit__$$$coroutine_1___aexit___locals *coroutine_heap = (struct contextlib$$$function_46___aexit__$$$coroutine_1___aexit___locals *)coroutine->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(coroutine->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    coroutine_heap->var_received_exc = NUITKA_BOOL_UNASSIGNED;
    coroutine_heap->var_frame_exc = PyCell_EMPTY();
    coroutine_heap->var__fix_exception_context = NULL;
    coroutine_heap->var_suppressed_exc = NULL;
    coroutine_heap->var_pending_raise = NULL;
    coroutine_heap->var_is_sync = NULL;
    coroutine_heap->var_cb = NULL;
    coroutine_heap->var_cb_suppress = NULL;
    coroutine_heap->var_new_exc_details = NULL;
    coroutine_heap->var_fixed_ctx = NULL;
    coroutine_heap->tmp_tuple_unpack_1__element_1 = NULL;
    coroutine_heap->tmp_tuple_unpack_1__element_2 = NULL;
    coroutine_heap->tmp_tuple_unpack_1__source_iter = NULL;
    coroutine_heap->type_description_1 = NULL;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;
    coroutine_heap->tmp_return_value = NULL;

    // Actual coroutine body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_1053119921a56c2bea8a426f0019c955, module_contextlib, sizeof(nuitka_bool)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    coroutine->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( coroutine->m_frame );
    assert( Py_REFCNT( coroutine->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    coroutine->m_frame->m_frame.f_gen = (PyObject *)coroutine;
#endif

    Py_CLEAR( coroutine->m_frame->m_frame.f_back );

    coroutine->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( coroutine->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &coroutine->m_frame->m_frame;
    Py_INCREF( coroutine->m_frame );

    Nuitka_Frame_MarkAsExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        coroutine->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( coroutine->m_frame->m_frame.f_exc_type == Py_None ) coroutine->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_type );
    coroutine->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_value );
    coroutine->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_frame->m_frame.f_exc_traceback );
#else
        coroutine->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( coroutine->m_exc_state.exc_type == Py_None ) coroutine->m_exc_state.exc_type = NULL;
        Py_XINCREF( coroutine->m_exc_state.exc_type );
        coroutine->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_value );
        coroutine->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( coroutine->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        nuitka_bool tmp_assign_source_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "exc_details" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 606;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_1 = PyCell_GET( coroutine->m_closure[0] );
        tmp_subscript_name_1 = const_int_0;
        tmp_compexpr_left_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 606;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_assign_source_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        coroutine_heap->var_received_exc = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_sys );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 610;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        coroutine->m_frame->m_frame.f_lineno = 610;
        tmp_subscribed_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_exc_info );
        if ( tmp_subscribed_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 610;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto frame_exception_exit_1;
        }
        tmp_subscript_name_2 = const_int_pos_1;
        tmp_assign_source_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 1 );
        Py_DECREF( tmp_subscribed_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 610;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto frame_exception_exit_1;
        }
        assert( PyCell_GET( coroutine_heap->var_frame_exc ) == NULL );
        PyCell_SET( coroutine_heap->var_frame_exc, tmp_assign_source_2 );

    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = MAKE_FUNCTION_contextlib$$$function_46___aexit__$$$coroutine_1___aexit__$$$function_1__fix_exception_context(  );

        ((struct Nuitka_FunctionObject *)tmp_assign_source_3)->m_closure[0] = coroutine_heap->var_frame_exc;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_3)->m_closure[0] );


        assert( coroutine_heap->var__fix_exception_context == NULL );
        coroutine_heap->var__fix_exception_context = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        tmp_assign_source_4 = Py_False;
        assert( coroutine_heap->var_suppressed_exc == NULL );
        Py_INCREF( tmp_assign_source_4 );
        coroutine_heap->var_suppressed_exc = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        tmp_assign_source_5 = Py_False;
        assert( coroutine_heap->var_pending_raise == NULL );
        Py_INCREF( tmp_assign_source_5 );
        coroutine_heap->var_pending_raise = tmp_assign_source_5;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_1;
        if ( PyCell_GET( coroutine->m_closure[1] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 629;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( coroutine->m_closure[1] );
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__exit_callbacks );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 629;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto frame_exception_exit_1;
        }
        coroutine_heap->tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( coroutine_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 629;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( coroutine_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_source_name_2;
        if ( PyCell_GET( coroutine->m_closure[1] ) == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 630;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_2 = PyCell_GET( coroutine->m_closure[1] );
        tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__exit_callbacks );
        if ( tmp_called_instance_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 630;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_2;
        }
        coroutine->m_frame->m_frame.f_lineno = 630;
        tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_pop );
        Py_DECREF( tmp_called_instance_2 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 630;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_2;
        }
        tmp_assign_source_6 = MAKE_UNPACK_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 630;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = coroutine_heap->tmp_tuple_unpack_1__source_iter;
            coroutine_heap->tmp_tuple_unpack_1__source_iter = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( coroutine_heap->tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = coroutine_heap->tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_7 = UNPACK_NEXT( tmp_unpack_1, 0, 2 );
        if ( tmp_assign_source_7 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                coroutine_heap->exception_type = PyExc_StopIteration;
                Py_INCREF( coroutine_heap->exception_type );
                coroutine_heap->exception_value = NULL;
                coroutine_heap->exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            }


            coroutine_heap->type_description_1 = "ccbcoooooooo";
            coroutine_heap->exception_lineno = 630;
            goto try_except_handler_3;
        }
        {
            PyObject *old = coroutine_heap->tmp_tuple_unpack_1__element_1;
            coroutine_heap->tmp_tuple_unpack_1__element_1 = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( coroutine_heap->tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = coroutine_heap->tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_8 = UNPACK_NEXT( tmp_unpack_2, 1, 2 );
        if ( tmp_assign_source_8 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                coroutine_heap->exception_type = PyExc_StopIteration;
                Py_INCREF( coroutine_heap->exception_type );
                coroutine_heap->exception_value = NULL;
                coroutine_heap->exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            }


            coroutine_heap->type_description_1 = "ccbcoooooooo";
            coroutine_heap->exception_lineno = 630;
            goto try_except_handler_3;
        }
        {
            PyObject *old = coroutine_heap->tmp_tuple_unpack_1__element_2;
            coroutine_heap->tmp_tuple_unpack_1__element_2 = tmp_assign_source_8;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( coroutine_heap->tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = coroutine_heap->tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        coroutine_heap->tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( coroutine_heap->tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );

                    coroutine_heap->type_description_1 = "ccbcoooooooo";
                    coroutine_heap->exception_lineno = 630;
                    goto try_except_handler_3;
                }
            }
        }
        else
        {
            Py_DECREF( coroutine_heap->tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );

            coroutine_heap->type_description_1 = "ccbcoooooooo";
            coroutine_heap->exception_lineno = 630;
            goto try_except_handler_3;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    coroutine_heap->exception_keeper_type_1 = coroutine_heap->exception_type;
    coroutine_heap->exception_keeper_value_1 = coroutine_heap->exception_value;
    coroutine_heap->exception_keeper_tb_1 = coroutine_heap->exception_tb;
    coroutine_heap->exception_keeper_lineno_1 = coroutine_heap->exception_lineno;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)coroutine_heap->tmp_tuple_unpack_1__source_iter );
    Py_DECREF( coroutine_heap->tmp_tuple_unpack_1__source_iter );
    coroutine_heap->tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_1;
    coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_1;
    coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_1;
    coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    coroutine_heap->exception_keeper_type_2 = coroutine_heap->exception_type;
    coroutine_heap->exception_keeper_value_2 = coroutine_heap->exception_value;
    coroutine_heap->exception_keeper_tb_2 = coroutine_heap->exception_tb;
    coroutine_heap->exception_keeper_lineno_2 = coroutine_heap->exception_lineno;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    Py_XDECREF( coroutine_heap->tmp_tuple_unpack_1__element_1 );
    coroutine_heap->tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( coroutine_heap->tmp_tuple_unpack_1__element_2 );
    coroutine_heap->tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_2;
    coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_2;
    coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_2;
    coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)coroutine_heap->tmp_tuple_unpack_1__source_iter );
    Py_DECREF( coroutine_heap->tmp_tuple_unpack_1__source_iter );
    coroutine_heap->tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_9;
        CHECK_OBJECT( coroutine_heap->tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_9 = coroutine_heap->tmp_tuple_unpack_1__element_1;
        {
            PyObject *old = coroutine_heap->var_is_sync;
            coroutine_heap->var_is_sync = tmp_assign_source_9;
            Py_INCREF( coroutine_heap->var_is_sync );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( coroutine_heap->tmp_tuple_unpack_1__element_1 );
    coroutine_heap->tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_10;
        CHECK_OBJECT( coroutine_heap->tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_10 = coroutine_heap->tmp_tuple_unpack_1__element_2;
        {
            PyObject *old = coroutine_heap->var_cb;
            coroutine_heap->var_cb = tmp_assign_source_10;
            Py_INCREF( coroutine_heap->var_cb );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( coroutine_heap->tmp_tuple_unpack_1__element_2 );
    coroutine_heap->tmp_tuple_unpack_1__element_2 = NULL;

    // Tried code:
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_1;
        CHECK_OBJECT( coroutine_heap->var_is_sync );
        tmp_truth_name_1 = CHECK_IF_TRUE( coroutine_heap->var_is_sync );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 632;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_4;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_11;
            PyObject *tmp_dircall_arg1_1;
            PyObject *tmp_dircall_arg2_1;
            CHECK_OBJECT( coroutine_heap->var_cb );
            tmp_dircall_arg1_1 = coroutine_heap->var_cb;
            if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
            {

                coroutine_heap->exception_type = PyExc_NameError;
                Py_INCREF( coroutine_heap->exception_type );
                coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "exc_details" );
                coroutine_heap->exception_tb = NULL;
                NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                CHAIN_EXCEPTION( coroutine_heap->exception_value );

                coroutine_heap->exception_lineno = 633;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_4;
            }

            tmp_dircall_arg2_1 = PyCell_GET( coroutine->m_closure[0] );
            Py_INCREF( tmp_dircall_arg1_1 );
            Py_INCREF( tmp_dircall_arg2_1 );

            {
                PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1};
                tmp_assign_source_11 = impl___internal__$$$function_2_complex_call_helper_star_list( dir_call_args );
            }
            if ( tmp_assign_source_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 633;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_4;
            }
            {
                PyObject *old = coroutine_heap->var_cb_suppress;
                coroutine_heap->var_cb_suppress = tmp_assign_source_11;
                Py_XDECREF( old );
            }

        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_12;
            PyObject *tmp_expression_name_1;
            PyObject *tmp_expression_name_2;
            PyObject *tmp_dircall_arg1_2;
            PyObject *tmp_dircall_arg2_2;
            coroutine->m_frame->m_frame.f_lineno = 635;
            CHECK_OBJECT( coroutine_heap->var_cb );
            tmp_dircall_arg1_2 = coroutine_heap->var_cb;
            if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
            {

                coroutine_heap->exception_type = PyExc_NameError;
                Py_INCREF( coroutine_heap->exception_type );
                coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "exc_details" );
                coroutine_heap->exception_tb = NULL;
                NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                CHAIN_EXCEPTION( coroutine_heap->exception_value );

                coroutine_heap->exception_lineno = 635;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_4;
            }

            tmp_dircall_arg2_2 = PyCell_GET( coroutine->m_closure[0] );
            Py_INCREF( tmp_dircall_arg1_2 );
            Py_INCREF( tmp_dircall_arg2_2 );

            {
                PyObject *dir_call_args[] = {tmp_dircall_arg1_2, tmp_dircall_arg2_2};
                tmp_expression_name_2 = impl___internal__$$$function_2_complex_call_helper_star_list( dir_call_args );
            }
            if ( tmp_expression_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 635;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_4;
            }
            tmp_expression_name_1 = ASYNC_AWAIT( tmp_expression_name_2, await_normal );
            Py_DECREF( tmp_expression_name_2 );
            if ( tmp_expression_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 635;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_4;
            }
            Nuitka_PreserveHeap( coroutine_heap->yield_tmps, &tmp_condition_result_2, sizeof(nuitka_bool), &tmp_truth_name_1, sizeof(int), &tmp_expression_name_2, sizeof(PyObject *), &tmp_dircall_arg1_2, sizeof(PyObject *), &tmp_dircall_arg2_2, sizeof(PyObject *), NULL );
            coroutine->m_yield_return_index = 1;
            coroutine->m_yieldfrom = tmp_expression_name_1;
            coroutine->m_awaiting = true;
            return NULL;

            yield_return_1:
            Nuitka_RestoreHeap( coroutine_heap->yield_tmps, &tmp_condition_result_2, sizeof(nuitka_bool), &tmp_truth_name_1, sizeof(int), &tmp_expression_name_2, sizeof(PyObject *), &tmp_dircall_arg1_2, sizeof(PyObject *), &tmp_dircall_arg2_2, sizeof(PyObject *), NULL );
            coroutine->m_awaiting = false;

            if ( yield_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 635;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_4;
            }
            tmp_assign_source_12 = yield_return_value;
            if ( tmp_assign_source_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 635;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_4;
            }
            {
                PyObject *old = coroutine_heap->var_cb_suppress;
                coroutine_heap->var_cb_suppress = tmp_assign_source_12;
                Py_XDECREF( old );
            }

        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_truth_name_2;
        CHECK_OBJECT( coroutine_heap->var_cb_suppress );
        tmp_truth_name_2 = CHECK_IF_TRUE( coroutine_heap->var_cb_suppress );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 637;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_4;
        }
        tmp_condition_result_3 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_13;
            tmp_assign_source_13 = Py_True;
            {
                PyObject *old = coroutine_heap->var_suppressed_exc;
                coroutine_heap->var_suppressed_exc = tmp_assign_source_13;
                Py_INCREF( coroutine_heap->var_suppressed_exc );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_14;
            tmp_assign_source_14 = Py_False;
            {
                PyObject *old = coroutine_heap->var_pending_raise;
                coroutine_heap->var_pending_raise = tmp_assign_source_14;
                Py_INCREF( coroutine_heap->var_pending_raise );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_15;
            tmp_assign_source_15 = const_tuple_none_none_none_tuple;
            {
                PyObject *old = PyCell_GET( coroutine->m_closure[0] );
                PyCell_SET( coroutine->m_closure[0], tmp_assign_source_15 );
                Py_INCREF( tmp_assign_source_15 );
                Py_XDECREF( old );
            }

        }
        branch_no_3:;
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    coroutine_heap->exception_keeper_type_3 = coroutine_heap->exception_type;
    coroutine_heap->exception_keeper_value_3 = coroutine_heap->exception_value;
    coroutine_heap->exception_keeper_tb_3 = coroutine_heap->exception_tb;
    coroutine_heap->exception_keeper_lineno_3 = coroutine_heap->exception_lineno;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    // Preserve existing published exception.
    coroutine_heap->exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF( coroutine_heap->exception_preserved_type_1 );
    coroutine_heap->exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF( coroutine_heap->exception_preserved_value_1 );
    coroutine_heap->exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF( coroutine_heap->exception_preserved_tb_1 );

    if ( coroutine_heap->exception_keeper_tb_3 == NULL )
    {
        coroutine_heap->exception_keeper_tb_3 = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_keeper_lineno_3 );
    }
    else if ( coroutine_heap->exception_keeper_lineno_3 != 0 )
    {
        coroutine_heap->exception_keeper_tb_3 = ADD_TRACEBACK( coroutine_heap->exception_keeper_tb_3, coroutine->m_frame, coroutine_heap->exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &coroutine_heap->exception_keeper_type_3, &coroutine_heap->exception_keeper_value_3, &coroutine_heap->exception_keeper_tb_3 );
    PyException_SetTraceback( coroutine_heap->exception_keeper_value_3, (PyObject *)coroutine_heap->exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &coroutine_heap->exception_keeper_type_3, &coroutine_heap->exception_keeper_value_3, &coroutine_heap->exception_keeper_tb_3 );
    // Tried code:
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_sys );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "sys" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 642;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_5;
        }

        tmp_called_instance_3 = tmp_mvar_value_2;
        coroutine->m_frame->m_frame.f_lineno = 642;
        tmp_assign_source_16 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_exc_info );
        if ( tmp_assign_source_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 642;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_5;
        }
        {
            PyObject *old = coroutine_heap->var_new_exc_details;
            coroutine_heap->var_new_exc_details = tmp_assign_source_16;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_subscript_name_4;
        CHECK_OBJECT( coroutine_heap->var__fix_exception_context );
        tmp_called_name_1 = coroutine_heap->var__fix_exception_context;
        CHECK_OBJECT( coroutine_heap->var_new_exc_details );
        tmp_subscribed_name_3 = coroutine_heap->var_new_exc_details;
        tmp_subscript_name_3 = const_int_pos_1;
        tmp_args_element_name_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 644;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_5;
        }
        if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
        {
            Py_DECREF( tmp_args_element_name_1 );
            coroutine_heap->exception_type = PyExc_NameError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "exc_details" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 644;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_5;
        }

        tmp_subscribed_name_4 = PyCell_GET( coroutine->m_closure[0] );
        tmp_subscript_name_4 = const_int_pos_1;
        tmp_args_element_name_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 1 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            Py_DECREF( tmp_args_element_name_1 );

            coroutine_heap->exception_lineno = 644;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_5;
        }
        coroutine->m_frame->m_frame.f_lineno = 644;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 644;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_5;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_5:;
    coroutine_heap->exception_keeper_type_4 = coroutine_heap->exception_type;
    coroutine_heap->exception_keeper_value_4 = coroutine_heap->exception_value;
    coroutine_heap->exception_keeper_tb_4 = coroutine_heap->exception_tb;
    coroutine_heap->exception_keeper_lineno_4 = coroutine_heap->exception_lineno;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION( coroutine_heap->exception_preserved_type_1, coroutine_heap->exception_preserved_value_1, coroutine_heap->exception_preserved_tb_1 );
    // Re-raise.
    coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_4;
    coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_4;
    coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_4;
    coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    {
        PyObject *tmp_assign_source_17;
        tmp_assign_source_17 = Py_True;
        {
            PyObject *old = coroutine_heap->var_pending_raise;
            coroutine_heap->var_pending_raise = tmp_assign_source_17;
            Py_INCREF( coroutine_heap->var_pending_raise );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_18;
        CHECK_OBJECT( coroutine_heap->var_new_exc_details );
        tmp_assign_source_18 = coroutine_heap->var_new_exc_details;
        {
            PyObject *old = PyCell_GET( coroutine->m_closure[0] );
            PyCell_SET( coroutine->m_closure[0], tmp_assign_source_18 );
            Py_INCREF( tmp_assign_source_18 );
            Py_XDECREF( old );
        }

    }
    // Restore previous exception.
    SET_CURRENT_EXCEPTION( coroutine_heap->exception_preserved_type_1, coroutine_heap->exception_preserved_value_1, coroutine_heap->exception_preserved_tb_1 );
    goto try_end_3;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_46___aexit__$$$coroutine_1___aexit__ );
    return NULL;
    // End of try:
    try_end_3:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


        coroutine_heap->exception_lineno = 629;
        coroutine_heap->type_description_1 = "ccbcoooooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_truth_name_3;
        if ( coroutine_heap->var_pending_raise == NULL )
        {

            coroutine_heap->exception_type = PyExc_UnboundLocalError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "pending_raise" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 647;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto frame_exception_exit_1;
        }

        tmp_truth_name_3 = CHECK_IF_TRUE( coroutine_heap->var_pending_raise );
        if ( tmp_truth_name_3 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 647;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        // Tried code:
        {
            PyObject *tmp_assign_source_19;
            PyObject *tmp_source_name_3;
            PyObject *tmp_subscribed_name_5;
            PyObject *tmp_subscript_name_5;
            if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
            {

                coroutine_heap->exception_type = PyExc_NameError;
                Py_INCREF( coroutine_heap->exception_type );
                coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "exc_details" );
                coroutine_heap->exception_tb = NULL;
                NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                CHAIN_EXCEPTION( coroutine_heap->exception_value );

                coroutine_heap->exception_lineno = 651;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_6;
            }

            tmp_subscribed_name_5 = PyCell_GET( coroutine->m_closure[0] );
            tmp_subscript_name_5 = const_int_pos_1;
            tmp_source_name_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_5, tmp_subscript_name_5, 1 );
            if ( tmp_source_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 651;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_6;
            }
            tmp_assign_source_19 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___context__ );
            Py_DECREF( tmp_source_name_3 );
            if ( tmp_assign_source_19 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 651;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_6;
            }
            assert( coroutine_heap->var_fixed_ctx == NULL );
            coroutine_heap->var_fixed_ctx = tmp_assign_source_19;
        }
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_subscribed_name_6;
            PyObject *tmp_subscript_name_6;
            if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
            {

                coroutine_heap->exception_type = PyExc_NameError;
                Py_INCREF( coroutine_heap->exception_type );
                coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "exc_details" );
                coroutine_heap->exception_tb = NULL;
                NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                CHAIN_EXCEPTION( coroutine_heap->exception_value );

                coroutine_heap->exception_lineno = 652;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_6;
            }

            tmp_subscribed_name_6 = PyCell_GET( coroutine->m_closure[0] );
            tmp_subscript_name_6 = const_int_pos_1;
            tmp_raise_type_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_6, tmp_subscript_name_6, 1 );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 652;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_6;
            }
            coroutine_heap->exception_type = tmp_raise_type_1;
            coroutine_heap->exception_lineno = 652;
            RAISE_EXCEPTION_WITH_TYPE( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_6;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib$$$function_46___aexit__$$$coroutine_1___aexit__ );
        return NULL;
        // Exception handler code:
        try_except_handler_6:;
        coroutine_heap->exception_keeper_type_5 = coroutine_heap->exception_type;
        coroutine_heap->exception_keeper_value_5 = coroutine_heap->exception_value;
        coroutine_heap->exception_keeper_tb_5 = coroutine_heap->exception_tb;
        coroutine_heap->exception_keeper_lineno_5 = coroutine_heap->exception_lineno;
        coroutine_heap->exception_type = NULL;
        coroutine_heap->exception_value = NULL;
        coroutine_heap->exception_tb = NULL;
        coroutine_heap->exception_lineno = 0;

        // Preserve existing published exception.
        coroutine_heap->exception_preserved_type_2 = EXC_TYPE(PyThreadState_GET());
        Py_XINCREF( coroutine_heap->exception_preserved_type_2 );
        coroutine_heap->exception_preserved_value_2 = EXC_VALUE(PyThreadState_GET());
        Py_XINCREF( coroutine_heap->exception_preserved_value_2 );
        coroutine_heap->exception_preserved_tb_2 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
        Py_XINCREF( coroutine_heap->exception_preserved_tb_2 );

        if ( coroutine_heap->exception_keeper_tb_5 == NULL )
        {
            coroutine_heap->exception_keeper_tb_5 = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_keeper_lineno_5 );
        }
        else if ( coroutine_heap->exception_keeper_lineno_5 != 0 )
        {
            coroutine_heap->exception_keeper_tb_5 = ADD_TRACEBACK( coroutine_heap->exception_keeper_tb_5, coroutine->m_frame, coroutine_heap->exception_keeper_lineno_5 );
        }

        NORMALIZE_EXCEPTION( &coroutine_heap->exception_keeper_type_5, &coroutine_heap->exception_keeper_value_5, &coroutine_heap->exception_keeper_tb_5 );
        PyException_SetTraceback( coroutine_heap->exception_keeper_value_5, (PyObject *)coroutine_heap->exception_keeper_tb_5 );
        PUBLISH_EXCEPTION( &coroutine_heap->exception_keeper_type_5, &coroutine_heap->exception_keeper_value_5, &coroutine_heap->exception_keeper_tb_5 );
        // Tried code:
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
            tmp_compexpr_right_2 = PyExc_BaseException;
            coroutine_heap->tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( coroutine_heap->tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                coroutine_heap->exception_lineno = 653;
                coroutine_heap->type_description_1 = "ccbcoooooooo";
                goto try_except_handler_7;
            }
            tmp_condition_result_5 = ( coroutine_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_5;
            }
            else
            {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_assattr_name_1;
                PyObject *tmp_assattr_target_1;
                PyObject *tmp_subscribed_name_7;
                PyObject *tmp_subscript_name_7;
                if ( coroutine_heap->var_fixed_ctx == NULL )
                {

                    coroutine_heap->exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( coroutine_heap->exception_type );
                    coroutine_heap->exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "fixed_ctx" );
                    coroutine_heap->exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                    CHAIN_EXCEPTION( coroutine_heap->exception_value );

                    coroutine_heap->exception_lineno = 654;
                    coroutine_heap->type_description_1 = "ccbcoooooooo";
                    goto try_except_handler_7;
                }

                tmp_assattr_name_1 = coroutine_heap->var_fixed_ctx;
                if ( PyCell_GET( coroutine->m_closure[0] ) == NULL )
                {

                    coroutine_heap->exception_type = PyExc_NameError;
                    Py_INCREF( coroutine_heap->exception_type );
                    coroutine_heap->exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "exc_details" );
                    coroutine_heap->exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
                    CHAIN_EXCEPTION( coroutine_heap->exception_value );

                    coroutine_heap->exception_lineno = 654;
                    coroutine_heap->type_description_1 = "ccbcoooooooo";
                    goto try_except_handler_7;
                }

                tmp_subscribed_name_7 = PyCell_GET( coroutine->m_closure[0] );
                tmp_subscript_name_7 = const_int_pos_1;
                tmp_assattr_target_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_7, tmp_subscript_name_7, 1 );
                if ( tmp_assattr_target_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                    coroutine_heap->exception_lineno = 654;
                    coroutine_heap->type_description_1 = "ccbcoooooooo";
                    goto try_except_handler_7;
                }
                coroutine_heap->tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain___context__, tmp_assattr_name_1 );
                Py_DECREF( tmp_assattr_target_1 );
                if ( coroutine_heap->tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


                    coroutine_heap->exception_lineno = 654;
                    coroutine_heap->type_description_1 = "ccbcoooooooo";
                    goto try_except_handler_7;
                }
            }
            coroutine_heap->tmp_result = RERAISE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            if (unlikely( coroutine_heap->tmp_result == false ))
            {
                coroutine_heap->exception_lineno = 655;
            }

            if (coroutine_heap->exception_tb && coroutine_heap->exception_tb->tb_frame == &coroutine->m_frame->m_frame) coroutine->m_frame->m_frame.f_lineno = coroutine_heap->exception_tb->tb_lineno;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_7;
            goto branch_end_5;
            branch_no_5:;
            coroutine_heap->tmp_result = RERAISE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            if (unlikely( coroutine_heap->tmp_result == false ))
            {
                coroutine_heap->exception_lineno = 648;
            }

            if (coroutine_heap->exception_tb && coroutine_heap->exception_tb->tb_frame == &coroutine->m_frame->m_frame) coroutine->m_frame->m_frame.f_lineno = coroutine_heap->exception_tb->tb_lineno;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto try_except_handler_7;
            branch_end_5:;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib$$$function_46___aexit__$$$coroutine_1___aexit__ );
        return NULL;
        // Exception handler code:
        try_except_handler_7:;
        coroutine_heap->exception_keeper_type_6 = coroutine_heap->exception_type;
        coroutine_heap->exception_keeper_value_6 = coroutine_heap->exception_value;
        coroutine_heap->exception_keeper_tb_6 = coroutine_heap->exception_tb;
        coroutine_heap->exception_keeper_lineno_6 = coroutine_heap->exception_lineno;
        coroutine_heap->exception_type = NULL;
        coroutine_heap->exception_value = NULL;
        coroutine_heap->exception_tb = NULL;
        coroutine_heap->exception_lineno = 0;

        // Restore previous exception.
        SET_CURRENT_EXCEPTION( coroutine_heap->exception_preserved_type_2, coroutine_heap->exception_preserved_value_2, coroutine_heap->exception_preserved_tb_2 );
        // Re-raise.
        coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_6;
        coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_6;
        coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_6;
        coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_6;

        goto frame_exception_exit_1;
        // End of try:
        // End of try:
        branch_no_4:;
    }
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        assert( coroutine_heap->var_received_exc != NUITKA_BOOL_UNASSIGNED);
        tmp_and_left_value_1 = ( coroutine_heap->var_received_exc == NUITKA_BOOL_TRUE ) ? Py_True : Py_False;
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );


            coroutine_heap->exception_lineno = 656;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        if ( coroutine_heap->var_suppressed_exc == NULL )
        {

            coroutine_heap->exception_type = PyExc_UnboundLocalError;
            Py_INCREF( coroutine_heap->exception_type );
            coroutine_heap->exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "suppressed_exc" );
            coroutine_heap->exception_tb = NULL;
            NORMALIZE_EXCEPTION( &coroutine_heap->exception_type, &coroutine_heap->exception_value, &coroutine_heap->exception_tb );
            CHAIN_EXCEPTION( coroutine_heap->exception_value );

            coroutine_heap->exception_lineno = 656;
            coroutine_heap->type_description_1 = "ccbcoooooooo";
            goto frame_exception_exit_1;
        }

        tmp_and_right_value_1 = coroutine_heap->var_suppressed_exc;
        coroutine_heap->tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        coroutine_heap->tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        Py_INCREF( coroutine_heap->tmp_return_value );
        goto frame_return_exit_1;
    }

    Nuitka_Frame_MarkAsNotExecuting( coroutine->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( coroutine->m_frame );
    goto frame_no_exception_1;

    frame_return_exit_1:;

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );
    goto try_return_handler_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( coroutine_heap->exception_type ) )
    {
        if ( coroutine_heap->exception_tb == NULL )
        {
            coroutine_heap->exception_tb = MAKE_TRACEBACK( coroutine->m_frame, coroutine_heap->exception_lineno );
        }
        else if ( coroutine_heap->exception_tb->tb_frame != &coroutine->m_frame->m_frame )
        {
            coroutine_heap->exception_tb = ADD_TRACEBACK( coroutine_heap->exception_tb, coroutine->m_frame, coroutine_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)coroutine->m_frame,
            coroutine_heap->type_description_1,
            coroutine->m_closure[1],
            coroutine->m_closure[0],
            (int)coroutine_heap->var_received_exc,
            coroutine_heap->var_frame_exc,
            coroutine_heap->var__fix_exception_context,
            coroutine_heap->var_suppressed_exc,
            coroutine_heap->var_pending_raise,
            coroutine_heap->var_is_sync,
            coroutine_heap->var_cb,
            coroutine_heap->var_cb_suppress,
            coroutine_heap->var_new_exc_details,
            coroutine_heap->var_fixed_ctx
        );


        // Release cached frame.
        if ( coroutine->m_frame == cache_m_frame )
        {
            Py_DECREF( coroutine->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( coroutine->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( coroutine->m_exc_state.exc_type );
    Py_CLEAR( coroutine->m_exc_state.exc_value );
    Py_CLEAR( coroutine->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_type );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_value );
    Py_CLEAR( coroutine->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( coroutine->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_46___aexit__$$$coroutine_1___aexit__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)coroutine_heap->var_frame_exc );
    Py_DECREF( coroutine_heap->var_frame_exc );
    coroutine_heap->var_frame_exc = NULL;

    CHECK_OBJECT( (PyObject *)coroutine_heap->var__fix_exception_context );
    Py_DECREF( coroutine_heap->var__fix_exception_context );
    coroutine_heap->var__fix_exception_context = NULL;

    Py_XDECREF( coroutine_heap->var_suppressed_exc );
    coroutine_heap->var_suppressed_exc = NULL;

    Py_XDECREF( coroutine_heap->var_pending_raise );
    coroutine_heap->var_pending_raise = NULL;

    Py_XDECREF( coroutine_heap->var_is_sync );
    coroutine_heap->var_is_sync = NULL;

    Py_XDECREF( coroutine_heap->var_cb );
    coroutine_heap->var_cb = NULL;

    Py_XDECREF( coroutine_heap->var_cb_suppress );
    coroutine_heap->var_cb_suppress = NULL;

    Py_XDECREF( coroutine_heap->var_new_exc_details );
    coroutine_heap->var_new_exc_details = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    coroutine_heap->exception_keeper_type_7 = coroutine_heap->exception_type;
    coroutine_heap->exception_keeper_value_7 = coroutine_heap->exception_value;
    coroutine_heap->exception_keeper_tb_7 = coroutine_heap->exception_tb;
    coroutine_heap->exception_keeper_lineno_7 = coroutine_heap->exception_lineno;
    coroutine_heap->exception_type = NULL;
    coroutine_heap->exception_value = NULL;
    coroutine_heap->exception_tb = NULL;
    coroutine_heap->exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)coroutine_heap->var_frame_exc );
    Py_DECREF( coroutine_heap->var_frame_exc );
    coroutine_heap->var_frame_exc = NULL;

    Py_XDECREF( coroutine_heap->var__fix_exception_context );
    coroutine_heap->var__fix_exception_context = NULL;

    Py_XDECREF( coroutine_heap->var_suppressed_exc );
    coroutine_heap->var_suppressed_exc = NULL;

    Py_XDECREF( coroutine_heap->var_pending_raise );
    coroutine_heap->var_pending_raise = NULL;

    Py_XDECREF( coroutine_heap->var_is_sync );
    coroutine_heap->var_is_sync = NULL;

    Py_XDECREF( coroutine_heap->var_cb );
    coroutine_heap->var_cb = NULL;

    Py_XDECREF( coroutine_heap->var_cb_suppress );
    coroutine_heap->var_cb_suppress = NULL;

    Py_XDECREF( coroutine_heap->var_new_exc_details );
    coroutine_heap->var_new_exc_details = NULL;

    Py_XDECREF( coroutine_heap->var_fixed_ctx );
    coroutine_heap->var_fixed_ctx = NULL;

    // Re-raise.
    coroutine_heap->exception_type = coroutine_heap->exception_keeper_type_7;
    coroutine_heap->exception_value = coroutine_heap->exception_keeper_value_7;
    coroutine_heap->exception_tb = coroutine_heap->exception_keeper_tb_7;
    coroutine_heap->exception_lineno = coroutine_heap->exception_keeper_lineno_7;

    goto function_exception_exit;
    // End of try:

    // Return statement must be present.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_46___aexit__$$$coroutine_1___aexit__ );

    function_exception_exit:
    assert( coroutine_heap->exception_type );
    RESTORE_ERROR_OCCURRED( coroutine_heap->exception_type, coroutine_heap->exception_value, coroutine_heap->exception_tb );
    return NULL;
    function_return_exit:;

    coroutine->m_returned = coroutine_heap->tmp_return_value;

    return NULL;

}

static PyObject *contextlib$$$function_46___aexit__$$$coroutine_1___aexit___maker( void )
{
    return Nuitka_Coroutine_New(
        contextlib$$$function_46___aexit__$$$coroutine_1___aexit___context,
        module_contextlib,
        const_str_plain___aexit__,
        const_str_digest_b427544bbbefa85025737b449f92ef67,
        codeobj_1053119921a56c2bea8a426f0019c955,
        2,
        sizeof(struct contextlib$$$function_46___aexit__$$$coroutine_1___aexit___locals)
    );
}


static PyObject *impl_contextlib$$$function_46___aexit__$$$coroutine_1___aexit__$$$function_1__fix_exception_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_new_exc = python_pars[ 0 ];
    PyObject *par_old_exc = python_pars[ 1 ];
    PyObject *var_exc_context = NULL;
    struct Nuitka_FrameObject *frame_472f3c61d3963d5dcde030560103997b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_472f3c61d3963d5dcde030560103997b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_472f3c61d3963d5dcde030560103997b, codeobj_472f3c61d3963d5dcde030560103997b, module_contextlib, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_472f3c61d3963d5dcde030560103997b = cache_frame_472f3c61d3963d5dcde030560103997b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_472f3c61d3963d5dcde030560103997b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_472f3c61d3963d5dcde030560103997b ) == 2 ); // Frame stack

    // Framed code:
    loop_start_1:;
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_new_exc );
        tmp_source_name_1 = par_new_exc;
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___context__ );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 614;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_exc_context;
            var_exc_context = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_exc_context );
        tmp_compexpr_left_1 = var_exc_context;
        CHECK_OBJECT( par_old_exc );
        tmp_compexpr_right_1 = par_old_exc;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT( var_exc_context );
        tmp_compexpr_left_2 = var_exc_context;
        tmp_compexpr_right_2 = Py_None;
        tmp_or_left_value_1 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( var_exc_context );
        tmp_compexpr_left_3 = var_exc_context;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "frame_exc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 618;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_3 = PyCell_GET( self->m_closure[0] );
        tmp_or_right_value_1 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_2 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_2 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        goto loop_end_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( var_exc_context );
        tmp_assign_source_2 = var_exc_context;
        {
            PyObject *old = par_new_exc;
            assert( old != NULL );
            par_new_exc = tmp_assign_source_2;
            Py_INCREF( par_new_exc );
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 613;
        type_description_1 = "oooc";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_old_exc );
        tmp_assattr_name_1 = par_old_exc;
        CHECK_OBJECT( par_new_exc );
        tmp_assattr_target_1 = par_new_exc;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain___context__, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 623;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_472f3c61d3963d5dcde030560103997b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_472f3c61d3963d5dcde030560103997b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_472f3c61d3963d5dcde030560103997b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_472f3c61d3963d5dcde030560103997b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_472f3c61d3963d5dcde030560103997b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_472f3c61d3963d5dcde030560103997b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_472f3c61d3963d5dcde030560103997b,
        type_description_1,
        par_new_exc,
        par_old_exc,
        var_exc_context,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_472f3c61d3963d5dcde030560103997b == cache_frame_472f3c61d3963d5dcde030560103997b )
    {
        Py_DECREF( frame_472f3c61d3963d5dcde030560103997b );
    }
    cache_frame_472f3c61d3963d5dcde030560103997b = NULL;

    assertFrameObject( frame_472f3c61d3963d5dcde030560103997b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_46___aexit__$$$coroutine_1___aexit__$$$function_1__fix_exception_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_new_exc );
    Py_DECREF( par_new_exc );
    par_new_exc = NULL;

    CHECK_OBJECT( (PyObject *)par_old_exc );
    Py_DECREF( par_old_exc );
    par_old_exc = NULL;

    CHECK_OBJECT( (PyObject *)var_exc_context );
    Py_DECREF( var_exc_context );
    var_exc_context = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_new_exc );
    Py_DECREF( par_new_exc );
    par_new_exc = NULL;

    CHECK_OBJECT( (PyObject *)par_old_exc );
    Py_DECREF( par_old_exc );
    par_old_exc = NULL;

    Py_XDECREF( var_exc_context );
    var_exc_context = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_46___aexit__$$$coroutine_1___aexit__$$$function_1__fix_exception_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_47___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_enter_result = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_3f39158aafe18f3b316031d137e3a7af;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3f39158aafe18f3b316031d137e3a7af = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3f39158aafe18f3b316031d137e3a7af, codeobj_3f39158aafe18f3b316031d137e3a7af, module_contextlib, sizeof(void *)+sizeof(void *) );
    frame_3f39158aafe18f3b316031d137e3a7af = cache_frame_3f39158aafe18f3b316031d137e3a7af;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3f39158aafe18f3b316031d137e3a7af );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3f39158aafe18f3b316031d137e3a7af ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_enter_result );
        tmp_assattr_name_1 = par_enter_result;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_enter_result, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 671;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3f39158aafe18f3b316031d137e3a7af );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3f39158aafe18f3b316031d137e3a7af );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3f39158aafe18f3b316031d137e3a7af, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3f39158aafe18f3b316031d137e3a7af->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3f39158aafe18f3b316031d137e3a7af, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3f39158aafe18f3b316031d137e3a7af,
        type_description_1,
        par_self,
        par_enter_result
    );


    // Release cached frame.
    if ( frame_3f39158aafe18f3b316031d137e3a7af == cache_frame_3f39158aafe18f3b316031d137e3a7af )
    {
        Py_DECREF( frame_3f39158aafe18f3b316031d137e3a7af );
    }
    cache_frame_3f39158aafe18f3b316031d137e3a7af = NULL;

    assertFrameObject( frame_3f39158aafe18f3b316031d137e3a7af );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_47___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_enter_result );
    Py_DECREF( par_enter_result );
    par_enter_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_enter_result );
    Py_DECREF( par_enter_result );
    par_enter_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_47___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_48___enter__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_ea577d827d21f03b7109facb03bac09c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ea577d827d21f03b7109facb03bac09c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ea577d827d21f03b7109facb03bac09c, codeobj_ea577d827d21f03b7109facb03bac09c, module_contextlib, sizeof(void *) );
    frame_ea577d827d21f03b7109facb03bac09c = cache_frame_ea577d827d21f03b7109facb03bac09c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ea577d827d21f03b7109facb03bac09c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ea577d827d21f03b7109facb03bac09c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_enter_result );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 674;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ea577d827d21f03b7109facb03bac09c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ea577d827d21f03b7109facb03bac09c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ea577d827d21f03b7109facb03bac09c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ea577d827d21f03b7109facb03bac09c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ea577d827d21f03b7109facb03bac09c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ea577d827d21f03b7109facb03bac09c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ea577d827d21f03b7109facb03bac09c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_ea577d827d21f03b7109facb03bac09c == cache_frame_ea577d827d21f03b7109facb03bac09c )
    {
        Py_DECREF( frame_ea577d827d21f03b7109facb03bac09c );
    }
    cache_frame_ea577d827d21f03b7109facb03bac09c = NULL;

    assertFrameObject( frame_ea577d827d21f03b7109facb03bac09c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_48___enter__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_48___enter__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_contextlib$$$function_49___exit__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_excinfo = python_pars[ 1 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_49___exit__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_excinfo );
    Py_DECREF( par_excinfo );
    par_excinfo = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_excinfo );
    Py_DECREF( par_excinfo );
    par_excinfo = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( contextlib$$$function_49___exit__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_10__recreate_cm(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_10__recreate_cm,
        const_str_plain__recreate_cm,
#if PYTHON_VERSION >= 300
        const_str_digest_25a5c522ea5890a2f0329489df61d4e7,
#endif
        codeobj_ae091acc94155ceeb0d0b8a3dab512c6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_11___enter__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_11___enter__,
        const_str_plain___enter__,
#if PYTHON_VERSION >= 300
        const_str_digest_5dcda8782ba35a75678a91209700af3e,
#endif
        codeobj_ab6d63e978e1252c4db14ab08bb51a49,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_12___exit__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_12___exit__,
        const_str_plain___exit__,
#if PYTHON_VERSION >= 300
        const_str_digest_e945221f7c26341208775e8abf72a8fa,
#endif
        codeobj_483345fee779ba1705e61c19617f3712,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_13___aenter__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_13___aenter__,
        const_str_plain___aenter__,
#if PYTHON_VERSION >= 300
        const_str_digest_c9273566575fea99bfeae6de0a02b843,
#endif
        codeobj_ad0164f70f9718d4c84eac4493bd0b3f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_14___aexit__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_14___aexit__,
        const_str_plain___aexit__,
#if PYTHON_VERSION >= 300
        const_str_digest_32920fc73b22ed7a2cae0938236ca756,
#endif
        codeobj_97a372fac4573135deb7dd07cd85c86d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_15_contextmanager(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_15_contextmanager,
        const_str_plain_contextmanager,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c9d7fea79421b5192503141dd6b626fa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_b09c25223d69ba668f56715025b1580f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_15_contextmanager$$$function_1_helper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_15_contextmanager$$$function_1_helper,
        const_str_plain_helper,
#if PYTHON_VERSION >= 300
        const_str_digest_d310a8f23c19ced2e835b7bda8daeaea,
#endif
        codeobj_b32d399f13c7f5cb32706e7e8544adcd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_16_asynccontextmanager(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_16_asynccontextmanager,
        const_str_plain_asynccontextmanager,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_535fe3b96fc9f66283c68667446d44b4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_6bf82b52b82827398412049d90b93095,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_16_asynccontextmanager$$$function_1_helper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_16_asynccontextmanager$$$function_1_helper,
        const_str_plain_helper,
#if PYTHON_VERSION >= 300
        const_str_digest_568a33c9e2d9c0e121adfde0743aa87a,
#endif
        codeobj_fe180fc33126050a85ed6c97d75eb435,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_17___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_17___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_1d16a40cf452909202a07d4a8894ff9f,
#endif
        codeobj_e3c17e4fc256ae365524c8cbb1598249,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_18___enter__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_18___enter__,
        const_str_plain___enter__,
#if PYTHON_VERSION >= 300
        const_str_digest_767308c1e3e7512bcaf23b84f8ac277a,
#endif
        codeobj_9b5da5032c05507da8147f4e6f99b839,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_19___exit__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_19___exit__,
        const_str_plain___exit__,
#if PYTHON_VERSION >= 300
        const_str_digest_738a6c63d8a7f3e6b47adb4108e7c9d1,
#endif
        codeobj_df97ed3424cb10a88b4203af3cf76740,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_1___enter__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_1___enter__,
        const_str_plain___enter__,
#if PYTHON_VERSION >= 300
        const_str_digest_a68aae16a095bf20f5b2dce3ef8bbc02,
#endif
        codeobj_608aec0519dfe3b8eecdb746943b25e8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_6616e0e68b690f14c87f57dc8a44bd85,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_20___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_20___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_0f0d45b1451f7c90ace5341c8d2acc76,
#endif
        codeobj_6e54b004743913720c86884cf47d4c7b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_21___enter__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_21___enter__,
        const_str_plain___enter__,
#if PYTHON_VERSION >= 300
        const_str_digest_d8ed76b736711588dc0441af0e3acdcb,
#endif
        codeobj_8fec8b0032b947333ecb2ffba5c36fda,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_22___exit__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_22___exit__,
        const_str_plain___exit__,
#if PYTHON_VERSION >= 300
        const_str_digest_a0e0ee5062c8c89817864b9873626e91,
#endif
        codeobj_67a1e3a1c0061e332d3094ae30557685,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_23___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_23___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_be6e50fdf69f187f977c4e5d0f4f92c1,
#endif
        codeobj_b4139367cf6f902d8f012d68c18fbdff,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_24___enter__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_24___enter__,
        const_str_plain___enter__,
#if PYTHON_VERSION >= 300
        const_str_digest_c12dd3159c30879cf943be20228dc60c,
#endif
        codeobj_8e9cb589a8f7d924c7e618eca92361d5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_25___exit__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_25___exit__,
        const_str_plain___exit__,
#if PYTHON_VERSION >= 300
        const_str_digest_5b4233ef7f235a30c90a3520223ec395,
#endif
        codeobj_1b47f9f1ce467f7f75848449b2718fa6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_26__create_exit_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_26__create_exit_wrapper,
        const_str_plain__create_exit_wrapper,
#if PYTHON_VERSION >= 300
        const_str_digest_0324378fdaf4c0afbda1d52593df0b3d,
#endif
        codeobj_50f7458fdc57dfdb87cc1909e09be3ec,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_26__create_exit_wrapper$$$function_1__exit_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_26__create_exit_wrapper$$$function_1__exit_wrapper,
        const_str_plain__exit_wrapper,
#if PYTHON_VERSION >= 300
        const_str_digest_cd9499f90d1fdb125e1fc42bc99bc8bc,
#endif
        codeobj_b314dfc24cfb446bc412a4b84347e7bb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_27__create_cb_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_27__create_cb_wrapper,
        const_str_plain__create_cb_wrapper,
#if PYTHON_VERSION >= 300
        const_str_digest_09d5c8d945353368df602f14ef2d947d,
#endif
        codeobj_f6bfedafdf345fc87a24d5cc8030c305,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_27__create_cb_wrapper$$$function_1__exit_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_27__create_cb_wrapper$$$function_1__exit_wrapper,
        const_str_plain__exit_wrapper,
#if PYTHON_VERSION >= 300
        const_str_digest_c3a7e7986afc535e6f02c4ca2ab3a121,
#endif
        codeobj_c5e0bdefa48e79d21cad1e6b166e62e9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        3
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_28___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_28___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_5723e006fbbb84d1de871bcae3bcd023,
#endif
        codeobj_209a810c6ebd52b561796e0f9bae79be,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_29_pop_all(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_29_pop_all,
        const_str_plain_pop_all,
#if PYTHON_VERSION >= 300
        const_str_digest_561259968dad5e211e270f1bf7b5ddcc,
#endif
        codeobj_ac1633f3fdcf108561287a9aaae4de40,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_639ebec650f2fbedf493b5dd0b28ed77,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_2___exit__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_2___exit__,
        const_str_plain___exit__,
#if PYTHON_VERSION >= 300
        const_str_digest_d00d203588989ad33939a2d912ad1378,
#endif
        codeobj_d50e67012bb275ea8e91c1af19ae7625,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_c90ebf416c6b3426c3ced10ea695a8ab,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_30_push(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_30_push,
        const_str_plain_push,
#if PYTHON_VERSION >= 300
        const_str_digest_657b8bde9f38fd964044ea752e7ced2d,
#endif
        codeobj_3eea89dad8802f791e00692828406a41,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_aa3df32e7619083adf0a2fbf5a235c36,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_31_enter_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_31_enter_context,
        const_str_plain_enter_context,
#if PYTHON_VERSION >= 300
        const_str_digest_266a0e5c654ff0c5f2b193bf2c56d53a,
#endif
        codeobj_c2b386b5b585286d75c620b41f07f6f9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_b577a7297d1ef67501fdbd40a3ef6040,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_32_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_32_callback,
        const_str_plain_callback,
#if PYTHON_VERSION >= 300
        const_str_digest_d3e49cbb4b25449e156e86388d4299ad,
#endif
        codeobj_d11d44405c07a698ba8f0ab99d8d0e2a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_3f30b003fbfc4f0bf645c8bc55efc51f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_33__push_cm_exit(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_33__push_cm_exit,
        const_str_plain__push_cm_exit,
#if PYTHON_VERSION >= 300
        const_str_digest_a35b309c4b1d53a114ad6b7b1cbbc3f0,
#endif
        codeobj_5e7507c3fa2f8357a290571a7c2c87fb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_45f4e32fb936425e6aae2a495ddd5db3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_34__push_exit_callback( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_34__push_exit_callback,
        const_str_plain__push_exit_callback,
#if PYTHON_VERSION >= 300
        const_str_digest_b7f7eed1cf6a5961dffed270fdd5feca,
#endif
        codeobj_e2bc8f99006d30c55dd2a8eecf6821aa,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_35___enter__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_35___enter__,
        const_str_plain___enter__,
#if PYTHON_VERSION >= 300
        const_str_digest_a20d2b369cfee2d243317b2de658a730,
#endif
        codeobj_b1c128d48b192bedb6577a8b7160a717,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_36___exit__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_36___exit__,
        const_str_plain___exit__,
#if PYTHON_VERSION >= 300
        const_str_digest_069d815edcbe4c452d78970be7a78ac2,
#endif
        codeobj_5319d6795f1312e749b7f025eaaf1c46,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_36___exit__$$$function_1__fix_exception_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_36___exit__$$$function_1__fix_exception_context,
        const_str_plain__fix_exception_context,
#if PYTHON_VERSION >= 300
        const_str_digest_15c01fc29f9c1a2be6b00d45717358b0,
#endif
        codeobj_bbfd4ac0f959c684210adaa396b9a35a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_37_close(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_37_close,
        const_str_plain_close,
#if PYTHON_VERSION >= 300
        const_str_digest_04bc19c38b15a93519f8e990f6a13da6,
#endif
        codeobj_6bd1f91ac15dd8324cd978b80269b375,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_6c74f90a83f8426d3debee986acb6dfb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_38__create_async_exit_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_38__create_async_exit_wrapper,
        const_str_plain__create_async_exit_wrapper,
#if PYTHON_VERSION >= 300
        const_str_digest_25c2da89c50fb28a7c6a154308bd9afe,
#endif
        codeobj_bff15e44f163505d42b2d15a38f2c81c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_38__create_async_exit_wrapper$$$function_1__exit_wrapper,
        const_str_plain__exit_wrapper,
#if PYTHON_VERSION >= 300
        const_str_digest_9b9905bf1735b3c8d0d69a874343ee1c,
#endif
        codeobj_c28aa9caf0be431315f136ca024fd8ff,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_39__create_async_cb_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_39__create_async_cb_wrapper,
        const_str_plain__create_async_cb_wrapper,
#if PYTHON_VERSION >= 300
        const_str_digest_454729390f92fd60b48378f2e1aa3db0,
#endif
        codeobj_cd00d3f4cbbe7bcc26349b3d24f73b5a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_39__create_async_cb_wrapper$$$function_1__exit_wrapper,
        const_str_plain__exit_wrapper,
#if PYTHON_VERSION >= 300
        const_str_digest_e363b48ed66180ea29569815ae2c814f,
#endif
        codeobj_79334a1036d8c97f06c39c18817bf2f2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        3
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_3___subclasshook__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_3___subclasshook__,
        const_str_plain___subclasshook__,
#if PYTHON_VERSION >= 300
        const_str_digest_bdb887d2ae600fc55f8a3783f325d1b8,
#endif
        codeobj_3010ebafdd9c4ae5d6be7668f47fd0ff,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_40_enter_async_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_40_enter_async_context,
        const_str_plain_enter_async_context,
#if PYTHON_VERSION >= 300
        const_str_digest_b7bfa96e1930f41166a4f32612e692f6,
#endif
        codeobj_b5aa3e2dedb8972036672150e4e23f41,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_81336c6ee73db5493c214b89c035e61d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_41_push_async_exit(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_41_push_async_exit,
        const_str_plain_push_async_exit,
#if PYTHON_VERSION >= 300
        const_str_digest_53f2bc37130ba4c17f452fdc4d047974,
#endif
        codeobj_2ceeed769613aea7ec41a0a0032b3f6d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_fb1417f379158cc513e12e6529ffb50b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_42_push_async_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_42_push_async_callback,
        const_str_plain_push_async_callback,
#if PYTHON_VERSION >= 300
        const_str_digest_df1f1d9b030254507b5122a26df9a71a,
#endif
        codeobj_45e2cf9544c4a969db74b67d603ee00d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_496479db0a523e2af9244fc0d8332ffd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_43_aclose(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_43_aclose,
        const_str_plain_aclose,
#if PYTHON_VERSION >= 300
        const_str_digest_ab10239cbb13ff94c3252ede7d4d1fce,
#endif
        codeobj_86d241f5735172421d3744f63bc43116,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_6c74f90a83f8426d3debee986acb6dfb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_44__push_async_cm_exit(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_44__push_async_cm_exit,
        const_str_plain__push_async_cm_exit,
#if PYTHON_VERSION >= 300
        const_str_digest_7d7f62a9e44e7e680c51c869c602a010,
#endif
        codeobj_b7274d5d850f21d60dd43edeab664be5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_44fc253913aa80f6b51dedb3b194ecf6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_45___aenter__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_45___aenter__,
        const_str_plain___aenter__,
#if PYTHON_VERSION >= 300
        const_str_digest_4cc0ab300f4fe8af2dc122c9eba3d7cc,
#endif
        codeobj_775fcfc9e192e06247503a9be4ac57a1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_46___aexit__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_46___aexit__,
        const_str_plain___aexit__,
#if PYTHON_VERSION >= 300
        const_str_digest_b427544bbbefa85025737b449f92ef67,
#endif
        codeobj_1053119921a56c2bea8a426f0019c955,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_46___aexit__$$$coroutine_1___aexit__$$$function_1__fix_exception_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_46___aexit__$$$coroutine_1___aexit__$$$function_1__fix_exception_context,
        const_str_plain__fix_exception_context,
#if PYTHON_VERSION >= 300
        const_str_digest_de72cb85464cbf04e752b2f7df1e4103,
#endif
        codeobj_472f3c61d3963d5dcde030560103997b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_47___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_47___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_1bd5d99d6eaccd3aded9fbcf030f961c,
#endif
        codeobj_3f39158aafe18f3b316031d137e3a7af,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_48___enter__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_48___enter__,
        const_str_plain___enter__,
#if PYTHON_VERSION >= 300
        const_str_digest_e8e9e8cf77df5602ad3518afa654e609,
#endif
        codeobj_ea577d827d21f03b7109facb03bac09c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_49___exit__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_49___exit__,
        const_str_plain___exit__,
#if PYTHON_VERSION >= 300
        const_str_digest_3194f1464a0dbee99d5da6e02a3ee3d6,
#endif
        codeobj_dd8108231668e71787c3c868f3031f9b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_4___aenter__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_4___aenter__,
        const_str_plain___aenter__,
#if PYTHON_VERSION >= 300
        const_str_digest_072d893f430d6100c064aab7d47e5365,
#endif
        codeobj_abe4ba583c817761ab022d36929753d8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_6616e0e68b690f14c87f57dc8a44bd85,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_5___aexit__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_5___aexit__,
        const_str_plain___aexit__,
#if PYTHON_VERSION >= 300
        const_str_digest_15e936ef3374424b98cf9aa15867b234,
#endif
        codeobj_d62b1f4472ae7081578940b4d26b2c48,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_c90ebf416c6b3426c3ced10ea695a8ab,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_6___subclasshook__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_6___subclasshook__,
        const_str_plain___subclasshook__,
#if PYTHON_VERSION >= 300
        const_str_digest_88d158957b0ede9fb261f4e63b263f20,
#endif
        codeobj_34b0278e9808572c069bceb941715927,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_7__recreate_cm(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_7__recreate_cm,
        const_str_plain__recreate_cm,
#if PYTHON_VERSION >= 300
        const_str_digest_492c9a2e0339f0b460e318e83c406d2a,
#endif
        codeobj_cb08c024b4d4f770d9b5cdd06dc0c2d8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        const_str_digest_75420df2bc0eb7333ada17751936a384,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_8___call__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_8___call__,
        const_str_plain___call__,
#if PYTHON_VERSION >= 300
        const_str_digest_4dbe0056da4a01eaffbc4834adabb195,
#endif
        codeobj_09fd19dda9487a9928a1b4ed8c1ffc15,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_8___call__$$$function_1_inner(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_8___call__$$$function_1_inner,
        const_str_plain_inner,
#if PYTHON_VERSION >= 300
        const_str_digest_4a605543d290dbdf95f4c339df4f12b9,
#endif
        codeobj_de02ad5f3ecd8dc39711a0813e03c5e9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_contextlib$$$function_9___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_contextlib$$$function_9___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_013a524d3bf3493644ac1b41fa206eb2,
#endif
        codeobj_7289da3863f64141e779df033dfe8c6d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_contextlib,
        NULL,
        0
    );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_contextlib =
{
    PyModuleDef_HEAD_INIT,
    "contextlib",
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___compiled__;

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

extern PyTypeObject Nuitka_Loader_Type;

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( contextlib )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_contextlib );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("contextlib: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("contextlib: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("contextlib: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initcontextlib" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_contextlib = Py_InitModule4(
        "contextlib",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_contextlib = PyModule_Create( &mdef_contextlib );
#endif

    moduledict_contextlib = MODULE_DICT( module_contextlib );

    // Set __compiled__ to what it we know.
    UPDATE_STRING_DICT1(
        moduledict_contextlib,
        (Nuitka_StringObject *)const_str_plain___compiled__,
        Nuitka_dunder_compiled_value
    );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_contextlib,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_contextlib,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_contextlib,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_contextlib );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PyImport_GetModuleDict(), const_str_plain_contextlib, module_contextlib );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type );
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___name__ ),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF( module_spec_class );

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT( spec_value );

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE( spec_value, const_str_plain_submodule_search_locations, PyList_New(0) );
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE( spec_value, const_str_plain__initializing, Py_True );

        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );
    }
#endif
#endif

    // Temp variables if any
    PyObject *outline_0_var___class__ = NULL;
    PyObject *outline_1_var___class__ = NULL;
    PyObject *outline_2_var___class__ = NULL;
    PyObject *outline_3_var___class__ = NULL;
    PyObject *outline_4_var___class__ = NULL;
    PyObject *outline_5_var___class__ = NULL;
    PyObject *outline_6_var___class__ = NULL;
    PyObject *outline_7_var___class__ = NULL;
    PyObject *outline_8_var___class__ = NULL;
    PyObject *outline_9_var___class__ = NULL;
    PyObject *outline_10_var___class__ = NULL;
    PyObject *outline_11_var___class__ = NULL;
    PyObject *outline_12_var___class__ = NULL;
    PyObject *outline_13_var___class__ = NULL;
    PyObject *outline_14_var___class__ = NULL;
    PyObject *tmp_class_creation_10__bases = NULL;
    PyObject *tmp_class_creation_10__bases_orig = NULL;
    PyObject *tmp_class_creation_10__class_decl_dict = NULL;
    PyObject *tmp_class_creation_10__metaclass = NULL;
    PyObject *tmp_class_creation_10__prepared = NULL;
    PyObject *tmp_class_creation_11__bases = NULL;
    PyObject *tmp_class_creation_11__bases_orig = NULL;
    PyObject *tmp_class_creation_11__class_decl_dict = NULL;
    PyObject *tmp_class_creation_11__metaclass = NULL;
    PyObject *tmp_class_creation_11__prepared = NULL;
    PyObject *tmp_class_creation_12__class_decl_dict = NULL;
    PyObject *tmp_class_creation_12__metaclass = NULL;
    PyObject *tmp_class_creation_12__prepared = NULL;
    PyObject *tmp_class_creation_13__bases = NULL;
    PyObject *tmp_class_creation_13__bases_orig = NULL;
    PyObject *tmp_class_creation_13__class_decl_dict = NULL;
    PyObject *tmp_class_creation_13__metaclass = NULL;
    PyObject *tmp_class_creation_13__prepared = NULL;
    PyObject *tmp_class_creation_14__bases = NULL;
    PyObject *tmp_class_creation_14__bases_orig = NULL;
    PyObject *tmp_class_creation_14__class_decl_dict = NULL;
    PyObject *tmp_class_creation_14__metaclass = NULL;
    PyObject *tmp_class_creation_14__prepared = NULL;
    PyObject *tmp_class_creation_15__bases = NULL;
    PyObject *tmp_class_creation_15__bases_orig = NULL;
    PyObject *tmp_class_creation_15__class_decl_dict = NULL;
    PyObject *tmp_class_creation_15__metaclass = NULL;
    PyObject *tmp_class_creation_15__prepared = NULL;
    PyObject *tmp_class_creation_1__bases = NULL;
    PyObject *tmp_class_creation_1__bases_orig = NULL;
    PyObject *tmp_class_creation_1__class_decl_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_1__prepared = NULL;
    PyObject *tmp_class_creation_2__bases = NULL;
    PyObject *tmp_class_creation_2__bases_orig = NULL;
    PyObject *tmp_class_creation_2__class_decl_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_2__prepared = NULL;
    PyObject *tmp_class_creation_3__bases = NULL;
    PyObject *tmp_class_creation_3__class_decl_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_3__prepared = NULL;
    PyObject *tmp_class_creation_4__class_decl_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_4__prepared = NULL;
    PyObject *tmp_class_creation_5__bases = NULL;
    PyObject *tmp_class_creation_5__bases_orig = NULL;
    PyObject *tmp_class_creation_5__class_decl_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_5__prepared = NULL;
    PyObject *tmp_class_creation_6__bases = NULL;
    PyObject *tmp_class_creation_6__bases_orig = NULL;
    PyObject *tmp_class_creation_6__class_decl_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_6__prepared = NULL;
    PyObject *tmp_class_creation_7__bases = NULL;
    PyObject *tmp_class_creation_7__bases_orig = NULL;
    PyObject *tmp_class_creation_7__class_decl_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_7__prepared = NULL;
    PyObject *tmp_class_creation_8__bases = NULL;
    PyObject *tmp_class_creation_8__bases_orig = NULL;
    PyObject *tmp_class_creation_8__class_decl_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_8__prepared = NULL;
    PyObject *tmp_class_creation_9__bases = NULL;
    PyObject *tmp_class_creation_9__bases_orig = NULL;
    PyObject *tmp_class_creation_9__class_decl_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_class_creation_9__prepared = NULL;
    struct Nuitka_FrameObject *frame_16be74c7884d209762a4409719331de6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_dictdel_dict;
    PyObject *tmp_dictdel_key;
    PyObject *locals_contextlib_14 = NULL;
    PyObject *tmp_dictset_value;
    struct Nuitka_FrameObject *frame_4035f91cc3ac63d7d4c73c33cc6faa55_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    static struct Nuitka_FrameObject *cache_frame_4035f91cc3ac63d7d4c73c33cc6faa55_2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *locals_contextlib_34 = NULL;
    struct Nuitka_FrameObject *frame_5b202f99d1876fb8487deeef8d71a950_3;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    static struct Nuitka_FrameObject *cache_frame_5b202f99d1876fb8487deeef8d71a950_3 = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *locals_contextlib_55 = NULL;
    struct Nuitka_FrameObject *frame_c04d551e7f2d47bde603a86a6cbab618_4;
    NUITKA_MAY_BE_UNUSED char const *type_description_4 = NULL;
    static struct Nuitka_FrameObject *cache_frame_c04d551e7f2d47bde603a86a6cbab618_4 = NULL;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *locals_contextlib_78 = NULL;
    struct Nuitka_FrameObject *frame_234568fa88d264a070f886691f02cf17_5;
    NUITKA_MAY_BE_UNUSED char const *type_description_5 = NULL;
    static struct Nuitka_FrameObject *cache_frame_234568fa88d264a070f886691f02cf17_5 = NULL;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *locals_contextlib_98 = NULL;
    struct Nuitka_FrameObject *frame_425d97b102abf105a65464ebdd2a370d_6;
    NUITKA_MAY_BE_UNUSED char const *type_description_6 = NULL;
    static struct Nuitka_FrameObject *cache_frame_425d97b102abf105a65464ebdd2a370d_6 = NULL;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *locals_contextlib_165 = NULL;
    struct Nuitka_FrameObject *frame_ed080fdeb1d9225b601fa380040f8380_7;
    NUITKA_MAY_BE_UNUSED char const *type_description_7 = NULL;
    static struct Nuitka_FrameObject *cache_frame_ed080fdeb1d9225b601fa380040f8380_7 = NULL;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *locals_contextlib_276 = NULL;
    struct Nuitka_FrameObject *frame_5d897d4474259a7128af7713d0e7b885_8;
    NUITKA_MAY_BE_UNUSED char const *type_description_8 = NULL;
    static struct Nuitka_FrameObject *cache_frame_5d897d4474259a7128af7713d0e7b885_8 = NULL;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *locals_contextlib_301 = NULL;
    struct Nuitka_FrameObject *frame_01fcb8cd929b0c4b32cd16ad15de112a_9;
    NUITKA_MAY_BE_UNUSED char const *type_description_9 = NULL;
    static struct Nuitka_FrameObject *cache_frame_01fcb8cd929b0c4b32cd16ad15de112a_9 = NULL;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *locals_contextlib_319 = NULL;
    struct Nuitka_FrameObject *frame_d7fd5dc9be95290492bee556cea09260_10;
    NUITKA_MAY_BE_UNUSED char const *type_description_10 = NULL;
    static struct Nuitka_FrameObject *cache_frame_d7fd5dc9be95290492bee556cea09260_10 = NULL;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *locals_contextlib_335 = NULL;
    struct Nuitka_FrameObject *frame_87f04e9c08916a537b9d28a0c7179091_11;
    NUITKA_MAY_BE_UNUSED char const *type_description_11 = NULL;
    static struct Nuitka_FrameObject *cache_frame_87f04e9c08916a537b9d28a0c7179091_11 = NULL;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;
    PyObject *locals_contextlib_341 = NULL;
    struct Nuitka_FrameObject *frame_780dcd518a86239b52f6ae1915c129d3_12;
    NUITKA_MAY_BE_UNUSED char const *type_description_12 = NULL;
    static struct Nuitka_FrameObject *cache_frame_780dcd518a86239b52f6ae1915c129d3_12 = NULL;
    PyObject *exception_keeper_type_31;
    PyObject *exception_keeper_value_31;
    PyTracebackObject *exception_keeper_tb_31;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_31;
    PyObject *exception_keeper_type_32;
    PyObject *exception_keeper_value_32;
    PyTracebackObject *exception_keeper_tb_32;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_32;
    PyObject *exception_keeper_type_33;
    PyObject *exception_keeper_value_33;
    PyTracebackObject *exception_keeper_tb_33;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_33;
    PyObject *locals_contextlib_371 = NULL;
    struct Nuitka_FrameObject *frame_5bce12272bd0320f1ba68a2377afbf7f_13;
    NUITKA_MAY_BE_UNUSED char const *type_description_13 = NULL;
    static struct Nuitka_FrameObject *cache_frame_5bce12272bd0320f1ba68a2377afbf7f_13 = NULL;
    PyObject *exception_keeper_type_34;
    PyObject *exception_keeper_value_34;
    PyTracebackObject *exception_keeper_tb_34;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_34;
    PyObject *exception_keeper_type_35;
    PyObject *exception_keeper_value_35;
    PyTracebackObject *exception_keeper_tb_35;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_35;
    PyObject *exception_keeper_type_36;
    PyObject *exception_keeper_value_36;
    PyTracebackObject *exception_keeper_tb_36;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_36;
    PyObject *locals_contextlib_454 = NULL;
    struct Nuitka_FrameObject *frame_4bcab7a51e5ec620770a43dbb3c4a947_14;
    NUITKA_MAY_BE_UNUSED char const *type_description_14 = NULL;
    static struct Nuitka_FrameObject *cache_frame_4bcab7a51e5ec620770a43dbb3c4a947_14 = NULL;
    PyObject *exception_keeper_type_37;
    PyObject *exception_keeper_value_37;
    PyTracebackObject *exception_keeper_tb_37;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_37;
    PyObject *exception_keeper_type_38;
    PyObject *exception_keeper_value_38;
    PyTracebackObject *exception_keeper_tb_38;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_38;
    PyObject *exception_keeper_type_39;
    PyObject *exception_keeper_value_39;
    PyTracebackObject *exception_keeper_tb_39;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_39;
    PyObject *locals_contextlib_523 = NULL;
    struct Nuitka_FrameObject *frame_10e144bd8ccb0415c605cd7bc640b3ce_15;
    NUITKA_MAY_BE_UNUSED char const *type_description_15 = NULL;
    static struct Nuitka_FrameObject *cache_frame_10e144bd8ccb0415c605cd7bc640b3ce_15 = NULL;
    PyObject *exception_keeper_type_40;
    PyObject *exception_keeper_value_40;
    PyTracebackObject *exception_keeper_tb_40;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_40;
    PyObject *exception_keeper_type_41;
    PyObject *exception_keeper_value_41;
    PyTracebackObject *exception_keeper_tb_41;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_41;
    PyObject *exception_keeper_type_42;
    PyObject *exception_keeper_value_42;
    PyTracebackObject *exception_keeper_tb_42;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_42;
    PyObject *locals_contextlib_659 = NULL;
    struct Nuitka_FrameObject *frame_2415601356a99a081119e44dfac162fa_16;
    NUITKA_MAY_BE_UNUSED char const *type_description_16 = NULL;
    static struct Nuitka_FrameObject *cache_frame_2415601356a99a081119e44dfac162fa_16 = NULL;
    PyObject *exception_keeper_type_43;
    PyObject *exception_keeper_value_43;
    PyTracebackObject *exception_keeper_tb_43;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_43;
    PyObject *exception_keeper_type_44;
    PyObject *exception_keeper_value_44;
    PyTracebackObject *exception_keeper_tb_44;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_44;
    PyObject *exception_keeper_type_45;
    PyObject *exception_keeper_value_45;
    PyTracebackObject *exception_keeper_tb_45;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_45;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = const_str_digest_196928cdda2f74dcaa86496536d7d0c7;
        UPDATE_STRING_DICT0( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = module_filename_obj;
        UPDATE_STRING_DICT0( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    }
    // Frame without reuse.
    frame_16be74c7884d209762a4409719331de6 = MAKE_MODULE_FRAME( codeobj_16be74c7884d209762a4409719331de6, module_contextlib );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_16be74c7884d209762a4409719331de6 );
    assert( Py_REFCNT( frame_16be74c7884d209762a4409719331de6 ) == 2 );

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        PyObject *tmp_mvar_value_1;
        tmp_assattr_name_1 = module_filename_obj;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___spec__ );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___spec__ );
        }

        CHECK_OBJECT( tmp_mvar_value_1 );
        tmp_assattr_target_1 = tmp_mvar_value_1;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_origin, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1;

            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        PyObject *tmp_mvar_value_2;
        tmp_assattr_name_2 = Py_True;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___spec__ );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___spec__ );
        }

        CHECK_OBJECT( tmp_mvar_value_2 );
        tmp_assattr_target_2 = tmp_mvar_value_2;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_has_location, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1;

            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = Py_None;
        UPDATE_STRING_DICT0( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___cached__, tmp_assign_source_3 );
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        PyObject *tmp_level_name_1;
        tmp_name_name_1 = const_str_plain_abc;
        tmp_globals_name_1 = (PyObject *)moduledict_contextlib;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = Py_None;
        tmp_level_name_1 = const_int_0;
        frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 2;
        tmp_assign_source_4 = IMPORT_MODULE5( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1, tmp_level_name_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_abc, tmp_assign_source_4 );
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        PyObject *tmp_level_name_2;
        tmp_name_name_2 = const_str_plain_sys;
        tmp_globals_name_2 = (PyObject *)moduledict_contextlib;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = Py_None;
        tmp_level_name_2 = const_int_0;
        frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 3;
        tmp_assign_source_5 = IMPORT_MODULE5( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2, tmp_level_name_2 );
        assert( !(tmp_assign_source_5 == NULL) );
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_sys, tmp_assign_source_5 );
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_name_name_3;
        PyObject *tmp_globals_name_3;
        PyObject *tmp_locals_name_3;
        PyObject *tmp_fromlist_name_3;
        PyObject *tmp_level_name_3;
        tmp_name_name_3 = const_str_plain__collections_abc;
        tmp_globals_name_3 = (PyObject *)moduledict_contextlib;
        tmp_locals_name_3 = Py_None;
        tmp_fromlist_name_3 = Py_None;
        tmp_level_name_3 = const_int_0;
        frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 4;
        tmp_assign_source_6 = IMPORT_MODULE5( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3, tmp_level_name_3 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 4;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__collections_abc, tmp_assign_source_6 );
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_4;
        PyObject *tmp_globals_name_4;
        PyObject *tmp_locals_name_4;
        PyObject *tmp_fromlist_name_4;
        PyObject *tmp_level_name_4;
        tmp_name_name_4 = const_str_plain_collections;
        tmp_globals_name_4 = (PyObject *)moduledict_contextlib;
        tmp_locals_name_4 = Py_None;
        tmp_fromlist_name_4 = const_tuple_str_plain_deque_tuple;
        tmp_level_name_4 = const_int_0;
        frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 5;
        tmp_import_name_from_1 = IMPORT_MODULE5( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4, tmp_level_name_4 );
        if ( tmp_import_name_from_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 5;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_7 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_deque );
        Py_DECREF( tmp_import_name_from_1 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 5;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_deque, tmp_assign_source_7 );
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_import_name_from_2;
        PyObject *tmp_name_name_5;
        PyObject *tmp_globals_name_5;
        PyObject *tmp_locals_name_5;
        PyObject *tmp_fromlist_name_5;
        PyObject *tmp_level_name_5;
        tmp_name_name_5 = const_str_plain_functools;
        tmp_globals_name_5 = (PyObject *)moduledict_contextlib;
        tmp_locals_name_5 = Py_None;
        tmp_fromlist_name_5 = const_tuple_str_plain_wraps_tuple;
        tmp_level_name_5 = const_int_0;
        frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 6;
        tmp_import_name_from_2 = IMPORT_MODULE5( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5, tmp_level_name_5 );
        if ( tmp_import_name_from_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 6;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_8 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_wraps );
        Py_DECREF( tmp_import_name_from_2 );
        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 6;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_wraps, tmp_assign_source_8 );
    }
    {
        PyObject *tmp_assign_source_9;
        tmp_assign_source_9 = LIST_COPY( const_list_af5b310e02bd439cf8ca1c65e737fe3b_list );
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___all__, tmp_assign_source_9 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_abc );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abc );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 14;

            goto try_except_handler_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ABC );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_1;
        }
        tmp_assign_source_10 = PyTuple_New( 1 );
        PyTuple_SET_ITEM( tmp_assign_source_10, 0, tmp_tuple_element_1 );
        assert( tmp_class_creation_1__bases_orig == NULL );
        tmp_class_creation_1__bases_orig = tmp_assign_source_10;
    }
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_dircall_arg1_1;
        CHECK_OBJECT( tmp_class_creation_1__bases_orig );
        tmp_dircall_arg1_1 = tmp_class_creation_1__bases_orig;
        Py_INCREF( tmp_dircall_arg1_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1};
            tmp_assign_source_11 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_1;
        }
        assert( tmp_class_creation_1__bases == NULL );
        tmp_class_creation_1__bases = tmp_assign_source_11;
    }
    {
        PyObject *tmp_assign_source_12;
        tmp_assign_source_12 = PyDict_New();
        assert( tmp_class_creation_1__class_decl_dict == NULL );
        tmp_class_creation_1__class_decl_dict = tmp_assign_source_12;
    }
    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_metaclass_name_1;
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_key_name_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_1;
        PyObject *tmp_type_arg_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_bases_name_1;
        tmp_key_name_1 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_1__class_decl_dict );
        tmp_dict_name_1 = tmp_class_creation_1__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_1, tmp_key_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_1;
        }
        else
        {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT( tmp_class_creation_1__class_decl_dict );
        tmp_dict_name_2 = tmp_class_creation_1__class_decl_dict;
        tmp_key_name_2 = const_str_plain_metaclass;
        tmp_metaclass_name_1 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
        if ( tmp_metaclass_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_1;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        CHECK_OBJECT( tmp_class_creation_1__bases );
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_class_creation_1__bases );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_2;
        }
        else
        {
            goto condexpr_false_2;
        }
        condexpr_true_2:;
        CHECK_OBJECT( tmp_class_creation_1__bases );
        tmp_subscribed_name_1 = tmp_class_creation_1__bases;
        tmp_subscript_name_1 = const_int_0;
        tmp_type_arg_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_type_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_1;
        }
        tmp_metaclass_name_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
        Py_DECREF( tmp_type_arg_1 );
        if ( tmp_metaclass_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_1;
        }
        goto condexpr_end_2;
        condexpr_false_2:;
        tmp_metaclass_name_1 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_1 );
        condexpr_end_2:;
        condexpr_end_1:;
        CHECK_OBJECT( tmp_class_creation_1__bases );
        tmp_bases_name_1 = tmp_class_creation_1__bases;
        tmp_assign_source_13 = SELECT_METACLASS( tmp_metaclass_name_1, tmp_bases_name_1 );
        Py_DECREF( tmp_metaclass_name_1 );
        if ( tmp_assign_source_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_1;
        }
        assert( tmp_class_creation_1__metaclass == NULL );
        tmp_class_creation_1__metaclass = tmp_assign_source_13;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_key_name_3;
        PyObject *tmp_dict_name_3;
        tmp_key_name_3 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_1__class_decl_dict );
        tmp_dict_name_3 = tmp_class_creation_1__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_3, tmp_key_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT( tmp_class_creation_1__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_1__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( tmp_class_creation_1__metaclass );
        tmp_source_name_2 = tmp_class_creation_1__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_2, const_str_plain___prepare__ );
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_14;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_name_1;
            PyObject *tmp_tuple_element_2;
            PyObject *tmp_kw_name_1;
            CHECK_OBJECT( tmp_class_creation_1__metaclass );
            tmp_source_name_3 = tmp_class_creation_1__metaclass;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___prepare__ );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 14;

                goto try_except_handler_1;
            }
            tmp_tuple_element_2 = const_str_plain_AbstractContextManager;
            tmp_args_name_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_2 );
            CHECK_OBJECT( tmp_class_creation_1__bases );
            tmp_tuple_element_2 = tmp_class_creation_1__bases;
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_2 );
            CHECK_OBJECT( tmp_class_creation_1__class_decl_dict );
            tmp_kw_name_1 = tmp_class_creation_1__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 14;
            tmp_assign_source_14 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );
            if ( tmp_assign_source_14 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 14;

                goto try_except_handler_1;
            }
            assert( tmp_class_creation_1__prepared == NULL );
            tmp_class_creation_1__prepared = tmp_assign_source_14;
        }
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_source_name_4;
            CHECK_OBJECT( tmp_class_creation_1__prepared );
            tmp_source_name_4 = tmp_class_creation_1__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_4, const_str_plain___getitem__ );
            tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 14;

                goto try_except_handler_1;
            }
            tmp_condition_result_5 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_raise_value_1;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_tuple_element_3;
                PyObject *tmp_getattr_target_1;
                PyObject *tmp_getattr_attr_1;
                PyObject *tmp_getattr_default_1;
                PyObject *tmp_source_name_5;
                PyObject *tmp_type_arg_2;
                tmp_raise_type_1 = PyExc_TypeError;
                tmp_left_name_1 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_1__metaclass );
                tmp_getattr_target_1 = tmp_class_creation_1__metaclass;
                tmp_getattr_attr_1 = const_str_plain___name__;
                tmp_getattr_default_1 = const_str_angle_metaclass;
                tmp_tuple_element_3 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1 );
                if ( tmp_tuple_element_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 14;

                    goto try_except_handler_1;
                }
                tmp_right_name_1 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_3 );
                CHECK_OBJECT( tmp_class_creation_1__prepared );
                tmp_type_arg_2 = tmp_class_creation_1__prepared;
                tmp_source_name_5 = BUILTIN_TYPE1( tmp_type_arg_2 );
                assert( !(tmp_source_name_5 == NULL) );
                tmp_tuple_element_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_5 );
                if ( tmp_tuple_element_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_1 );

                    exception_lineno = 14;

                    goto try_except_handler_1;
                }
                PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_3 );
                tmp_raise_value_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
                Py_DECREF( tmp_right_name_1 );
                if ( tmp_raise_value_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 14;

                    goto try_except_handler_1;
                }
                exception_type = tmp_raise_type_1;
                Py_INCREF( tmp_raise_type_1 );
                exception_value = tmp_raise_value_1;
                exception_lineno = 14;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_1;
            }
            branch_no_3:;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_15;
            tmp_assign_source_15 = PyDict_New();
            assert( tmp_class_creation_1__prepared == NULL );
            tmp_class_creation_1__prepared = tmp_assign_source_15;
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_assign_source_16;
        {
            PyObject *tmp_set_locals_1;
            CHECK_OBJECT( tmp_class_creation_1__prepared );
            tmp_set_locals_1 = tmp_class_creation_1__prepared;
            locals_contextlib_14 = tmp_set_locals_1;
            Py_INCREF( tmp_set_locals_1 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_14, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_3;
        }
        tmp_dictset_value = const_str_digest_5622473d84a607757f5490c88c2fc06a;
        tmp_res = PyObject_SetItem( locals_contextlib_14, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_3;
        }
        tmp_dictset_value = const_str_plain_AbstractContextManager;
        tmp_res = PyObject_SetItem( locals_contextlib_14, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto try_except_handler_3;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_4035f91cc3ac63d7d4c73c33cc6faa55_2, codeobj_4035f91cc3ac63d7d4c73c33cc6faa55, module_contextlib, sizeof(void *) );
        frame_4035f91cc3ac63d7d4c73c33cc6faa55_2 = cache_frame_4035f91cc3ac63d7d4c73c33cc6faa55_2;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_4035f91cc3ac63d7d4c73c33cc6faa55_2 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_4035f91cc3ac63d7d4c73c33cc6faa55_2 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_1___enter__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_14, const_str_plain___enter__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 18;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_1;
            tmp_called_instance_1 = PyObject_GetItem( locals_contextlib_14, const_str_plain_abc );

            if ( tmp_called_instance_1 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_abc );

                if (unlikely( tmp_mvar_value_4 == NULL ))
                {
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abc );
                }

                if ( tmp_mvar_value_4 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abc" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 22;
                    type_description_2 = "o";
                    goto frame_exception_exit_2;
                }

                tmp_called_instance_1 = tmp_mvar_value_4;
                Py_INCREF( tmp_called_instance_1 );
                }
            }

            tmp_args_element_name_1 = MAKE_FUNCTION_contextlib$$$function_2___exit__(  );



            frame_4035f91cc3ac63d7d4c73c33cc6faa55_2->m_frame.f_lineno = 22;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_abstractmethod, call_args );
            }

            Py_DECREF( tmp_called_instance_1 );
            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 22;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_res = PyObject_SetItem( locals_contextlib_14, const_str_plain___exit__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 22;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_6;
            PyObject *tmp_called_name_2;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_classmethod_arg_1;
            tmp_res = MAPPING_HAS_ITEM( locals_contextlib_14, const_str_plain_classmethod );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 27;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_6 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_3;
            }
            else
            {
                goto condexpr_false_3;
            }
            condexpr_true_3:;
            tmp_called_name_2 = PyObject_GetItem( locals_contextlib_14, const_str_plain_classmethod );

            if ( tmp_called_name_2 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "classmethod" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 27;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 27;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_2 = MAKE_FUNCTION_contextlib$$$function_3___subclasshook__(  );



            frame_4035f91cc3ac63d7d4c73c33cc6faa55_2->m_frame.f_lineno = 27;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 27;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_3;
            condexpr_false_3:;
            tmp_classmethod_arg_1 = MAKE_FUNCTION_contextlib$$$function_3___subclasshook__(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_1 );
            Py_DECREF( tmp_classmethod_arg_1 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 27;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_3:;
            tmp_res = PyObject_SetItem( locals_contextlib_14, const_str_plain___subclasshook__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 27;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_4035f91cc3ac63d7d4c73c33cc6faa55_2 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_4035f91cc3ac63d7d4c73c33cc6faa55_2 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_4035f91cc3ac63d7d4c73c33cc6faa55_2, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_4035f91cc3ac63d7d4c73c33cc6faa55_2->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_4035f91cc3ac63d7d4c73c33cc6faa55_2, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_4035f91cc3ac63d7d4c73c33cc6faa55_2,
            type_description_2,
            outline_0_var___class__
        );


        // Release cached frame.
        if ( frame_4035f91cc3ac63d7d4c73c33cc6faa55_2 == cache_frame_4035f91cc3ac63d7d4c73c33cc6faa55_2 )
        {
            Py_DECREF( frame_4035f91cc3ac63d7d4c73c33cc6faa55_2 );
        }
        cache_frame_4035f91cc3ac63d7d4c73c33cc6faa55_2 = NULL;

        assertFrameObject( frame_4035f91cc3ac63d7d4c73c33cc6faa55_2 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;

        goto try_except_handler_3;
        skip_nested_handling_1:;
        {
            nuitka_bool tmp_condition_result_7;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            CHECK_OBJECT( tmp_class_creation_1__bases );
            tmp_compexpr_left_1 = tmp_class_creation_1__bases;
            CHECK_OBJECT( tmp_class_creation_1__bases_orig );
            tmp_compexpr_right_1 = tmp_class_creation_1__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 14;

                goto try_except_handler_3;
            }
            tmp_condition_result_7 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            CHECK_OBJECT( tmp_class_creation_1__bases_orig );
            tmp_dictset_value = tmp_class_creation_1__bases_orig;
            tmp_res = PyObject_SetItem( locals_contextlib_14, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 14;

                goto try_except_handler_3;
            }
            branch_no_4:;
        }
        {
            PyObject *tmp_assign_source_17;
            PyObject *tmp_called_name_3;
            PyObject *tmp_args_name_2;
            PyObject *tmp_tuple_element_4;
            PyObject *tmp_kw_name_2;
            CHECK_OBJECT( tmp_class_creation_1__metaclass );
            tmp_called_name_3 = tmp_class_creation_1__metaclass;
            tmp_tuple_element_4 = const_str_plain_AbstractContextManager;
            tmp_args_name_2 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_4 );
            PyTuple_SET_ITEM( tmp_args_name_2, 0, tmp_tuple_element_4 );
            CHECK_OBJECT( tmp_class_creation_1__bases );
            tmp_tuple_element_4 = tmp_class_creation_1__bases;
            Py_INCREF( tmp_tuple_element_4 );
            PyTuple_SET_ITEM( tmp_args_name_2, 1, tmp_tuple_element_4 );
            tmp_tuple_element_4 = locals_contextlib_14;
            Py_INCREF( tmp_tuple_element_4 );
            PyTuple_SET_ITEM( tmp_args_name_2, 2, tmp_tuple_element_4 );
            CHECK_OBJECT( tmp_class_creation_1__class_decl_dict );
            tmp_kw_name_2 = tmp_class_creation_1__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 14;
            tmp_assign_source_17 = CALL_FUNCTION( tmp_called_name_3, tmp_args_name_2, tmp_kw_name_2 );
            Py_DECREF( tmp_args_name_2 );
            if ( tmp_assign_source_17 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 14;

                goto try_except_handler_3;
            }
            assert( outline_0_var___class__ == NULL );
            outline_0_var___class__ = tmp_assign_source_17;
        }
        CHECK_OBJECT( outline_0_var___class__ );
        tmp_assign_source_16 = outline_0_var___class__;
        Py_INCREF( tmp_assign_source_16 );
        goto try_return_handler_3;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_3:;
        Py_DECREF( locals_contextlib_14 );
        locals_contextlib_14 = NULL;
        goto try_return_handler_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_14 );
        locals_contextlib_14 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto try_except_handler_2;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)outline_0_var___class__ );
        Py_DECREF( outline_0_var___class__ );
        outline_0_var___class__ = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_1:;
        exception_lineno = 14;
        goto try_except_handler_1;
        outline_result_1:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AbstractContextManager, tmp_assign_source_16 );
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_1__bases_orig );
    tmp_class_creation_1__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    Py_XDECREF( tmp_class_creation_1__class_decl_dict );
    tmp_class_creation_1__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_1__prepared );
    tmp_class_creation_1__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases_orig );
    Py_DECREF( tmp_class_creation_1__bases_orig );
    tmp_class_creation_1__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_decl_dict );
    Py_DECREF( tmp_class_creation_1__class_decl_dict );
    tmp_class_creation_1__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__prepared );
    Py_DECREF( tmp_class_creation_1__prepared );
    tmp_class_creation_1__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_18;
        PyObject *tmp_tuple_element_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_abc );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abc );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 34;

            goto try_except_handler_4;
        }

        tmp_source_name_6 = tmp_mvar_value_5;
        tmp_tuple_element_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_ABC );
        if ( tmp_tuple_element_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_4;
        }
        tmp_assign_source_18 = PyTuple_New( 1 );
        PyTuple_SET_ITEM( tmp_assign_source_18, 0, tmp_tuple_element_5 );
        assert( tmp_class_creation_2__bases_orig == NULL );
        tmp_class_creation_2__bases_orig = tmp_assign_source_18;
    }
    {
        PyObject *tmp_assign_source_19;
        PyObject *tmp_dircall_arg1_2;
        CHECK_OBJECT( tmp_class_creation_2__bases_orig );
        tmp_dircall_arg1_2 = tmp_class_creation_2__bases_orig;
        Py_INCREF( tmp_dircall_arg1_2 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_2};
            tmp_assign_source_19 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_19 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_4;
        }
        assert( tmp_class_creation_2__bases == NULL );
        tmp_class_creation_2__bases = tmp_assign_source_19;
    }
    {
        PyObject *tmp_assign_source_20;
        tmp_assign_source_20 = PyDict_New();
        assert( tmp_class_creation_2__class_decl_dict == NULL );
        tmp_class_creation_2__class_decl_dict = tmp_assign_source_20;
    }
    {
        PyObject *tmp_assign_source_21;
        PyObject *tmp_metaclass_name_2;
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_key_name_4;
        PyObject *tmp_dict_name_4;
        PyObject *tmp_dict_name_5;
        PyObject *tmp_key_name_5;
        nuitka_bool tmp_condition_result_9;
        int tmp_truth_name_2;
        PyObject *tmp_type_arg_3;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_bases_name_2;
        tmp_key_name_4 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_2__class_decl_dict );
        tmp_dict_name_4 = tmp_class_creation_2__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_4, tmp_key_name_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_4;
        }
        tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_4;
        }
        else
        {
            goto condexpr_false_4;
        }
        condexpr_true_4:;
        CHECK_OBJECT( tmp_class_creation_2__class_decl_dict );
        tmp_dict_name_5 = tmp_class_creation_2__class_decl_dict;
        tmp_key_name_5 = const_str_plain_metaclass;
        tmp_metaclass_name_2 = DICT_GET_ITEM( tmp_dict_name_5, tmp_key_name_5 );
        if ( tmp_metaclass_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_4;
        }
        goto condexpr_end_4;
        condexpr_false_4:;
        CHECK_OBJECT( tmp_class_creation_2__bases );
        tmp_truth_name_2 = CHECK_IF_TRUE( tmp_class_creation_2__bases );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_4;
        }
        tmp_condition_result_9 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_5;
        }
        else
        {
            goto condexpr_false_5;
        }
        condexpr_true_5:;
        CHECK_OBJECT( tmp_class_creation_2__bases );
        tmp_subscribed_name_2 = tmp_class_creation_2__bases;
        tmp_subscript_name_2 = const_int_0;
        tmp_type_arg_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
        if ( tmp_type_arg_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_4;
        }
        tmp_metaclass_name_2 = BUILTIN_TYPE1( tmp_type_arg_3 );
        Py_DECREF( tmp_type_arg_3 );
        if ( tmp_metaclass_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_4;
        }
        goto condexpr_end_5;
        condexpr_false_5:;
        tmp_metaclass_name_2 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_2 );
        condexpr_end_5:;
        condexpr_end_4:;
        CHECK_OBJECT( tmp_class_creation_2__bases );
        tmp_bases_name_2 = tmp_class_creation_2__bases;
        tmp_assign_source_21 = SELECT_METACLASS( tmp_metaclass_name_2, tmp_bases_name_2 );
        Py_DECREF( tmp_metaclass_name_2 );
        if ( tmp_assign_source_21 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_4;
        }
        assert( tmp_class_creation_2__metaclass == NULL );
        tmp_class_creation_2__metaclass = tmp_assign_source_21;
    }
    {
        nuitka_bool tmp_condition_result_10;
        PyObject *tmp_key_name_6;
        PyObject *tmp_dict_name_6;
        tmp_key_name_6 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_2__class_decl_dict );
        tmp_dict_name_6 = tmp_class_creation_2__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_6, tmp_key_name_6 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_4;
        }
        tmp_condition_result_10 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        CHECK_OBJECT( tmp_class_creation_2__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_2__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_4;
        }
        branch_no_5:;
    }
    {
        nuitka_bool tmp_condition_result_11;
        PyObject *tmp_source_name_7;
        CHECK_OBJECT( tmp_class_creation_2__metaclass );
        tmp_source_name_7 = tmp_class_creation_2__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_7, const_str_plain___prepare__ );
        tmp_condition_result_11 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_assign_source_22;
            PyObject *tmp_called_name_4;
            PyObject *tmp_source_name_8;
            PyObject *tmp_args_name_3;
            PyObject *tmp_tuple_element_6;
            PyObject *tmp_kw_name_3;
            CHECK_OBJECT( tmp_class_creation_2__metaclass );
            tmp_source_name_8 = tmp_class_creation_2__metaclass;
            tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___prepare__ );
            if ( tmp_called_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 34;

                goto try_except_handler_4;
            }
            tmp_tuple_element_6 = const_str_plain_AbstractAsyncContextManager;
            tmp_args_name_3 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_6 );
            PyTuple_SET_ITEM( tmp_args_name_3, 0, tmp_tuple_element_6 );
            CHECK_OBJECT( tmp_class_creation_2__bases );
            tmp_tuple_element_6 = tmp_class_creation_2__bases;
            Py_INCREF( tmp_tuple_element_6 );
            PyTuple_SET_ITEM( tmp_args_name_3, 1, tmp_tuple_element_6 );
            CHECK_OBJECT( tmp_class_creation_2__class_decl_dict );
            tmp_kw_name_3 = tmp_class_creation_2__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 34;
            tmp_assign_source_22 = CALL_FUNCTION( tmp_called_name_4, tmp_args_name_3, tmp_kw_name_3 );
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_name_3 );
            if ( tmp_assign_source_22 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 34;

                goto try_except_handler_4;
            }
            assert( tmp_class_creation_2__prepared == NULL );
            tmp_class_creation_2__prepared = tmp_assign_source_22;
        }
        {
            nuitka_bool tmp_condition_result_12;
            PyObject *tmp_operand_name_2;
            PyObject *tmp_source_name_9;
            CHECK_OBJECT( tmp_class_creation_2__prepared );
            tmp_source_name_9 = tmp_class_creation_2__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_9, const_str_plain___getitem__ );
            tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 34;

                goto try_except_handler_4;
            }
            tmp_condition_result_12 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_12 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_7;
            }
            else
            {
                goto branch_no_7;
            }
            branch_yes_7:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_raise_value_2;
                PyObject *tmp_left_name_2;
                PyObject *tmp_right_name_2;
                PyObject *tmp_tuple_element_7;
                PyObject *tmp_getattr_target_2;
                PyObject *tmp_getattr_attr_2;
                PyObject *tmp_getattr_default_2;
                PyObject *tmp_source_name_10;
                PyObject *tmp_type_arg_4;
                tmp_raise_type_2 = PyExc_TypeError;
                tmp_left_name_2 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_2__metaclass );
                tmp_getattr_target_2 = tmp_class_creation_2__metaclass;
                tmp_getattr_attr_2 = const_str_plain___name__;
                tmp_getattr_default_2 = const_str_angle_metaclass;
                tmp_tuple_element_7 = BUILTIN_GETATTR( tmp_getattr_target_2, tmp_getattr_attr_2, tmp_getattr_default_2 );
                if ( tmp_tuple_element_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 34;

                    goto try_except_handler_4;
                }
                tmp_right_name_2 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_7 );
                CHECK_OBJECT( tmp_class_creation_2__prepared );
                tmp_type_arg_4 = tmp_class_creation_2__prepared;
                tmp_source_name_10 = BUILTIN_TYPE1( tmp_type_arg_4 );
                assert( !(tmp_source_name_10 == NULL) );
                tmp_tuple_element_7 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_10 );
                if ( tmp_tuple_element_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_2 );

                    exception_lineno = 34;

                    goto try_except_handler_4;
                }
                PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_7 );
                tmp_raise_value_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
                Py_DECREF( tmp_right_name_2 );
                if ( tmp_raise_value_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 34;

                    goto try_except_handler_4;
                }
                exception_type = tmp_raise_type_2;
                Py_INCREF( tmp_raise_type_2 );
                exception_value = tmp_raise_value_2;
                exception_lineno = 34;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_4;
            }
            branch_no_7:;
        }
        goto branch_end_6;
        branch_no_6:;
        {
            PyObject *tmp_assign_source_23;
            tmp_assign_source_23 = PyDict_New();
            assert( tmp_class_creation_2__prepared == NULL );
            tmp_class_creation_2__prepared = tmp_assign_source_23;
        }
        branch_end_6:;
    }
    {
        PyObject *tmp_assign_source_24;
        {
            PyObject *tmp_set_locals_2;
            CHECK_OBJECT( tmp_class_creation_2__prepared );
            tmp_set_locals_2 = tmp_class_creation_2__prepared;
            locals_contextlib_34 = tmp_set_locals_2;
            Py_INCREF( tmp_set_locals_2 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_34, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_6;
        }
        tmp_dictset_value = const_str_digest_292ad321106653ddbe62f853458ccdc4;
        tmp_res = PyObject_SetItem( locals_contextlib_34, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_6;
        }
        tmp_dictset_value = const_str_plain_AbstractAsyncContextManager;
        tmp_res = PyObject_SetItem( locals_contextlib_34, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;

            goto try_except_handler_6;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_5b202f99d1876fb8487deeef8d71a950_3, codeobj_5b202f99d1876fb8487deeef8d71a950, module_contextlib, sizeof(void *) );
        frame_5b202f99d1876fb8487deeef8d71a950_3 = cache_frame_5b202f99d1876fb8487deeef8d71a950_3;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_5b202f99d1876fb8487deeef8d71a950_3 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_5b202f99d1876fb8487deeef8d71a950_3 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_4___aenter__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_34, const_str_plain___aenter__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 38;
            type_description_2 = "o";
            goto frame_exception_exit_3;
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_3;
            tmp_called_instance_2 = PyObject_GetItem( locals_contextlib_34, const_str_plain_abc );

            if ( tmp_called_instance_2 == NULL )
            {
                if ( CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_abc );

                if (unlikely( tmp_mvar_value_6 == NULL ))
                {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_abc );
                }

                if ( tmp_mvar_value_6 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "abc" );
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                    CHAIN_EXCEPTION( exception_value );

                    exception_lineno = 42;
                    type_description_2 = "o";
                    goto frame_exception_exit_3;
                }

                tmp_called_instance_2 = tmp_mvar_value_6;
                Py_INCREF( tmp_called_instance_2 );
                }
            }

            tmp_args_element_name_3 = MAKE_FUNCTION_contextlib$$$function_5___aexit__(  );



            frame_5b202f99d1876fb8487deeef8d71a950_3->m_frame.f_lineno = 42;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_abstractmethod, call_args );
            }

            Py_DECREF( tmp_called_instance_2 );
            Py_DECREF( tmp_args_element_name_3 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 42;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_res = PyObject_SetItem( locals_contextlib_34, const_str_plain___aexit__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 42;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_13;
            PyObject *tmp_called_name_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_classmethod_arg_2;
            tmp_res = MAPPING_HAS_ITEM( locals_contextlib_34, const_str_plain_classmethod );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 47;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_13 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_13 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_6;
            }
            else
            {
                goto condexpr_false_6;
            }
            condexpr_true_6:;
            tmp_called_name_5 = PyObject_GetItem( locals_contextlib_34, const_str_plain_classmethod );

            if ( tmp_called_name_5 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "classmethod" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 47;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if ( tmp_called_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 47;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_4 = MAKE_FUNCTION_contextlib$$$function_6___subclasshook__(  );



            frame_5b202f99d1876fb8487deeef8d71a950_3->m_frame.f_lineno = 47;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
            }

            Py_DECREF( tmp_called_name_5 );
            Py_DECREF( tmp_args_element_name_4 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 47;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_6;
            condexpr_false_6:;
            tmp_classmethod_arg_2 = MAKE_FUNCTION_contextlib$$$function_6___subclasshook__(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_2 );
            Py_DECREF( tmp_classmethod_arg_2 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 47;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_6:;
            tmp_res = PyObject_SetItem( locals_contextlib_34, const_str_plain___subclasshook__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 47;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_5b202f99d1876fb8487deeef8d71a950_3 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_2;

        frame_exception_exit_3:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_5b202f99d1876fb8487deeef8d71a950_3 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_5b202f99d1876fb8487deeef8d71a950_3, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_5b202f99d1876fb8487deeef8d71a950_3->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_5b202f99d1876fb8487deeef8d71a950_3, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_5b202f99d1876fb8487deeef8d71a950_3,
            type_description_2,
            outline_1_var___class__
        );


        // Release cached frame.
        if ( frame_5b202f99d1876fb8487deeef8d71a950_3 == cache_frame_5b202f99d1876fb8487deeef8d71a950_3 )
        {
            Py_DECREF( frame_5b202f99d1876fb8487deeef8d71a950_3 );
        }
        cache_frame_5b202f99d1876fb8487deeef8d71a950_3 = NULL;

        assertFrameObject( frame_5b202f99d1876fb8487deeef8d71a950_3 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_2;

        frame_no_exception_2:;
        goto skip_nested_handling_2;
        nested_frame_exit_2:;

        goto try_except_handler_6;
        skip_nested_handling_2:;
        {
            nuitka_bool tmp_condition_result_14;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( tmp_class_creation_2__bases );
            tmp_compexpr_left_2 = tmp_class_creation_2__bases;
            CHECK_OBJECT( tmp_class_creation_2__bases_orig );
            tmp_compexpr_right_2 = tmp_class_creation_2__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 34;

                goto try_except_handler_6;
            }
            tmp_condition_result_14 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_14 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_8;
            }
            else
            {
                goto branch_no_8;
            }
            branch_yes_8:;
            CHECK_OBJECT( tmp_class_creation_2__bases_orig );
            tmp_dictset_value = tmp_class_creation_2__bases_orig;
            tmp_res = PyObject_SetItem( locals_contextlib_34, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 34;

                goto try_except_handler_6;
            }
            branch_no_8:;
        }
        {
            PyObject *tmp_assign_source_25;
            PyObject *tmp_called_name_6;
            PyObject *tmp_args_name_4;
            PyObject *tmp_tuple_element_8;
            PyObject *tmp_kw_name_4;
            CHECK_OBJECT( tmp_class_creation_2__metaclass );
            tmp_called_name_6 = tmp_class_creation_2__metaclass;
            tmp_tuple_element_8 = const_str_plain_AbstractAsyncContextManager;
            tmp_args_name_4 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_8 );
            PyTuple_SET_ITEM( tmp_args_name_4, 0, tmp_tuple_element_8 );
            CHECK_OBJECT( tmp_class_creation_2__bases );
            tmp_tuple_element_8 = tmp_class_creation_2__bases;
            Py_INCREF( tmp_tuple_element_8 );
            PyTuple_SET_ITEM( tmp_args_name_4, 1, tmp_tuple_element_8 );
            tmp_tuple_element_8 = locals_contextlib_34;
            Py_INCREF( tmp_tuple_element_8 );
            PyTuple_SET_ITEM( tmp_args_name_4, 2, tmp_tuple_element_8 );
            CHECK_OBJECT( tmp_class_creation_2__class_decl_dict );
            tmp_kw_name_4 = tmp_class_creation_2__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 34;
            tmp_assign_source_25 = CALL_FUNCTION( tmp_called_name_6, tmp_args_name_4, tmp_kw_name_4 );
            Py_DECREF( tmp_args_name_4 );
            if ( tmp_assign_source_25 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 34;

                goto try_except_handler_6;
            }
            assert( outline_1_var___class__ == NULL );
            outline_1_var___class__ = tmp_assign_source_25;
        }
        CHECK_OBJECT( outline_1_var___class__ );
        tmp_assign_source_24 = outline_1_var___class__;
        Py_INCREF( tmp_assign_source_24 );
        goto try_return_handler_6;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_6:;
        Py_DECREF( locals_contextlib_34 );
        locals_contextlib_34 = NULL;
        goto try_return_handler_5;
        // Exception handler code:
        try_except_handler_6:;
        exception_keeper_type_4 = exception_type;
        exception_keeper_value_4 = exception_value;
        exception_keeper_tb_4 = exception_tb;
        exception_keeper_lineno_4 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_34 );
        locals_contextlib_34 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_4;
        exception_value = exception_keeper_value_4;
        exception_tb = exception_keeper_tb_4;
        exception_lineno = exception_keeper_lineno_4;

        goto try_except_handler_5;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_5:;
        CHECK_OBJECT( (PyObject *)outline_1_var___class__ );
        Py_DECREF( outline_1_var___class__ );
        outline_1_var___class__ = NULL;

        goto outline_result_2;
        // Exception handler code:
        try_except_handler_5:;
        exception_keeper_type_5 = exception_type;
        exception_keeper_value_5 = exception_value;
        exception_keeper_tb_5 = exception_tb;
        exception_keeper_lineno_5 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_5;
        exception_value = exception_keeper_value_5;
        exception_tb = exception_keeper_tb_5;
        exception_lineno = exception_keeper_lineno_5;

        goto outline_exception_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_2:;
        exception_lineno = 34;
        goto try_except_handler_4;
        outline_result_2:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AbstractAsyncContextManager, tmp_assign_source_24 );
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_2__bases_orig );
    tmp_class_creation_2__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_2__bases );
    tmp_class_creation_2__bases = NULL;

    Py_XDECREF( tmp_class_creation_2__class_decl_dict );
    tmp_class_creation_2__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_2__prepared );
    tmp_class_creation_2__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__bases_orig );
    Py_DECREF( tmp_class_creation_2__bases_orig );
    tmp_class_creation_2__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__bases );
    Py_DECREF( tmp_class_creation_2__bases );
    tmp_class_creation_2__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_decl_dict );
    Py_DECREF( tmp_class_creation_2__class_decl_dict );
    tmp_class_creation_2__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__prepared );
    Py_DECREF( tmp_class_creation_2__prepared );
    tmp_class_creation_2__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_26;
        PyObject *tmp_dircall_arg1_3;
        tmp_dircall_arg1_3 = const_tuple_type_object_tuple;
        Py_INCREF( tmp_dircall_arg1_3 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_3};
            tmp_assign_source_26 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_26 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 55;

            goto try_except_handler_7;
        }
        assert( tmp_class_creation_3__bases == NULL );
        tmp_class_creation_3__bases = tmp_assign_source_26;
    }
    {
        PyObject *tmp_assign_source_27;
        tmp_assign_source_27 = PyDict_New();
        assert( tmp_class_creation_3__class_decl_dict == NULL );
        tmp_class_creation_3__class_decl_dict = tmp_assign_source_27;
    }
    {
        PyObject *tmp_assign_source_28;
        PyObject *tmp_metaclass_name_3;
        nuitka_bool tmp_condition_result_15;
        PyObject *tmp_key_name_7;
        PyObject *tmp_dict_name_7;
        PyObject *tmp_dict_name_8;
        PyObject *tmp_key_name_8;
        nuitka_bool tmp_condition_result_16;
        int tmp_truth_name_3;
        PyObject *tmp_type_arg_5;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_bases_name_3;
        tmp_key_name_7 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_3__class_decl_dict );
        tmp_dict_name_7 = tmp_class_creation_3__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_7, tmp_key_name_7 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 55;

            goto try_except_handler_7;
        }
        tmp_condition_result_15 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_15 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_7;
        }
        else
        {
            goto condexpr_false_7;
        }
        condexpr_true_7:;
        CHECK_OBJECT( tmp_class_creation_3__class_decl_dict );
        tmp_dict_name_8 = tmp_class_creation_3__class_decl_dict;
        tmp_key_name_8 = const_str_plain_metaclass;
        tmp_metaclass_name_3 = DICT_GET_ITEM( tmp_dict_name_8, tmp_key_name_8 );
        if ( tmp_metaclass_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 55;

            goto try_except_handler_7;
        }
        goto condexpr_end_7;
        condexpr_false_7:;
        CHECK_OBJECT( tmp_class_creation_3__bases );
        tmp_truth_name_3 = CHECK_IF_TRUE( tmp_class_creation_3__bases );
        if ( tmp_truth_name_3 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 55;

            goto try_except_handler_7;
        }
        tmp_condition_result_16 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_16 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_8;
        }
        else
        {
            goto condexpr_false_8;
        }
        condexpr_true_8:;
        CHECK_OBJECT( tmp_class_creation_3__bases );
        tmp_subscribed_name_3 = tmp_class_creation_3__bases;
        tmp_subscript_name_3 = const_int_0;
        tmp_type_arg_5 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
        if ( tmp_type_arg_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 55;

            goto try_except_handler_7;
        }
        tmp_metaclass_name_3 = BUILTIN_TYPE1( tmp_type_arg_5 );
        Py_DECREF( tmp_type_arg_5 );
        if ( tmp_metaclass_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 55;

            goto try_except_handler_7;
        }
        goto condexpr_end_8;
        condexpr_false_8:;
        tmp_metaclass_name_3 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_3 );
        condexpr_end_8:;
        condexpr_end_7:;
        CHECK_OBJECT( tmp_class_creation_3__bases );
        tmp_bases_name_3 = tmp_class_creation_3__bases;
        tmp_assign_source_28 = SELECT_METACLASS( tmp_metaclass_name_3, tmp_bases_name_3 );
        Py_DECREF( tmp_metaclass_name_3 );
        if ( tmp_assign_source_28 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 55;

            goto try_except_handler_7;
        }
        assert( tmp_class_creation_3__metaclass == NULL );
        tmp_class_creation_3__metaclass = tmp_assign_source_28;
    }
    {
        nuitka_bool tmp_condition_result_17;
        PyObject *tmp_key_name_9;
        PyObject *tmp_dict_name_9;
        tmp_key_name_9 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_3__class_decl_dict );
        tmp_dict_name_9 = tmp_class_creation_3__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_9, tmp_key_name_9 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 55;

            goto try_except_handler_7;
        }
        tmp_condition_result_17 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_17 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_9;
        }
        else
        {
            goto branch_no_9;
        }
        branch_yes_9:;
        CHECK_OBJECT( tmp_class_creation_3__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_3__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 55;

            goto try_except_handler_7;
        }
        branch_no_9:;
    }
    {
        nuitka_bool tmp_condition_result_18;
        PyObject *tmp_source_name_11;
        CHECK_OBJECT( tmp_class_creation_3__metaclass );
        tmp_source_name_11 = tmp_class_creation_3__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_11, const_str_plain___prepare__ );
        tmp_condition_result_18 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_18 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_10;
        }
        else
        {
            goto branch_no_10;
        }
        branch_yes_10:;
        {
            PyObject *tmp_assign_source_29;
            PyObject *tmp_called_name_7;
            PyObject *tmp_source_name_12;
            PyObject *tmp_args_name_5;
            PyObject *tmp_tuple_element_9;
            PyObject *tmp_kw_name_5;
            CHECK_OBJECT( tmp_class_creation_3__metaclass );
            tmp_source_name_12 = tmp_class_creation_3__metaclass;
            tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain___prepare__ );
            if ( tmp_called_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 55;

                goto try_except_handler_7;
            }
            tmp_tuple_element_9 = const_str_plain_ContextDecorator;
            tmp_args_name_5 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_9 );
            PyTuple_SET_ITEM( tmp_args_name_5, 0, tmp_tuple_element_9 );
            CHECK_OBJECT( tmp_class_creation_3__bases );
            tmp_tuple_element_9 = tmp_class_creation_3__bases;
            Py_INCREF( tmp_tuple_element_9 );
            PyTuple_SET_ITEM( tmp_args_name_5, 1, tmp_tuple_element_9 );
            CHECK_OBJECT( tmp_class_creation_3__class_decl_dict );
            tmp_kw_name_5 = tmp_class_creation_3__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 55;
            tmp_assign_source_29 = CALL_FUNCTION( tmp_called_name_7, tmp_args_name_5, tmp_kw_name_5 );
            Py_DECREF( tmp_called_name_7 );
            Py_DECREF( tmp_args_name_5 );
            if ( tmp_assign_source_29 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 55;

                goto try_except_handler_7;
            }
            assert( tmp_class_creation_3__prepared == NULL );
            tmp_class_creation_3__prepared = tmp_assign_source_29;
        }
        {
            nuitka_bool tmp_condition_result_19;
            PyObject *tmp_operand_name_3;
            PyObject *tmp_source_name_13;
            CHECK_OBJECT( tmp_class_creation_3__prepared );
            tmp_source_name_13 = tmp_class_creation_3__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_13, const_str_plain___getitem__ );
            tmp_operand_name_3 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 55;

                goto try_except_handler_7;
            }
            tmp_condition_result_19 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_19 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_11;
            }
            else
            {
                goto branch_no_11;
            }
            branch_yes_11:;
            {
                PyObject *tmp_raise_type_3;
                PyObject *tmp_raise_value_3;
                PyObject *tmp_left_name_3;
                PyObject *tmp_right_name_3;
                PyObject *tmp_tuple_element_10;
                PyObject *tmp_getattr_target_3;
                PyObject *tmp_getattr_attr_3;
                PyObject *tmp_getattr_default_3;
                PyObject *tmp_source_name_14;
                PyObject *tmp_type_arg_6;
                tmp_raise_type_3 = PyExc_TypeError;
                tmp_left_name_3 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_3__metaclass );
                tmp_getattr_target_3 = tmp_class_creation_3__metaclass;
                tmp_getattr_attr_3 = const_str_plain___name__;
                tmp_getattr_default_3 = const_str_angle_metaclass;
                tmp_tuple_element_10 = BUILTIN_GETATTR( tmp_getattr_target_3, tmp_getattr_attr_3, tmp_getattr_default_3 );
                if ( tmp_tuple_element_10 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 55;

                    goto try_except_handler_7;
                }
                tmp_right_name_3 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_3, 0, tmp_tuple_element_10 );
                CHECK_OBJECT( tmp_class_creation_3__prepared );
                tmp_type_arg_6 = tmp_class_creation_3__prepared;
                tmp_source_name_14 = BUILTIN_TYPE1( tmp_type_arg_6 );
                assert( !(tmp_source_name_14 == NULL) );
                tmp_tuple_element_10 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_14 );
                if ( tmp_tuple_element_10 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_3 );

                    exception_lineno = 55;

                    goto try_except_handler_7;
                }
                PyTuple_SET_ITEM( tmp_right_name_3, 1, tmp_tuple_element_10 );
                tmp_raise_value_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
                Py_DECREF( tmp_right_name_3 );
                if ( tmp_raise_value_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 55;

                    goto try_except_handler_7;
                }
                exception_type = tmp_raise_type_3;
                Py_INCREF( tmp_raise_type_3 );
                exception_value = tmp_raise_value_3;
                exception_lineno = 55;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_7;
            }
            branch_no_11:;
        }
        goto branch_end_10;
        branch_no_10:;
        {
            PyObject *tmp_assign_source_30;
            tmp_assign_source_30 = PyDict_New();
            assert( tmp_class_creation_3__prepared == NULL );
            tmp_class_creation_3__prepared = tmp_assign_source_30;
        }
        branch_end_10:;
    }
    {
        PyObject *tmp_assign_source_31;
        {
            PyObject *tmp_set_locals_3;
            CHECK_OBJECT( tmp_class_creation_3__prepared );
            tmp_set_locals_3 = tmp_class_creation_3__prepared;
            locals_contextlib_55 = tmp_set_locals_3;
            Py_INCREF( tmp_set_locals_3 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_55, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 55;

            goto try_except_handler_9;
        }
        tmp_dictset_value = const_str_digest_dd701e09dbf36c7cd84ab2997f9a35cf;
        tmp_res = PyObject_SetItem( locals_contextlib_55, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 55;

            goto try_except_handler_9;
        }
        tmp_dictset_value = const_str_plain_ContextDecorator;
        tmp_res = PyObject_SetItem( locals_contextlib_55, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 55;

            goto try_except_handler_9;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_c04d551e7f2d47bde603a86a6cbab618_4, codeobj_c04d551e7f2d47bde603a86a6cbab618, module_contextlib, sizeof(void *) );
        frame_c04d551e7f2d47bde603a86a6cbab618_4 = cache_frame_c04d551e7f2d47bde603a86a6cbab618_4;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_c04d551e7f2d47bde603a86a6cbab618_4 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_c04d551e7f2d47bde603a86a6cbab618_4 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_7__recreate_cm(  );



        tmp_res = PyObject_SetItem( locals_contextlib_55, const_str_plain__recreate_cm, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 58;
            type_description_2 = "o";
            goto frame_exception_exit_4;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_8___call__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_55, const_str_plain___call__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 70;
            type_description_2 = "o";
            goto frame_exception_exit_4;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_c04d551e7f2d47bde603a86a6cbab618_4 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_3;

        frame_exception_exit_4:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_c04d551e7f2d47bde603a86a6cbab618_4 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_c04d551e7f2d47bde603a86a6cbab618_4, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_c04d551e7f2d47bde603a86a6cbab618_4->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_c04d551e7f2d47bde603a86a6cbab618_4, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_c04d551e7f2d47bde603a86a6cbab618_4,
            type_description_2,
            outline_2_var___class__
        );


        // Release cached frame.
        if ( frame_c04d551e7f2d47bde603a86a6cbab618_4 == cache_frame_c04d551e7f2d47bde603a86a6cbab618_4 )
        {
            Py_DECREF( frame_c04d551e7f2d47bde603a86a6cbab618_4 );
        }
        cache_frame_c04d551e7f2d47bde603a86a6cbab618_4 = NULL;

        assertFrameObject( frame_c04d551e7f2d47bde603a86a6cbab618_4 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_3;

        frame_no_exception_3:;
        goto skip_nested_handling_3;
        nested_frame_exit_3:;

        goto try_except_handler_9;
        skip_nested_handling_3:;
        {
            nuitka_bool tmp_condition_result_20;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            CHECK_OBJECT( tmp_class_creation_3__bases );
            tmp_compexpr_left_3 = tmp_class_creation_3__bases;
            tmp_compexpr_right_3 = const_tuple_type_object_tuple;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 55;

                goto try_except_handler_9;
            }
            tmp_condition_result_20 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_20 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_12;
            }
            else
            {
                goto branch_no_12;
            }
            branch_yes_12:;
            tmp_dictset_value = const_tuple_type_object_tuple;
            tmp_res = PyObject_SetItem( locals_contextlib_55, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 55;

                goto try_except_handler_9;
            }
            branch_no_12:;
        }
        {
            PyObject *tmp_assign_source_32;
            PyObject *tmp_called_name_8;
            PyObject *tmp_args_name_6;
            PyObject *tmp_tuple_element_11;
            PyObject *tmp_kw_name_6;
            CHECK_OBJECT( tmp_class_creation_3__metaclass );
            tmp_called_name_8 = tmp_class_creation_3__metaclass;
            tmp_tuple_element_11 = const_str_plain_ContextDecorator;
            tmp_args_name_6 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_11 );
            PyTuple_SET_ITEM( tmp_args_name_6, 0, tmp_tuple_element_11 );
            CHECK_OBJECT( tmp_class_creation_3__bases );
            tmp_tuple_element_11 = tmp_class_creation_3__bases;
            Py_INCREF( tmp_tuple_element_11 );
            PyTuple_SET_ITEM( tmp_args_name_6, 1, tmp_tuple_element_11 );
            tmp_tuple_element_11 = locals_contextlib_55;
            Py_INCREF( tmp_tuple_element_11 );
            PyTuple_SET_ITEM( tmp_args_name_6, 2, tmp_tuple_element_11 );
            CHECK_OBJECT( tmp_class_creation_3__class_decl_dict );
            tmp_kw_name_6 = tmp_class_creation_3__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 55;
            tmp_assign_source_32 = CALL_FUNCTION( tmp_called_name_8, tmp_args_name_6, tmp_kw_name_6 );
            Py_DECREF( tmp_args_name_6 );
            if ( tmp_assign_source_32 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 55;

                goto try_except_handler_9;
            }
            assert( outline_2_var___class__ == NULL );
            outline_2_var___class__ = tmp_assign_source_32;
        }
        CHECK_OBJECT( outline_2_var___class__ );
        tmp_assign_source_31 = outline_2_var___class__;
        Py_INCREF( tmp_assign_source_31 );
        goto try_return_handler_9;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_9:;
        Py_DECREF( locals_contextlib_55 );
        locals_contextlib_55 = NULL;
        goto try_return_handler_8;
        // Exception handler code:
        try_except_handler_9:;
        exception_keeper_type_7 = exception_type;
        exception_keeper_value_7 = exception_value;
        exception_keeper_tb_7 = exception_tb;
        exception_keeper_lineno_7 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_55 );
        locals_contextlib_55 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_7;
        exception_value = exception_keeper_value_7;
        exception_tb = exception_keeper_tb_7;
        exception_lineno = exception_keeper_lineno_7;

        goto try_except_handler_8;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_8:;
        CHECK_OBJECT( (PyObject *)outline_2_var___class__ );
        Py_DECREF( outline_2_var___class__ );
        outline_2_var___class__ = NULL;

        goto outline_result_3;
        // Exception handler code:
        try_except_handler_8:;
        exception_keeper_type_8 = exception_type;
        exception_keeper_value_8 = exception_value;
        exception_keeper_tb_8 = exception_tb;
        exception_keeper_lineno_8 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_8;
        exception_value = exception_keeper_value_8;
        exception_tb = exception_keeper_tb_8;
        exception_lineno = exception_keeper_lineno_8;

        goto outline_exception_3;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_3:;
        exception_lineno = 55;
        goto try_except_handler_7;
        outline_result_3:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_ContextDecorator, tmp_assign_source_31 );
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_3__bases );
    tmp_class_creation_3__bases = NULL;

    Py_XDECREF( tmp_class_creation_3__class_decl_dict );
    tmp_class_creation_3__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_3__prepared );
    tmp_class_creation_3__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__bases );
    Py_DECREF( tmp_class_creation_3__bases );
    tmp_class_creation_3__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_decl_dict );
    Py_DECREF( tmp_class_creation_3__class_decl_dict );
    tmp_class_creation_3__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__metaclass );
    Py_DECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__prepared );
    Py_DECREF( tmp_class_creation_3__prepared );
    tmp_class_creation_3__prepared = NULL;

    {
        PyObject *tmp_assign_source_33;
        tmp_assign_source_33 = PyDict_New();
        assert( tmp_class_creation_4__class_decl_dict == NULL );
        tmp_class_creation_4__class_decl_dict = tmp_assign_source_33;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_34;
        PyObject *tmp_metaclass_name_4;
        nuitka_bool tmp_condition_result_21;
        PyObject *tmp_key_name_10;
        PyObject *tmp_dict_name_10;
        PyObject *tmp_dict_name_11;
        PyObject *tmp_key_name_11;
        PyObject *tmp_bases_name_4;
        tmp_key_name_10 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_4__class_decl_dict );
        tmp_dict_name_10 = tmp_class_creation_4__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_10, tmp_key_name_10 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 78;

            goto try_except_handler_10;
        }
        tmp_condition_result_21 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_21 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_9;
        }
        else
        {
            goto condexpr_false_9;
        }
        condexpr_true_9:;
        CHECK_OBJECT( tmp_class_creation_4__class_decl_dict );
        tmp_dict_name_11 = tmp_class_creation_4__class_decl_dict;
        tmp_key_name_11 = const_str_plain_metaclass;
        tmp_metaclass_name_4 = DICT_GET_ITEM( tmp_dict_name_11, tmp_key_name_11 );
        if ( tmp_metaclass_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 78;

            goto try_except_handler_10;
        }
        goto condexpr_end_9;
        condexpr_false_9:;
        tmp_metaclass_name_4 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_4 );
        condexpr_end_9:;
        tmp_bases_name_4 = const_tuple_empty;
        tmp_assign_source_34 = SELECT_METACLASS( tmp_metaclass_name_4, tmp_bases_name_4 );
        Py_DECREF( tmp_metaclass_name_4 );
        if ( tmp_assign_source_34 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 78;

            goto try_except_handler_10;
        }
        assert( tmp_class_creation_4__metaclass == NULL );
        tmp_class_creation_4__metaclass = tmp_assign_source_34;
    }
    {
        nuitka_bool tmp_condition_result_22;
        PyObject *tmp_key_name_12;
        PyObject *tmp_dict_name_12;
        tmp_key_name_12 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_4__class_decl_dict );
        tmp_dict_name_12 = tmp_class_creation_4__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_12, tmp_key_name_12 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 78;

            goto try_except_handler_10;
        }
        tmp_condition_result_22 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_22 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_13;
        }
        else
        {
            goto branch_no_13;
        }
        branch_yes_13:;
        CHECK_OBJECT( tmp_class_creation_4__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_4__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 78;

            goto try_except_handler_10;
        }
        branch_no_13:;
    }
    {
        nuitka_bool tmp_condition_result_23;
        PyObject *tmp_source_name_15;
        CHECK_OBJECT( tmp_class_creation_4__metaclass );
        tmp_source_name_15 = tmp_class_creation_4__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_15, const_str_plain___prepare__ );
        tmp_condition_result_23 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_23 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_14;
        }
        else
        {
            goto branch_no_14;
        }
        branch_yes_14:;
        {
            PyObject *tmp_assign_source_35;
            PyObject *tmp_called_name_9;
            PyObject *tmp_source_name_16;
            PyObject *tmp_args_name_7;
            PyObject *tmp_kw_name_7;
            CHECK_OBJECT( tmp_class_creation_4__metaclass );
            tmp_source_name_16 = tmp_class_creation_4__metaclass;
            tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain___prepare__ );
            if ( tmp_called_name_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 78;

                goto try_except_handler_10;
            }
            tmp_args_name_7 = const_tuple_str_plain__GeneratorContextManagerBase_tuple_empty_tuple;
            CHECK_OBJECT( tmp_class_creation_4__class_decl_dict );
            tmp_kw_name_7 = tmp_class_creation_4__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 78;
            tmp_assign_source_35 = CALL_FUNCTION( tmp_called_name_9, tmp_args_name_7, tmp_kw_name_7 );
            Py_DECREF( tmp_called_name_9 );
            if ( tmp_assign_source_35 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 78;

                goto try_except_handler_10;
            }
            assert( tmp_class_creation_4__prepared == NULL );
            tmp_class_creation_4__prepared = tmp_assign_source_35;
        }
        {
            nuitka_bool tmp_condition_result_24;
            PyObject *tmp_operand_name_4;
            PyObject *tmp_source_name_17;
            CHECK_OBJECT( tmp_class_creation_4__prepared );
            tmp_source_name_17 = tmp_class_creation_4__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_17, const_str_plain___getitem__ );
            tmp_operand_name_4 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 78;

                goto try_except_handler_10;
            }
            tmp_condition_result_24 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_24 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_15;
            }
            else
            {
                goto branch_no_15;
            }
            branch_yes_15:;
            {
                PyObject *tmp_raise_type_4;
                PyObject *tmp_raise_value_4;
                PyObject *tmp_left_name_4;
                PyObject *tmp_right_name_4;
                PyObject *tmp_tuple_element_12;
                PyObject *tmp_getattr_target_4;
                PyObject *tmp_getattr_attr_4;
                PyObject *tmp_getattr_default_4;
                PyObject *tmp_source_name_18;
                PyObject *tmp_type_arg_7;
                tmp_raise_type_4 = PyExc_TypeError;
                tmp_left_name_4 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_4__metaclass );
                tmp_getattr_target_4 = tmp_class_creation_4__metaclass;
                tmp_getattr_attr_4 = const_str_plain___name__;
                tmp_getattr_default_4 = const_str_angle_metaclass;
                tmp_tuple_element_12 = BUILTIN_GETATTR( tmp_getattr_target_4, tmp_getattr_attr_4, tmp_getattr_default_4 );
                if ( tmp_tuple_element_12 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 78;

                    goto try_except_handler_10;
                }
                tmp_right_name_4 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_4, 0, tmp_tuple_element_12 );
                CHECK_OBJECT( tmp_class_creation_4__prepared );
                tmp_type_arg_7 = tmp_class_creation_4__prepared;
                tmp_source_name_18 = BUILTIN_TYPE1( tmp_type_arg_7 );
                assert( !(tmp_source_name_18 == NULL) );
                tmp_tuple_element_12 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_18 );
                if ( tmp_tuple_element_12 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_4 );

                    exception_lineno = 78;

                    goto try_except_handler_10;
                }
                PyTuple_SET_ITEM( tmp_right_name_4, 1, tmp_tuple_element_12 );
                tmp_raise_value_4 = BINARY_OPERATION_REMAINDER( tmp_left_name_4, tmp_right_name_4 );
                Py_DECREF( tmp_right_name_4 );
                if ( tmp_raise_value_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 78;

                    goto try_except_handler_10;
                }
                exception_type = tmp_raise_type_4;
                Py_INCREF( tmp_raise_type_4 );
                exception_value = tmp_raise_value_4;
                exception_lineno = 78;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_10;
            }
            branch_no_15:;
        }
        goto branch_end_14;
        branch_no_14:;
        {
            PyObject *tmp_assign_source_36;
            tmp_assign_source_36 = PyDict_New();
            assert( tmp_class_creation_4__prepared == NULL );
            tmp_class_creation_4__prepared = tmp_assign_source_36;
        }
        branch_end_14:;
    }
    {
        PyObject *tmp_assign_source_37;
        {
            PyObject *tmp_set_locals_4;
            CHECK_OBJECT( tmp_class_creation_4__prepared );
            tmp_set_locals_4 = tmp_class_creation_4__prepared;
            locals_contextlib_78 = tmp_set_locals_4;
            Py_INCREF( tmp_set_locals_4 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_78, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 78;

            goto try_except_handler_12;
        }
        tmp_dictset_value = const_str_digest_6ffe76711bdd5b699aa8c216d8ac87ec;
        tmp_res = PyObject_SetItem( locals_contextlib_78, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 78;

            goto try_except_handler_12;
        }
        tmp_dictset_value = const_str_plain__GeneratorContextManagerBase;
        tmp_res = PyObject_SetItem( locals_contextlib_78, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 78;

            goto try_except_handler_12;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_234568fa88d264a070f886691f02cf17_5, codeobj_234568fa88d264a070f886691f02cf17, module_contextlib, sizeof(void *) );
        frame_234568fa88d264a070f886691f02cf17_5 = cache_frame_234568fa88d264a070f886691f02cf17_5;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_234568fa88d264a070f886691f02cf17_5 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_234568fa88d264a070f886691f02cf17_5 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_9___init__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_78, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 81;
            type_description_2 = "o";
            goto frame_exception_exit_5;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_234568fa88d264a070f886691f02cf17_5 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_4;

        frame_exception_exit_5:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_234568fa88d264a070f886691f02cf17_5 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_234568fa88d264a070f886691f02cf17_5, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_234568fa88d264a070f886691f02cf17_5->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_234568fa88d264a070f886691f02cf17_5, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_234568fa88d264a070f886691f02cf17_5,
            type_description_2,
            outline_3_var___class__
        );


        // Release cached frame.
        if ( frame_234568fa88d264a070f886691f02cf17_5 == cache_frame_234568fa88d264a070f886691f02cf17_5 )
        {
            Py_DECREF( frame_234568fa88d264a070f886691f02cf17_5 );
        }
        cache_frame_234568fa88d264a070f886691f02cf17_5 = NULL;

        assertFrameObject( frame_234568fa88d264a070f886691f02cf17_5 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_4;

        frame_no_exception_4:;
        goto skip_nested_handling_4;
        nested_frame_exit_4:;

        goto try_except_handler_12;
        skip_nested_handling_4:;
        {
            PyObject *tmp_assign_source_38;
            PyObject *tmp_called_name_10;
            PyObject *tmp_args_name_8;
            PyObject *tmp_tuple_element_13;
            PyObject *tmp_kw_name_8;
            CHECK_OBJECT( tmp_class_creation_4__metaclass );
            tmp_called_name_10 = tmp_class_creation_4__metaclass;
            tmp_tuple_element_13 = const_str_plain__GeneratorContextManagerBase;
            tmp_args_name_8 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_13 );
            PyTuple_SET_ITEM( tmp_args_name_8, 0, tmp_tuple_element_13 );
            tmp_tuple_element_13 = const_tuple_empty;
            Py_INCREF( tmp_tuple_element_13 );
            PyTuple_SET_ITEM( tmp_args_name_8, 1, tmp_tuple_element_13 );
            tmp_tuple_element_13 = locals_contextlib_78;
            Py_INCREF( tmp_tuple_element_13 );
            PyTuple_SET_ITEM( tmp_args_name_8, 2, tmp_tuple_element_13 );
            CHECK_OBJECT( tmp_class_creation_4__class_decl_dict );
            tmp_kw_name_8 = tmp_class_creation_4__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 78;
            tmp_assign_source_38 = CALL_FUNCTION( tmp_called_name_10, tmp_args_name_8, tmp_kw_name_8 );
            Py_DECREF( tmp_args_name_8 );
            if ( tmp_assign_source_38 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 78;

                goto try_except_handler_12;
            }
            assert( outline_3_var___class__ == NULL );
            outline_3_var___class__ = tmp_assign_source_38;
        }
        CHECK_OBJECT( outline_3_var___class__ );
        tmp_assign_source_37 = outline_3_var___class__;
        Py_INCREF( tmp_assign_source_37 );
        goto try_return_handler_12;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_12:;
        Py_DECREF( locals_contextlib_78 );
        locals_contextlib_78 = NULL;
        goto try_return_handler_11;
        // Exception handler code:
        try_except_handler_12:;
        exception_keeper_type_10 = exception_type;
        exception_keeper_value_10 = exception_value;
        exception_keeper_tb_10 = exception_tb;
        exception_keeper_lineno_10 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_78 );
        locals_contextlib_78 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_10;
        exception_value = exception_keeper_value_10;
        exception_tb = exception_keeper_tb_10;
        exception_lineno = exception_keeper_lineno_10;

        goto try_except_handler_11;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_11:;
        CHECK_OBJECT( (PyObject *)outline_3_var___class__ );
        Py_DECREF( outline_3_var___class__ );
        outline_3_var___class__ = NULL;

        goto outline_result_4;
        // Exception handler code:
        try_except_handler_11:;
        exception_keeper_type_11 = exception_type;
        exception_keeper_value_11 = exception_value;
        exception_keeper_tb_11 = exception_tb;
        exception_keeper_lineno_11 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_11;
        exception_value = exception_keeper_value_11;
        exception_tb = exception_keeper_tb_11;
        exception_lineno = exception_keeper_lineno_11;

        goto outline_exception_4;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_4:;
        exception_lineno = 78;
        goto try_except_handler_10;
        outline_result_4:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__GeneratorContextManagerBase, tmp_assign_source_37 );
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_10:;
    exception_keeper_type_12 = exception_type;
    exception_keeper_value_12 = exception_value;
    exception_keeper_tb_12 = exception_tb;
    exception_keeper_lineno_12 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class_decl_dict );
    Py_DECREF( tmp_class_creation_4__class_decl_dict );
    tmp_class_creation_4__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_4__prepared );
    tmp_class_creation_4__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_12;
    exception_value = exception_keeper_value_12;
    exception_tb = exception_keeper_tb_12;
    exception_lineno = exception_keeper_lineno_12;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class_decl_dict );
    Py_DECREF( tmp_class_creation_4__class_decl_dict );
    tmp_class_creation_4__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__metaclass );
    Py_DECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__prepared );
    Py_DECREF( tmp_class_creation_4__prepared );
    tmp_class_creation_4__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_39;
        PyObject *tmp_tuple_element_14;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__GeneratorContextManagerBase );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__GeneratorContextManagerBase );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_GeneratorContextManagerBase" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 96;

            goto try_except_handler_13;
        }

        tmp_tuple_element_14 = tmp_mvar_value_7;
        tmp_assign_source_39 = PyTuple_New( 3 );
        Py_INCREF( tmp_tuple_element_14 );
        PyTuple_SET_ITEM( tmp_assign_source_39, 0, tmp_tuple_element_14 );
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );
        }

        if ( tmp_mvar_value_8 == NULL )
        {
            Py_DECREF( tmp_assign_source_39 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "AbstractContextManager" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 97;

            goto try_except_handler_13;
        }

        tmp_tuple_element_14 = tmp_mvar_value_8;
        Py_INCREF( tmp_tuple_element_14 );
        PyTuple_SET_ITEM( tmp_assign_source_39, 1, tmp_tuple_element_14 );
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_ContextDecorator );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ContextDecorator );
        }

        if ( tmp_mvar_value_9 == NULL )
        {
            Py_DECREF( tmp_assign_source_39 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "ContextDecorator" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 98;

            goto try_except_handler_13;
        }

        tmp_tuple_element_14 = tmp_mvar_value_9;
        Py_INCREF( tmp_tuple_element_14 );
        PyTuple_SET_ITEM( tmp_assign_source_39, 2, tmp_tuple_element_14 );
        assert( tmp_class_creation_5__bases_orig == NULL );
        tmp_class_creation_5__bases_orig = tmp_assign_source_39;
    }
    {
        PyObject *tmp_assign_source_40;
        PyObject *tmp_dircall_arg1_4;
        CHECK_OBJECT( tmp_class_creation_5__bases_orig );
        tmp_dircall_arg1_4 = tmp_class_creation_5__bases_orig;
        Py_INCREF( tmp_dircall_arg1_4 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_4};
            tmp_assign_source_40 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_40 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto try_except_handler_13;
        }
        assert( tmp_class_creation_5__bases == NULL );
        tmp_class_creation_5__bases = tmp_assign_source_40;
    }
    {
        PyObject *tmp_assign_source_41;
        tmp_assign_source_41 = PyDict_New();
        assert( tmp_class_creation_5__class_decl_dict == NULL );
        tmp_class_creation_5__class_decl_dict = tmp_assign_source_41;
    }
    {
        PyObject *tmp_assign_source_42;
        PyObject *tmp_metaclass_name_5;
        nuitka_bool tmp_condition_result_25;
        PyObject *tmp_key_name_13;
        PyObject *tmp_dict_name_13;
        PyObject *tmp_dict_name_14;
        PyObject *tmp_key_name_14;
        nuitka_bool tmp_condition_result_26;
        int tmp_truth_name_4;
        PyObject *tmp_type_arg_8;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_subscript_name_4;
        PyObject *tmp_bases_name_5;
        tmp_key_name_13 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_5__class_decl_dict );
        tmp_dict_name_13 = tmp_class_creation_5__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_13, tmp_key_name_13 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto try_except_handler_13;
        }
        tmp_condition_result_25 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_25 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_10;
        }
        else
        {
            goto condexpr_false_10;
        }
        condexpr_true_10:;
        CHECK_OBJECT( tmp_class_creation_5__class_decl_dict );
        tmp_dict_name_14 = tmp_class_creation_5__class_decl_dict;
        tmp_key_name_14 = const_str_plain_metaclass;
        tmp_metaclass_name_5 = DICT_GET_ITEM( tmp_dict_name_14, tmp_key_name_14 );
        if ( tmp_metaclass_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto try_except_handler_13;
        }
        goto condexpr_end_10;
        condexpr_false_10:;
        CHECK_OBJECT( tmp_class_creation_5__bases );
        tmp_truth_name_4 = CHECK_IF_TRUE( tmp_class_creation_5__bases );
        if ( tmp_truth_name_4 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto try_except_handler_13;
        }
        tmp_condition_result_26 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_26 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_11;
        }
        else
        {
            goto condexpr_false_11;
        }
        condexpr_true_11:;
        CHECK_OBJECT( tmp_class_creation_5__bases );
        tmp_subscribed_name_4 = tmp_class_creation_5__bases;
        tmp_subscript_name_4 = const_int_0;
        tmp_type_arg_8 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 0 );
        if ( tmp_type_arg_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto try_except_handler_13;
        }
        tmp_metaclass_name_5 = BUILTIN_TYPE1( tmp_type_arg_8 );
        Py_DECREF( tmp_type_arg_8 );
        if ( tmp_metaclass_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto try_except_handler_13;
        }
        goto condexpr_end_11;
        condexpr_false_11:;
        tmp_metaclass_name_5 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_5 );
        condexpr_end_11:;
        condexpr_end_10:;
        CHECK_OBJECT( tmp_class_creation_5__bases );
        tmp_bases_name_5 = tmp_class_creation_5__bases;
        tmp_assign_source_42 = SELECT_METACLASS( tmp_metaclass_name_5, tmp_bases_name_5 );
        Py_DECREF( tmp_metaclass_name_5 );
        if ( tmp_assign_source_42 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto try_except_handler_13;
        }
        assert( tmp_class_creation_5__metaclass == NULL );
        tmp_class_creation_5__metaclass = tmp_assign_source_42;
    }
    {
        nuitka_bool tmp_condition_result_27;
        PyObject *tmp_key_name_15;
        PyObject *tmp_dict_name_15;
        tmp_key_name_15 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_5__class_decl_dict );
        tmp_dict_name_15 = tmp_class_creation_5__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_15, tmp_key_name_15 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto try_except_handler_13;
        }
        tmp_condition_result_27 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_27 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_16;
        }
        else
        {
            goto branch_no_16;
        }
        branch_yes_16:;
        CHECK_OBJECT( tmp_class_creation_5__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_5__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto try_except_handler_13;
        }
        branch_no_16:;
    }
    {
        nuitka_bool tmp_condition_result_28;
        PyObject *tmp_source_name_19;
        CHECK_OBJECT( tmp_class_creation_5__metaclass );
        tmp_source_name_19 = tmp_class_creation_5__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_19, const_str_plain___prepare__ );
        tmp_condition_result_28 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_28 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_17;
        }
        else
        {
            goto branch_no_17;
        }
        branch_yes_17:;
        {
            PyObject *tmp_assign_source_43;
            PyObject *tmp_called_name_11;
            PyObject *tmp_source_name_20;
            PyObject *tmp_args_name_9;
            PyObject *tmp_tuple_element_15;
            PyObject *tmp_kw_name_9;
            CHECK_OBJECT( tmp_class_creation_5__metaclass );
            tmp_source_name_20 = tmp_class_creation_5__metaclass;
            tmp_called_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain___prepare__ );
            if ( tmp_called_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 98;

                goto try_except_handler_13;
            }
            tmp_tuple_element_15 = const_str_plain__GeneratorContextManager;
            tmp_args_name_9 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_15 );
            PyTuple_SET_ITEM( tmp_args_name_9, 0, tmp_tuple_element_15 );
            CHECK_OBJECT( tmp_class_creation_5__bases );
            tmp_tuple_element_15 = tmp_class_creation_5__bases;
            Py_INCREF( tmp_tuple_element_15 );
            PyTuple_SET_ITEM( tmp_args_name_9, 1, tmp_tuple_element_15 );
            CHECK_OBJECT( tmp_class_creation_5__class_decl_dict );
            tmp_kw_name_9 = tmp_class_creation_5__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 98;
            tmp_assign_source_43 = CALL_FUNCTION( tmp_called_name_11, tmp_args_name_9, tmp_kw_name_9 );
            Py_DECREF( tmp_called_name_11 );
            Py_DECREF( tmp_args_name_9 );
            if ( tmp_assign_source_43 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 98;

                goto try_except_handler_13;
            }
            assert( tmp_class_creation_5__prepared == NULL );
            tmp_class_creation_5__prepared = tmp_assign_source_43;
        }
        {
            nuitka_bool tmp_condition_result_29;
            PyObject *tmp_operand_name_5;
            PyObject *tmp_source_name_21;
            CHECK_OBJECT( tmp_class_creation_5__prepared );
            tmp_source_name_21 = tmp_class_creation_5__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_21, const_str_plain___getitem__ );
            tmp_operand_name_5 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 98;

                goto try_except_handler_13;
            }
            tmp_condition_result_29 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_29 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_18;
            }
            else
            {
                goto branch_no_18;
            }
            branch_yes_18:;
            {
                PyObject *tmp_raise_type_5;
                PyObject *tmp_raise_value_5;
                PyObject *tmp_left_name_5;
                PyObject *tmp_right_name_5;
                PyObject *tmp_tuple_element_16;
                PyObject *tmp_getattr_target_5;
                PyObject *tmp_getattr_attr_5;
                PyObject *tmp_getattr_default_5;
                PyObject *tmp_source_name_22;
                PyObject *tmp_type_arg_9;
                tmp_raise_type_5 = PyExc_TypeError;
                tmp_left_name_5 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_5__metaclass );
                tmp_getattr_target_5 = tmp_class_creation_5__metaclass;
                tmp_getattr_attr_5 = const_str_plain___name__;
                tmp_getattr_default_5 = const_str_angle_metaclass;
                tmp_tuple_element_16 = BUILTIN_GETATTR( tmp_getattr_target_5, tmp_getattr_attr_5, tmp_getattr_default_5 );
                if ( tmp_tuple_element_16 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 98;

                    goto try_except_handler_13;
                }
                tmp_right_name_5 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_5, 0, tmp_tuple_element_16 );
                CHECK_OBJECT( tmp_class_creation_5__prepared );
                tmp_type_arg_9 = tmp_class_creation_5__prepared;
                tmp_source_name_22 = BUILTIN_TYPE1( tmp_type_arg_9 );
                assert( !(tmp_source_name_22 == NULL) );
                tmp_tuple_element_16 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_22 );
                if ( tmp_tuple_element_16 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_5 );

                    exception_lineno = 98;

                    goto try_except_handler_13;
                }
                PyTuple_SET_ITEM( tmp_right_name_5, 1, tmp_tuple_element_16 );
                tmp_raise_value_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_5, tmp_right_name_5 );
                Py_DECREF( tmp_right_name_5 );
                if ( tmp_raise_value_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 98;

                    goto try_except_handler_13;
                }
                exception_type = tmp_raise_type_5;
                Py_INCREF( tmp_raise_type_5 );
                exception_value = tmp_raise_value_5;
                exception_lineno = 98;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_13;
            }
            branch_no_18:;
        }
        goto branch_end_17;
        branch_no_17:;
        {
            PyObject *tmp_assign_source_44;
            tmp_assign_source_44 = PyDict_New();
            assert( tmp_class_creation_5__prepared == NULL );
            tmp_class_creation_5__prepared = tmp_assign_source_44;
        }
        branch_end_17:;
    }
    {
        PyObject *tmp_assign_source_45;
        {
            PyObject *tmp_set_locals_5;
            CHECK_OBJECT( tmp_class_creation_5__prepared );
            tmp_set_locals_5 = tmp_class_creation_5__prepared;
            locals_contextlib_98 = tmp_set_locals_5;
            Py_INCREF( tmp_set_locals_5 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_98, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto try_except_handler_15;
        }
        tmp_dictset_value = const_str_digest_8a1dccae593581f4052d7559e1c2ae2c;
        tmp_res = PyObject_SetItem( locals_contextlib_98, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto try_except_handler_15;
        }
        tmp_dictset_value = const_str_plain__GeneratorContextManager;
        tmp_res = PyObject_SetItem( locals_contextlib_98, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 98;

            goto try_except_handler_15;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_425d97b102abf105a65464ebdd2a370d_6, codeobj_425d97b102abf105a65464ebdd2a370d, module_contextlib, sizeof(void *) );
        frame_425d97b102abf105a65464ebdd2a370d_6 = cache_frame_425d97b102abf105a65464ebdd2a370d_6;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_425d97b102abf105a65464ebdd2a370d_6 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_425d97b102abf105a65464ebdd2a370d_6 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_10__recreate_cm(  );



        tmp_res = PyObject_SetItem( locals_contextlib_98, const_str_plain__recreate_cm, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 101;
            type_description_2 = "o";
            goto frame_exception_exit_6;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_11___enter__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_98, const_str_plain___enter__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 107;
            type_description_2 = "o";
            goto frame_exception_exit_6;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_12___exit__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_98, const_str_plain___exit__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 116;
            type_description_2 = "o";
            goto frame_exception_exit_6;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_425d97b102abf105a65464ebdd2a370d_6 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_5;

        frame_exception_exit_6:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_425d97b102abf105a65464ebdd2a370d_6 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_425d97b102abf105a65464ebdd2a370d_6, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_425d97b102abf105a65464ebdd2a370d_6->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_425d97b102abf105a65464ebdd2a370d_6, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_425d97b102abf105a65464ebdd2a370d_6,
            type_description_2,
            outline_4_var___class__
        );


        // Release cached frame.
        if ( frame_425d97b102abf105a65464ebdd2a370d_6 == cache_frame_425d97b102abf105a65464ebdd2a370d_6 )
        {
            Py_DECREF( frame_425d97b102abf105a65464ebdd2a370d_6 );
        }
        cache_frame_425d97b102abf105a65464ebdd2a370d_6 = NULL;

        assertFrameObject( frame_425d97b102abf105a65464ebdd2a370d_6 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_5;

        frame_no_exception_5:;
        goto skip_nested_handling_5;
        nested_frame_exit_5:;

        goto try_except_handler_15;
        skip_nested_handling_5:;
        {
            nuitka_bool tmp_condition_result_30;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            CHECK_OBJECT( tmp_class_creation_5__bases );
            tmp_compexpr_left_4 = tmp_class_creation_5__bases;
            CHECK_OBJECT( tmp_class_creation_5__bases_orig );
            tmp_compexpr_right_4 = tmp_class_creation_5__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 98;

                goto try_except_handler_15;
            }
            tmp_condition_result_30 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_30 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_19;
            }
            else
            {
                goto branch_no_19;
            }
            branch_yes_19:;
            CHECK_OBJECT( tmp_class_creation_5__bases_orig );
            tmp_dictset_value = tmp_class_creation_5__bases_orig;
            tmp_res = PyObject_SetItem( locals_contextlib_98, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 98;

                goto try_except_handler_15;
            }
            branch_no_19:;
        }
        {
            PyObject *tmp_assign_source_46;
            PyObject *tmp_called_name_12;
            PyObject *tmp_args_name_10;
            PyObject *tmp_tuple_element_17;
            PyObject *tmp_kw_name_10;
            CHECK_OBJECT( tmp_class_creation_5__metaclass );
            tmp_called_name_12 = tmp_class_creation_5__metaclass;
            tmp_tuple_element_17 = const_str_plain__GeneratorContextManager;
            tmp_args_name_10 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_17 );
            PyTuple_SET_ITEM( tmp_args_name_10, 0, tmp_tuple_element_17 );
            CHECK_OBJECT( tmp_class_creation_5__bases );
            tmp_tuple_element_17 = tmp_class_creation_5__bases;
            Py_INCREF( tmp_tuple_element_17 );
            PyTuple_SET_ITEM( tmp_args_name_10, 1, tmp_tuple_element_17 );
            tmp_tuple_element_17 = locals_contextlib_98;
            Py_INCREF( tmp_tuple_element_17 );
            PyTuple_SET_ITEM( tmp_args_name_10, 2, tmp_tuple_element_17 );
            CHECK_OBJECT( tmp_class_creation_5__class_decl_dict );
            tmp_kw_name_10 = tmp_class_creation_5__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 98;
            tmp_assign_source_46 = CALL_FUNCTION( tmp_called_name_12, tmp_args_name_10, tmp_kw_name_10 );
            Py_DECREF( tmp_args_name_10 );
            if ( tmp_assign_source_46 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 98;

                goto try_except_handler_15;
            }
            assert( outline_4_var___class__ == NULL );
            outline_4_var___class__ = tmp_assign_source_46;
        }
        CHECK_OBJECT( outline_4_var___class__ );
        tmp_assign_source_45 = outline_4_var___class__;
        Py_INCREF( tmp_assign_source_45 );
        goto try_return_handler_15;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_15:;
        Py_DECREF( locals_contextlib_98 );
        locals_contextlib_98 = NULL;
        goto try_return_handler_14;
        // Exception handler code:
        try_except_handler_15:;
        exception_keeper_type_13 = exception_type;
        exception_keeper_value_13 = exception_value;
        exception_keeper_tb_13 = exception_tb;
        exception_keeper_lineno_13 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_98 );
        locals_contextlib_98 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_13;
        exception_value = exception_keeper_value_13;
        exception_tb = exception_keeper_tb_13;
        exception_lineno = exception_keeper_lineno_13;

        goto try_except_handler_14;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_14:;
        CHECK_OBJECT( (PyObject *)outline_4_var___class__ );
        Py_DECREF( outline_4_var___class__ );
        outline_4_var___class__ = NULL;

        goto outline_result_5;
        // Exception handler code:
        try_except_handler_14:;
        exception_keeper_type_14 = exception_type;
        exception_keeper_value_14 = exception_value;
        exception_keeper_tb_14 = exception_tb;
        exception_keeper_lineno_14 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_14;
        exception_value = exception_keeper_value_14;
        exception_tb = exception_keeper_tb_14;
        exception_lineno = exception_keeper_lineno_14;

        goto outline_exception_5;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_5:;
        exception_lineno = 98;
        goto try_except_handler_13;
        outline_result_5:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__GeneratorContextManager, tmp_assign_source_45 );
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_13:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_5__bases_orig );
    tmp_class_creation_5__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_5__bases );
    tmp_class_creation_5__bases = NULL;

    Py_XDECREF( tmp_class_creation_5__class_decl_dict );
    tmp_class_creation_5__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_5__prepared );
    tmp_class_creation_5__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_15;
    exception_value = exception_keeper_value_15;
    exception_tb = exception_keeper_tb_15;
    exception_lineno = exception_keeper_lineno_15;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__bases_orig );
    Py_DECREF( tmp_class_creation_5__bases_orig );
    tmp_class_creation_5__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__bases );
    Py_DECREF( tmp_class_creation_5__bases );
    tmp_class_creation_5__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class_decl_dict );
    Py_DECREF( tmp_class_creation_5__class_decl_dict );
    tmp_class_creation_5__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__metaclass );
    Py_DECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__prepared );
    Py_DECREF( tmp_class_creation_5__prepared );
    tmp_class_creation_5__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_47;
        PyObject *tmp_tuple_element_18;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_mvar_value_11;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__GeneratorContextManagerBase );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__GeneratorContextManagerBase );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_GeneratorContextManagerBase" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 164;

            goto try_except_handler_16;
        }

        tmp_tuple_element_18 = tmp_mvar_value_10;
        tmp_assign_source_47 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_18 );
        PyTuple_SET_ITEM( tmp_assign_source_47, 0, tmp_tuple_element_18 );
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AbstractAsyncContextManager );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AbstractAsyncContextManager );
        }

        if ( tmp_mvar_value_11 == NULL )
        {
            Py_DECREF( tmp_assign_source_47 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "AbstractAsyncContextManager" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 165;

            goto try_except_handler_16;
        }

        tmp_tuple_element_18 = tmp_mvar_value_11;
        Py_INCREF( tmp_tuple_element_18 );
        PyTuple_SET_ITEM( tmp_assign_source_47, 1, tmp_tuple_element_18 );
        assert( tmp_class_creation_6__bases_orig == NULL );
        tmp_class_creation_6__bases_orig = tmp_assign_source_47;
    }
    {
        PyObject *tmp_assign_source_48;
        PyObject *tmp_dircall_arg1_5;
        CHECK_OBJECT( tmp_class_creation_6__bases_orig );
        tmp_dircall_arg1_5 = tmp_class_creation_6__bases_orig;
        Py_INCREF( tmp_dircall_arg1_5 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_5};
            tmp_assign_source_48 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_48 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto try_except_handler_16;
        }
        assert( tmp_class_creation_6__bases == NULL );
        tmp_class_creation_6__bases = tmp_assign_source_48;
    }
    {
        PyObject *tmp_assign_source_49;
        tmp_assign_source_49 = PyDict_New();
        assert( tmp_class_creation_6__class_decl_dict == NULL );
        tmp_class_creation_6__class_decl_dict = tmp_assign_source_49;
    }
    {
        PyObject *tmp_assign_source_50;
        PyObject *tmp_metaclass_name_6;
        nuitka_bool tmp_condition_result_31;
        PyObject *tmp_key_name_16;
        PyObject *tmp_dict_name_16;
        PyObject *tmp_dict_name_17;
        PyObject *tmp_key_name_17;
        nuitka_bool tmp_condition_result_32;
        int tmp_truth_name_5;
        PyObject *tmp_type_arg_10;
        PyObject *tmp_subscribed_name_5;
        PyObject *tmp_subscript_name_5;
        PyObject *tmp_bases_name_6;
        tmp_key_name_16 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_6__class_decl_dict );
        tmp_dict_name_16 = tmp_class_creation_6__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_16, tmp_key_name_16 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto try_except_handler_16;
        }
        tmp_condition_result_31 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_31 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_12;
        }
        else
        {
            goto condexpr_false_12;
        }
        condexpr_true_12:;
        CHECK_OBJECT( tmp_class_creation_6__class_decl_dict );
        tmp_dict_name_17 = tmp_class_creation_6__class_decl_dict;
        tmp_key_name_17 = const_str_plain_metaclass;
        tmp_metaclass_name_6 = DICT_GET_ITEM( tmp_dict_name_17, tmp_key_name_17 );
        if ( tmp_metaclass_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto try_except_handler_16;
        }
        goto condexpr_end_12;
        condexpr_false_12:;
        CHECK_OBJECT( tmp_class_creation_6__bases );
        tmp_truth_name_5 = CHECK_IF_TRUE( tmp_class_creation_6__bases );
        if ( tmp_truth_name_5 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto try_except_handler_16;
        }
        tmp_condition_result_32 = tmp_truth_name_5 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_32 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_13;
        }
        else
        {
            goto condexpr_false_13;
        }
        condexpr_true_13:;
        CHECK_OBJECT( tmp_class_creation_6__bases );
        tmp_subscribed_name_5 = tmp_class_creation_6__bases;
        tmp_subscript_name_5 = const_int_0;
        tmp_type_arg_10 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_5, tmp_subscript_name_5, 0 );
        if ( tmp_type_arg_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto try_except_handler_16;
        }
        tmp_metaclass_name_6 = BUILTIN_TYPE1( tmp_type_arg_10 );
        Py_DECREF( tmp_type_arg_10 );
        if ( tmp_metaclass_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto try_except_handler_16;
        }
        goto condexpr_end_13;
        condexpr_false_13:;
        tmp_metaclass_name_6 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_6 );
        condexpr_end_13:;
        condexpr_end_12:;
        CHECK_OBJECT( tmp_class_creation_6__bases );
        tmp_bases_name_6 = tmp_class_creation_6__bases;
        tmp_assign_source_50 = SELECT_METACLASS( tmp_metaclass_name_6, tmp_bases_name_6 );
        Py_DECREF( tmp_metaclass_name_6 );
        if ( tmp_assign_source_50 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto try_except_handler_16;
        }
        assert( tmp_class_creation_6__metaclass == NULL );
        tmp_class_creation_6__metaclass = tmp_assign_source_50;
    }
    {
        nuitka_bool tmp_condition_result_33;
        PyObject *tmp_key_name_18;
        PyObject *tmp_dict_name_18;
        tmp_key_name_18 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_6__class_decl_dict );
        tmp_dict_name_18 = tmp_class_creation_6__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_18, tmp_key_name_18 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto try_except_handler_16;
        }
        tmp_condition_result_33 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_33 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_20;
        }
        else
        {
            goto branch_no_20;
        }
        branch_yes_20:;
        CHECK_OBJECT( tmp_class_creation_6__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_6__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto try_except_handler_16;
        }
        branch_no_20:;
    }
    {
        nuitka_bool tmp_condition_result_34;
        PyObject *tmp_source_name_23;
        CHECK_OBJECT( tmp_class_creation_6__metaclass );
        tmp_source_name_23 = tmp_class_creation_6__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_23, const_str_plain___prepare__ );
        tmp_condition_result_34 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_34 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_21;
        }
        else
        {
            goto branch_no_21;
        }
        branch_yes_21:;
        {
            PyObject *tmp_assign_source_51;
            PyObject *tmp_called_name_13;
            PyObject *tmp_source_name_24;
            PyObject *tmp_args_name_11;
            PyObject *tmp_tuple_element_19;
            PyObject *tmp_kw_name_11;
            CHECK_OBJECT( tmp_class_creation_6__metaclass );
            tmp_source_name_24 = tmp_class_creation_6__metaclass;
            tmp_called_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain___prepare__ );
            if ( tmp_called_name_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 165;

                goto try_except_handler_16;
            }
            tmp_tuple_element_19 = const_str_plain__AsyncGeneratorContextManager;
            tmp_args_name_11 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_19 );
            PyTuple_SET_ITEM( tmp_args_name_11, 0, tmp_tuple_element_19 );
            CHECK_OBJECT( tmp_class_creation_6__bases );
            tmp_tuple_element_19 = tmp_class_creation_6__bases;
            Py_INCREF( tmp_tuple_element_19 );
            PyTuple_SET_ITEM( tmp_args_name_11, 1, tmp_tuple_element_19 );
            CHECK_OBJECT( tmp_class_creation_6__class_decl_dict );
            tmp_kw_name_11 = tmp_class_creation_6__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 165;
            tmp_assign_source_51 = CALL_FUNCTION( tmp_called_name_13, tmp_args_name_11, tmp_kw_name_11 );
            Py_DECREF( tmp_called_name_13 );
            Py_DECREF( tmp_args_name_11 );
            if ( tmp_assign_source_51 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 165;

                goto try_except_handler_16;
            }
            assert( tmp_class_creation_6__prepared == NULL );
            tmp_class_creation_6__prepared = tmp_assign_source_51;
        }
        {
            nuitka_bool tmp_condition_result_35;
            PyObject *tmp_operand_name_6;
            PyObject *tmp_source_name_25;
            CHECK_OBJECT( tmp_class_creation_6__prepared );
            tmp_source_name_25 = tmp_class_creation_6__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_25, const_str_plain___getitem__ );
            tmp_operand_name_6 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_6 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 165;

                goto try_except_handler_16;
            }
            tmp_condition_result_35 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_35 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_22;
            }
            else
            {
                goto branch_no_22;
            }
            branch_yes_22:;
            {
                PyObject *tmp_raise_type_6;
                PyObject *tmp_raise_value_6;
                PyObject *tmp_left_name_6;
                PyObject *tmp_right_name_6;
                PyObject *tmp_tuple_element_20;
                PyObject *tmp_getattr_target_6;
                PyObject *tmp_getattr_attr_6;
                PyObject *tmp_getattr_default_6;
                PyObject *tmp_source_name_26;
                PyObject *tmp_type_arg_11;
                tmp_raise_type_6 = PyExc_TypeError;
                tmp_left_name_6 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_6__metaclass );
                tmp_getattr_target_6 = tmp_class_creation_6__metaclass;
                tmp_getattr_attr_6 = const_str_plain___name__;
                tmp_getattr_default_6 = const_str_angle_metaclass;
                tmp_tuple_element_20 = BUILTIN_GETATTR( tmp_getattr_target_6, tmp_getattr_attr_6, tmp_getattr_default_6 );
                if ( tmp_tuple_element_20 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 165;

                    goto try_except_handler_16;
                }
                tmp_right_name_6 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_6, 0, tmp_tuple_element_20 );
                CHECK_OBJECT( tmp_class_creation_6__prepared );
                tmp_type_arg_11 = tmp_class_creation_6__prepared;
                tmp_source_name_26 = BUILTIN_TYPE1( tmp_type_arg_11 );
                assert( !(tmp_source_name_26 == NULL) );
                tmp_tuple_element_20 = LOOKUP_ATTRIBUTE( tmp_source_name_26, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_26 );
                if ( tmp_tuple_element_20 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_6 );

                    exception_lineno = 165;

                    goto try_except_handler_16;
                }
                PyTuple_SET_ITEM( tmp_right_name_6, 1, tmp_tuple_element_20 );
                tmp_raise_value_6 = BINARY_OPERATION_REMAINDER( tmp_left_name_6, tmp_right_name_6 );
                Py_DECREF( tmp_right_name_6 );
                if ( tmp_raise_value_6 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 165;

                    goto try_except_handler_16;
                }
                exception_type = tmp_raise_type_6;
                Py_INCREF( tmp_raise_type_6 );
                exception_value = tmp_raise_value_6;
                exception_lineno = 165;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_16;
            }
            branch_no_22:;
        }
        goto branch_end_21;
        branch_no_21:;
        {
            PyObject *tmp_assign_source_52;
            tmp_assign_source_52 = PyDict_New();
            assert( tmp_class_creation_6__prepared == NULL );
            tmp_class_creation_6__prepared = tmp_assign_source_52;
        }
        branch_end_21:;
    }
    {
        PyObject *tmp_assign_source_53;
        {
            PyObject *tmp_set_locals_6;
            CHECK_OBJECT( tmp_class_creation_6__prepared );
            tmp_set_locals_6 = tmp_class_creation_6__prepared;
            locals_contextlib_165 = tmp_set_locals_6;
            Py_INCREF( tmp_set_locals_6 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_165, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto try_except_handler_18;
        }
        tmp_dictset_value = const_str_digest_2f96db194079aab1e334d80c67e520d2;
        tmp_res = PyObject_SetItem( locals_contextlib_165, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto try_except_handler_18;
        }
        tmp_dictset_value = const_str_plain__AsyncGeneratorContextManager;
        tmp_res = PyObject_SetItem( locals_contextlib_165, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto try_except_handler_18;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_ed080fdeb1d9225b601fa380040f8380_7, codeobj_ed080fdeb1d9225b601fa380040f8380, module_contextlib, sizeof(void *) );
        frame_ed080fdeb1d9225b601fa380040f8380_7 = cache_frame_ed080fdeb1d9225b601fa380040f8380_7;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_ed080fdeb1d9225b601fa380040f8380_7 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_ed080fdeb1d9225b601fa380040f8380_7 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_13___aenter__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_165, const_str_plain___aenter__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 168;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_14___aexit__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_165, const_str_plain___aexit__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 174;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_ed080fdeb1d9225b601fa380040f8380_7 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_6;

        frame_exception_exit_7:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_ed080fdeb1d9225b601fa380040f8380_7 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_ed080fdeb1d9225b601fa380040f8380_7, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_ed080fdeb1d9225b601fa380040f8380_7->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_ed080fdeb1d9225b601fa380040f8380_7, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_ed080fdeb1d9225b601fa380040f8380_7,
            type_description_2,
            outline_5_var___class__
        );


        // Release cached frame.
        if ( frame_ed080fdeb1d9225b601fa380040f8380_7 == cache_frame_ed080fdeb1d9225b601fa380040f8380_7 )
        {
            Py_DECREF( frame_ed080fdeb1d9225b601fa380040f8380_7 );
        }
        cache_frame_ed080fdeb1d9225b601fa380040f8380_7 = NULL;

        assertFrameObject( frame_ed080fdeb1d9225b601fa380040f8380_7 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_6;

        frame_no_exception_6:;
        goto skip_nested_handling_6;
        nested_frame_exit_6:;

        goto try_except_handler_18;
        skip_nested_handling_6:;
        {
            nuitka_bool tmp_condition_result_36;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            CHECK_OBJECT( tmp_class_creation_6__bases );
            tmp_compexpr_left_5 = tmp_class_creation_6__bases;
            CHECK_OBJECT( tmp_class_creation_6__bases_orig );
            tmp_compexpr_right_5 = tmp_class_creation_6__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 165;

                goto try_except_handler_18;
            }
            tmp_condition_result_36 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_36 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_23;
            }
            else
            {
                goto branch_no_23;
            }
            branch_yes_23:;
            CHECK_OBJECT( tmp_class_creation_6__bases_orig );
            tmp_dictset_value = tmp_class_creation_6__bases_orig;
            tmp_res = PyObject_SetItem( locals_contextlib_165, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 165;

                goto try_except_handler_18;
            }
            branch_no_23:;
        }
        {
            PyObject *tmp_assign_source_54;
            PyObject *tmp_called_name_14;
            PyObject *tmp_args_name_12;
            PyObject *tmp_tuple_element_21;
            PyObject *tmp_kw_name_12;
            CHECK_OBJECT( tmp_class_creation_6__metaclass );
            tmp_called_name_14 = tmp_class_creation_6__metaclass;
            tmp_tuple_element_21 = const_str_plain__AsyncGeneratorContextManager;
            tmp_args_name_12 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_21 );
            PyTuple_SET_ITEM( tmp_args_name_12, 0, tmp_tuple_element_21 );
            CHECK_OBJECT( tmp_class_creation_6__bases );
            tmp_tuple_element_21 = tmp_class_creation_6__bases;
            Py_INCREF( tmp_tuple_element_21 );
            PyTuple_SET_ITEM( tmp_args_name_12, 1, tmp_tuple_element_21 );
            tmp_tuple_element_21 = locals_contextlib_165;
            Py_INCREF( tmp_tuple_element_21 );
            PyTuple_SET_ITEM( tmp_args_name_12, 2, tmp_tuple_element_21 );
            CHECK_OBJECT( tmp_class_creation_6__class_decl_dict );
            tmp_kw_name_12 = tmp_class_creation_6__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 165;
            tmp_assign_source_54 = CALL_FUNCTION( tmp_called_name_14, tmp_args_name_12, tmp_kw_name_12 );
            Py_DECREF( tmp_args_name_12 );
            if ( tmp_assign_source_54 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 165;

                goto try_except_handler_18;
            }
            assert( outline_5_var___class__ == NULL );
            outline_5_var___class__ = tmp_assign_source_54;
        }
        CHECK_OBJECT( outline_5_var___class__ );
        tmp_assign_source_53 = outline_5_var___class__;
        Py_INCREF( tmp_assign_source_53 );
        goto try_return_handler_18;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_18:;
        Py_DECREF( locals_contextlib_165 );
        locals_contextlib_165 = NULL;
        goto try_return_handler_17;
        // Exception handler code:
        try_except_handler_18:;
        exception_keeper_type_16 = exception_type;
        exception_keeper_value_16 = exception_value;
        exception_keeper_tb_16 = exception_tb;
        exception_keeper_lineno_16 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_165 );
        locals_contextlib_165 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_16;
        exception_value = exception_keeper_value_16;
        exception_tb = exception_keeper_tb_16;
        exception_lineno = exception_keeper_lineno_16;

        goto try_except_handler_17;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_17:;
        CHECK_OBJECT( (PyObject *)outline_5_var___class__ );
        Py_DECREF( outline_5_var___class__ );
        outline_5_var___class__ = NULL;

        goto outline_result_6;
        // Exception handler code:
        try_except_handler_17:;
        exception_keeper_type_17 = exception_type;
        exception_keeper_value_17 = exception_value;
        exception_keeper_tb_17 = exception_tb;
        exception_keeper_lineno_17 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_17;
        exception_value = exception_keeper_value_17;
        exception_tb = exception_keeper_tb_17;
        exception_lineno = exception_keeper_lineno_17;

        goto outline_exception_6;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_6:;
        exception_lineno = 165;
        goto try_except_handler_16;
        outline_result_6:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__AsyncGeneratorContextManager, tmp_assign_source_53 );
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_16:;
    exception_keeper_type_18 = exception_type;
    exception_keeper_value_18 = exception_value;
    exception_keeper_tb_18 = exception_tb;
    exception_keeper_lineno_18 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_6__bases_orig );
    tmp_class_creation_6__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_6__bases );
    tmp_class_creation_6__bases = NULL;

    Py_XDECREF( tmp_class_creation_6__class_decl_dict );
    tmp_class_creation_6__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_6__prepared );
    tmp_class_creation_6__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_18;
    exception_value = exception_keeper_value_18;
    exception_tb = exception_keeper_tb_18;
    exception_lineno = exception_keeper_lineno_18;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__bases_orig );
    Py_DECREF( tmp_class_creation_6__bases_orig );
    tmp_class_creation_6__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__bases );
    Py_DECREF( tmp_class_creation_6__bases );
    tmp_class_creation_6__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class_decl_dict );
    Py_DECREF( tmp_class_creation_6__class_decl_dict );
    tmp_class_creation_6__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__metaclass );
    Py_DECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__prepared );
    Py_DECREF( tmp_class_creation_6__prepared );
    tmp_class_creation_6__prepared = NULL;

    {
        PyObject *tmp_assign_source_55;
        tmp_assign_source_55 = MAKE_FUNCTION_contextlib$$$function_15_contextmanager(  );



        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_contextmanager, tmp_assign_source_55 );
    }
    {
        PyObject *tmp_assign_source_56;
        tmp_assign_source_56 = MAKE_FUNCTION_contextlib$$$function_16_asynccontextmanager(  );



        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_asynccontextmanager, tmp_assign_source_56 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_57;
        PyObject *tmp_tuple_element_22;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "AbstractContextManager" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 276;

            goto try_except_handler_19;
        }

        tmp_tuple_element_22 = tmp_mvar_value_12;
        tmp_assign_source_57 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_22 );
        PyTuple_SET_ITEM( tmp_assign_source_57, 0, tmp_tuple_element_22 );
        assert( tmp_class_creation_7__bases_orig == NULL );
        tmp_class_creation_7__bases_orig = tmp_assign_source_57;
    }
    {
        PyObject *tmp_assign_source_58;
        PyObject *tmp_dircall_arg1_6;
        CHECK_OBJECT( tmp_class_creation_7__bases_orig );
        tmp_dircall_arg1_6 = tmp_class_creation_7__bases_orig;
        Py_INCREF( tmp_dircall_arg1_6 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_6};
            tmp_assign_source_58 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_58 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;

            goto try_except_handler_19;
        }
        assert( tmp_class_creation_7__bases == NULL );
        tmp_class_creation_7__bases = tmp_assign_source_58;
    }
    {
        PyObject *tmp_assign_source_59;
        tmp_assign_source_59 = PyDict_New();
        assert( tmp_class_creation_7__class_decl_dict == NULL );
        tmp_class_creation_7__class_decl_dict = tmp_assign_source_59;
    }
    {
        PyObject *tmp_assign_source_60;
        PyObject *tmp_metaclass_name_7;
        nuitka_bool tmp_condition_result_37;
        PyObject *tmp_key_name_19;
        PyObject *tmp_dict_name_19;
        PyObject *tmp_dict_name_20;
        PyObject *tmp_key_name_20;
        nuitka_bool tmp_condition_result_38;
        int tmp_truth_name_6;
        PyObject *tmp_type_arg_12;
        PyObject *tmp_subscribed_name_6;
        PyObject *tmp_subscript_name_6;
        PyObject *tmp_bases_name_7;
        tmp_key_name_19 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_7__class_decl_dict );
        tmp_dict_name_19 = tmp_class_creation_7__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_19, tmp_key_name_19 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;

            goto try_except_handler_19;
        }
        tmp_condition_result_37 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_37 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_14;
        }
        else
        {
            goto condexpr_false_14;
        }
        condexpr_true_14:;
        CHECK_OBJECT( tmp_class_creation_7__class_decl_dict );
        tmp_dict_name_20 = tmp_class_creation_7__class_decl_dict;
        tmp_key_name_20 = const_str_plain_metaclass;
        tmp_metaclass_name_7 = DICT_GET_ITEM( tmp_dict_name_20, tmp_key_name_20 );
        if ( tmp_metaclass_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;

            goto try_except_handler_19;
        }
        goto condexpr_end_14;
        condexpr_false_14:;
        CHECK_OBJECT( tmp_class_creation_7__bases );
        tmp_truth_name_6 = CHECK_IF_TRUE( tmp_class_creation_7__bases );
        if ( tmp_truth_name_6 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;

            goto try_except_handler_19;
        }
        tmp_condition_result_38 = tmp_truth_name_6 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_38 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_15;
        }
        else
        {
            goto condexpr_false_15;
        }
        condexpr_true_15:;
        CHECK_OBJECT( tmp_class_creation_7__bases );
        tmp_subscribed_name_6 = tmp_class_creation_7__bases;
        tmp_subscript_name_6 = const_int_0;
        tmp_type_arg_12 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_6, tmp_subscript_name_6, 0 );
        if ( tmp_type_arg_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;

            goto try_except_handler_19;
        }
        tmp_metaclass_name_7 = BUILTIN_TYPE1( tmp_type_arg_12 );
        Py_DECREF( tmp_type_arg_12 );
        if ( tmp_metaclass_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;

            goto try_except_handler_19;
        }
        goto condexpr_end_15;
        condexpr_false_15:;
        tmp_metaclass_name_7 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_7 );
        condexpr_end_15:;
        condexpr_end_14:;
        CHECK_OBJECT( tmp_class_creation_7__bases );
        tmp_bases_name_7 = tmp_class_creation_7__bases;
        tmp_assign_source_60 = SELECT_METACLASS( tmp_metaclass_name_7, tmp_bases_name_7 );
        Py_DECREF( tmp_metaclass_name_7 );
        if ( tmp_assign_source_60 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;

            goto try_except_handler_19;
        }
        assert( tmp_class_creation_7__metaclass == NULL );
        tmp_class_creation_7__metaclass = tmp_assign_source_60;
    }
    {
        nuitka_bool tmp_condition_result_39;
        PyObject *tmp_key_name_21;
        PyObject *tmp_dict_name_21;
        tmp_key_name_21 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_7__class_decl_dict );
        tmp_dict_name_21 = tmp_class_creation_7__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_21, tmp_key_name_21 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;

            goto try_except_handler_19;
        }
        tmp_condition_result_39 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_39 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_24;
        }
        else
        {
            goto branch_no_24;
        }
        branch_yes_24:;
        CHECK_OBJECT( tmp_class_creation_7__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_7__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;

            goto try_except_handler_19;
        }
        branch_no_24:;
    }
    {
        nuitka_bool tmp_condition_result_40;
        PyObject *tmp_source_name_27;
        CHECK_OBJECT( tmp_class_creation_7__metaclass );
        tmp_source_name_27 = tmp_class_creation_7__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_27, const_str_plain___prepare__ );
        tmp_condition_result_40 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_40 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_25;
        }
        else
        {
            goto branch_no_25;
        }
        branch_yes_25:;
        {
            PyObject *tmp_assign_source_61;
            PyObject *tmp_called_name_15;
            PyObject *tmp_source_name_28;
            PyObject *tmp_args_name_13;
            PyObject *tmp_tuple_element_23;
            PyObject *tmp_kw_name_13;
            CHECK_OBJECT( tmp_class_creation_7__metaclass );
            tmp_source_name_28 = tmp_class_creation_7__metaclass;
            tmp_called_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_28, const_str_plain___prepare__ );
            if ( tmp_called_name_15 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 276;

                goto try_except_handler_19;
            }
            tmp_tuple_element_23 = const_str_plain_closing;
            tmp_args_name_13 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_23 );
            PyTuple_SET_ITEM( tmp_args_name_13, 0, tmp_tuple_element_23 );
            CHECK_OBJECT( tmp_class_creation_7__bases );
            tmp_tuple_element_23 = tmp_class_creation_7__bases;
            Py_INCREF( tmp_tuple_element_23 );
            PyTuple_SET_ITEM( tmp_args_name_13, 1, tmp_tuple_element_23 );
            CHECK_OBJECT( tmp_class_creation_7__class_decl_dict );
            tmp_kw_name_13 = tmp_class_creation_7__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 276;
            tmp_assign_source_61 = CALL_FUNCTION( tmp_called_name_15, tmp_args_name_13, tmp_kw_name_13 );
            Py_DECREF( tmp_called_name_15 );
            Py_DECREF( tmp_args_name_13 );
            if ( tmp_assign_source_61 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 276;

                goto try_except_handler_19;
            }
            assert( tmp_class_creation_7__prepared == NULL );
            tmp_class_creation_7__prepared = tmp_assign_source_61;
        }
        {
            nuitka_bool tmp_condition_result_41;
            PyObject *tmp_operand_name_7;
            PyObject *tmp_source_name_29;
            CHECK_OBJECT( tmp_class_creation_7__prepared );
            tmp_source_name_29 = tmp_class_creation_7__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_29, const_str_plain___getitem__ );
            tmp_operand_name_7 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_7 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 276;

                goto try_except_handler_19;
            }
            tmp_condition_result_41 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_41 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_26;
            }
            else
            {
                goto branch_no_26;
            }
            branch_yes_26:;
            {
                PyObject *tmp_raise_type_7;
                PyObject *tmp_raise_value_7;
                PyObject *tmp_left_name_7;
                PyObject *tmp_right_name_7;
                PyObject *tmp_tuple_element_24;
                PyObject *tmp_getattr_target_7;
                PyObject *tmp_getattr_attr_7;
                PyObject *tmp_getattr_default_7;
                PyObject *tmp_source_name_30;
                PyObject *tmp_type_arg_13;
                tmp_raise_type_7 = PyExc_TypeError;
                tmp_left_name_7 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_7__metaclass );
                tmp_getattr_target_7 = tmp_class_creation_7__metaclass;
                tmp_getattr_attr_7 = const_str_plain___name__;
                tmp_getattr_default_7 = const_str_angle_metaclass;
                tmp_tuple_element_24 = BUILTIN_GETATTR( tmp_getattr_target_7, tmp_getattr_attr_7, tmp_getattr_default_7 );
                if ( tmp_tuple_element_24 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 276;

                    goto try_except_handler_19;
                }
                tmp_right_name_7 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_7, 0, tmp_tuple_element_24 );
                CHECK_OBJECT( tmp_class_creation_7__prepared );
                tmp_type_arg_13 = tmp_class_creation_7__prepared;
                tmp_source_name_30 = BUILTIN_TYPE1( tmp_type_arg_13 );
                assert( !(tmp_source_name_30 == NULL) );
                tmp_tuple_element_24 = LOOKUP_ATTRIBUTE( tmp_source_name_30, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_30 );
                if ( tmp_tuple_element_24 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_7 );

                    exception_lineno = 276;

                    goto try_except_handler_19;
                }
                PyTuple_SET_ITEM( tmp_right_name_7, 1, tmp_tuple_element_24 );
                tmp_raise_value_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_7, tmp_right_name_7 );
                Py_DECREF( tmp_right_name_7 );
                if ( tmp_raise_value_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 276;

                    goto try_except_handler_19;
                }
                exception_type = tmp_raise_type_7;
                Py_INCREF( tmp_raise_type_7 );
                exception_value = tmp_raise_value_7;
                exception_lineno = 276;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_19;
            }
            branch_no_26:;
        }
        goto branch_end_25;
        branch_no_25:;
        {
            PyObject *tmp_assign_source_62;
            tmp_assign_source_62 = PyDict_New();
            assert( tmp_class_creation_7__prepared == NULL );
            tmp_class_creation_7__prepared = tmp_assign_source_62;
        }
        branch_end_25:;
    }
    {
        PyObject *tmp_assign_source_63;
        {
            PyObject *tmp_set_locals_7;
            CHECK_OBJECT( tmp_class_creation_7__prepared );
            tmp_set_locals_7 = tmp_class_creation_7__prepared;
            locals_contextlib_276 = tmp_set_locals_7;
            Py_INCREF( tmp_set_locals_7 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_276, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;

            goto try_except_handler_21;
        }
        tmp_dictset_value = const_str_digest_b4cbc7dbf1044832ac051ba8cf22b782;
        tmp_res = PyObject_SetItem( locals_contextlib_276, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;

            goto try_except_handler_21;
        }
        tmp_dictset_value = const_str_plain_closing;
        tmp_res = PyObject_SetItem( locals_contextlib_276, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;

            goto try_except_handler_21;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_5d897d4474259a7128af7713d0e7b885_8, codeobj_5d897d4474259a7128af7713d0e7b885, module_contextlib, sizeof(void *) );
        frame_5d897d4474259a7128af7713d0e7b885_8 = cache_frame_5d897d4474259a7128af7713d0e7b885_8;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_5d897d4474259a7128af7713d0e7b885_8 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_5d897d4474259a7128af7713d0e7b885_8 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_17___init__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_276, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 293;
            type_description_2 = "o";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_18___enter__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_276, const_str_plain___enter__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 295;
            type_description_2 = "o";
            goto frame_exception_exit_8;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_19___exit__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_276, const_str_plain___exit__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 297;
            type_description_2 = "o";
            goto frame_exception_exit_8;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_5d897d4474259a7128af7713d0e7b885_8 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_7;

        frame_exception_exit_8:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_5d897d4474259a7128af7713d0e7b885_8 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_5d897d4474259a7128af7713d0e7b885_8, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_5d897d4474259a7128af7713d0e7b885_8->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_5d897d4474259a7128af7713d0e7b885_8, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_5d897d4474259a7128af7713d0e7b885_8,
            type_description_2,
            outline_6_var___class__
        );


        // Release cached frame.
        if ( frame_5d897d4474259a7128af7713d0e7b885_8 == cache_frame_5d897d4474259a7128af7713d0e7b885_8 )
        {
            Py_DECREF( frame_5d897d4474259a7128af7713d0e7b885_8 );
        }
        cache_frame_5d897d4474259a7128af7713d0e7b885_8 = NULL;

        assertFrameObject( frame_5d897d4474259a7128af7713d0e7b885_8 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_7;

        frame_no_exception_7:;
        goto skip_nested_handling_7;
        nested_frame_exit_7:;

        goto try_except_handler_21;
        skip_nested_handling_7:;
        {
            nuitka_bool tmp_condition_result_42;
            PyObject *tmp_compexpr_left_6;
            PyObject *tmp_compexpr_right_6;
            CHECK_OBJECT( tmp_class_creation_7__bases );
            tmp_compexpr_left_6 = tmp_class_creation_7__bases;
            CHECK_OBJECT( tmp_class_creation_7__bases_orig );
            tmp_compexpr_right_6 = tmp_class_creation_7__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 276;

                goto try_except_handler_21;
            }
            tmp_condition_result_42 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_42 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_27;
            }
            else
            {
                goto branch_no_27;
            }
            branch_yes_27:;
            CHECK_OBJECT( tmp_class_creation_7__bases_orig );
            tmp_dictset_value = tmp_class_creation_7__bases_orig;
            tmp_res = PyObject_SetItem( locals_contextlib_276, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 276;

                goto try_except_handler_21;
            }
            branch_no_27:;
        }
        {
            PyObject *tmp_assign_source_64;
            PyObject *tmp_called_name_16;
            PyObject *tmp_args_name_14;
            PyObject *tmp_tuple_element_25;
            PyObject *tmp_kw_name_14;
            CHECK_OBJECT( tmp_class_creation_7__metaclass );
            tmp_called_name_16 = tmp_class_creation_7__metaclass;
            tmp_tuple_element_25 = const_str_plain_closing;
            tmp_args_name_14 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_25 );
            PyTuple_SET_ITEM( tmp_args_name_14, 0, tmp_tuple_element_25 );
            CHECK_OBJECT( tmp_class_creation_7__bases );
            tmp_tuple_element_25 = tmp_class_creation_7__bases;
            Py_INCREF( tmp_tuple_element_25 );
            PyTuple_SET_ITEM( tmp_args_name_14, 1, tmp_tuple_element_25 );
            tmp_tuple_element_25 = locals_contextlib_276;
            Py_INCREF( tmp_tuple_element_25 );
            PyTuple_SET_ITEM( tmp_args_name_14, 2, tmp_tuple_element_25 );
            CHECK_OBJECT( tmp_class_creation_7__class_decl_dict );
            tmp_kw_name_14 = tmp_class_creation_7__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 276;
            tmp_assign_source_64 = CALL_FUNCTION( tmp_called_name_16, tmp_args_name_14, tmp_kw_name_14 );
            Py_DECREF( tmp_args_name_14 );
            if ( tmp_assign_source_64 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 276;

                goto try_except_handler_21;
            }
            assert( outline_6_var___class__ == NULL );
            outline_6_var___class__ = tmp_assign_source_64;
        }
        CHECK_OBJECT( outline_6_var___class__ );
        tmp_assign_source_63 = outline_6_var___class__;
        Py_INCREF( tmp_assign_source_63 );
        goto try_return_handler_21;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_21:;
        Py_DECREF( locals_contextlib_276 );
        locals_contextlib_276 = NULL;
        goto try_return_handler_20;
        // Exception handler code:
        try_except_handler_21:;
        exception_keeper_type_19 = exception_type;
        exception_keeper_value_19 = exception_value;
        exception_keeper_tb_19 = exception_tb;
        exception_keeper_lineno_19 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_276 );
        locals_contextlib_276 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_19;
        exception_value = exception_keeper_value_19;
        exception_tb = exception_keeper_tb_19;
        exception_lineno = exception_keeper_lineno_19;

        goto try_except_handler_20;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_20:;
        CHECK_OBJECT( (PyObject *)outline_6_var___class__ );
        Py_DECREF( outline_6_var___class__ );
        outline_6_var___class__ = NULL;

        goto outline_result_7;
        // Exception handler code:
        try_except_handler_20:;
        exception_keeper_type_20 = exception_type;
        exception_keeper_value_20 = exception_value;
        exception_keeper_tb_20 = exception_tb;
        exception_keeper_lineno_20 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_20;
        exception_value = exception_keeper_value_20;
        exception_tb = exception_keeper_tb_20;
        exception_lineno = exception_keeper_lineno_20;

        goto outline_exception_7;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_7:;
        exception_lineno = 276;
        goto try_except_handler_19;
        outline_result_7:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_closing, tmp_assign_source_63 );
    }
    goto try_end_7;
    // Exception handler code:
    try_except_handler_19:;
    exception_keeper_type_21 = exception_type;
    exception_keeper_value_21 = exception_value;
    exception_keeper_tb_21 = exception_tb;
    exception_keeper_lineno_21 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_7__bases_orig );
    tmp_class_creation_7__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_7__bases );
    tmp_class_creation_7__bases = NULL;

    Py_XDECREF( tmp_class_creation_7__class_decl_dict );
    tmp_class_creation_7__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_7__prepared );
    tmp_class_creation_7__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_21;
    exception_value = exception_keeper_value_21;
    exception_tb = exception_keeper_tb_21;
    exception_lineno = exception_keeper_lineno_21;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__bases_orig );
    Py_DECREF( tmp_class_creation_7__bases_orig );
    tmp_class_creation_7__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__bases );
    Py_DECREF( tmp_class_creation_7__bases );
    tmp_class_creation_7__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class_decl_dict );
    Py_DECREF( tmp_class_creation_7__class_decl_dict );
    tmp_class_creation_7__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__metaclass );
    Py_DECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__prepared );
    Py_DECREF( tmp_class_creation_7__prepared );
    tmp_class_creation_7__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_65;
        PyObject *tmp_tuple_element_26;
        PyObject *tmp_mvar_value_13;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "AbstractContextManager" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 301;

            goto try_except_handler_22;
        }

        tmp_tuple_element_26 = tmp_mvar_value_13;
        tmp_assign_source_65 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_26 );
        PyTuple_SET_ITEM( tmp_assign_source_65, 0, tmp_tuple_element_26 );
        assert( tmp_class_creation_8__bases_orig == NULL );
        tmp_class_creation_8__bases_orig = tmp_assign_source_65;
    }
    {
        PyObject *tmp_assign_source_66;
        PyObject *tmp_dircall_arg1_7;
        CHECK_OBJECT( tmp_class_creation_8__bases_orig );
        tmp_dircall_arg1_7 = tmp_class_creation_8__bases_orig;
        Py_INCREF( tmp_dircall_arg1_7 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_7};
            tmp_assign_source_66 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_66 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;

            goto try_except_handler_22;
        }
        assert( tmp_class_creation_8__bases == NULL );
        tmp_class_creation_8__bases = tmp_assign_source_66;
    }
    {
        PyObject *tmp_assign_source_67;
        tmp_assign_source_67 = PyDict_New();
        assert( tmp_class_creation_8__class_decl_dict == NULL );
        tmp_class_creation_8__class_decl_dict = tmp_assign_source_67;
    }
    {
        PyObject *tmp_assign_source_68;
        PyObject *tmp_metaclass_name_8;
        nuitka_bool tmp_condition_result_43;
        PyObject *tmp_key_name_22;
        PyObject *tmp_dict_name_22;
        PyObject *tmp_dict_name_23;
        PyObject *tmp_key_name_23;
        nuitka_bool tmp_condition_result_44;
        int tmp_truth_name_7;
        PyObject *tmp_type_arg_14;
        PyObject *tmp_subscribed_name_7;
        PyObject *tmp_subscript_name_7;
        PyObject *tmp_bases_name_8;
        tmp_key_name_22 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_8__class_decl_dict );
        tmp_dict_name_22 = tmp_class_creation_8__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_22, tmp_key_name_22 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;

            goto try_except_handler_22;
        }
        tmp_condition_result_43 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_43 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_16;
        }
        else
        {
            goto condexpr_false_16;
        }
        condexpr_true_16:;
        CHECK_OBJECT( tmp_class_creation_8__class_decl_dict );
        tmp_dict_name_23 = tmp_class_creation_8__class_decl_dict;
        tmp_key_name_23 = const_str_plain_metaclass;
        tmp_metaclass_name_8 = DICT_GET_ITEM( tmp_dict_name_23, tmp_key_name_23 );
        if ( tmp_metaclass_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;

            goto try_except_handler_22;
        }
        goto condexpr_end_16;
        condexpr_false_16:;
        CHECK_OBJECT( tmp_class_creation_8__bases );
        tmp_truth_name_7 = CHECK_IF_TRUE( tmp_class_creation_8__bases );
        if ( tmp_truth_name_7 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;

            goto try_except_handler_22;
        }
        tmp_condition_result_44 = tmp_truth_name_7 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_44 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_17;
        }
        else
        {
            goto condexpr_false_17;
        }
        condexpr_true_17:;
        CHECK_OBJECT( tmp_class_creation_8__bases );
        tmp_subscribed_name_7 = tmp_class_creation_8__bases;
        tmp_subscript_name_7 = const_int_0;
        tmp_type_arg_14 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_7, tmp_subscript_name_7, 0 );
        if ( tmp_type_arg_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;

            goto try_except_handler_22;
        }
        tmp_metaclass_name_8 = BUILTIN_TYPE1( tmp_type_arg_14 );
        Py_DECREF( tmp_type_arg_14 );
        if ( tmp_metaclass_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;

            goto try_except_handler_22;
        }
        goto condexpr_end_17;
        condexpr_false_17:;
        tmp_metaclass_name_8 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_8 );
        condexpr_end_17:;
        condexpr_end_16:;
        CHECK_OBJECT( tmp_class_creation_8__bases );
        tmp_bases_name_8 = tmp_class_creation_8__bases;
        tmp_assign_source_68 = SELECT_METACLASS( tmp_metaclass_name_8, tmp_bases_name_8 );
        Py_DECREF( tmp_metaclass_name_8 );
        if ( tmp_assign_source_68 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;

            goto try_except_handler_22;
        }
        assert( tmp_class_creation_8__metaclass == NULL );
        tmp_class_creation_8__metaclass = tmp_assign_source_68;
    }
    {
        nuitka_bool tmp_condition_result_45;
        PyObject *tmp_key_name_24;
        PyObject *tmp_dict_name_24;
        tmp_key_name_24 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_8__class_decl_dict );
        tmp_dict_name_24 = tmp_class_creation_8__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_24, tmp_key_name_24 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;

            goto try_except_handler_22;
        }
        tmp_condition_result_45 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_45 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_28;
        }
        else
        {
            goto branch_no_28;
        }
        branch_yes_28:;
        CHECK_OBJECT( tmp_class_creation_8__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_8__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;

            goto try_except_handler_22;
        }
        branch_no_28:;
    }
    {
        nuitka_bool tmp_condition_result_46;
        PyObject *tmp_source_name_31;
        CHECK_OBJECT( tmp_class_creation_8__metaclass );
        tmp_source_name_31 = tmp_class_creation_8__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_31, const_str_plain___prepare__ );
        tmp_condition_result_46 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_46 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_29;
        }
        else
        {
            goto branch_no_29;
        }
        branch_yes_29:;
        {
            PyObject *tmp_assign_source_69;
            PyObject *tmp_called_name_17;
            PyObject *tmp_source_name_32;
            PyObject *tmp_args_name_15;
            PyObject *tmp_tuple_element_27;
            PyObject *tmp_kw_name_15;
            CHECK_OBJECT( tmp_class_creation_8__metaclass );
            tmp_source_name_32 = tmp_class_creation_8__metaclass;
            tmp_called_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_32, const_str_plain___prepare__ );
            if ( tmp_called_name_17 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 301;

                goto try_except_handler_22;
            }
            tmp_tuple_element_27 = const_str_plain__RedirectStream;
            tmp_args_name_15 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_27 );
            PyTuple_SET_ITEM( tmp_args_name_15, 0, tmp_tuple_element_27 );
            CHECK_OBJECT( tmp_class_creation_8__bases );
            tmp_tuple_element_27 = tmp_class_creation_8__bases;
            Py_INCREF( tmp_tuple_element_27 );
            PyTuple_SET_ITEM( tmp_args_name_15, 1, tmp_tuple_element_27 );
            CHECK_OBJECT( tmp_class_creation_8__class_decl_dict );
            tmp_kw_name_15 = tmp_class_creation_8__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 301;
            tmp_assign_source_69 = CALL_FUNCTION( tmp_called_name_17, tmp_args_name_15, tmp_kw_name_15 );
            Py_DECREF( tmp_called_name_17 );
            Py_DECREF( tmp_args_name_15 );
            if ( tmp_assign_source_69 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 301;

                goto try_except_handler_22;
            }
            assert( tmp_class_creation_8__prepared == NULL );
            tmp_class_creation_8__prepared = tmp_assign_source_69;
        }
        {
            nuitka_bool tmp_condition_result_47;
            PyObject *tmp_operand_name_8;
            PyObject *tmp_source_name_33;
            CHECK_OBJECT( tmp_class_creation_8__prepared );
            tmp_source_name_33 = tmp_class_creation_8__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_33, const_str_plain___getitem__ );
            tmp_operand_name_8 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_8 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 301;

                goto try_except_handler_22;
            }
            tmp_condition_result_47 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_47 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_30;
            }
            else
            {
                goto branch_no_30;
            }
            branch_yes_30:;
            {
                PyObject *tmp_raise_type_8;
                PyObject *tmp_raise_value_8;
                PyObject *tmp_left_name_8;
                PyObject *tmp_right_name_8;
                PyObject *tmp_tuple_element_28;
                PyObject *tmp_getattr_target_8;
                PyObject *tmp_getattr_attr_8;
                PyObject *tmp_getattr_default_8;
                PyObject *tmp_source_name_34;
                PyObject *tmp_type_arg_15;
                tmp_raise_type_8 = PyExc_TypeError;
                tmp_left_name_8 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_8__metaclass );
                tmp_getattr_target_8 = tmp_class_creation_8__metaclass;
                tmp_getattr_attr_8 = const_str_plain___name__;
                tmp_getattr_default_8 = const_str_angle_metaclass;
                tmp_tuple_element_28 = BUILTIN_GETATTR( tmp_getattr_target_8, tmp_getattr_attr_8, tmp_getattr_default_8 );
                if ( tmp_tuple_element_28 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 301;

                    goto try_except_handler_22;
                }
                tmp_right_name_8 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_8, 0, tmp_tuple_element_28 );
                CHECK_OBJECT( tmp_class_creation_8__prepared );
                tmp_type_arg_15 = tmp_class_creation_8__prepared;
                tmp_source_name_34 = BUILTIN_TYPE1( tmp_type_arg_15 );
                assert( !(tmp_source_name_34 == NULL) );
                tmp_tuple_element_28 = LOOKUP_ATTRIBUTE( tmp_source_name_34, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_34 );
                if ( tmp_tuple_element_28 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_8 );

                    exception_lineno = 301;

                    goto try_except_handler_22;
                }
                PyTuple_SET_ITEM( tmp_right_name_8, 1, tmp_tuple_element_28 );
                tmp_raise_value_8 = BINARY_OPERATION_REMAINDER( tmp_left_name_8, tmp_right_name_8 );
                Py_DECREF( tmp_right_name_8 );
                if ( tmp_raise_value_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 301;

                    goto try_except_handler_22;
                }
                exception_type = tmp_raise_type_8;
                Py_INCREF( tmp_raise_type_8 );
                exception_value = tmp_raise_value_8;
                exception_lineno = 301;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_22;
            }
            branch_no_30:;
        }
        goto branch_end_29;
        branch_no_29:;
        {
            PyObject *tmp_assign_source_70;
            tmp_assign_source_70 = PyDict_New();
            assert( tmp_class_creation_8__prepared == NULL );
            tmp_class_creation_8__prepared = tmp_assign_source_70;
        }
        branch_end_29:;
    }
    {
        PyObject *tmp_assign_source_71;
        {
            PyObject *tmp_set_locals_8;
            CHECK_OBJECT( tmp_class_creation_8__prepared );
            tmp_set_locals_8 = tmp_class_creation_8__prepared;
            locals_contextlib_301 = tmp_set_locals_8;
            Py_INCREF( tmp_set_locals_8 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_301, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;

            goto try_except_handler_24;
        }
        tmp_dictset_value = const_str_plain__RedirectStream;
        tmp_res = PyObject_SetItem( locals_contextlib_301, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;

            goto try_except_handler_24;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_01fcb8cd929b0c4b32cd16ad15de112a_9, codeobj_01fcb8cd929b0c4b32cd16ad15de112a, module_contextlib, sizeof(void *) );
        frame_01fcb8cd929b0c4b32cd16ad15de112a_9 = cache_frame_01fcb8cd929b0c4b32cd16ad15de112a_9;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_01fcb8cd929b0c4b32cd16ad15de112a_9 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_01fcb8cd929b0c4b32cd16ad15de112a_9 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = Py_None;
        tmp_res = PyObject_SetItem( locals_contextlib_301, const_str_plain__stream, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 303;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_20___init__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_301, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 305;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_21___enter__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_301, const_str_plain___enter__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 310;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_22___exit__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_301, const_str_plain___exit__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 315;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_01fcb8cd929b0c4b32cd16ad15de112a_9 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_8;

        frame_exception_exit_9:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_01fcb8cd929b0c4b32cd16ad15de112a_9 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_01fcb8cd929b0c4b32cd16ad15de112a_9, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_01fcb8cd929b0c4b32cd16ad15de112a_9->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_01fcb8cd929b0c4b32cd16ad15de112a_9, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_01fcb8cd929b0c4b32cd16ad15de112a_9,
            type_description_2,
            outline_7_var___class__
        );


        // Release cached frame.
        if ( frame_01fcb8cd929b0c4b32cd16ad15de112a_9 == cache_frame_01fcb8cd929b0c4b32cd16ad15de112a_9 )
        {
            Py_DECREF( frame_01fcb8cd929b0c4b32cd16ad15de112a_9 );
        }
        cache_frame_01fcb8cd929b0c4b32cd16ad15de112a_9 = NULL;

        assertFrameObject( frame_01fcb8cd929b0c4b32cd16ad15de112a_9 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_8;

        frame_no_exception_8:;
        goto skip_nested_handling_8;
        nested_frame_exit_8:;

        goto try_except_handler_24;
        skip_nested_handling_8:;
        {
            nuitka_bool tmp_condition_result_48;
            PyObject *tmp_compexpr_left_7;
            PyObject *tmp_compexpr_right_7;
            CHECK_OBJECT( tmp_class_creation_8__bases );
            tmp_compexpr_left_7 = tmp_class_creation_8__bases;
            CHECK_OBJECT( tmp_class_creation_8__bases_orig );
            tmp_compexpr_right_7 = tmp_class_creation_8__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_7, tmp_compexpr_right_7 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 301;

                goto try_except_handler_24;
            }
            tmp_condition_result_48 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_48 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_31;
            }
            else
            {
                goto branch_no_31;
            }
            branch_yes_31:;
            CHECK_OBJECT( tmp_class_creation_8__bases_orig );
            tmp_dictset_value = tmp_class_creation_8__bases_orig;
            tmp_res = PyObject_SetItem( locals_contextlib_301, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 301;

                goto try_except_handler_24;
            }
            branch_no_31:;
        }
        {
            PyObject *tmp_assign_source_72;
            PyObject *tmp_called_name_18;
            PyObject *tmp_args_name_16;
            PyObject *tmp_tuple_element_29;
            PyObject *tmp_kw_name_16;
            CHECK_OBJECT( tmp_class_creation_8__metaclass );
            tmp_called_name_18 = tmp_class_creation_8__metaclass;
            tmp_tuple_element_29 = const_str_plain__RedirectStream;
            tmp_args_name_16 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_29 );
            PyTuple_SET_ITEM( tmp_args_name_16, 0, tmp_tuple_element_29 );
            CHECK_OBJECT( tmp_class_creation_8__bases );
            tmp_tuple_element_29 = tmp_class_creation_8__bases;
            Py_INCREF( tmp_tuple_element_29 );
            PyTuple_SET_ITEM( tmp_args_name_16, 1, tmp_tuple_element_29 );
            tmp_tuple_element_29 = locals_contextlib_301;
            Py_INCREF( tmp_tuple_element_29 );
            PyTuple_SET_ITEM( tmp_args_name_16, 2, tmp_tuple_element_29 );
            CHECK_OBJECT( tmp_class_creation_8__class_decl_dict );
            tmp_kw_name_16 = tmp_class_creation_8__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 301;
            tmp_assign_source_72 = CALL_FUNCTION( tmp_called_name_18, tmp_args_name_16, tmp_kw_name_16 );
            Py_DECREF( tmp_args_name_16 );
            if ( tmp_assign_source_72 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 301;

                goto try_except_handler_24;
            }
            assert( outline_7_var___class__ == NULL );
            outline_7_var___class__ = tmp_assign_source_72;
        }
        CHECK_OBJECT( outline_7_var___class__ );
        tmp_assign_source_71 = outline_7_var___class__;
        Py_INCREF( tmp_assign_source_71 );
        goto try_return_handler_24;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_24:;
        Py_DECREF( locals_contextlib_301 );
        locals_contextlib_301 = NULL;
        goto try_return_handler_23;
        // Exception handler code:
        try_except_handler_24:;
        exception_keeper_type_22 = exception_type;
        exception_keeper_value_22 = exception_value;
        exception_keeper_tb_22 = exception_tb;
        exception_keeper_lineno_22 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_301 );
        locals_contextlib_301 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_22;
        exception_value = exception_keeper_value_22;
        exception_tb = exception_keeper_tb_22;
        exception_lineno = exception_keeper_lineno_22;

        goto try_except_handler_23;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_23:;
        CHECK_OBJECT( (PyObject *)outline_7_var___class__ );
        Py_DECREF( outline_7_var___class__ );
        outline_7_var___class__ = NULL;

        goto outline_result_8;
        // Exception handler code:
        try_except_handler_23:;
        exception_keeper_type_23 = exception_type;
        exception_keeper_value_23 = exception_value;
        exception_keeper_tb_23 = exception_tb;
        exception_keeper_lineno_23 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_23;
        exception_value = exception_keeper_value_23;
        exception_tb = exception_keeper_tb_23;
        exception_lineno = exception_keeper_lineno_23;

        goto outline_exception_8;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_8:;
        exception_lineno = 301;
        goto try_except_handler_22;
        outline_result_8:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__RedirectStream, tmp_assign_source_71 );
    }
    goto try_end_8;
    // Exception handler code:
    try_except_handler_22:;
    exception_keeper_type_24 = exception_type;
    exception_keeper_value_24 = exception_value;
    exception_keeper_tb_24 = exception_tb;
    exception_keeper_lineno_24 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_8__bases_orig );
    tmp_class_creation_8__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_8__bases );
    tmp_class_creation_8__bases = NULL;

    Py_XDECREF( tmp_class_creation_8__class_decl_dict );
    tmp_class_creation_8__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_8__prepared );
    tmp_class_creation_8__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_24;
    exception_value = exception_keeper_value_24;
    exception_tb = exception_keeper_tb_24;
    exception_lineno = exception_keeper_lineno_24;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__bases_orig );
    Py_DECREF( tmp_class_creation_8__bases_orig );
    tmp_class_creation_8__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__bases );
    Py_DECREF( tmp_class_creation_8__bases );
    tmp_class_creation_8__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class_decl_dict );
    Py_DECREF( tmp_class_creation_8__class_decl_dict );
    tmp_class_creation_8__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__metaclass );
    Py_DECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__prepared );
    Py_DECREF( tmp_class_creation_8__prepared );
    tmp_class_creation_8__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_73;
        PyObject *tmp_tuple_element_30;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__RedirectStream );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__RedirectStream );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_RedirectStream" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 319;

            goto try_except_handler_25;
        }

        tmp_tuple_element_30 = tmp_mvar_value_14;
        tmp_assign_source_73 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_30 );
        PyTuple_SET_ITEM( tmp_assign_source_73, 0, tmp_tuple_element_30 );
        assert( tmp_class_creation_9__bases_orig == NULL );
        tmp_class_creation_9__bases_orig = tmp_assign_source_73;
    }
    {
        PyObject *tmp_assign_source_74;
        PyObject *tmp_dircall_arg1_8;
        CHECK_OBJECT( tmp_class_creation_9__bases_orig );
        tmp_dircall_arg1_8 = tmp_class_creation_9__bases_orig;
        Py_INCREF( tmp_dircall_arg1_8 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_8};
            tmp_assign_source_74 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_74 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;

            goto try_except_handler_25;
        }
        assert( tmp_class_creation_9__bases == NULL );
        tmp_class_creation_9__bases = tmp_assign_source_74;
    }
    {
        PyObject *tmp_assign_source_75;
        tmp_assign_source_75 = PyDict_New();
        assert( tmp_class_creation_9__class_decl_dict == NULL );
        tmp_class_creation_9__class_decl_dict = tmp_assign_source_75;
    }
    {
        PyObject *tmp_assign_source_76;
        PyObject *tmp_metaclass_name_9;
        nuitka_bool tmp_condition_result_49;
        PyObject *tmp_key_name_25;
        PyObject *tmp_dict_name_25;
        PyObject *tmp_dict_name_26;
        PyObject *tmp_key_name_26;
        nuitka_bool tmp_condition_result_50;
        int tmp_truth_name_8;
        PyObject *tmp_type_arg_16;
        PyObject *tmp_subscribed_name_8;
        PyObject *tmp_subscript_name_8;
        PyObject *tmp_bases_name_9;
        tmp_key_name_25 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_9__class_decl_dict );
        tmp_dict_name_25 = tmp_class_creation_9__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_25, tmp_key_name_25 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;

            goto try_except_handler_25;
        }
        tmp_condition_result_49 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_49 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_18;
        }
        else
        {
            goto condexpr_false_18;
        }
        condexpr_true_18:;
        CHECK_OBJECT( tmp_class_creation_9__class_decl_dict );
        tmp_dict_name_26 = tmp_class_creation_9__class_decl_dict;
        tmp_key_name_26 = const_str_plain_metaclass;
        tmp_metaclass_name_9 = DICT_GET_ITEM( tmp_dict_name_26, tmp_key_name_26 );
        if ( tmp_metaclass_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;

            goto try_except_handler_25;
        }
        goto condexpr_end_18;
        condexpr_false_18:;
        CHECK_OBJECT( tmp_class_creation_9__bases );
        tmp_truth_name_8 = CHECK_IF_TRUE( tmp_class_creation_9__bases );
        if ( tmp_truth_name_8 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;

            goto try_except_handler_25;
        }
        tmp_condition_result_50 = tmp_truth_name_8 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_50 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_19;
        }
        else
        {
            goto condexpr_false_19;
        }
        condexpr_true_19:;
        CHECK_OBJECT( tmp_class_creation_9__bases );
        tmp_subscribed_name_8 = tmp_class_creation_9__bases;
        tmp_subscript_name_8 = const_int_0;
        tmp_type_arg_16 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_8, tmp_subscript_name_8, 0 );
        if ( tmp_type_arg_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;

            goto try_except_handler_25;
        }
        tmp_metaclass_name_9 = BUILTIN_TYPE1( tmp_type_arg_16 );
        Py_DECREF( tmp_type_arg_16 );
        if ( tmp_metaclass_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;

            goto try_except_handler_25;
        }
        goto condexpr_end_19;
        condexpr_false_19:;
        tmp_metaclass_name_9 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_9 );
        condexpr_end_19:;
        condexpr_end_18:;
        CHECK_OBJECT( tmp_class_creation_9__bases );
        tmp_bases_name_9 = tmp_class_creation_9__bases;
        tmp_assign_source_76 = SELECT_METACLASS( tmp_metaclass_name_9, tmp_bases_name_9 );
        Py_DECREF( tmp_metaclass_name_9 );
        if ( tmp_assign_source_76 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;

            goto try_except_handler_25;
        }
        assert( tmp_class_creation_9__metaclass == NULL );
        tmp_class_creation_9__metaclass = tmp_assign_source_76;
    }
    {
        nuitka_bool tmp_condition_result_51;
        PyObject *tmp_key_name_27;
        PyObject *tmp_dict_name_27;
        tmp_key_name_27 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_9__class_decl_dict );
        tmp_dict_name_27 = tmp_class_creation_9__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_27, tmp_key_name_27 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;

            goto try_except_handler_25;
        }
        tmp_condition_result_51 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_51 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_32;
        }
        else
        {
            goto branch_no_32;
        }
        branch_yes_32:;
        CHECK_OBJECT( tmp_class_creation_9__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_9__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;

            goto try_except_handler_25;
        }
        branch_no_32:;
    }
    {
        nuitka_bool tmp_condition_result_52;
        PyObject *tmp_source_name_35;
        CHECK_OBJECT( tmp_class_creation_9__metaclass );
        tmp_source_name_35 = tmp_class_creation_9__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_35, const_str_plain___prepare__ );
        tmp_condition_result_52 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_52 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_33;
        }
        else
        {
            goto branch_no_33;
        }
        branch_yes_33:;
        {
            PyObject *tmp_assign_source_77;
            PyObject *tmp_called_name_19;
            PyObject *tmp_source_name_36;
            PyObject *tmp_args_name_17;
            PyObject *tmp_tuple_element_31;
            PyObject *tmp_kw_name_17;
            CHECK_OBJECT( tmp_class_creation_9__metaclass );
            tmp_source_name_36 = tmp_class_creation_9__metaclass;
            tmp_called_name_19 = LOOKUP_ATTRIBUTE( tmp_source_name_36, const_str_plain___prepare__ );
            if ( tmp_called_name_19 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 319;

                goto try_except_handler_25;
            }
            tmp_tuple_element_31 = const_str_plain_redirect_stdout;
            tmp_args_name_17 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_31 );
            PyTuple_SET_ITEM( tmp_args_name_17, 0, tmp_tuple_element_31 );
            CHECK_OBJECT( tmp_class_creation_9__bases );
            tmp_tuple_element_31 = tmp_class_creation_9__bases;
            Py_INCREF( tmp_tuple_element_31 );
            PyTuple_SET_ITEM( tmp_args_name_17, 1, tmp_tuple_element_31 );
            CHECK_OBJECT( tmp_class_creation_9__class_decl_dict );
            tmp_kw_name_17 = tmp_class_creation_9__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 319;
            tmp_assign_source_77 = CALL_FUNCTION( tmp_called_name_19, tmp_args_name_17, tmp_kw_name_17 );
            Py_DECREF( tmp_called_name_19 );
            Py_DECREF( tmp_args_name_17 );
            if ( tmp_assign_source_77 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 319;

                goto try_except_handler_25;
            }
            assert( tmp_class_creation_9__prepared == NULL );
            tmp_class_creation_9__prepared = tmp_assign_source_77;
        }
        {
            nuitka_bool tmp_condition_result_53;
            PyObject *tmp_operand_name_9;
            PyObject *tmp_source_name_37;
            CHECK_OBJECT( tmp_class_creation_9__prepared );
            tmp_source_name_37 = tmp_class_creation_9__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_37, const_str_plain___getitem__ );
            tmp_operand_name_9 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_9 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 319;

                goto try_except_handler_25;
            }
            tmp_condition_result_53 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_53 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_34;
            }
            else
            {
                goto branch_no_34;
            }
            branch_yes_34:;
            {
                PyObject *tmp_raise_type_9;
                PyObject *tmp_raise_value_9;
                PyObject *tmp_left_name_9;
                PyObject *tmp_right_name_9;
                PyObject *tmp_tuple_element_32;
                PyObject *tmp_getattr_target_9;
                PyObject *tmp_getattr_attr_9;
                PyObject *tmp_getattr_default_9;
                PyObject *tmp_source_name_38;
                PyObject *tmp_type_arg_17;
                tmp_raise_type_9 = PyExc_TypeError;
                tmp_left_name_9 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_9__metaclass );
                tmp_getattr_target_9 = tmp_class_creation_9__metaclass;
                tmp_getattr_attr_9 = const_str_plain___name__;
                tmp_getattr_default_9 = const_str_angle_metaclass;
                tmp_tuple_element_32 = BUILTIN_GETATTR( tmp_getattr_target_9, tmp_getattr_attr_9, tmp_getattr_default_9 );
                if ( tmp_tuple_element_32 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 319;

                    goto try_except_handler_25;
                }
                tmp_right_name_9 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_9, 0, tmp_tuple_element_32 );
                CHECK_OBJECT( tmp_class_creation_9__prepared );
                tmp_type_arg_17 = tmp_class_creation_9__prepared;
                tmp_source_name_38 = BUILTIN_TYPE1( tmp_type_arg_17 );
                assert( !(tmp_source_name_38 == NULL) );
                tmp_tuple_element_32 = LOOKUP_ATTRIBUTE( tmp_source_name_38, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_38 );
                if ( tmp_tuple_element_32 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_9 );

                    exception_lineno = 319;

                    goto try_except_handler_25;
                }
                PyTuple_SET_ITEM( tmp_right_name_9, 1, tmp_tuple_element_32 );
                tmp_raise_value_9 = BINARY_OPERATION_REMAINDER( tmp_left_name_9, tmp_right_name_9 );
                Py_DECREF( tmp_right_name_9 );
                if ( tmp_raise_value_9 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 319;

                    goto try_except_handler_25;
                }
                exception_type = tmp_raise_type_9;
                Py_INCREF( tmp_raise_type_9 );
                exception_value = tmp_raise_value_9;
                exception_lineno = 319;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_25;
            }
            branch_no_34:;
        }
        goto branch_end_33;
        branch_no_33:;
        {
            PyObject *tmp_assign_source_78;
            tmp_assign_source_78 = PyDict_New();
            assert( tmp_class_creation_9__prepared == NULL );
            tmp_class_creation_9__prepared = tmp_assign_source_78;
        }
        branch_end_33:;
    }
    {
        PyObject *tmp_assign_source_79;
        {
            PyObject *tmp_set_locals_9;
            CHECK_OBJECT( tmp_class_creation_9__prepared );
            tmp_set_locals_9 = tmp_class_creation_9__prepared;
            locals_contextlib_319 = tmp_set_locals_9;
            Py_INCREF( tmp_set_locals_9 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_319, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;

            goto try_except_handler_27;
        }
        tmp_dictset_value = const_str_digest_37d3501df59cc79d8d4db5901783de2a;
        tmp_res = PyObject_SetItem( locals_contextlib_319, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;

            goto try_except_handler_27;
        }
        tmp_dictset_value = const_str_plain_redirect_stdout;
        tmp_res = PyObject_SetItem( locals_contextlib_319, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;

            goto try_except_handler_27;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_d7fd5dc9be95290492bee556cea09260_10, codeobj_d7fd5dc9be95290492bee556cea09260, module_contextlib, sizeof(void *) );
        frame_d7fd5dc9be95290492bee556cea09260_10 = cache_frame_d7fd5dc9be95290492bee556cea09260_10;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_d7fd5dc9be95290492bee556cea09260_10 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_d7fd5dc9be95290492bee556cea09260_10 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = const_str_plain_stdout;
        tmp_res = PyObject_SetItem( locals_contextlib_319, const_str_plain__stream, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 332;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_d7fd5dc9be95290492bee556cea09260_10 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_9;

        frame_exception_exit_10:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_d7fd5dc9be95290492bee556cea09260_10 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_d7fd5dc9be95290492bee556cea09260_10, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_d7fd5dc9be95290492bee556cea09260_10->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_d7fd5dc9be95290492bee556cea09260_10, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_d7fd5dc9be95290492bee556cea09260_10,
            type_description_2,
            outline_8_var___class__
        );


        // Release cached frame.
        if ( frame_d7fd5dc9be95290492bee556cea09260_10 == cache_frame_d7fd5dc9be95290492bee556cea09260_10 )
        {
            Py_DECREF( frame_d7fd5dc9be95290492bee556cea09260_10 );
        }
        cache_frame_d7fd5dc9be95290492bee556cea09260_10 = NULL;

        assertFrameObject( frame_d7fd5dc9be95290492bee556cea09260_10 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_9;

        frame_no_exception_9:;
        goto skip_nested_handling_9;
        nested_frame_exit_9:;

        goto try_except_handler_27;
        skip_nested_handling_9:;
        {
            nuitka_bool tmp_condition_result_54;
            PyObject *tmp_compexpr_left_8;
            PyObject *tmp_compexpr_right_8;
            CHECK_OBJECT( tmp_class_creation_9__bases );
            tmp_compexpr_left_8 = tmp_class_creation_9__bases;
            CHECK_OBJECT( tmp_class_creation_9__bases_orig );
            tmp_compexpr_right_8 = tmp_class_creation_9__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_8, tmp_compexpr_right_8 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 319;

                goto try_except_handler_27;
            }
            tmp_condition_result_54 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_54 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_35;
            }
            else
            {
                goto branch_no_35;
            }
            branch_yes_35:;
            CHECK_OBJECT( tmp_class_creation_9__bases_orig );
            tmp_dictset_value = tmp_class_creation_9__bases_orig;
            tmp_res = PyObject_SetItem( locals_contextlib_319, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 319;

                goto try_except_handler_27;
            }
            branch_no_35:;
        }
        {
            PyObject *tmp_assign_source_80;
            PyObject *tmp_called_name_20;
            PyObject *tmp_args_name_18;
            PyObject *tmp_tuple_element_33;
            PyObject *tmp_kw_name_18;
            CHECK_OBJECT( tmp_class_creation_9__metaclass );
            tmp_called_name_20 = tmp_class_creation_9__metaclass;
            tmp_tuple_element_33 = const_str_plain_redirect_stdout;
            tmp_args_name_18 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_33 );
            PyTuple_SET_ITEM( tmp_args_name_18, 0, tmp_tuple_element_33 );
            CHECK_OBJECT( tmp_class_creation_9__bases );
            tmp_tuple_element_33 = tmp_class_creation_9__bases;
            Py_INCREF( tmp_tuple_element_33 );
            PyTuple_SET_ITEM( tmp_args_name_18, 1, tmp_tuple_element_33 );
            tmp_tuple_element_33 = locals_contextlib_319;
            Py_INCREF( tmp_tuple_element_33 );
            PyTuple_SET_ITEM( tmp_args_name_18, 2, tmp_tuple_element_33 );
            CHECK_OBJECT( tmp_class_creation_9__class_decl_dict );
            tmp_kw_name_18 = tmp_class_creation_9__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 319;
            tmp_assign_source_80 = CALL_FUNCTION( tmp_called_name_20, tmp_args_name_18, tmp_kw_name_18 );
            Py_DECREF( tmp_args_name_18 );
            if ( tmp_assign_source_80 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 319;

                goto try_except_handler_27;
            }
            assert( outline_8_var___class__ == NULL );
            outline_8_var___class__ = tmp_assign_source_80;
        }
        CHECK_OBJECT( outline_8_var___class__ );
        tmp_assign_source_79 = outline_8_var___class__;
        Py_INCREF( tmp_assign_source_79 );
        goto try_return_handler_27;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_27:;
        Py_DECREF( locals_contextlib_319 );
        locals_contextlib_319 = NULL;
        goto try_return_handler_26;
        // Exception handler code:
        try_except_handler_27:;
        exception_keeper_type_25 = exception_type;
        exception_keeper_value_25 = exception_value;
        exception_keeper_tb_25 = exception_tb;
        exception_keeper_lineno_25 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_319 );
        locals_contextlib_319 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_25;
        exception_value = exception_keeper_value_25;
        exception_tb = exception_keeper_tb_25;
        exception_lineno = exception_keeper_lineno_25;

        goto try_except_handler_26;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_26:;
        CHECK_OBJECT( (PyObject *)outline_8_var___class__ );
        Py_DECREF( outline_8_var___class__ );
        outline_8_var___class__ = NULL;

        goto outline_result_9;
        // Exception handler code:
        try_except_handler_26:;
        exception_keeper_type_26 = exception_type;
        exception_keeper_value_26 = exception_value;
        exception_keeper_tb_26 = exception_tb;
        exception_keeper_lineno_26 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_26;
        exception_value = exception_keeper_value_26;
        exception_tb = exception_keeper_tb_26;
        exception_lineno = exception_keeper_lineno_26;

        goto outline_exception_9;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_9:;
        exception_lineno = 319;
        goto try_except_handler_25;
        outline_result_9:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_redirect_stdout, tmp_assign_source_79 );
    }
    goto try_end_9;
    // Exception handler code:
    try_except_handler_25:;
    exception_keeper_type_27 = exception_type;
    exception_keeper_value_27 = exception_value;
    exception_keeper_tb_27 = exception_tb;
    exception_keeper_lineno_27 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_9__bases_orig );
    tmp_class_creation_9__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_9__bases );
    tmp_class_creation_9__bases = NULL;

    Py_XDECREF( tmp_class_creation_9__class_decl_dict );
    tmp_class_creation_9__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_9__prepared );
    tmp_class_creation_9__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_27;
    exception_value = exception_keeper_value_27;
    exception_tb = exception_keeper_tb_27;
    exception_lineno = exception_keeper_lineno_27;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__bases_orig );
    Py_DECREF( tmp_class_creation_9__bases_orig );
    tmp_class_creation_9__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__bases );
    Py_DECREF( tmp_class_creation_9__bases );
    tmp_class_creation_9__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class_decl_dict );
    Py_DECREF( tmp_class_creation_9__class_decl_dict );
    tmp_class_creation_9__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__metaclass );
    Py_DECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__prepared );
    Py_DECREF( tmp_class_creation_9__prepared );
    tmp_class_creation_9__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_81;
        PyObject *tmp_tuple_element_34;
        PyObject *tmp_mvar_value_15;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__RedirectStream );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__RedirectStream );
        }

        if ( tmp_mvar_value_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_RedirectStream" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 335;

            goto try_except_handler_28;
        }

        tmp_tuple_element_34 = tmp_mvar_value_15;
        tmp_assign_source_81 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_34 );
        PyTuple_SET_ITEM( tmp_assign_source_81, 0, tmp_tuple_element_34 );
        assert( tmp_class_creation_10__bases_orig == NULL );
        tmp_class_creation_10__bases_orig = tmp_assign_source_81;
    }
    {
        PyObject *tmp_assign_source_82;
        PyObject *tmp_dircall_arg1_9;
        CHECK_OBJECT( tmp_class_creation_10__bases_orig );
        tmp_dircall_arg1_9 = tmp_class_creation_10__bases_orig;
        Py_INCREF( tmp_dircall_arg1_9 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_9};
            tmp_assign_source_82 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_82 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;

            goto try_except_handler_28;
        }
        assert( tmp_class_creation_10__bases == NULL );
        tmp_class_creation_10__bases = tmp_assign_source_82;
    }
    {
        PyObject *tmp_assign_source_83;
        tmp_assign_source_83 = PyDict_New();
        assert( tmp_class_creation_10__class_decl_dict == NULL );
        tmp_class_creation_10__class_decl_dict = tmp_assign_source_83;
    }
    {
        PyObject *tmp_assign_source_84;
        PyObject *tmp_metaclass_name_10;
        nuitka_bool tmp_condition_result_55;
        PyObject *tmp_key_name_28;
        PyObject *tmp_dict_name_28;
        PyObject *tmp_dict_name_29;
        PyObject *tmp_key_name_29;
        nuitka_bool tmp_condition_result_56;
        int tmp_truth_name_9;
        PyObject *tmp_type_arg_18;
        PyObject *tmp_subscribed_name_9;
        PyObject *tmp_subscript_name_9;
        PyObject *tmp_bases_name_10;
        tmp_key_name_28 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_10__class_decl_dict );
        tmp_dict_name_28 = tmp_class_creation_10__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_28, tmp_key_name_28 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;

            goto try_except_handler_28;
        }
        tmp_condition_result_55 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_55 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_20;
        }
        else
        {
            goto condexpr_false_20;
        }
        condexpr_true_20:;
        CHECK_OBJECT( tmp_class_creation_10__class_decl_dict );
        tmp_dict_name_29 = tmp_class_creation_10__class_decl_dict;
        tmp_key_name_29 = const_str_plain_metaclass;
        tmp_metaclass_name_10 = DICT_GET_ITEM( tmp_dict_name_29, tmp_key_name_29 );
        if ( tmp_metaclass_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;

            goto try_except_handler_28;
        }
        goto condexpr_end_20;
        condexpr_false_20:;
        CHECK_OBJECT( tmp_class_creation_10__bases );
        tmp_truth_name_9 = CHECK_IF_TRUE( tmp_class_creation_10__bases );
        if ( tmp_truth_name_9 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;

            goto try_except_handler_28;
        }
        tmp_condition_result_56 = tmp_truth_name_9 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_56 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_21;
        }
        else
        {
            goto condexpr_false_21;
        }
        condexpr_true_21:;
        CHECK_OBJECT( tmp_class_creation_10__bases );
        tmp_subscribed_name_9 = tmp_class_creation_10__bases;
        tmp_subscript_name_9 = const_int_0;
        tmp_type_arg_18 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_9, tmp_subscript_name_9, 0 );
        if ( tmp_type_arg_18 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;

            goto try_except_handler_28;
        }
        tmp_metaclass_name_10 = BUILTIN_TYPE1( tmp_type_arg_18 );
        Py_DECREF( tmp_type_arg_18 );
        if ( tmp_metaclass_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;

            goto try_except_handler_28;
        }
        goto condexpr_end_21;
        condexpr_false_21:;
        tmp_metaclass_name_10 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_10 );
        condexpr_end_21:;
        condexpr_end_20:;
        CHECK_OBJECT( tmp_class_creation_10__bases );
        tmp_bases_name_10 = tmp_class_creation_10__bases;
        tmp_assign_source_84 = SELECT_METACLASS( tmp_metaclass_name_10, tmp_bases_name_10 );
        Py_DECREF( tmp_metaclass_name_10 );
        if ( tmp_assign_source_84 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;

            goto try_except_handler_28;
        }
        assert( tmp_class_creation_10__metaclass == NULL );
        tmp_class_creation_10__metaclass = tmp_assign_source_84;
    }
    {
        nuitka_bool tmp_condition_result_57;
        PyObject *tmp_key_name_30;
        PyObject *tmp_dict_name_30;
        tmp_key_name_30 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_10__class_decl_dict );
        tmp_dict_name_30 = tmp_class_creation_10__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_30, tmp_key_name_30 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;

            goto try_except_handler_28;
        }
        tmp_condition_result_57 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_57 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_36;
        }
        else
        {
            goto branch_no_36;
        }
        branch_yes_36:;
        CHECK_OBJECT( tmp_class_creation_10__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_10__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;

            goto try_except_handler_28;
        }
        branch_no_36:;
    }
    {
        nuitka_bool tmp_condition_result_58;
        PyObject *tmp_source_name_39;
        CHECK_OBJECT( tmp_class_creation_10__metaclass );
        tmp_source_name_39 = tmp_class_creation_10__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_39, const_str_plain___prepare__ );
        tmp_condition_result_58 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_58 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_37;
        }
        else
        {
            goto branch_no_37;
        }
        branch_yes_37:;
        {
            PyObject *tmp_assign_source_85;
            PyObject *tmp_called_name_21;
            PyObject *tmp_source_name_40;
            PyObject *tmp_args_name_19;
            PyObject *tmp_tuple_element_35;
            PyObject *tmp_kw_name_19;
            CHECK_OBJECT( tmp_class_creation_10__metaclass );
            tmp_source_name_40 = tmp_class_creation_10__metaclass;
            tmp_called_name_21 = LOOKUP_ATTRIBUTE( tmp_source_name_40, const_str_plain___prepare__ );
            if ( tmp_called_name_21 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 335;

                goto try_except_handler_28;
            }
            tmp_tuple_element_35 = const_str_plain_redirect_stderr;
            tmp_args_name_19 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_35 );
            PyTuple_SET_ITEM( tmp_args_name_19, 0, tmp_tuple_element_35 );
            CHECK_OBJECT( tmp_class_creation_10__bases );
            tmp_tuple_element_35 = tmp_class_creation_10__bases;
            Py_INCREF( tmp_tuple_element_35 );
            PyTuple_SET_ITEM( tmp_args_name_19, 1, tmp_tuple_element_35 );
            CHECK_OBJECT( tmp_class_creation_10__class_decl_dict );
            tmp_kw_name_19 = tmp_class_creation_10__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 335;
            tmp_assign_source_85 = CALL_FUNCTION( tmp_called_name_21, tmp_args_name_19, tmp_kw_name_19 );
            Py_DECREF( tmp_called_name_21 );
            Py_DECREF( tmp_args_name_19 );
            if ( tmp_assign_source_85 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 335;

                goto try_except_handler_28;
            }
            assert( tmp_class_creation_10__prepared == NULL );
            tmp_class_creation_10__prepared = tmp_assign_source_85;
        }
        {
            nuitka_bool tmp_condition_result_59;
            PyObject *tmp_operand_name_10;
            PyObject *tmp_source_name_41;
            CHECK_OBJECT( tmp_class_creation_10__prepared );
            tmp_source_name_41 = tmp_class_creation_10__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_41, const_str_plain___getitem__ );
            tmp_operand_name_10 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_10 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 335;

                goto try_except_handler_28;
            }
            tmp_condition_result_59 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_59 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_38;
            }
            else
            {
                goto branch_no_38;
            }
            branch_yes_38:;
            {
                PyObject *tmp_raise_type_10;
                PyObject *tmp_raise_value_10;
                PyObject *tmp_left_name_10;
                PyObject *tmp_right_name_10;
                PyObject *tmp_tuple_element_36;
                PyObject *tmp_getattr_target_10;
                PyObject *tmp_getattr_attr_10;
                PyObject *tmp_getattr_default_10;
                PyObject *tmp_source_name_42;
                PyObject *tmp_type_arg_19;
                tmp_raise_type_10 = PyExc_TypeError;
                tmp_left_name_10 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_10__metaclass );
                tmp_getattr_target_10 = tmp_class_creation_10__metaclass;
                tmp_getattr_attr_10 = const_str_plain___name__;
                tmp_getattr_default_10 = const_str_angle_metaclass;
                tmp_tuple_element_36 = BUILTIN_GETATTR( tmp_getattr_target_10, tmp_getattr_attr_10, tmp_getattr_default_10 );
                if ( tmp_tuple_element_36 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 335;

                    goto try_except_handler_28;
                }
                tmp_right_name_10 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_10, 0, tmp_tuple_element_36 );
                CHECK_OBJECT( tmp_class_creation_10__prepared );
                tmp_type_arg_19 = tmp_class_creation_10__prepared;
                tmp_source_name_42 = BUILTIN_TYPE1( tmp_type_arg_19 );
                assert( !(tmp_source_name_42 == NULL) );
                tmp_tuple_element_36 = LOOKUP_ATTRIBUTE( tmp_source_name_42, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_42 );
                if ( tmp_tuple_element_36 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_10 );

                    exception_lineno = 335;

                    goto try_except_handler_28;
                }
                PyTuple_SET_ITEM( tmp_right_name_10, 1, tmp_tuple_element_36 );
                tmp_raise_value_10 = BINARY_OPERATION_REMAINDER( tmp_left_name_10, tmp_right_name_10 );
                Py_DECREF( tmp_right_name_10 );
                if ( tmp_raise_value_10 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 335;

                    goto try_except_handler_28;
                }
                exception_type = tmp_raise_type_10;
                Py_INCREF( tmp_raise_type_10 );
                exception_value = tmp_raise_value_10;
                exception_lineno = 335;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_28;
            }
            branch_no_38:;
        }
        goto branch_end_37;
        branch_no_37:;
        {
            PyObject *tmp_assign_source_86;
            tmp_assign_source_86 = PyDict_New();
            assert( tmp_class_creation_10__prepared == NULL );
            tmp_class_creation_10__prepared = tmp_assign_source_86;
        }
        branch_end_37:;
    }
    {
        PyObject *tmp_assign_source_87;
        {
            PyObject *tmp_set_locals_10;
            CHECK_OBJECT( tmp_class_creation_10__prepared );
            tmp_set_locals_10 = tmp_class_creation_10__prepared;
            locals_contextlib_335 = tmp_set_locals_10;
            Py_INCREF( tmp_set_locals_10 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_335, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;

            goto try_except_handler_30;
        }
        tmp_dictset_value = const_str_digest_fc380e569c01f57799c4fb3916d89707;
        tmp_res = PyObject_SetItem( locals_contextlib_335, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;

            goto try_except_handler_30;
        }
        tmp_dictset_value = const_str_plain_redirect_stderr;
        tmp_res = PyObject_SetItem( locals_contextlib_335, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;

            goto try_except_handler_30;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_87f04e9c08916a537b9d28a0c7179091_11, codeobj_87f04e9c08916a537b9d28a0c7179091, module_contextlib, sizeof(void *) );
        frame_87f04e9c08916a537b9d28a0c7179091_11 = cache_frame_87f04e9c08916a537b9d28a0c7179091_11;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_87f04e9c08916a537b9d28a0c7179091_11 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_87f04e9c08916a537b9d28a0c7179091_11 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = const_str_plain_stderr;
        tmp_res = PyObject_SetItem( locals_contextlib_335, const_str_plain__stream, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 338;
            type_description_2 = "o";
            goto frame_exception_exit_11;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_87f04e9c08916a537b9d28a0c7179091_11 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_10;

        frame_exception_exit_11:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_87f04e9c08916a537b9d28a0c7179091_11 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_87f04e9c08916a537b9d28a0c7179091_11, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_87f04e9c08916a537b9d28a0c7179091_11->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_87f04e9c08916a537b9d28a0c7179091_11, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_87f04e9c08916a537b9d28a0c7179091_11,
            type_description_2,
            outline_9_var___class__
        );


        // Release cached frame.
        if ( frame_87f04e9c08916a537b9d28a0c7179091_11 == cache_frame_87f04e9c08916a537b9d28a0c7179091_11 )
        {
            Py_DECREF( frame_87f04e9c08916a537b9d28a0c7179091_11 );
        }
        cache_frame_87f04e9c08916a537b9d28a0c7179091_11 = NULL;

        assertFrameObject( frame_87f04e9c08916a537b9d28a0c7179091_11 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_10;

        frame_no_exception_10:;
        goto skip_nested_handling_10;
        nested_frame_exit_10:;

        goto try_except_handler_30;
        skip_nested_handling_10:;
        {
            nuitka_bool tmp_condition_result_60;
            PyObject *tmp_compexpr_left_9;
            PyObject *tmp_compexpr_right_9;
            CHECK_OBJECT( tmp_class_creation_10__bases );
            tmp_compexpr_left_9 = tmp_class_creation_10__bases;
            CHECK_OBJECT( tmp_class_creation_10__bases_orig );
            tmp_compexpr_right_9 = tmp_class_creation_10__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_9, tmp_compexpr_right_9 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 335;

                goto try_except_handler_30;
            }
            tmp_condition_result_60 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_60 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_39;
            }
            else
            {
                goto branch_no_39;
            }
            branch_yes_39:;
            CHECK_OBJECT( tmp_class_creation_10__bases_orig );
            tmp_dictset_value = tmp_class_creation_10__bases_orig;
            tmp_res = PyObject_SetItem( locals_contextlib_335, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 335;

                goto try_except_handler_30;
            }
            branch_no_39:;
        }
        {
            PyObject *tmp_assign_source_88;
            PyObject *tmp_called_name_22;
            PyObject *tmp_args_name_20;
            PyObject *tmp_tuple_element_37;
            PyObject *tmp_kw_name_20;
            CHECK_OBJECT( tmp_class_creation_10__metaclass );
            tmp_called_name_22 = tmp_class_creation_10__metaclass;
            tmp_tuple_element_37 = const_str_plain_redirect_stderr;
            tmp_args_name_20 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_37 );
            PyTuple_SET_ITEM( tmp_args_name_20, 0, tmp_tuple_element_37 );
            CHECK_OBJECT( tmp_class_creation_10__bases );
            tmp_tuple_element_37 = tmp_class_creation_10__bases;
            Py_INCREF( tmp_tuple_element_37 );
            PyTuple_SET_ITEM( tmp_args_name_20, 1, tmp_tuple_element_37 );
            tmp_tuple_element_37 = locals_contextlib_335;
            Py_INCREF( tmp_tuple_element_37 );
            PyTuple_SET_ITEM( tmp_args_name_20, 2, tmp_tuple_element_37 );
            CHECK_OBJECT( tmp_class_creation_10__class_decl_dict );
            tmp_kw_name_20 = tmp_class_creation_10__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 335;
            tmp_assign_source_88 = CALL_FUNCTION( tmp_called_name_22, tmp_args_name_20, tmp_kw_name_20 );
            Py_DECREF( tmp_args_name_20 );
            if ( tmp_assign_source_88 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 335;

                goto try_except_handler_30;
            }
            assert( outline_9_var___class__ == NULL );
            outline_9_var___class__ = tmp_assign_source_88;
        }
        CHECK_OBJECT( outline_9_var___class__ );
        tmp_assign_source_87 = outline_9_var___class__;
        Py_INCREF( tmp_assign_source_87 );
        goto try_return_handler_30;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_30:;
        Py_DECREF( locals_contextlib_335 );
        locals_contextlib_335 = NULL;
        goto try_return_handler_29;
        // Exception handler code:
        try_except_handler_30:;
        exception_keeper_type_28 = exception_type;
        exception_keeper_value_28 = exception_value;
        exception_keeper_tb_28 = exception_tb;
        exception_keeper_lineno_28 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_335 );
        locals_contextlib_335 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_28;
        exception_value = exception_keeper_value_28;
        exception_tb = exception_keeper_tb_28;
        exception_lineno = exception_keeper_lineno_28;

        goto try_except_handler_29;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_29:;
        CHECK_OBJECT( (PyObject *)outline_9_var___class__ );
        Py_DECREF( outline_9_var___class__ );
        outline_9_var___class__ = NULL;

        goto outline_result_10;
        // Exception handler code:
        try_except_handler_29:;
        exception_keeper_type_29 = exception_type;
        exception_keeper_value_29 = exception_value;
        exception_keeper_tb_29 = exception_tb;
        exception_keeper_lineno_29 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_29;
        exception_value = exception_keeper_value_29;
        exception_tb = exception_keeper_tb_29;
        exception_lineno = exception_keeper_lineno_29;

        goto outline_exception_10;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_10:;
        exception_lineno = 335;
        goto try_except_handler_28;
        outline_result_10:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_redirect_stderr, tmp_assign_source_87 );
    }
    goto try_end_10;
    // Exception handler code:
    try_except_handler_28:;
    exception_keeper_type_30 = exception_type;
    exception_keeper_value_30 = exception_value;
    exception_keeper_tb_30 = exception_tb;
    exception_keeper_lineno_30 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_10__bases_orig );
    tmp_class_creation_10__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_10__bases );
    tmp_class_creation_10__bases = NULL;

    Py_XDECREF( tmp_class_creation_10__class_decl_dict );
    tmp_class_creation_10__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_10__prepared );
    tmp_class_creation_10__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_30;
    exception_value = exception_keeper_value_30;
    exception_tb = exception_keeper_tb_30;
    exception_lineno = exception_keeper_lineno_30;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__bases_orig );
    Py_DECREF( tmp_class_creation_10__bases_orig );
    tmp_class_creation_10__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__bases );
    Py_DECREF( tmp_class_creation_10__bases );
    tmp_class_creation_10__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class_decl_dict );
    Py_DECREF( tmp_class_creation_10__class_decl_dict );
    tmp_class_creation_10__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__metaclass );
    Py_DECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__prepared );
    Py_DECREF( tmp_class_creation_10__prepared );
    tmp_class_creation_10__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_89;
        PyObject *tmp_tuple_element_38;
        PyObject *tmp_mvar_value_16;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );
        }

        if ( tmp_mvar_value_16 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "AbstractContextManager" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 341;

            goto try_except_handler_31;
        }

        tmp_tuple_element_38 = tmp_mvar_value_16;
        tmp_assign_source_89 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_38 );
        PyTuple_SET_ITEM( tmp_assign_source_89, 0, tmp_tuple_element_38 );
        assert( tmp_class_creation_11__bases_orig == NULL );
        tmp_class_creation_11__bases_orig = tmp_assign_source_89;
    }
    {
        PyObject *tmp_assign_source_90;
        PyObject *tmp_dircall_arg1_10;
        CHECK_OBJECT( tmp_class_creation_11__bases_orig );
        tmp_dircall_arg1_10 = tmp_class_creation_11__bases_orig;
        Py_INCREF( tmp_dircall_arg1_10 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_10};
            tmp_assign_source_90 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_90 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;

            goto try_except_handler_31;
        }
        assert( tmp_class_creation_11__bases == NULL );
        tmp_class_creation_11__bases = tmp_assign_source_90;
    }
    {
        PyObject *tmp_assign_source_91;
        tmp_assign_source_91 = PyDict_New();
        assert( tmp_class_creation_11__class_decl_dict == NULL );
        tmp_class_creation_11__class_decl_dict = tmp_assign_source_91;
    }
    {
        PyObject *tmp_assign_source_92;
        PyObject *tmp_metaclass_name_11;
        nuitka_bool tmp_condition_result_61;
        PyObject *tmp_key_name_31;
        PyObject *tmp_dict_name_31;
        PyObject *tmp_dict_name_32;
        PyObject *tmp_key_name_32;
        nuitka_bool tmp_condition_result_62;
        int tmp_truth_name_10;
        PyObject *tmp_type_arg_20;
        PyObject *tmp_subscribed_name_10;
        PyObject *tmp_subscript_name_10;
        PyObject *tmp_bases_name_11;
        tmp_key_name_31 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_11__class_decl_dict );
        tmp_dict_name_31 = tmp_class_creation_11__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_31, tmp_key_name_31 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;

            goto try_except_handler_31;
        }
        tmp_condition_result_61 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_61 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_22;
        }
        else
        {
            goto condexpr_false_22;
        }
        condexpr_true_22:;
        CHECK_OBJECT( tmp_class_creation_11__class_decl_dict );
        tmp_dict_name_32 = tmp_class_creation_11__class_decl_dict;
        tmp_key_name_32 = const_str_plain_metaclass;
        tmp_metaclass_name_11 = DICT_GET_ITEM( tmp_dict_name_32, tmp_key_name_32 );
        if ( tmp_metaclass_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;

            goto try_except_handler_31;
        }
        goto condexpr_end_22;
        condexpr_false_22:;
        CHECK_OBJECT( tmp_class_creation_11__bases );
        tmp_truth_name_10 = CHECK_IF_TRUE( tmp_class_creation_11__bases );
        if ( tmp_truth_name_10 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;

            goto try_except_handler_31;
        }
        tmp_condition_result_62 = tmp_truth_name_10 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_62 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_23;
        }
        else
        {
            goto condexpr_false_23;
        }
        condexpr_true_23:;
        CHECK_OBJECT( tmp_class_creation_11__bases );
        tmp_subscribed_name_10 = tmp_class_creation_11__bases;
        tmp_subscript_name_10 = const_int_0;
        tmp_type_arg_20 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_10, tmp_subscript_name_10, 0 );
        if ( tmp_type_arg_20 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;

            goto try_except_handler_31;
        }
        tmp_metaclass_name_11 = BUILTIN_TYPE1( tmp_type_arg_20 );
        Py_DECREF( tmp_type_arg_20 );
        if ( tmp_metaclass_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;

            goto try_except_handler_31;
        }
        goto condexpr_end_23;
        condexpr_false_23:;
        tmp_metaclass_name_11 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_11 );
        condexpr_end_23:;
        condexpr_end_22:;
        CHECK_OBJECT( tmp_class_creation_11__bases );
        tmp_bases_name_11 = tmp_class_creation_11__bases;
        tmp_assign_source_92 = SELECT_METACLASS( tmp_metaclass_name_11, tmp_bases_name_11 );
        Py_DECREF( tmp_metaclass_name_11 );
        if ( tmp_assign_source_92 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;

            goto try_except_handler_31;
        }
        assert( tmp_class_creation_11__metaclass == NULL );
        tmp_class_creation_11__metaclass = tmp_assign_source_92;
    }
    {
        nuitka_bool tmp_condition_result_63;
        PyObject *tmp_key_name_33;
        PyObject *tmp_dict_name_33;
        tmp_key_name_33 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_11__class_decl_dict );
        tmp_dict_name_33 = tmp_class_creation_11__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_33, tmp_key_name_33 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;

            goto try_except_handler_31;
        }
        tmp_condition_result_63 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_63 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_40;
        }
        else
        {
            goto branch_no_40;
        }
        branch_yes_40:;
        CHECK_OBJECT( tmp_class_creation_11__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_11__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;

            goto try_except_handler_31;
        }
        branch_no_40:;
    }
    {
        nuitka_bool tmp_condition_result_64;
        PyObject *tmp_source_name_43;
        CHECK_OBJECT( tmp_class_creation_11__metaclass );
        tmp_source_name_43 = tmp_class_creation_11__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_43, const_str_plain___prepare__ );
        tmp_condition_result_64 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_64 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_41;
        }
        else
        {
            goto branch_no_41;
        }
        branch_yes_41:;
        {
            PyObject *tmp_assign_source_93;
            PyObject *tmp_called_name_23;
            PyObject *tmp_source_name_44;
            PyObject *tmp_args_name_21;
            PyObject *tmp_tuple_element_39;
            PyObject *tmp_kw_name_21;
            CHECK_OBJECT( tmp_class_creation_11__metaclass );
            tmp_source_name_44 = tmp_class_creation_11__metaclass;
            tmp_called_name_23 = LOOKUP_ATTRIBUTE( tmp_source_name_44, const_str_plain___prepare__ );
            if ( tmp_called_name_23 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 341;

                goto try_except_handler_31;
            }
            tmp_tuple_element_39 = const_str_plain_suppress;
            tmp_args_name_21 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_39 );
            PyTuple_SET_ITEM( tmp_args_name_21, 0, tmp_tuple_element_39 );
            CHECK_OBJECT( tmp_class_creation_11__bases );
            tmp_tuple_element_39 = tmp_class_creation_11__bases;
            Py_INCREF( tmp_tuple_element_39 );
            PyTuple_SET_ITEM( tmp_args_name_21, 1, tmp_tuple_element_39 );
            CHECK_OBJECT( tmp_class_creation_11__class_decl_dict );
            tmp_kw_name_21 = tmp_class_creation_11__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 341;
            tmp_assign_source_93 = CALL_FUNCTION( tmp_called_name_23, tmp_args_name_21, tmp_kw_name_21 );
            Py_DECREF( tmp_called_name_23 );
            Py_DECREF( tmp_args_name_21 );
            if ( tmp_assign_source_93 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 341;

                goto try_except_handler_31;
            }
            assert( tmp_class_creation_11__prepared == NULL );
            tmp_class_creation_11__prepared = tmp_assign_source_93;
        }
        {
            nuitka_bool tmp_condition_result_65;
            PyObject *tmp_operand_name_11;
            PyObject *tmp_source_name_45;
            CHECK_OBJECT( tmp_class_creation_11__prepared );
            tmp_source_name_45 = tmp_class_creation_11__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_45, const_str_plain___getitem__ );
            tmp_operand_name_11 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_11 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 341;

                goto try_except_handler_31;
            }
            tmp_condition_result_65 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_65 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_42;
            }
            else
            {
                goto branch_no_42;
            }
            branch_yes_42:;
            {
                PyObject *tmp_raise_type_11;
                PyObject *tmp_raise_value_11;
                PyObject *tmp_left_name_11;
                PyObject *tmp_right_name_11;
                PyObject *tmp_tuple_element_40;
                PyObject *tmp_getattr_target_11;
                PyObject *tmp_getattr_attr_11;
                PyObject *tmp_getattr_default_11;
                PyObject *tmp_source_name_46;
                PyObject *tmp_type_arg_21;
                tmp_raise_type_11 = PyExc_TypeError;
                tmp_left_name_11 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_11__metaclass );
                tmp_getattr_target_11 = tmp_class_creation_11__metaclass;
                tmp_getattr_attr_11 = const_str_plain___name__;
                tmp_getattr_default_11 = const_str_angle_metaclass;
                tmp_tuple_element_40 = BUILTIN_GETATTR( tmp_getattr_target_11, tmp_getattr_attr_11, tmp_getattr_default_11 );
                if ( tmp_tuple_element_40 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 341;

                    goto try_except_handler_31;
                }
                tmp_right_name_11 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_11, 0, tmp_tuple_element_40 );
                CHECK_OBJECT( tmp_class_creation_11__prepared );
                tmp_type_arg_21 = tmp_class_creation_11__prepared;
                tmp_source_name_46 = BUILTIN_TYPE1( tmp_type_arg_21 );
                assert( !(tmp_source_name_46 == NULL) );
                tmp_tuple_element_40 = LOOKUP_ATTRIBUTE( tmp_source_name_46, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_46 );
                if ( tmp_tuple_element_40 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_11 );

                    exception_lineno = 341;

                    goto try_except_handler_31;
                }
                PyTuple_SET_ITEM( tmp_right_name_11, 1, tmp_tuple_element_40 );
                tmp_raise_value_11 = BINARY_OPERATION_REMAINDER( tmp_left_name_11, tmp_right_name_11 );
                Py_DECREF( tmp_right_name_11 );
                if ( tmp_raise_value_11 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 341;

                    goto try_except_handler_31;
                }
                exception_type = tmp_raise_type_11;
                Py_INCREF( tmp_raise_type_11 );
                exception_value = tmp_raise_value_11;
                exception_lineno = 341;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_31;
            }
            branch_no_42:;
        }
        goto branch_end_41;
        branch_no_41:;
        {
            PyObject *tmp_assign_source_94;
            tmp_assign_source_94 = PyDict_New();
            assert( tmp_class_creation_11__prepared == NULL );
            tmp_class_creation_11__prepared = tmp_assign_source_94;
        }
        branch_end_41:;
    }
    {
        PyObject *tmp_assign_source_95;
        {
            PyObject *tmp_set_locals_11;
            CHECK_OBJECT( tmp_class_creation_11__prepared );
            tmp_set_locals_11 = tmp_class_creation_11__prepared;
            locals_contextlib_341 = tmp_set_locals_11;
            Py_INCREF( tmp_set_locals_11 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_341, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;

            goto try_except_handler_33;
        }
        tmp_dictset_value = const_str_digest_27a9aa6471512d55712a8b3b3beb97a9;
        tmp_res = PyObject_SetItem( locals_contextlib_341, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;

            goto try_except_handler_33;
        }
        tmp_dictset_value = const_str_plain_suppress;
        tmp_res = PyObject_SetItem( locals_contextlib_341, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;

            goto try_except_handler_33;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_780dcd518a86239b52f6ae1915c129d3_12, codeobj_780dcd518a86239b52f6ae1915c129d3, module_contextlib, sizeof(void *) );
        frame_780dcd518a86239b52f6ae1915c129d3_12 = cache_frame_780dcd518a86239b52f6ae1915c129d3_12;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_780dcd518a86239b52f6ae1915c129d3_12 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_780dcd518a86239b52f6ae1915c129d3_12 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_23___init__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_341, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 352;
            type_description_2 = "o";
            goto frame_exception_exit_12;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_24___enter__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_341, const_str_plain___enter__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 355;
            type_description_2 = "o";
            goto frame_exception_exit_12;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_25___exit__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_341, const_str_plain___exit__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 358;
            type_description_2 = "o";
            goto frame_exception_exit_12;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_780dcd518a86239b52f6ae1915c129d3_12 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_11;

        frame_exception_exit_12:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_780dcd518a86239b52f6ae1915c129d3_12 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_780dcd518a86239b52f6ae1915c129d3_12, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_780dcd518a86239b52f6ae1915c129d3_12->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_780dcd518a86239b52f6ae1915c129d3_12, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_780dcd518a86239b52f6ae1915c129d3_12,
            type_description_2,
            outline_10_var___class__
        );


        // Release cached frame.
        if ( frame_780dcd518a86239b52f6ae1915c129d3_12 == cache_frame_780dcd518a86239b52f6ae1915c129d3_12 )
        {
            Py_DECREF( frame_780dcd518a86239b52f6ae1915c129d3_12 );
        }
        cache_frame_780dcd518a86239b52f6ae1915c129d3_12 = NULL;

        assertFrameObject( frame_780dcd518a86239b52f6ae1915c129d3_12 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_11;

        frame_no_exception_11:;
        goto skip_nested_handling_11;
        nested_frame_exit_11:;

        goto try_except_handler_33;
        skip_nested_handling_11:;
        {
            nuitka_bool tmp_condition_result_66;
            PyObject *tmp_compexpr_left_10;
            PyObject *tmp_compexpr_right_10;
            CHECK_OBJECT( tmp_class_creation_11__bases );
            tmp_compexpr_left_10 = tmp_class_creation_11__bases;
            CHECK_OBJECT( tmp_class_creation_11__bases_orig );
            tmp_compexpr_right_10 = tmp_class_creation_11__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_10, tmp_compexpr_right_10 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 341;

                goto try_except_handler_33;
            }
            tmp_condition_result_66 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_66 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_43;
            }
            else
            {
                goto branch_no_43;
            }
            branch_yes_43:;
            CHECK_OBJECT( tmp_class_creation_11__bases_orig );
            tmp_dictset_value = tmp_class_creation_11__bases_orig;
            tmp_res = PyObject_SetItem( locals_contextlib_341, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 341;

                goto try_except_handler_33;
            }
            branch_no_43:;
        }
        {
            PyObject *tmp_assign_source_96;
            PyObject *tmp_called_name_24;
            PyObject *tmp_args_name_22;
            PyObject *tmp_tuple_element_41;
            PyObject *tmp_kw_name_22;
            CHECK_OBJECT( tmp_class_creation_11__metaclass );
            tmp_called_name_24 = tmp_class_creation_11__metaclass;
            tmp_tuple_element_41 = const_str_plain_suppress;
            tmp_args_name_22 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_41 );
            PyTuple_SET_ITEM( tmp_args_name_22, 0, tmp_tuple_element_41 );
            CHECK_OBJECT( tmp_class_creation_11__bases );
            tmp_tuple_element_41 = tmp_class_creation_11__bases;
            Py_INCREF( tmp_tuple_element_41 );
            PyTuple_SET_ITEM( tmp_args_name_22, 1, tmp_tuple_element_41 );
            tmp_tuple_element_41 = locals_contextlib_341;
            Py_INCREF( tmp_tuple_element_41 );
            PyTuple_SET_ITEM( tmp_args_name_22, 2, tmp_tuple_element_41 );
            CHECK_OBJECT( tmp_class_creation_11__class_decl_dict );
            tmp_kw_name_22 = tmp_class_creation_11__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 341;
            tmp_assign_source_96 = CALL_FUNCTION( tmp_called_name_24, tmp_args_name_22, tmp_kw_name_22 );
            Py_DECREF( tmp_args_name_22 );
            if ( tmp_assign_source_96 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 341;

                goto try_except_handler_33;
            }
            assert( outline_10_var___class__ == NULL );
            outline_10_var___class__ = tmp_assign_source_96;
        }
        CHECK_OBJECT( outline_10_var___class__ );
        tmp_assign_source_95 = outline_10_var___class__;
        Py_INCREF( tmp_assign_source_95 );
        goto try_return_handler_33;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_33:;
        Py_DECREF( locals_contextlib_341 );
        locals_contextlib_341 = NULL;
        goto try_return_handler_32;
        // Exception handler code:
        try_except_handler_33:;
        exception_keeper_type_31 = exception_type;
        exception_keeper_value_31 = exception_value;
        exception_keeper_tb_31 = exception_tb;
        exception_keeper_lineno_31 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_341 );
        locals_contextlib_341 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_31;
        exception_value = exception_keeper_value_31;
        exception_tb = exception_keeper_tb_31;
        exception_lineno = exception_keeper_lineno_31;

        goto try_except_handler_32;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_32:;
        CHECK_OBJECT( (PyObject *)outline_10_var___class__ );
        Py_DECREF( outline_10_var___class__ );
        outline_10_var___class__ = NULL;

        goto outline_result_11;
        // Exception handler code:
        try_except_handler_32:;
        exception_keeper_type_32 = exception_type;
        exception_keeper_value_32 = exception_value;
        exception_keeper_tb_32 = exception_tb;
        exception_keeper_lineno_32 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_32;
        exception_value = exception_keeper_value_32;
        exception_tb = exception_keeper_tb_32;
        exception_lineno = exception_keeper_lineno_32;

        goto outline_exception_11;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_11:;
        exception_lineno = 341;
        goto try_except_handler_31;
        outline_result_11:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_suppress, tmp_assign_source_95 );
    }
    goto try_end_11;
    // Exception handler code:
    try_except_handler_31:;
    exception_keeper_type_33 = exception_type;
    exception_keeper_value_33 = exception_value;
    exception_keeper_tb_33 = exception_tb;
    exception_keeper_lineno_33 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_11__bases_orig );
    tmp_class_creation_11__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_11__bases );
    tmp_class_creation_11__bases = NULL;

    Py_XDECREF( tmp_class_creation_11__class_decl_dict );
    tmp_class_creation_11__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_11__prepared );
    tmp_class_creation_11__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_33;
    exception_value = exception_keeper_value_33;
    exception_tb = exception_keeper_tb_33;
    exception_lineno = exception_keeper_lineno_33;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__bases_orig );
    Py_DECREF( tmp_class_creation_11__bases_orig );
    tmp_class_creation_11__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__bases );
    Py_DECREF( tmp_class_creation_11__bases );
    tmp_class_creation_11__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class_decl_dict );
    Py_DECREF( tmp_class_creation_11__class_decl_dict );
    tmp_class_creation_11__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__metaclass );
    Py_DECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__prepared );
    Py_DECREF( tmp_class_creation_11__prepared );
    tmp_class_creation_11__prepared = NULL;

    {
        PyObject *tmp_assign_source_97;
        tmp_assign_source_97 = PyDict_New();
        assert( tmp_class_creation_12__class_decl_dict == NULL );
        tmp_class_creation_12__class_decl_dict = tmp_assign_source_97;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_98;
        PyObject *tmp_metaclass_name_12;
        nuitka_bool tmp_condition_result_67;
        PyObject *tmp_key_name_34;
        PyObject *tmp_dict_name_34;
        PyObject *tmp_dict_name_35;
        PyObject *tmp_key_name_35;
        PyObject *tmp_bases_name_12;
        tmp_key_name_34 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_12__class_decl_dict );
        tmp_dict_name_34 = tmp_class_creation_12__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_34, tmp_key_name_34 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 371;

            goto try_except_handler_34;
        }
        tmp_condition_result_67 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_67 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_24;
        }
        else
        {
            goto condexpr_false_24;
        }
        condexpr_true_24:;
        CHECK_OBJECT( tmp_class_creation_12__class_decl_dict );
        tmp_dict_name_35 = tmp_class_creation_12__class_decl_dict;
        tmp_key_name_35 = const_str_plain_metaclass;
        tmp_metaclass_name_12 = DICT_GET_ITEM( tmp_dict_name_35, tmp_key_name_35 );
        if ( tmp_metaclass_name_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 371;

            goto try_except_handler_34;
        }
        goto condexpr_end_24;
        condexpr_false_24:;
        tmp_metaclass_name_12 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_12 );
        condexpr_end_24:;
        tmp_bases_name_12 = const_tuple_empty;
        tmp_assign_source_98 = SELECT_METACLASS( tmp_metaclass_name_12, tmp_bases_name_12 );
        Py_DECREF( tmp_metaclass_name_12 );
        if ( tmp_assign_source_98 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 371;

            goto try_except_handler_34;
        }
        assert( tmp_class_creation_12__metaclass == NULL );
        tmp_class_creation_12__metaclass = tmp_assign_source_98;
    }
    {
        nuitka_bool tmp_condition_result_68;
        PyObject *tmp_key_name_36;
        PyObject *tmp_dict_name_36;
        tmp_key_name_36 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_12__class_decl_dict );
        tmp_dict_name_36 = tmp_class_creation_12__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_36, tmp_key_name_36 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 371;

            goto try_except_handler_34;
        }
        tmp_condition_result_68 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_68 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_44;
        }
        else
        {
            goto branch_no_44;
        }
        branch_yes_44:;
        CHECK_OBJECT( tmp_class_creation_12__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_12__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 371;

            goto try_except_handler_34;
        }
        branch_no_44:;
    }
    {
        nuitka_bool tmp_condition_result_69;
        PyObject *tmp_source_name_47;
        CHECK_OBJECT( tmp_class_creation_12__metaclass );
        tmp_source_name_47 = tmp_class_creation_12__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_47, const_str_plain___prepare__ );
        tmp_condition_result_69 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_69 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_45;
        }
        else
        {
            goto branch_no_45;
        }
        branch_yes_45:;
        {
            PyObject *tmp_assign_source_99;
            PyObject *tmp_called_name_25;
            PyObject *tmp_source_name_48;
            PyObject *tmp_args_name_23;
            PyObject *tmp_kw_name_23;
            CHECK_OBJECT( tmp_class_creation_12__metaclass );
            tmp_source_name_48 = tmp_class_creation_12__metaclass;
            tmp_called_name_25 = LOOKUP_ATTRIBUTE( tmp_source_name_48, const_str_plain___prepare__ );
            if ( tmp_called_name_25 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 371;

                goto try_except_handler_34;
            }
            tmp_args_name_23 = const_tuple_str_plain__BaseExitStack_tuple_empty_tuple;
            CHECK_OBJECT( tmp_class_creation_12__class_decl_dict );
            tmp_kw_name_23 = tmp_class_creation_12__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 371;
            tmp_assign_source_99 = CALL_FUNCTION( tmp_called_name_25, tmp_args_name_23, tmp_kw_name_23 );
            Py_DECREF( tmp_called_name_25 );
            if ( tmp_assign_source_99 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 371;

                goto try_except_handler_34;
            }
            assert( tmp_class_creation_12__prepared == NULL );
            tmp_class_creation_12__prepared = tmp_assign_source_99;
        }
        {
            nuitka_bool tmp_condition_result_70;
            PyObject *tmp_operand_name_12;
            PyObject *tmp_source_name_49;
            CHECK_OBJECT( tmp_class_creation_12__prepared );
            tmp_source_name_49 = tmp_class_creation_12__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_49, const_str_plain___getitem__ );
            tmp_operand_name_12 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_12 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 371;

                goto try_except_handler_34;
            }
            tmp_condition_result_70 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_70 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_46;
            }
            else
            {
                goto branch_no_46;
            }
            branch_yes_46:;
            {
                PyObject *tmp_raise_type_12;
                PyObject *tmp_raise_value_12;
                PyObject *tmp_left_name_12;
                PyObject *tmp_right_name_12;
                PyObject *tmp_tuple_element_42;
                PyObject *tmp_getattr_target_12;
                PyObject *tmp_getattr_attr_12;
                PyObject *tmp_getattr_default_12;
                PyObject *tmp_source_name_50;
                PyObject *tmp_type_arg_22;
                tmp_raise_type_12 = PyExc_TypeError;
                tmp_left_name_12 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_12__metaclass );
                tmp_getattr_target_12 = tmp_class_creation_12__metaclass;
                tmp_getattr_attr_12 = const_str_plain___name__;
                tmp_getattr_default_12 = const_str_angle_metaclass;
                tmp_tuple_element_42 = BUILTIN_GETATTR( tmp_getattr_target_12, tmp_getattr_attr_12, tmp_getattr_default_12 );
                if ( tmp_tuple_element_42 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 371;

                    goto try_except_handler_34;
                }
                tmp_right_name_12 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_12, 0, tmp_tuple_element_42 );
                CHECK_OBJECT( tmp_class_creation_12__prepared );
                tmp_type_arg_22 = tmp_class_creation_12__prepared;
                tmp_source_name_50 = BUILTIN_TYPE1( tmp_type_arg_22 );
                assert( !(tmp_source_name_50 == NULL) );
                tmp_tuple_element_42 = LOOKUP_ATTRIBUTE( tmp_source_name_50, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_50 );
                if ( tmp_tuple_element_42 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_12 );

                    exception_lineno = 371;

                    goto try_except_handler_34;
                }
                PyTuple_SET_ITEM( tmp_right_name_12, 1, tmp_tuple_element_42 );
                tmp_raise_value_12 = BINARY_OPERATION_REMAINDER( tmp_left_name_12, tmp_right_name_12 );
                Py_DECREF( tmp_right_name_12 );
                if ( tmp_raise_value_12 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 371;

                    goto try_except_handler_34;
                }
                exception_type = tmp_raise_type_12;
                Py_INCREF( tmp_raise_type_12 );
                exception_value = tmp_raise_value_12;
                exception_lineno = 371;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_34;
            }
            branch_no_46:;
        }
        goto branch_end_45;
        branch_no_45:;
        {
            PyObject *tmp_assign_source_100;
            tmp_assign_source_100 = PyDict_New();
            assert( tmp_class_creation_12__prepared == NULL );
            tmp_class_creation_12__prepared = tmp_assign_source_100;
        }
        branch_end_45:;
    }
    {
        PyObject *tmp_assign_source_101;
        {
            PyObject *tmp_set_locals_12;
            CHECK_OBJECT( tmp_class_creation_12__prepared );
            tmp_set_locals_12 = tmp_class_creation_12__prepared;
            locals_contextlib_371 = tmp_set_locals_12;
            Py_INCREF( tmp_set_locals_12 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_371, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 371;

            goto try_except_handler_36;
        }
        tmp_dictset_value = const_str_digest_361410c9c3db1345a7a5859bf6b7df79;
        tmp_res = PyObject_SetItem( locals_contextlib_371, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 371;

            goto try_except_handler_36;
        }
        tmp_dictset_value = const_str_plain__BaseExitStack;
        tmp_res = PyObject_SetItem( locals_contextlib_371, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 371;

            goto try_except_handler_36;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_5bce12272bd0320f1ba68a2377afbf7f_13, codeobj_5bce12272bd0320f1ba68a2377afbf7f, module_contextlib, sizeof(void *) );
        frame_5bce12272bd0320f1ba68a2377afbf7f_13 = cache_frame_5bce12272bd0320f1ba68a2377afbf7f_13;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_5bce12272bd0320f1ba68a2377afbf7f_13 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_5bce12272bd0320f1ba68a2377afbf7f_13 ) == 2 ); // Frame stack

        // Framed code:
        {
            nuitka_bool tmp_condition_result_71;
            PyObject *tmp_called_name_26;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_staticmethod_arg_1;
            tmp_res = MAPPING_HAS_ITEM( locals_contextlib_371, const_str_plain_staticmethod );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 374;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }
            tmp_condition_result_71 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_71 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_25;
            }
            else
            {
                goto condexpr_false_25;
            }
            condexpr_true_25:;
            tmp_called_name_26 = PyObject_GetItem( locals_contextlib_371, const_str_plain_staticmethod );

            if ( tmp_called_name_26 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "staticmethod" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 374;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }

            if ( tmp_called_name_26 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 374;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }
            tmp_args_element_name_5 = MAKE_FUNCTION_contextlib$$$function_26__create_exit_wrapper(  );



            frame_5bce12272bd0320f1ba68a2377afbf7f_13->m_frame.f_lineno = 374;
            {
                PyObject *call_args[] = { tmp_args_element_name_5 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_26, call_args );
            }

            Py_DECREF( tmp_called_name_26 );
            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 374;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }
            goto condexpr_end_25;
            condexpr_false_25:;
            tmp_staticmethod_arg_1 = MAKE_FUNCTION_contextlib$$$function_26__create_exit_wrapper(  );



            tmp_dictset_value = BUILTIN_STATICMETHOD( tmp_staticmethod_arg_1 );
            Py_DECREF( tmp_staticmethod_arg_1 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 374;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }
            condexpr_end_25:;
            tmp_res = PyObject_SetItem( locals_contextlib_371, const_str_plain__create_exit_wrapper, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 374;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }
        }
        {
            nuitka_bool tmp_condition_result_72;
            PyObject *tmp_called_name_27;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_staticmethod_arg_2;
            tmp_res = MAPPING_HAS_ITEM( locals_contextlib_371, const_str_plain_staticmethod );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 380;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }
            tmp_condition_result_72 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_72 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_26;
            }
            else
            {
                goto condexpr_false_26;
            }
            condexpr_true_26:;
            tmp_called_name_27 = PyObject_GetItem( locals_contextlib_371, const_str_plain_staticmethod );

            if ( tmp_called_name_27 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "staticmethod" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 380;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }

            if ( tmp_called_name_27 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 380;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }
            tmp_args_element_name_6 = MAKE_FUNCTION_contextlib$$$function_27__create_cb_wrapper(  );



            frame_5bce12272bd0320f1ba68a2377afbf7f_13->m_frame.f_lineno = 380;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_27, call_args );
            }

            Py_DECREF( tmp_called_name_27 );
            Py_DECREF( tmp_args_element_name_6 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 380;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }
            goto condexpr_end_26;
            condexpr_false_26:;
            tmp_staticmethod_arg_2 = MAKE_FUNCTION_contextlib$$$function_27__create_cb_wrapper(  );



            tmp_dictset_value = BUILTIN_STATICMETHOD( tmp_staticmethod_arg_2 );
            Py_DECREF( tmp_staticmethod_arg_2 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 380;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }
            condexpr_end_26:;
            tmp_res = PyObject_SetItem( locals_contextlib_371, const_str_plain__create_cb_wrapper, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 380;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_28___init__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_371, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 386;
            type_description_2 = "o";
            goto frame_exception_exit_13;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_29_pop_all(  );



        tmp_res = PyObject_SetItem( locals_contextlib_371, const_str_plain_pop_all, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 389;
            type_description_2 = "o";
            goto frame_exception_exit_13;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_30_push(  );



        tmp_res = PyObject_SetItem( locals_contextlib_371, const_str_plain_push, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 396;
            type_description_2 = "o";
            goto frame_exception_exit_13;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_31_enter_context(  );



        tmp_res = PyObject_SetItem( locals_contextlib_371, const_str_plain_enter_context, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 416;
            type_description_2 = "o";
            goto frame_exception_exit_13;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_32_callback(  );



        tmp_res = PyObject_SetItem( locals_contextlib_371, const_str_plain_callback, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 430;
            type_description_2 = "o";
            goto frame_exception_exit_13;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_33__push_cm_exit(  );



        tmp_res = PyObject_SetItem( locals_contextlib_371, const_str_plain__push_cm_exit, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 443;
            type_description_2 = "o";
            goto frame_exception_exit_13;
        }
        {
            PyObject *tmp_defaults_1;
            tmp_defaults_1 = const_tuple_true_tuple;
            Py_INCREF( tmp_defaults_1 );
            tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_34__push_exit_callback( tmp_defaults_1 );



            tmp_res = PyObject_SetItem( locals_contextlib_371, const_str_plain__push_exit_callback, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 449;
                type_description_2 = "o";
                goto frame_exception_exit_13;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_5bce12272bd0320f1ba68a2377afbf7f_13 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_12;

        frame_exception_exit_13:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_5bce12272bd0320f1ba68a2377afbf7f_13 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_5bce12272bd0320f1ba68a2377afbf7f_13, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_5bce12272bd0320f1ba68a2377afbf7f_13->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_5bce12272bd0320f1ba68a2377afbf7f_13, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_5bce12272bd0320f1ba68a2377afbf7f_13,
            type_description_2,
            outline_11_var___class__
        );


        // Release cached frame.
        if ( frame_5bce12272bd0320f1ba68a2377afbf7f_13 == cache_frame_5bce12272bd0320f1ba68a2377afbf7f_13 )
        {
            Py_DECREF( frame_5bce12272bd0320f1ba68a2377afbf7f_13 );
        }
        cache_frame_5bce12272bd0320f1ba68a2377afbf7f_13 = NULL;

        assertFrameObject( frame_5bce12272bd0320f1ba68a2377afbf7f_13 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_12;

        frame_no_exception_12:;
        goto skip_nested_handling_12;
        nested_frame_exit_12:;

        goto try_except_handler_36;
        skip_nested_handling_12:;
        {
            PyObject *tmp_assign_source_102;
            PyObject *tmp_called_name_28;
            PyObject *tmp_args_name_24;
            PyObject *tmp_tuple_element_43;
            PyObject *tmp_kw_name_24;
            CHECK_OBJECT( tmp_class_creation_12__metaclass );
            tmp_called_name_28 = tmp_class_creation_12__metaclass;
            tmp_tuple_element_43 = const_str_plain__BaseExitStack;
            tmp_args_name_24 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_43 );
            PyTuple_SET_ITEM( tmp_args_name_24, 0, tmp_tuple_element_43 );
            tmp_tuple_element_43 = const_tuple_empty;
            Py_INCREF( tmp_tuple_element_43 );
            PyTuple_SET_ITEM( tmp_args_name_24, 1, tmp_tuple_element_43 );
            tmp_tuple_element_43 = locals_contextlib_371;
            Py_INCREF( tmp_tuple_element_43 );
            PyTuple_SET_ITEM( tmp_args_name_24, 2, tmp_tuple_element_43 );
            CHECK_OBJECT( tmp_class_creation_12__class_decl_dict );
            tmp_kw_name_24 = tmp_class_creation_12__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 371;
            tmp_assign_source_102 = CALL_FUNCTION( tmp_called_name_28, tmp_args_name_24, tmp_kw_name_24 );
            Py_DECREF( tmp_args_name_24 );
            if ( tmp_assign_source_102 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 371;

                goto try_except_handler_36;
            }
            assert( outline_11_var___class__ == NULL );
            outline_11_var___class__ = tmp_assign_source_102;
        }
        CHECK_OBJECT( outline_11_var___class__ );
        tmp_assign_source_101 = outline_11_var___class__;
        Py_INCREF( tmp_assign_source_101 );
        goto try_return_handler_36;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_36:;
        Py_DECREF( locals_contextlib_371 );
        locals_contextlib_371 = NULL;
        goto try_return_handler_35;
        // Exception handler code:
        try_except_handler_36:;
        exception_keeper_type_34 = exception_type;
        exception_keeper_value_34 = exception_value;
        exception_keeper_tb_34 = exception_tb;
        exception_keeper_lineno_34 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_371 );
        locals_contextlib_371 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_34;
        exception_value = exception_keeper_value_34;
        exception_tb = exception_keeper_tb_34;
        exception_lineno = exception_keeper_lineno_34;

        goto try_except_handler_35;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_35:;
        CHECK_OBJECT( (PyObject *)outline_11_var___class__ );
        Py_DECREF( outline_11_var___class__ );
        outline_11_var___class__ = NULL;

        goto outline_result_12;
        // Exception handler code:
        try_except_handler_35:;
        exception_keeper_type_35 = exception_type;
        exception_keeper_value_35 = exception_value;
        exception_keeper_tb_35 = exception_tb;
        exception_keeper_lineno_35 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_35;
        exception_value = exception_keeper_value_35;
        exception_tb = exception_keeper_tb_35;
        exception_lineno = exception_keeper_lineno_35;

        goto outline_exception_12;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_12:;
        exception_lineno = 371;
        goto try_except_handler_34;
        outline_result_12:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__BaseExitStack, tmp_assign_source_101 );
    }
    goto try_end_12;
    // Exception handler code:
    try_except_handler_34:;
    exception_keeper_type_36 = exception_type;
    exception_keeper_value_36 = exception_value;
    exception_keeper_tb_36 = exception_tb;
    exception_keeper_lineno_36 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class_decl_dict );
    Py_DECREF( tmp_class_creation_12__class_decl_dict );
    tmp_class_creation_12__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_12__prepared );
    tmp_class_creation_12__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_36;
    exception_value = exception_keeper_value_36;
    exception_tb = exception_keeper_tb_36;
    exception_lineno = exception_keeper_lineno_36;

    goto frame_exception_exit_1;
    // End of try:
    try_end_12:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class_decl_dict );
    Py_DECREF( tmp_class_creation_12__class_decl_dict );
    tmp_class_creation_12__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__metaclass );
    Py_DECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__prepared );
    Py_DECREF( tmp_class_creation_12__prepared );
    tmp_class_creation_12__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_103;
        PyObject *tmp_tuple_element_44;
        PyObject *tmp_mvar_value_17;
        PyObject *tmp_mvar_value_18;
        tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__BaseExitStack );

        if (unlikely( tmp_mvar_value_17 == NULL ))
        {
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseExitStack );
        }

        if ( tmp_mvar_value_17 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_BaseExitStack" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 454;

            goto try_except_handler_37;
        }

        tmp_tuple_element_44 = tmp_mvar_value_17;
        tmp_assign_source_103 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_44 );
        PyTuple_SET_ITEM( tmp_assign_source_103, 0, tmp_tuple_element_44 );
        tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );

        if (unlikely( tmp_mvar_value_18 == NULL ))
        {
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );
        }

        if ( tmp_mvar_value_18 == NULL )
        {
            Py_DECREF( tmp_assign_source_103 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "AbstractContextManager" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 454;

            goto try_except_handler_37;
        }

        tmp_tuple_element_44 = tmp_mvar_value_18;
        Py_INCREF( tmp_tuple_element_44 );
        PyTuple_SET_ITEM( tmp_assign_source_103, 1, tmp_tuple_element_44 );
        assert( tmp_class_creation_13__bases_orig == NULL );
        tmp_class_creation_13__bases_orig = tmp_assign_source_103;
    }
    {
        PyObject *tmp_assign_source_104;
        PyObject *tmp_dircall_arg1_11;
        CHECK_OBJECT( tmp_class_creation_13__bases_orig );
        tmp_dircall_arg1_11 = tmp_class_creation_13__bases_orig;
        Py_INCREF( tmp_dircall_arg1_11 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_11};
            tmp_assign_source_104 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_104 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;

            goto try_except_handler_37;
        }
        assert( tmp_class_creation_13__bases == NULL );
        tmp_class_creation_13__bases = tmp_assign_source_104;
    }
    {
        PyObject *tmp_assign_source_105;
        tmp_assign_source_105 = PyDict_New();
        assert( tmp_class_creation_13__class_decl_dict == NULL );
        tmp_class_creation_13__class_decl_dict = tmp_assign_source_105;
    }
    {
        PyObject *tmp_assign_source_106;
        PyObject *tmp_metaclass_name_13;
        nuitka_bool tmp_condition_result_73;
        PyObject *tmp_key_name_37;
        PyObject *tmp_dict_name_37;
        PyObject *tmp_dict_name_38;
        PyObject *tmp_key_name_38;
        nuitka_bool tmp_condition_result_74;
        int tmp_truth_name_11;
        PyObject *tmp_type_arg_23;
        PyObject *tmp_subscribed_name_11;
        PyObject *tmp_subscript_name_11;
        PyObject *tmp_bases_name_13;
        tmp_key_name_37 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_13__class_decl_dict );
        tmp_dict_name_37 = tmp_class_creation_13__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_37, tmp_key_name_37 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;

            goto try_except_handler_37;
        }
        tmp_condition_result_73 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_73 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_27;
        }
        else
        {
            goto condexpr_false_27;
        }
        condexpr_true_27:;
        CHECK_OBJECT( tmp_class_creation_13__class_decl_dict );
        tmp_dict_name_38 = tmp_class_creation_13__class_decl_dict;
        tmp_key_name_38 = const_str_plain_metaclass;
        tmp_metaclass_name_13 = DICT_GET_ITEM( tmp_dict_name_38, tmp_key_name_38 );
        if ( tmp_metaclass_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;

            goto try_except_handler_37;
        }
        goto condexpr_end_27;
        condexpr_false_27:;
        CHECK_OBJECT( tmp_class_creation_13__bases );
        tmp_truth_name_11 = CHECK_IF_TRUE( tmp_class_creation_13__bases );
        if ( tmp_truth_name_11 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;

            goto try_except_handler_37;
        }
        tmp_condition_result_74 = tmp_truth_name_11 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_74 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_28;
        }
        else
        {
            goto condexpr_false_28;
        }
        condexpr_true_28:;
        CHECK_OBJECT( tmp_class_creation_13__bases );
        tmp_subscribed_name_11 = tmp_class_creation_13__bases;
        tmp_subscript_name_11 = const_int_0;
        tmp_type_arg_23 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_11, tmp_subscript_name_11, 0 );
        if ( tmp_type_arg_23 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;

            goto try_except_handler_37;
        }
        tmp_metaclass_name_13 = BUILTIN_TYPE1( tmp_type_arg_23 );
        Py_DECREF( tmp_type_arg_23 );
        if ( tmp_metaclass_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;

            goto try_except_handler_37;
        }
        goto condexpr_end_28;
        condexpr_false_28:;
        tmp_metaclass_name_13 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_13 );
        condexpr_end_28:;
        condexpr_end_27:;
        CHECK_OBJECT( tmp_class_creation_13__bases );
        tmp_bases_name_13 = tmp_class_creation_13__bases;
        tmp_assign_source_106 = SELECT_METACLASS( tmp_metaclass_name_13, tmp_bases_name_13 );
        Py_DECREF( tmp_metaclass_name_13 );
        if ( tmp_assign_source_106 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;

            goto try_except_handler_37;
        }
        assert( tmp_class_creation_13__metaclass == NULL );
        tmp_class_creation_13__metaclass = tmp_assign_source_106;
    }
    {
        nuitka_bool tmp_condition_result_75;
        PyObject *tmp_key_name_39;
        PyObject *tmp_dict_name_39;
        tmp_key_name_39 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_13__class_decl_dict );
        tmp_dict_name_39 = tmp_class_creation_13__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_39, tmp_key_name_39 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;

            goto try_except_handler_37;
        }
        tmp_condition_result_75 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_75 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_47;
        }
        else
        {
            goto branch_no_47;
        }
        branch_yes_47:;
        CHECK_OBJECT( tmp_class_creation_13__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_13__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;

            goto try_except_handler_37;
        }
        branch_no_47:;
    }
    {
        nuitka_bool tmp_condition_result_76;
        PyObject *tmp_source_name_51;
        CHECK_OBJECT( tmp_class_creation_13__metaclass );
        tmp_source_name_51 = tmp_class_creation_13__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_51, const_str_plain___prepare__ );
        tmp_condition_result_76 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_76 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_48;
        }
        else
        {
            goto branch_no_48;
        }
        branch_yes_48:;
        {
            PyObject *tmp_assign_source_107;
            PyObject *tmp_called_name_29;
            PyObject *tmp_source_name_52;
            PyObject *tmp_args_name_25;
            PyObject *tmp_tuple_element_45;
            PyObject *tmp_kw_name_25;
            CHECK_OBJECT( tmp_class_creation_13__metaclass );
            tmp_source_name_52 = tmp_class_creation_13__metaclass;
            tmp_called_name_29 = LOOKUP_ATTRIBUTE( tmp_source_name_52, const_str_plain___prepare__ );
            if ( tmp_called_name_29 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 454;

                goto try_except_handler_37;
            }
            tmp_tuple_element_45 = const_str_plain_ExitStack;
            tmp_args_name_25 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_45 );
            PyTuple_SET_ITEM( tmp_args_name_25, 0, tmp_tuple_element_45 );
            CHECK_OBJECT( tmp_class_creation_13__bases );
            tmp_tuple_element_45 = tmp_class_creation_13__bases;
            Py_INCREF( tmp_tuple_element_45 );
            PyTuple_SET_ITEM( tmp_args_name_25, 1, tmp_tuple_element_45 );
            CHECK_OBJECT( tmp_class_creation_13__class_decl_dict );
            tmp_kw_name_25 = tmp_class_creation_13__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 454;
            tmp_assign_source_107 = CALL_FUNCTION( tmp_called_name_29, tmp_args_name_25, tmp_kw_name_25 );
            Py_DECREF( tmp_called_name_29 );
            Py_DECREF( tmp_args_name_25 );
            if ( tmp_assign_source_107 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 454;

                goto try_except_handler_37;
            }
            assert( tmp_class_creation_13__prepared == NULL );
            tmp_class_creation_13__prepared = tmp_assign_source_107;
        }
        {
            nuitka_bool tmp_condition_result_77;
            PyObject *tmp_operand_name_13;
            PyObject *tmp_source_name_53;
            CHECK_OBJECT( tmp_class_creation_13__prepared );
            tmp_source_name_53 = tmp_class_creation_13__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_53, const_str_plain___getitem__ );
            tmp_operand_name_13 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_13 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 454;

                goto try_except_handler_37;
            }
            tmp_condition_result_77 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_77 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_49;
            }
            else
            {
                goto branch_no_49;
            }
            branch_yes_49:;
            {
                PyObject *tmp_raise_type_13;
                PyObject *tmp_raise_value_13;
                PyObject *tmp_left_name_13;
                PyObject *tmp_right_name_13;
                PyObject *tmp_tuple_element_46;
                PyObject *tmp_getattr_target_13;
                PyObject *tmp_getattr_attr_13;
                PyObject *tmp_getattr_default_13;
                PyObject *tmp_source_name_54;
                PyObject *tmp_type_arg_24;
                tmp_raise_type_13 = PyExc_TypeError;
                tmp_left_name_13 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_13__metaclass );
                tmp_getattr_target_13 = tmp_class_creation_13__metaclass;
                tmp_getattr_attr_13 = const_str_plain___name__;
                tmp_getattr_default_13 = const_str_angle_metaclass;
                tmp_tuple_element_46 = BUILTIN_GETATTR( tmp_getattr_target_13, tmp_getattr_attr_13, tmp_getattr_default_13 );
                if ( tmp_tuple_element_46 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 454;

                    goto try_except_handler_37;
                }
                tmp_right_name_13 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_13, 0, tmp_tuple_element_46 );
                CHECK_OBJECT( tmp_class_creation_13__prepared );
                tmp_type_arg_24 = tmp_class_creation_13__prepared;
                tmp_source_name_54 = BUILTIN_TYPE1( tmp_type_arg_24 );
                assert( !(tmp_source_name_54 == NULL) );
                tmp_tuple_element_46 = LOOKUP_ATTRIBUTE( tmp_source_name_54, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_54 );
                if ( tmp_tuple_element_46 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_13 );

                    exception_lineno = 454;

                    goto try_except_handler_37;
                }
                PyTuple_SET_ITEM( tmp_right_name_13, 1, tmp_tuple_element_46 );
                tmp_raise_value_13 = BINARY_OPERATION_REMAINDER( tmp_left_name_13, tmp_right_name_13 );
                Py_DECREF( tmp_right_name_13 );
                if ( tmp_raise_value_13 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 454;

                    goto try_except_handler_37;
                }
                exception_type = tmp_raise_type_13;
                Py_INCREF( tmp_raise_type_13 );
                exception_value = tmp_raise_value_13;
                exception_lineno = 454;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_37;
            }
            branch_no_49:;
        }
        goto branch_end_48;
        branch_no_48:;
        {
            PyObject *tmp_assign_source_108;
            tmp_assign_source_108 = PyDict_New();
            assert( tmp_class_creation_13__prepared == NULL );
            tmp_class_creation_13__prepared = tmp_assign_source_108;
        }
        branch_end_48:;
    }
    {
        PyObject *tmp_assign_source_109;
        {
            PyObject *tmp_set_locals_13;
            CHECK_OBJECT( tmp_class_creation_13__prepared );
            tmp_set_locals_13 = tmp_class_creation_13__prepared;
            locals_contextlib_454 = tmp_set_locals_13;
            Py_INCREF( tmp_set_locals_13 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_454, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;

            goto try_except_handler_39;
        }
        tmp_dictset_value = const_str_digest_8925bc3e79b6caccc0000e42e8cb2562;
        tmp_res = PyObject_SetItem( locals_contextlib_454, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;

            goto try_except_handler_39;
        }
        tmp_dictset_value = const_str_plain_ExitStack;
        tmp_res = PyObject_SetItem( locals_contextlib_454, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;

            goto try_except_handler_39;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_4bcab7a51e5ec620770a43dbb3c4a947_14, codeobj_4bcab7a51e5ec620770a43dbb3c4a947, module_contextlib, sizeof(void *) );
        frame_4bcab7a51e5ec620770a43dbb3c4a947_14 = cache_frame_4bcab7a51e5ec620770a43dbb3c4a947_14;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_4bcab7a51e5ec620770a43dbb3c4a947_14 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_4bcab7a51e5ec620770a43dbb3c4a947_14 ) == 2 ); // Frame stack

        // Framed code:
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_35___enter__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_454, const_str_plain___enter__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 465;
            type_description_2 = "o";
            goto frame_exception_exit_14;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_36___exit__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_454, const_str_plain___exit__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 468;
            type_description_2 = "o";
            goto frame_exception_exit_14;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_37_close(  );



        tmp_res = PyObject_SetItem( locals_contextlib_454, const_str_plain_close, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 517;
            type_description_2 = "o";
            goto frame_exception_exit_14;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_4bcab7a51e5ec620770a43dbb3c4a947_14 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_13;

        frame_exception_exit_14:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_4bcab7a51e5ec620770a43dbb3c4a947_14 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_4bcab7a51e5ec620770a43dbb3c4a947_14, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_4bcab7a51e5ec620770a43dbb3c4a947_14->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_4bcab7a51e5ec620770a43dbb3c4a947_14, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_4bcab7a51e5ec620770a43dbb3c4a947_14,
            type_description_2,
            outline_12_var___class__
        );


        // Release cached frame.
        if ( frame_4bcab7a51e5ec620770a43dbb3c4a947_14 == cache_frame_4bcab7a51e5ec620770a43dbb3c4a947_14 )
        {
            Py_DECREF( frame_4bcab7a51e5ec620770a43dbb3c4a947_14 );
        }
        cache_frame_4bcab7a51e5ec620770a43dbb3c4a947_14 = NULL;

        assertFrameObject( frame_4bcab7a51e5ec620770a43dbb3c4a947_14 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_13;

        frame_no_exception_13:;
        goto skip_nested_handling_13;
        nested_frame_exit_13:;

        goto try_except_handler_39;
        skip_nested_handling_13:;
        {
            nuitka_bool tmp_condition_result_78;
            PyObject *tmp_compexpr_left_11;
            PyObject *tmp_compexpr_right_11;
            CHECK_OBJECT( tmp_class_creation_13__bases );
            tmp_compexpr_left_11 = tmp_class_creation_13__bases;
            CHECK_OBJECT( tmp_class_creation_13__bases_orig );
            tmp_compexpr_right_11 = tmp_class_creation_13__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_11, tmp_compexpr_right_11 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 454;

                goto try_except_handler_39;
            }
            tmp_condition_result_78 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_78 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_50;
            }
            else
            {
                goto branch_no_50;
            }
            branch_yes_50:;
            CHECK_OBJECT( tmp_class_creation_13__bases_orig );
            tmp_dictset_value = tmp_class_creation_13__bases_orig;
            tmp_res = PyObject_SetItem( locals_contextlib_454, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 454;

                goto try_except_handler_39;
            }
            branch_no_50:;
        }
        {
            PyObject *tmp_assign_source_110;
            PyObject *tmp_called_name_30;
            PyObject *tmp_args_name_26;
            PyObject *tmp_tuple_element_47;
            PyObject *tmp_kw_name_26;
            CHECK_OBJECT( tmp_class_creation_13__metaclass );
            tmp_called_name_30 = tmp_class_creation_13__metaclass;
            tmp_tuple_element_47 = const_str_plain_ExitStack;
            tmp_args_name_26 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_47 );
            PyTuple_SET_ITEM( tmp_args_name_26, 0, tmp_tuple_element_47 );
            CHECK_OBJECT( tmp_class_creation_13__bases );
            tmp_tuple_element_47 = tmp_class_creation_13__bases;
            Py_INCREF( tmp_tuple_element_47 );
            PyTuple_SET_ITEM( tmp_args_name_26, 1, tmp_tuple_element_47 );
            tmp_tuple_element_47 = locals_contextlib_454;
            Py_INCREF( tmp_tuple_element_47 );
            PyTuple_SET_ITEM( tmp_args_name_26, 2, tmp_tuple_element_47 );
            CHECK_OBJECT( tmp_class_creation_13__class_decl_dict );
            tmp_kw_name_26 = tmp_class_creation_13__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 454;
            tmp_assign_source_110 = CALL_FUNCTION( tmp_called_name_30, tmp_args_name_26, tmp_kw_name_26 );
            Py_DECREF( tmp_args_name_26 );
            if ( tmp_assign_source_110 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 454;

                goto try_except_handler_39;
            }
            assert( outline_12_var___class__ == NULL );
            outline_12_var___class__ = tmp_assign_source_110;
        }
        CHECK_OBJECT( outline_12_var___class__ );
        tmp_assign_source_109 = outline_12_var___class__;
        Py_INCREF( tmp_assign_source_109 );
        goto try_return_handler_39;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_39:;
        Py_DECREF( locals_contextlib_454 );
        locals_contextlib_454 = NULL;
        goto try_return_handler_38;
        // Exception handler code:
        try_except_handler_39:;
        exception_keeper_type_37 = exception_type;
        exception_keeper_value_37 = exception_value;
        exception_keeper_tb_37 = exception_tb;
        exception_keeper_lineno_37 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_454 );
        locals_contextlib_454 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_37;
        exception_value = exception_keeper_value_37;
        exception_tb = exception_keeper_tb_37;
        exception_lineno = exception_keeper_lineno_37;

        goto try_except_handler_38;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_38:;
        CHECK_OBJECT( (PyObject *)outline_12_var___class__ );
        Py_DECREF( outline_12_var___class__ );
        outline_12_var___class__ = NULL;

        goto outline_result_13;
        // Exception handler code:
        try_except_handler_38:;
        exception_keeper_type_38 = exception_type;
        exception_keeper_value_38 = exception_value;
        exception_keeper_tb_38 = exception_tb;
        exception_keeper_lineno_38 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_38;
        exception_value = exception_keeper_value_38;
        exception_tb = exception_keeper_tb_38;
        exception_lineno = exception_keeper_lineno_38;

        goto outline_exception_13;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_13:;
        exception_lineno = 454;
        goto try_except_handler_37;
        outline_result_13:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_ExitStack, tmp_assign_source_109 );
    }
    goto try_end_13;
    // Exception handler code:
    try_except_handler_37:;
    exception_keeper_type_39 = exception_type;
    exception_keeper_value_39 = exception_value;
    exception_keeper_tb_39 = exception_tb;
    exception_keeper_lineno_39 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_13__bases_orig );
    tmp_class_creation_13__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_13__bases );
    tmp_class_creation_13__bases = NULL;

    Py_XDECREF( tmp_class_creation_13__class_decl_dict );
    tmp_class_creation_13__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_13__prepared );
    tmp_class_creation_13__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_39;
    exception_value = exception_keeper_value_39;
    exception_tb = exception_keeper_tb_39;
    exception_lineno = exception_keeper_lineno_39;

    goto frame_exception_exit_1;
    // End of try:
    try_end_13:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__bases_orig );
    Py_DECREF( tmp_class_creation_13__bases_orig );
    tmp_class_creation_13__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__bases );
    Py_DECREF( tmp_class_creation_13__bases );
    tmp_class_creation_13__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class_decl_dict );
    Py_DECREF( tmp_class_creation_13__class_decl_dict );
    tmp_class_creation_13__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__metaclass );
    Py_DECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__prepared );
    Py_DECREF( tmp_class_creation_13__prepared );
    tmp_class_creation_13__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_111;
        PyObject *tmp_tuple_element_48;
        PyObject *tmp_mvar_value_19;
        PyObject *tmp_mvar_value_20;
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain__BaseExitStack );

        if (unlikely( tmp_mvar_value_19 == NULL ))
        {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BaseExitStack );
        }

        if ( tmp_mvar_value_19 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_BaseExitStack" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 523;

            goto try_except_handler_40;
        }

        tmp_tuple_element_48 = tmp_mvar_value_19;
        tmp_assign_source_111 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_48 );
        PyTuple_SET_ITEM( tmp_assign_source_111, 0, tmp_tuple_element_48 );
        tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AbstractAsyncContextManager );

        if (unlikely( tmp_mvar_value_20 == NULL ))
        {
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AbstractAsyncContextManager );
        }

        if ( tmp_mvar_value_20 == NULL )
        {
            Py_DECREF( tmp_assign_source_111 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "AbstractAsyncContextManager" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 523;

            goto try_except_handler_40;
        }

        tmp_tuple_element_48 = tmp_mvar_value_20;
        Py_INCREF( tmp_tuple_element_48 );
        PyTuple_SET_ITEM( tmp_assign_source_111, 1, tmp_tuple_element_48 );
        assert( tmp_class_creation_14__bases_orig == NULL );
        tmp_class_creation_14__bases_orig = tmp_assign_source_111;
    }
    {
        PyObject *tmp_assign_source_112;
        PyObject *tmp_dircall_arg1_12;
        CHECK_OBJECT( tmp_class_creation_14__bases_orig );
        tmp_dircall_arg1_12 = tmp_class_creation_14__bases_orig;
        Py_INCREF( tmp_dircall_arg1_12 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_12};
            tmp_assign_source_112 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_112 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;

            goto try_except_handler_40;
        }
        assert( tmp_class_creation_14__bases == NULL );
        tmp_class_creation_14__bases = tmp_assign_source_112;
    }
    {
        PyObject *tmp_assign_source_113;
        tmp_assign_source_113 = PyDict_New();
        assert( tmp_class_creation_14__class_decl_dict == NULL );
        tmp_class_creation_14__class_decl_dict = tmp_assign_source_113;
    }
    {
        PyObject *tmp_assign_source_114;
        PyObject *tmp_metaclass_name_14;
        nuitka_bool tmp_condition_result_79;
        PyObject *tmp_key_name_40;
        PyObject *tmp_dict_name_40;
        PyObject *tmp_dict_name_41;
        PyObject *tmp_key_name_41;
        nuitka_bool tmp_condition_result_80;
        int tmp_truth_name_12;
        PyObject *tmp_type_arg_25;
        PyObject *tmp_subscribed_name_12;
        PyObject *tmp_subscript_name_12;
        PyObject *tmp_bases_name_14;
        tmp_key_name_40 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_14__class_decl_dict );
        tmp_dict_name_40 = tmp_class_creation_14__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_40, tmp_key_name_40 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;

            goto try_except_handler_40;
        }
        tmp_condition_result_79 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_79 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_29;
        }
        else
        {
            goto condexpr_false_29;
        }
        condexpr_true_29:;
        CHECK_OBJECT( tmp_class_creation_14__class_decl_dict );
        tmp_dict_name_41 = tmp_class_creation_14__class_decl_dict;
        tmp_key_name_41 = const_str_plain_metaclass;
        tmp_metaclass_name_14 = DICT_GET_ITEM( tmp_dict_name_41, tmp_key_name_41 );
        if ( tmp_metaclass_name_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;

            goto try_except_handler_40;
        }
        goto condexpr_end_29;
        condexpr_false_29:;
        CHECK_OBJECT( tmp_class_creation_14__bases );
        tmp_truth_name_12 = CHECK_IF_TRUE( tmp_class_creation_14__bases );
        if ( tmp_truth_name_12 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;

            goto try_except_handler_40;
        }
        tmp_condition_result_80 = tmp_truth_name_12 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_80 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_30;
        }
        else
        {
            goto condexpr_false_30;
        }
        condexpr_true_30:;
        CHECK_OBJECT( tmp_class_creation_14__bases );
        tmp_subscribed_name_12 = tmp_class_creation_14__bases;
        tmp_subscript_name_12 = const_int_0;
        tmp_type_arg_25 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_12, tmp_subscript_name_12, 0 );
        if ( tmp_type_arg_25 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;

            goto try_except_handler_40;
        }
        tmp_metaclass_name_14 = BUILTIN_TYPE1( tmp_type_arg_25 );
        Py_DECREF( tmp_type_arg_25 );
        if ( tmp_metaclass_name_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;

            goto try_except_handler_40;
        }
        goto condexpr_end_30;
        condexpr_false_30:;
        tmp_metaclass_name_14 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_14 );
        condexpr_end_30:;
        condexpr_end_29:;
        CHECK_OBJECT( tmp_class_creation_14__bases );
        tmp_bases_name_14 = tmp_class_creation_14__bases;
        tmp_assign_source_114 = SELECT_METACLASS( tmp_metaclass_name_14, tmp_bases_name_14 );
        Py_DECREF( tmp_metaclass_name_14 );
        if ( tmp_assign_source_114 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;

            goto try_except_handler_40;
        }
        assert( tmp_class_creation_14__metaclass == NULL );
        tmp_class_creation_14__metaclass = tmp_assign_source_114;
    }
    {
        nuitka_bool tmp_condition_result_81;
        PyObject *tmp_key_name_42;
        PyObject *tmp_dict_name_42;
        tmp_key_name_42 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_14__class_decl_dict );
        tmp_dict_name_42 = tmp_class_creation_14__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_42, tmp_key_name_42 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;

            goto try_except_handler_40;
        }
        tmp_condition_result_81 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_81 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_51;
        }
        else
        {
            goto branch_no_51;
        }
        branch_yes_51:;
        CHECK_OBJECT( tmp_class_creation_14__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_14__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;

            goto try_except_handler_40;
        }
        branch_no_51:;
    }
    {
        nuitka_bool tmp_condition_result_82;
        PyObject *tmp_source_name_55;
        CHECK_OBJECT( tmp_class_creation_14__metaclass );
        tmp_source_name_55 = tmp_class_creation_14__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_55, const_str_plain___prepare__ );
        tmp_condition_result_82 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_82 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_52;
        }
        else
        {
            goto branch_no_52;
        }
        branch_yes_52:;
        {
            PyObject *tmp_assign_source_115;
            PyObject *tmp_called_name_31;
            PyObject *tmp_source_name_56;
            PyObject *tmp_args_name_27;
            PyObject *tmp_tuple_element_49;
            PyObject *tmp_kw_name_27;
            CHECK_OBJECT( tmp_class_creation_14__metaclass );
            tmp_source_name_56 = tmp_class_creation_14__metaclass;
            tmp_called_name_31 = LOOKUP_ATTRIBUTE( tmp_source_name_56, const_str_plain___prepare__ );
            if ( tmp_called_name_31 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 523;

                goto try_except_handler_40;
            }
            tmp_tuple_element_49 = const_str_plain_AsyncExitStack;
            tmp_args_name_27 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_49 );
            PyTuple_SET_ITEM( tmp_args_name_27, 0, tmp_tuple_element_49 );
            CHECK_OBJECT( tmp_class_creation_14__bases );
            tmp_tuple_element_49 = tmp_class_creation_14__bases;
            Py_INCREF( tmp_tuple_element_49 );
            PyTuple_SET_ITEM( tmp_args_name_27, 1, tmp_tuple_element_49 );
            CHECK_OBJECT( tmp_class_creation_14__class_decl_dict );
            tmp_kw_name_27 = tmp_class_creation_14__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 523;
            tmp_assign_source_115 = CALL_FUNCTION( tmp_called_name_31, tmp_args_name_27, tmp_kw_name_27 );
            Py_DECREF( tmp_called_name_31 );
            Py_DECREF( tmp_args_name_27 );
            if ( tmp_assign_source_115 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 523;

                goto try_except_handler_40;
            }
            assert( tmp_class_creation_14__prepared == NULL );
            tmp_class_creation_14__prepared = tmp_assign_source_115;
        }
        {
            nuitka_bool tmp_condition_result_83;
            PyObject *tmp_operand_name_14;
            PyObject *tmp_source_name_57;
            CHECK_OBJECT( tmp_class_creation_14__prepared );
            tmp_source_name_57 = tmp_class_creation_14__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_57, const_str_plain___getitem__ );
            tmp_operand_name_14 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_14 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 523;

                goto try_except_handler_40;
            }
            tmp_condition_result_83 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_83 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_53;
            }
            else
            {
                goto branch_no_53;
            }
            branch_yes_53:;
            {
                PyObject *tmp_raise_type_14;
                PyObject *tmp_raise_value_14;
                PyObject *tmp_left_name_14;
                PyObject *tmp_right_name_14;
                PyObject *tmp_tuple_element_50;
                PyObject *tmp_getattr_target_14;
                PyObject *tmp_getattr_attr_14;
                PyObject *tmp_getattr_default_14;
                PyObject *tmp_source_name_58;
                PyObject *tmp_type_arg_26;
                tmp_raise_type_14 = PyExc_TypeError;
                tmp_left_name_14 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_14__metaclass );
                tmp_getattr_target_14 = tmp_class_creation_14__metaclass;
                tmp_getattr_attr_14 = const_str_plain___name__;
                tmp_getattr_default_14 = const_str_angle_metaclass;
                tmp_tuple_element_50 = BUILTIN_GETATTR( tmp_getattr_target_14, tmp_getattr_attr_14, tmp_getattr_default_14 );
                if ( tmp_tuple_element_50 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 523;

                    goto try_except_handler_40;
                }
                tmp_right_name_14 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_14, 0, tmp_tuple_element_50 );
                CHECK_OBJECT( tmp_class_creation_14__prepared );
                tmp_type_arg_26 = tmp_class_creation_14__prepared;
                tmp_source_name_58 = BUILTIN_TYPE1( tmp_type_arg_26 );
                assert( !(tmp_source_name_58 == NULL) );
                tmp_tuple_element_50 = LOOKUP_ATTRIBUTE( tmp_source_name_58, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_58 );
                if ( tmp_tuple_element_50 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_14 );

                    exception_lineno = 523;

                    goto try_except_handler_40;
                }
                PyTuple_SET_ITEM( tmp_right_name_14, 1, tmp_tuple_element_50 );
                tmp_raise_value_14 = BINARY_OPERATION_REMAINDER( tmp_left_name_14, tmp_right_name_14 );
                Py_DECREF( tmp_right_name_14 );
                if ( tmp_raise_value_14 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 523;

                    goto try_except_handler_40;
                }
                exception_type = tmp_raise_type_14;
                Py_INCREF( tmp_raise_type_14 );
                exception_value = tmp_raise_value_14;
                exception_lineno = 523;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_40;
            }
            branch_no_53:;
        }
        goto branch_end_52;
        branch_no_52:;
        {
            PyObject *tmp_assign_source_116;
            tmp_assign_source_116 = PyDict_New();
            assert( tmp_class_creation_14__prepared == NULL );
            tmp_class_creation_14__prepared = tmp_assign_source_116;
        }
        branch_end_52:;
    }
    {
        PyObject *tmp_assign_source_117;
        {
            PyObject *tmp_set_locals_14;
            CHECK_OBJECT( tmp_class_creation_14__prepared );
            tmp_set_locals_14 = tmp_class_creation_14__prepared;
            locals_contextlib_523 = tmp_set_locals_14;
            Py_INCREF( tmp_set_locals_14 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;

            goto try_except_handler_42;
        }
        tmp_dictset_value = const_str_digest_3e88ac70b637d24d9d579630d818ac0c;
        tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;

            goto try_except_handler_42;
        }
        tmp_dictset_value = const_str_plain_AsyncExitStack;
        tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;

            goto try_except_handler_42;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_10e144bd8ccb0415c605cd7bc640b3ce_15, codeobj_10e144bd8ccb0415c605cd7bc640b3ce, module_contextlib, sizeof(void *) );
        frame_10e144bd8ccb0415c605cd7bc640b3ce_15 = cache_frame_10e144bd8ccb0415c605cd7bc640b3ce_15;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_10e144bd8ccb0415c605cd7bc640b3ce_15 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_10e144bd8ccb0415c605cd7bc640b3ce_15 ) == 2 ); // Frame stack

        // Framed code:
        {
            nuitka_bool tmp_condition_result_84;
            PyObject *tmp_called_name_32;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_staticmethod_arg_3;
            tmp_res = MAPPING_HAS_ITEM( locals_contextlib_523, const_str_plain_staticmethod );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 536;
                type_description_2 = "o";
                goto frame_exception_exit_15;
            }
            tmp_condition_result_84 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_84 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_31;
            }
            else
            {
                goto condexpr_false_31;
            }
            condexpr_true_31:;
            tmp_called_name_32 = PyObject_GetItem( locals_contextlib_523, const_str_plain_staticmethod );

            if ( tmp_called_name_32 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "staticmethod" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 536;
                type_description_2 = "o";
                goto frame_exception_exit_15;
            }

            if ( tmp_called_name_32 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 536;
                type_description_2 = "o";
                goto frame_exception_exit_15;
            }
            tmp_args_element_name_7 = MAKE_FUNCTION_contextlib$$$function_38__create_async_exit_wrapper(  );



            frame_10e144bd8ccb0415c605cd7bc640b3ce_15->m_frame.f_lineno = 536;
            {
                PyObject *call_args[] = { tmp_args_element_name_7 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_32, call_args );
            }

            Py_DECREF( tmp_called_name_32 );
            Py_DECREF( tmp_args_element_name_7 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 536;
                type_description_2 = "o";
                goto frame_exception_exit_15;
            }
            goto condexpr_end_31;
            condexpr_false_31:;
            tmp_staticmethod_arg_3 = MAKE_FUNCTION_contextlib$$$function_38__create_async_exit_wrapper(  );



            tmp_dictset_value = BUILTIN_STATICMETHOD( tmp_staticmethod_arg_3 );
            Py_DECREF( tmp_staticmethod_arg_3 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 536;
                type_description_2 = "o";
                goto frame_exception_exit_15;
            }
            condexpr_end_31:;
            tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain__create_async_exit_wrapper, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 536;
                type_description_2 = "o";
                goto frame_exception_exit_15;
            }
        }
        {
            nuitka_bool tmp_condition_result_85;
            PyObject *tmp_called_name_33;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_staticmethod_arg_4;
            tmp_res = MAPPING_HAS_ITEM( locals_contextlib_523, const_str_plain_staticmethod );

            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 542;
                type_description_2 = "o";
                goto frame_exception_exit_15;
            }
            tmp_condition_result_85 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_85 == NUITKA_BOOL_TRUE )
            {
                goto condexpr_true_32;
            }
            else
            {
                goto condexpr_false_32;
            }
            condexpr_true_32:;
            tmp_called_name_33 = PyObject_GetItem( locals_contextlib_523, const_str_plain_staticmethod );

            if ( tmp_called_name_33 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "staticmethod" );
                exception_tb = NULL;
                NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
                CHAIN_EXCEPTION( exception_value );

                exception_lineno = 542;
                type_description_2 = "o";
                goto frame_exception_exit_15;
            }

            if ( tmp_called_name_33 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 542;
                type_description_2 = "o";
                goto frame_exception_exit_15;
            }
            tmp_args_element_name_8 = MAKE_FUNCTION_contextlib$$$function_39__create_async_cb_wrapper(  );



            frame_10e144bd8ccb0415c605cd7bc640b3ce_15->m_frame.f_lineno = 542;
            {
                PyObject *call_args[] = { tmp_args_element_name_8 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_33, call_args );
            }

            Py_DECREF( tmp_called_name_33 );
            Py_DECREF( tmp_args_element_name_8 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 542;
                type_description_2 = "o";
                goto frame_exception_exit_15;
            }
            goto condexpr_end_32;
            condexpr_false_32:;
            tmp_staticmethod_arg_4 = MAKE_FUNCTION_contextlib$$$function_39__create_async_cb_wrapper(  );



            tmp_dictset_value = BUILTIN_STATICMETHOD( tmp_staticmethod_arg_4 );
            Py_DECREF( tmp_staticmethod_arg_4 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 542;
                type_description_2 = "o";
                goto frame_exception_exit_15;
            }
            condexpr_end_32:;
            tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain__create_async_cb_wrapper, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 542;
                type_description_2 = "o";
                goto frame_exception_exit_15;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_40_enter_async_context(  );



        tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain_enter_async_context, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 548;
            type_description_2 = "o";
            goto frame_exception_exit_15;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_41_push_async_exit(  );



        tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain_push_async_exit, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 560;
            type_description_2 = "o";
            goto frame_exception_exit_15;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_42_push_async_callback(  );



        tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain_push_async_callback, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 578;
            type_description_2 = "o";
            goto frame_exception_exit_15;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_43_aclose(  );



        tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain_aclose, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 591;
            type_description_2 = "o";
            goto frame_exception_exit_15;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_44__push_async_cm_exit(  );



        tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain__push_async_cm_exit, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 595;
            type_description_2 = "o";
            goto frame_exception_exit_15;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_45___aenter__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain___aenter__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 602;
            type_description_2 = "o";
            goto frame_exception_exit_15;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_46___aexit__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain___aexit__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 605;
            type_description_2 = "o";
            goto frame_exception_exit_15;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_10e144bd8ccb0415c605cd7bc640b3ce_15 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_14;

        frame_exception_exit_15:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_10e144bd8ccb0415c605cd7bc640b3ce_15 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_10e144bd8ccb0415c605cd7bc640b3ce_15, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_10e144bd8ccb0415c605cd7bc640b3ce_15->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_10e144bd8ccb0415c605cd7bc640b3ce_15, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_10e144bd8ccb0415c605cd7bc640b3ce_15,
            type_description_2,
            outline_13_var___class__
        );


        // Release cached frame.
        if ( frame_10e144bd8ccb0415c605cd7bc640b3ce_15 == cache_frame_10e144bd8ccb0415c605cd7bc640b3ce_15 )
        {
            Py_DECREF( frame_10e144bd8ccb0415c605cd7bc640b3ce_15 );
        }
        cache_frame_10e144bd8ccb0415c605cd7bc640b3ce_15 = NULL;

        assertFrameObject( frame_10e144bd8ccb0415c605cd7bc640b3ce_15 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_14;

        frame_no_exception_14:;
        goto skip_nested_handling_14;
        nested_frame_exit_14:;

        goto try_except_handler_42;
        skip_nested_handling_14:;
        {
            nuitka_bool tmp_condition_result_86;
            PyObject *tmp_compexpr_left_12;
            PyObject *tmp_compexpr_right_12;
            CHECK_OBJECT( tmp_class_creation_14__bases );
            tmp_compexpr_left_12 = tmp_class_creation_14__bases;
            CHECK_OBJECT( tmp_class_creation_14__bases_orig );
            tmp_compexpr_right_12 = tmp_class_creation_14__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_12, tmp_compexpr_right_12 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 523;

                goto try_except_handler_42;
            }
            tmp_condition_result_86 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_86 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_54;
            }
            else
            {
                goto branch_no_54;
            }
            branch_yes_54:;
            CHECK_OBJECT( tmp_class_creation_14__bases_orig );
            tmp_dictset_value = tmp_class_creation_14__bases_orig;
            tmp_res = PyObject_SetItem( locals_contextlib_523, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 523;

                goto try_except_handler_42;
            }
            branch_no_54:;
        }
        {
            PyObject *tmp_assign_source_118;
            PyObject *tmp_called_name_34;
            PyObject *tmp_args_name_28;
            PyObject *tmp_tuple_element_51;
            PyObject *tmp_kw_name_28;
            CHECK_OBJECT( tmp_class_creation_14__metaclass );
            tmp_called_name_34 = tmp_class_creation_14__metaclass;
            tmp_tuple_element_51 = const_str_plain_AsyncExitStack;
            tmp_args_name_28 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_51 );
            PyTuple_SET_ITEM( tmp_args_name_28, 0, tmp_tuple_element_51 );
            CHECK_OBJECT( tmp_class_creation_14__bases );
            tmp_tuple_element_51 = tmp_class_creation_14__bases;
            Py_INCREF( tmp_tuple_element_51 );
            PyTuple_SET_ITEM( tmp_args_name_28, 1, tmp_tuple_element_51 );
            tmp_tuple_element_51 = locals_contextlib_523;
            Py_INCREF( tmp_tuple_element_51 );
            PyTuple_SET_ITEM( tmp_args_name_28, 2, tmp_tuple_element_51 );
            CHECK_OBJECT( tmp_class_creation_14__class_decl_dict );
            tmp_kw_name_28 = tmp_class_creation_14__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 523;
            tmp_assign_source_118 = CALL_FUNCTION( tmp_called_name_34, tmp_args_name_28, tmp_kw_name_28 );
            Py_DECREF( tmp_args_name_28 );
            if ( tmp_assign_source_118 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 523;

                goto try_except_handler_42;
            }
            assert( outline_13_var___class__ == NULL );
            outline_13_var___class__ = tmp_assign_source_118;
        }
        CHECK_OBJECT( outline_13_var___class__ );
        tmp_assign_source_117 = outline_13_var___class__;
        Py_INCREF( tmp_assign_source_117 );
        goto try_return_handler_42;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_42:;
        Py_DECREF( locals_contextlib_523 );
        locals_contextlib_523 = NULL;
        goto try_return_handler_41;
        // Exception handler code:
        try_except_handler_42:;
        exception_keeper_type_40 = exception_type;
        exception_keeper_value_40 = exception_value;
        exception_keeper_tb_40 = exception_tb;
        exception_keeper_lineno_40 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_523 );
        locals_contextlib_523 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_40;
        exception_value = exception_keeper_value_40;
        exception_tb = exception_keeper_tb_40;
        exception_lineno = exception_keeper_lineno_40;

        goto try_except_handler_41;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_41:;
        CHECK_OBJECT( (PyObject *)outline_13_var___class__ );
        Py_DECREF( outline_13_var___class__ );
        outline_13_var___class__ = NULL;

        goto outline_result_14;
        // Exception handler code:
        try_except_handler_41:;
        exception_keeper_type_41 = exception_type;
        exception_keeper_value_41 = exception_value;
        exception_keeper_tb_41 = exception_tb;
        exception_keeper_lineno_41 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_41;
        exception_value = exception_keeper_value_41;
        exception_tb = exception_keeper_tb_41;
        exception_lineno = exception_keeper_lineno_41;

        goto outline_exception_14;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_14:;
        exception_lineno = 523;
        goto try_except_handler_40;
        outline_result_14:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AsyncExitStack, tmp_assign_source_117 );
    }
    goto try_end_14;
    // Exception handler code:
    try_except_handler_40:;
    exception_keeper_type_42 = exception_type;
    exception_keeper_value_42 = exception_value;
    exception_keeper_tb_42 = exception_tb;
    exception_keeper_lineno_42 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_14__bases_orig );
    tmp_class_creation_14__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_14__bases );
    tmp_class_creation_14__bases = NULL;

    Py_XDECREF( tmp_class_creation_14__class_decl_dict );
    tmp_class_creation_14__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_14__prepared );
    tmp_class_creation_14__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_42;
    exception_value = exception_keeper_value_42;
    exception_tb = exception_keeper_tb_42;
    exception_lineno = exception_keeper_lineno_42;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__bases_orig );
    Py_DECREF( tmp_class_creation_14__bases_orig );
    tmp_class_creation_14__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__bases );
    Py_DECREF( tmp_class_creation_14__bases );
    tmp_class_creation_14__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class_decl_dict );
    Py_DECREF( tmp_class_creation_14__class_decl_dict );
    tmp_class_creation_14__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__metaclass );
    Py_DECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__prepared );
    Py_DECREF( tmp_class_creation_14__prepared );
    tmp_class_creation_14__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_119;
        PyObject *tmp_tuple_element_52;
        PyObject *tmp_mvar_value_21;
        tmp_mvar_value_21 = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );

        if (unlikely( tmp_mvar_value_21 == NULL ))
        {
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AbstractContextManager );
        }

        if ( tmp_mvar_value_21 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "AbstractContextManager" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 659;

            goto try_except_handler_43;
        }

        tmp_tuple_element_52 = tmp_mvar_value_21;
        tmp_assign_source_119 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_52 );
        PyTuple_SET_ITEM( tmp_assign_source_119, 0, tmp_tuple_element_52 );
        assert( tmp_class_creation_15__bases_orig == NULL );
        tmp_class_creation_15__bases_orig = tmp_assign_source_119;
    }
    {
        PyObject *tmp_assign_source_120;
        PyObject *tmp_dircall_arg1_13;
        CHECK_OBJECT( tmp_class_creation_15__bases_orig );
        tmp_dircall_arg1_13 = tmp_class_creation_15__bases_orig;
        Py_INCREF( tmp_dircall_arg1_13 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_13};
            tmp_assign_source_120 = impl___internal__$$$function_1__mro_entries_conversion( dir_call_args );
        }
        if ( tmp_assign_source_120 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto try_except_handler_43;
        }
        assert( tmp_class_creation_15__bases == NULL );
        tmp_class_creation_15__bases = tmp_assign_source_120;
    }
    {
        PyObject *tmp_assign_source_121;
        tmp_assign_source_121 = PyDict_New();
        assert( tmp_class_creation_15__class_decl_dict == NULL );
        tmp_class_creation_15__class_decl_dict = tmp_assign_source_121;
    }
    {
        PyObject *tmp_assign_source_122;
        PyObject *tmp_metaclass_name_15;
        nuitka_bool tmp_condition_result_87;
        PyObject *tmp_key_name_43;
        PyObject *tmp_dict_name_43;
        PyObject *tmp_dict_name_44;
        PyObject *tmp_key_name_44;
        nuitka_bool tmp_condition_result_88;
        int tmp_truth_name_13;
        PyObject *tmp_type_arg_27;
        PyObject *tmp_subscribed_name_13;
        PyObject *tmp_subscript_name_13;
        PyObject *tmp_bases_name_15;
        tmp_key_name_43 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_15__class_decl_dict );
        tmp_dict_name_43 = tmp_class_creation_15__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_43, tmp_key_name_43 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto try_except_handler_43;
        }
        tmp_condition_result_87 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_87 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_33;
        }
        else
        {
            goto condexpr_false_33;
        }
        condexpr_true_33:;
        CHECK_OBJECT( tmp_class_creation_15__class_decl_dict );
        tmp_dict_name_44 = tmp_class_creation_15__class_decl_dict;
        tmp_key_name_44 = const_str_plain_metaclass;
        tmp_metaclass_name_15 = DICT_GET_ITEM( tmp_dict_name_44, tmp_key_name_44 );
        if ( tmp_metaclass_name_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto try_except_handler_43;
        }
        goto condexpr_end_33;
        condexpr_false_33:;
        CHECK_OBJECT( tmp_class_creation_15__bases );
        tmp_truth_name_13 = CHECK_IF_TRUE( tmp_class_creation_15__bases );
        if ( tmp_truth_name_13 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto try_except_handler_43;
        }
        tmp_condition_result_88 = tmp_truth_name_13 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_88 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_34;
        }
        else
        {
            goto condexpr_false_34;
        }
        condexpr_true_34:;
        CHECK_OBJECT( tmp_class_creation_15__bases );
        tmp_subscribed_name_13 = tmp_class_creation_15__bases;
        tmp_subscript_name_13 = const_int_0;
        tmp_type_arg_27 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_13, tmp_subscript_name_13, 0 );
        if ( tmp_type_arg_27 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto try_except_handler_43;
        }
        tmp_metaclass_name_15 = BUILTIN_TYPE1( tmp_type_arg_27 );
        Py_DECREF( tmp_type_arg_27 );
        if ( tmp_metaclass_name_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto try_except_handler_43;
        }
        goto condexpr_end_34;
        condexpr_false_34:;
        tmp_metaclass_name_15 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_metaclass_name_15 );
        condexpr_end_34:;
        condexpr_end_33:;
        CHECK_OBJECT( tmp_class_creation_15__bases );
        tmp_bases_name_15 = tmp_class_creation_15__bases;
        tmp_assign_source_122 = SELECT_METACLASS( tmp_metaclass_name_15, tmp_bases_name_15 );
        Py_DECREF( tmp_metaclass_name_15 );
        if ( tmp_assign_source_122 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto try_except_handler_43;
        }
        assert( tmp_class_creation_15__metaclass == NULL );
        tmp_class_creation_15__metaclass = tmp_assign_source_122;
    }
    {
        nuitka_bool tmp_condition_result_89;
        PyObject *tmp_key_name_45;
        PyObject *tmp_dict_name_45;
        tmp_key_name_45 = const_str_plain_metaclass;
        CHECK_OBJECT( tmp_class_creation_15__class_decl_dict );
        tmp_dict_name_45 = tmp_class_creation_15__class_decl_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_45, tmp_key_name_45 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto try_except_handler_43;
        }
        tmp_condition_result_89 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_89 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_55;
        }
        else
        {
            goto branch_no_55;
        }
        branch_yes_55:;
        CHECK_OBJECT( tmp_class_creation_15__class_decl_dict );
        tmp_dictdel_dict = tmp_class_creation_15__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto try_except_handler_43;
        }
        branch_no_55:;
    }
    {
        nuitka_bool tmp_condition_result_90;
        PyObject *tmp_source_name_59;
        CHECK_OBJECT( tmp_class_creation_15__metaclass );
        tmp_source_name_59 = tmp_class_creation_15__metaclass;
        tmp_res = PyObject_HasAttr( tmp_source_name_59, const_str_plain___prepare__ );
        tmp_condition_result_90 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_90 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_56;
        }
        else
        {
            goto branch_no_56;
        }
        branch_yes_56:;
        {
            PyObject *tmp_assign_source_123;
            PyObject *tmp_called_name_35;
            PyObject *tmp_source_name_60;
            PyObject *tmp_args_name_29;
            PyObject *tmp_tuple_element_53;
            PyObject *tmp_kw_name_29;
            CHECK_OBJECT( tmp_class_creation_15__metaclass );
            tmp_source_name_60 = tmp_class_creation_15__metaclass;
            tmp_called_name_35 = LOOKUP_ATTRIBUTE( tmp_source_name_60, const_str_plain___prepare__ );
            if ( tmp_called_name_35 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 659;

                goto try_except_handler_43;
            }
            tmp_tuple_element_53 = const_str_plain_nullcontext;
            tmp_args_name_29 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_53 );
            PyTuple_SET_ITEM( tmp_args_name_29, 0, tmp_tuple_element_53 );
            CHECK_OBJECT( tmp_class_creation_15__bases );
            tmp_tuple_element_53 = tmp_class_creation_15__bases;
            Py_INCREF( tmp_tuple_element_53 );
            PyTuple_SET_ITEM( tmp_args_name_29, 1, tmp_tuple_element_53 );
            CHECK_OBJECT( tmp_class_creation_15__class_decl_dict );
            tmp_kw_name_29 = tmp_class_creation_15__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 659;
            tmp_assign_source_123 = CALL_FUNCTION( tmp_called_name_35, tmp_args_name_29, tmp_kw_name_29 );
            Py_DECREF( tmp_called_name_35 );
            Py_DECREF( tmp_args_name_29 );
            if ( tmp_assign_source_123 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 659;

                goto try_except_handler_43;
            }
            assert( tmp_class_creation_15__prepared == NULL );
            tmp_class_creation_15__prepared = tmp_assign_source_123;
        }
        {
            nuitka_bool tmp_condition_result_91;
            PyObject *tmp_operand_name_15;
            PyObject *tmp_source_name_61;
            CHECK_OBJECT( tmp_class_creation_15__prepared );
            tmp_source_name_61 = tmp_class_creation_15__prepared;
            tmp_res = PyObject_HasAttr( tmp_source_name_61, const_str_plain___getitem__ );
            tmp_operand_name_15 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_15 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 659;

                goto try_except_handler_43;
            }
            tmp_condition_result_91 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_91 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_57;
            }
            else
            {
                goto branch_no_57;
            }
            branch_yes_57:;
            {
                PyObject *tmp_raise_type_15;
                PyObject *tmp_raise_value_15;
                PyObject *tmp_left_name_15;
                PyObject *tmp_right_name_15;
                PyObject *tmp_tuple_element_54;
                PyObject *tmp_getattr_target_15;
                PyObject *tmp_getattr_attr_15;
                PyObject *tmp_getattr_default_15;
                PyObject *tmp_source_name_62;
                PyObject *tmp_type_arg_28;
                tmp_raise_type_15 = PyExc_TypeError;
                tmp_left_name_15 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT( tmp_class_creation_15__metaclass );
                tmp_getattr_target_15 = tmp_class_creation_15__metaclass;
                tmp_getattr_attr_15 = const_str_plain___name__;
                tmp_getattr_default_15 = const_str_angle_metaclass;
                tmp_tuple_element_54 = BUILTIN_GETATTR( tmp_getattr_target_15, tmp_getattr_attr_15, tmp_getattr_default_15 );
                if ( tmp_tuple_element_54 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 659;

                    goto try_except_handler_43;
                }
                tmp_right_name_15 = PyTuple_New( 2 );
                PyTuple_SET_ITEM( tmp_right_name_15, 0, tmp_tuple_element_54 );
                CHECK_OBJECT( tmp_class_creation_15__prepared );
                tmp_type_arg_28 = tmp_class_creation_15__prepared;
                tmp_source_name_62 = BUILTIN_TYPE1( tmp_type_arg_28 );
                assert( !(tmp_source_name_62 == NULL) );
                tmp_tuple_element_54 = LOOKUP_ATTRIBUTE( tmp_source_name_62, const_str_plain___name__ );
                Py_DECREF( tmp_source_name_62 );
                if ( tmp_tuple_element_54 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_right_name_15 );

                    exception_lineno = 659;

                    goto try_except_handler_43;
                }
                PyTuple_SET_ITEM( tmp_right_name_15, 1, tmp_tuple_element_54 );
                tmp_raise_value_15 = BINARY_OPERATION_REMAINDER( tmp_left_name_15, tmp_right_name_15 );
                Py_DECREF( tmp_right_name_15 );
                if ( tmp_raise_value_15 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 659;

                    goto try_except_handler_43;
                }
                exception_type = tmp_raise_type_15;
                Py_INCREF( tmp_raise_type_15 );
                exception_value = tmp_raise_value_15;
                exception_lineno = 659;
                RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_43;
            }
            branch_no_57:;
        }
        goto branch_end_56;
        branch_no_56:;
        {
            PyObject *tmp_assign_source_124;
            tmp_assign_source_124 = PyDict_New();
            assert( tmp_class_creation_15__prepared == NULL );
            tmp_class_creation_15__prepared = tmp_assign_source_124;
        }
        branch_end_56:;
    }
    {
        PyObject *tmp_assign_source_125;
        {
            PyObject *tmp_set_locals_15;
            CHECK_OBJECT( tmp_class_creation_15__prepared );
            tmp_set_locals_15 = tmp_class_creation_15__prepared;
            locals_contextlib_659 = tmp_set_locals_15;
            Py_INCREF( tmp_set_locals_15 );
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_plain_contextlib;
        tmp_res = PyObject_SetItem( locals_contextlib_659, const_str_plain___module__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto try_except_handler_45;
        }
        tmp_dictset_value = const_str_digest_9f3d2b5ab4e4cad7444ce685cb22d525;
        tmp_res = PyObject_SetItem( locals_contextlib_659, const_str_plain___doc__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto try_except_handler_45;
        }
        tmp_dictset_value = const_str_plain_nullcontext;
        tmp_res = PyObject_SetItem( locals_contextlib_659, const_str_plain___qualname__, tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto try_except_handler_45;
        }
        MAKE_OR_REUSE_FRAME( cache_frame_2415601356a99a081119e44dfac162fa_16, codeobj_2415601356a99a081119e44dfac162fa, module_contextlib, sizeof(void *) );
        frame_2415601356a99a081119e44dfac162fa_16 = cache_frame_2415601356a99a081119e44dfac162fa_16;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_2415601356a99a081119e44dfac162fa_16 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_2415601356a99a081119e44dfac162fa_16 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_defaults_2;
            tmp_defaults_2 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_2 );
            tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_47___init__( tmp_defaults_2 );



            tmp_res = PyObject_SetItem( locals_contextlib_659, const_str_plain___init__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 670;
                type_description_2 = "o";
                goto frame_exception_exit_16;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_48___enter__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_659, const_str_plain___enter__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 673;
            type_description_2 = "o";
            goto frame_exception_exit_16;
        }
        tmp_dictset_value = MAKE_FUNCTION_contextlib$$$function_49___exit__(  );



        tmp_res = PyObject_SetItem( locals_contextlib_659, const_str_plain___exit__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 676;
            type_description_2 = "o";
            goto frame_exception_exit_16;
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_2415601356a99a081119e44dfac162fa_16 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_15;

        frame_exception_exit_16:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_2415601356a99a081119e44dfac162fa_16 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_2415601356a99a081119e44dfac162fa_16, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_2415601356a99a081119e44dfac162fa_16->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_2415601356a99a081119e44dfac162fa_16, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_2415601356a99a081119e44dfac162fa_16,
            type_description_2,
            outline_14_var___class__
        );


        // Release cached frame.
        if ( frame_2415601356a99a081119e44dfac162fa_16 == cache_frame_2415601356a99a081119e44dfac162fa_16 )
        {
            Py_DECREF( frame_2415601356a99a081119e44dfac162fa_16 );
        }
        cache_frame_2415601356a99a081119e44dfac162fa_16 = NULL;

        assertFrameObject( frame_2415601356a99a081119e44dfac162fa_16 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_15;

        frame_no_exception_15:;
        goto skip_nested_handling_15;
        nested_frame_exit_15:;

        goto try_except_handler_45;
        skip_nested_handling_15:;
        {
            nuitka_bool tmp_condition_result_92;
            PyObject *tmp_compexpr_left_13;
            PyObject *tmp_compexpr_right_13;
            CHECK_OBJECT( tmp_class_creation_15__bases );
            tmp_compexpr_left_13 = tmp_class_creation_15__bases;
            CHECK_OBJECT( tmp_class_creation_15__bases_orig );
            tmp_compexpr_right_13 = tmp_class_creation_15__bases_orig;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_13, tmp_compexpr_right_13 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 659;

                goto try_except_handler_45;
            }
            tmp_condition_result_92 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_92 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_58;
            }
            else
            {
                goto branch_no_58;
            }
            branch_yes_58:;
            CHECK_OBJECT( tmp_class_creation_15__bases_orig );
            tmp_dictset_value = tmp_class_creation_15__bases_orig;
            tmp_res = PyObject_SetItem( locals_contextlib_659, const_str_plain___orig_bases__, tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 659;

                goto try_except_handler_45;
            }
            branch_no_58:;
        }
        {
            PyObject *tmp_assign_source_126;
            PyObject *tmp_called_name_36;
            PyObject *tmp_args_name_30;
            PyObject *tmp_tuple_element_55;
            PyObject *tmp_kw_name_30;
            CHECK_OBJECT( tmp_class_creation_15__metaclass );
            tmp_called_name_36 = tmp_class_creation_15__metaclass;
            tmp_tuple_element_55 = const_str_plain_nullcontext;
            tmp_args_name_30 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_55 );
            PyTuple_SET_ITEM( tmp_args_name_30, 0, tmp_tuple_element_55 );
            CHECK_OBJECT( tmp_class_creation_15__bases );
            tmp_tuple_element_55 = tmp_class_creation_15__bases;
            Py_INCREF( tmp_tuple_element_55 );
            PyTuple_SET_ITEM( tmp_args_name_30, 1, tmp_tuple_element_55 );
            tmp_tuple_element_55 = locals_contextlib_659;
            Py_INCREF( tmp_tuple_element_55 );
            PyTuple_SET_ITEM( tmp_args_name_30, 2, tmp_tuple_element_55 );
            CHECK_OBJECT( tmp_class_creation_15__class_decl_dict );
            tmp_kw_name_30 = tmp_class_creation_15__class_decl_dict;
            frame_16be74c7884d209762a4409719331de6->m_frame.f_lineno = 659;
            tmp_assign_source_126 = CALL_FUNCTION( tmp_called_name_36, tmp_args_name_30, tmp_kw_name_30 );
            Py_DECREF( tmp_args_name_30 );
            if ( tmp_assign_source_126 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 659;

                goto try_except_handler_45;
            }
            assert( outline_14_var___class__ == NULL );
            outline_14_var___class__ = tmp_assign_source_126;
        }
        CHECK_OBJECT( outline_14_var___class__ );
        tmp_assign_source_125 = outline_14_var___class__;
        Py_INCREF( tmp_assign_source_125 );
        goto try_return_handler_45;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_45:;
        Py_DECREF( locals_contextlib_659 );
        locals_contextlib_659 = NULL;
        goto try_return_handler_44;
        // Exception handler code:
        try_except_handler_45:;
        exception_keeper_type_43 = exception_type;
        exception_keeper_value_43 = exception_value;
        exception_keeper_tb_43 = exception_tb;
        exception_keeper_lineno_43 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_contextlib_659 );
        locals_contextlib_659 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_43;
        exception_value = exception_keeper_value_43;
        exception_tb = exception_keeper_tb_43;
        exception_lineno = exception_keeper_lineno_43;

        goto try_except_handler_44;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_44:;
        CHECK_OBJECT( (PyObject *)outline_14_var___class__ );
        Py_DECREF( outline_14_var___class__ );
        outline_14_var___class__ = NULL;

        goto outline_result_15;
        // Exception handler code:
        try_except_handler_44:;
        exception_keeper_type_44 = exception_type;
        exception_keeper_value_44 = exception_value;
        exception_keeper_tb_44 = exception_tb;
        exception_keeper_lineno_44 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_44;
        exception_value = exception_keeper_value_44;
        exception_tb = exception_keeper_tb_44;
        exception_lineno = exception_keeper_lineno_44;

        goto outline_exception_15;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( contextlib );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_15:;
        exception_lineno = 659;
        goto try_except_handler_43;
        outline_result_15:;
        UPDATE_STRING_DICT1( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain_nullcontext, tmp_assign_source_125 );
    }
    goto try_end_15;
    // Exception handler code:
    try_except_handler_43:;
    exception_keeper_type_45 = exception_type;
    exception_keeper_value_45 = exception_value;
    exception_keeper_tb_45 = exception_tb;
    exception_keeper_lineno_45 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_15__bases_orig );
    tmp_class_creation_15__bases_orig = NULL;

    Py_XDECREF( tmp_class_creation_15__bases );
    tmp_class_creation_15__bases = NULL;

    Py_XDECREF( tmp_class_creation_15__class_decl_dict );
    tmp_class_creation_15__class_decl_dict = NULL;

    Py_XDECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    Py_XDECREF( tmp_class_creation_15__prepared );
    tmp_class_creation_15__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_45;
    exception_value = exception_keeper_value_45;
    exception_tb = exception_keeper_tb_45;
    exception_lineno = exception_keeper_lineno_45;

    goto frame_exception_exit_1;
    // End of try:
    try_end_15:;

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_16be74c7884d209762a4409719331de6 );
#endif
    popFrameStack();

    assertFrameObject( frame_16be74c7884d209762a4409719331de6 );

    goto frame_no_exception_16;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_16be74c7884d209762a4409719331de6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_16be74c7884d209762a4409719331de6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_16be74c7884d209762a4409719331de6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_16be74c7884d209762a4409719331de6, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_16:;
    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__bases_orig );
    Py_DECREF( tmp_class_creation_15__bases_orig );
    tmp_class_creation_15__bases_orig = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__bases );
    Py_DECREF( tmp_class_creation_15__bases );
    tmp_class_creation_15__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class_decl_dict );
    Py_DECREF( tmp_class_creation_15__class_decl_dict );
    tmp_class_creation_15__class_decl_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__metaclass );
    Py_DECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__prepared );
    Py_DECREF( tmp_class_creation_15__prepared );
    tmp_class_creation_15__prepared = NULL;


#if _NUITKA_EXPERIMENTAL_PKGUTIL_ITERMODULES
#if 0 && 0
    {
        PyObject *path_value = GET_STRING_DICT_VALUE( moduledict_contextlib, (Nuitka_StringObject *)const_str_plain___path__ );

        if (path_value && PyList_CheckExact(path_value) && PyList_Size(path_value) > 0)
        {
            PyObject *path_element = PyList_GetItem( path_value, 0 );

            PyObject *path_importer_cache = PySys_GetObject((char *)"path_importer_cache");
            CHECK_OBJECT( path_importer_cache );

            int res = PyDict_SetItem( path_importer_cache, path_element, (PyObject *)&Nuitka_Loader_Type );
            assert( res == 0 );
        }
    }
#endif
#endif

    return MOD_RETURN_VALUE( module_contextlib );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
